{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/BoostTrees简介.md","hash":"dc2ec21c08d3587c67596865f7a6543022c1da4f","modified":1528378507276},{"_id":"source/_posts/ES分词器.md","hash":"b57d1d4afe2bf9d87b8cd33003488b2b76d31dff","modified":1528380375375},{"_id":"source/_posts/Fabric启用网络.md","hash":"3433ec28318f0de5c000d37453e7c2a0345f083e","modified":1528378507276},{"_id":"source/_posts/Hive用户自定义聚合函数UDAF和表生成函数UDTF.md","hash":"25b6dd34ded85fdaee82e165271880225fbb46e9","modified":1528378507276},{"_id":"source/_posts/JVM-Java内存区域与内存溢出异常.md","hash":"8de8c90115712ef5c967f915010ecb327be1a7f2","modified":1528378507276},{"_id":"source/_posts/Java并发编程——并发基础构建模块.md","hash":"08c1142f7d75ccd20c1d3ed0eebddcff07423198","modified":1528378507276},{"_id":"source/_posts/Java并发编程——线程池的使用.md","hash":"509c95ef482e79fd7cb1534fb61a8770d8ebca66","modified":1528378507276},{"_id":"source/_posts/Java并发编程——线程的取消与关闭.md","hash":"8b157057182707ec0554b89f5ebe21b7efe3d596","modified":1528378507276},{"_id":"source/_posts/Java并发编程——结构化并发应用程序.md","hash":"ae6d4a51e3a5e11ef1a91b5258cdc6d764dc17b7","modified":1528378507276},{"_id":"source/_posts/Java并发编程——结构化并发应用程序2.md","hash":"cd63ca4e0ff982394c3fd0d27bd1df0cc7c691e3","modified":1528378507276},{"_id":"source/_posts/KMP算法.md","hash":"0a051b41758dbbfc09b9432f2905672cb99fd2ec","modified":1528378507276},{"_id":"source/_posts/Kafka中Consumer的多线程实现.md","hash":"2610322bf2de9a011f073a7fecaf42d1d149d05f","modified":1528378507276},{"_id":"source/_posts/MLlib-协同过滤算法.md","hash":"b17028dc99059bc9bee2d82ea48e091b14d4754d","modified":1528378507276},{"_id":"source/_posts/MySQL查漏补缺（三）.md","hash":"a544961aecd7f2df3ac9d35c2a876728fc74995b","modified":1528378507276},{"_id":"source/_posts/MySQL查漏补缺（一）.md","hash":"deaf29166c9f174336ae5626d2e1c4a53ff8d98a","modified":1528378507276},{"_id":"source/_posts/MySQL查漏补缺（二）.md","hash":"ee112abd91d63e1dc2ef63b0a59d00693975a809","modified":1528378507276},{"_id":"source/_posts/MLlib-基本概念.md","hash":"08822068531a639c0062d003e6898ea64576175f","modified":1528378507276},{"_id":"source/_posts/Scala快速学习.md","hash":"8cc024059f4a016f4b1449fdaf83e4416b94c053","modified":1528378507276},{"_id":"source/_posts/lightGbm简要原理.md","hash":"7ca9402484d5ab2027f3853c5e7ed3c4d3483d64","modified":1528380394267},{"_id":"source/_posts/scala——actor，Akka.md","hash":"c88444891c6a29a730cf35cf411f001f42fad7ff","modified":1528378507276},{"_id":"source/_posts/scala面向对象和模式匹配.md","hash":"8e8c62d80a971eb2069401eff9e36019ba60a703","modified":1528378507276},{"_id":"source/_posts/《区块链原理、设计与应用》读书摘要.md","hash":"9443c7399a231ecc894526ba7fb49ed9b63db36a","modified":1528378507276},{"_id":"source/_posts/今日头条2018春季实习生笔试题-BFS两道.md","hash":"8e66e0805cfc74f2735b2ce453528e419a5a3c39","modified":1528378507276},{"_id":"source/_posts/关于Crunch.md","hash":"6bd22adbcfe6c428c828800ea3e0e04e53b7511f","modified":1528378507276},{"_id":"source/_posts/关于HBase.md","hash":"60d8a50f877ff98f59f772e7ecef9f6fcaff1f46","modified":1528378507276},{"_id":"source/_posts/关于HIVE.md","hash":"a4d3482ce91b7da70ef90782f2a341431c95e051","modified":1528378507276},{"_id":"source/_posts/scala——Actor、柯里化与隐式转换.md","hash":"4f3ad54efb1a6bd2952d87c70890ba8109a4f584","modified":1528378507276},{"_id":"source/_posts/动态规划算法面试题-硬币组合问题.md","hash":"cd512acf6759b119bfa40d662a07ae52893fc059","modified":1528378507276},{"_id":"source/_posts/Scala常用方法.md","hash":"268ffd9e6daff05396ed57b9411217b5a7855a7e","modified":1528378507276},{"_id":"source/_posts/hexo系列问题之我们换了电脑怎么办.md","hash":"2e01cbce72c74be0166257f47a36b930018336ea","modified":1528378507276},{"_id":"source/_posts/实习笔记-HTTP方法-GET对比POST.md","hash":"da3ecab5ac9b3e5e7f690be7f764fd57351f58e5","modified":1528378507276},{"_id":"source/_posts/数据算法-二次排序.md","hash":"20eb834aa8502bfc062e9f0b8b32d5d61fea2127","modified":1528371645000},{"_id":"source/_posts/数据算法——Spark的二次排序解决方案.md","hash":"6c4c4b568eeaace2769a79bb16c08c1d71e83d37","modified":1528378507276},{"_id":"source/_posts/特征提取方法-one-hot和TF-IDF.md","hash":"3d626178ac2c099c6c3d7b3d547d9daee27edff6","modified":1528378507276},{"_id":"source/_posts/用Mahout编写一个基本推荐系统.md","hash":"4a0405f77af0cb4f23270c38a95c6f68821ea7bb","modified":1528378507280},{"_id":"source/_posts/线程的生命周期.md","hash":"d6551b8d498fbf7b3b98d430bef7c54eb416ef22","modified":1528378507280},{"_id":"source/_posts/用hadoop构建豆瓣图书推荐系统.md","hash":"c9dd956a59dced784ff45b2324dc56394f36c961","modified":1528378507280},{"_id":"source/_posts/记录一道笔试算法题.md","hash":"588aac7415bd0c356382cd72feb0ab332eb78cbf","modified":1528378507280},{"_id":"source/_posts/数据库中：维度表和事实表.md","hash":"a343870d9db3a8223d881e354298933386b9af7e","modified":1528378507276},{"_id":"public/content.json","hash":"51358828b906fc4343e3e310702fed43003554dd","modified":1528380044698},{"_id":"public/2018/06/07/数据算法——Spark的二次排序解决方案/index.html","hash":"a28660a22f61d6fba06551ab187879b6751b6c1a","modified":1528380045598},{"_id":"public/2018/06/07/lightGbm简要原理/index.html","hash":"e17e77736b777dfa5be28e3523d443fc32e41e99","modified":1528380404336},{"_id":"public/2018/06/04/数据算法-二次排序/index.html","hash":"ebecfaa5691c6c9e532dba8c96e277f7e91edf93","modified":1528380045282},{"_id":"public/2018/06/04/ES分词器/index.html","hash":"76392365dd95434c42676bc8c9cd7bd96712dd71","modified":1528380404634},{"_id":"public/2018/06/04/hexo系列问题之我们换了电脑怎么办/index.html","hash":"9de5b712053e7998cd2a53e94866b0893655a57a","modified":1528380045594},{"_id":"public/2018/06/04/数据库中：维度表和事实表/index.html","hash":"4e7b6460923dc54ea78833d89d45850a5ba1d71e","modified":1528380045594},{"_id":"public/2018/06/04/线程的生命周期/index.html","hash":"37cb9257853dca6086136040cb0a8ea0285f8d0a","modified":1528380045593},{"_id":"public/2018/06/04/Java并发编程——线程的取消与关闭/index.html","hash":"71fb5663dc9c7898aa5114301442eb2fe387fe9c","modified":1528380045598},{"_id":"public/2018/06/04/Java并发编程——线程池的使用/index.html","hash":"1a28e1f5041396d20eda0eee654d2b5d1f6b08b9","modified":1528380045598},{"_id":"public/2018/05/30/Hive用户自定义聚合函数UDAF和表生成函数UDTF/index.html","hash":"6bfed0873dda61655eb287d6fe5e9e6b13a7913b","modified":1528380045598},{"_id":"public/2018/05/28/BoostTrees简介/index.html","hash":"1200f8d1a999f15bb6a7ee996c3bd282649bfdf5","modified":1528380045598},{"_id":"public/2018/05/27/Java并发编程——并发基础构建模块/index.html","hash":"8b0f0b7602c224101ed2a05bec4b4673b37065b4","modified":1528380045598},{"_id":"public/2018/05/27/Java并发编程——结构化并发应用程序2/index.html","hash":"50e168322aa20bb9a4cb4cd8fef1775e1efa93c2","modified":1528380045599},{"_id":"public/2018/05/27/Kafka中Consumer的多线程实现/index.html","hash":"b94197671ad3f551fe868065690e50e02116667d","modified":1528380045599},{"_id":"public/2018/05/27/特征提取方法-one-hot和TF-IDF/index.html","hash":"5102085df0991c50425f825c96d7b3e29439e9b4","modified":1528380045599},{"_id":"public/2018/05/09/实习笔记-HTTP方法-GET对比POST/index.html","hash":"53152521d088f437bc37db9c458328cdd9efd102","modified":1528380045599},{"_id":"public/2018/05/06/MLlib-协同过滤算法/index.html","hash":"0e13b8939004fab148bef74859a15b532a89054b","modified":1528380045595},{"_id":"public/2018/05/06/MLlib-基本概念/index.html","hash":"d1107fd07caa18733b1b609695161e8e96fe56c1","modified":1528380045599},{"_id":"public/2018/05/02/Fabric启用网络/index.html","hash":"5002c2b143751b43cc6f8c3e7e96353838d08c9f","modified":1528380045599},{"_id":"public/2018/04/29/scala——actor，Akka/index.html","hash":"ec2b545815b0715f454d4a6726547b3e1577f212","modified":1528380045595},{"_id":"public/2018/04/28/scala——Actor、柯里化与隐式转换/index.html","hash":"af9179b9563280f15fc436c831d055f248eed1e5","modified":1528380045599},{"_id":"public/2018/04/25/scala面向对象和模式匹配/index.html","hash":"06bae53a821486d7c3bcab44d1177a7c48d7bf9e","modified":1528380045599},{"_id":"public/2018/04/25/Scala常用方法/index.html","hash":"46e348315a636981fc3a571f9a6fe21c4cf5e435","modified":1528380045599},{"_id":"public/2018/04/25/Scala快速学习/index.html","hash":"65847722db7d0c78ea0f4839d90d2e5400f930b2","modified":1528380045600},{"_id":"public/2018/04/15/JVM-Java内存区域与内存溢出异常/index.html","hash":"ddff8c7c819b81bba70da8aaaf37c85d6a45a300","modified":1528380045595},{"_id":"public/2018/04/10/用Mahout编写一个基本推荐系统/index.html","hash":"457c32e5cc8965f626e107a7a370491ae242035c","modified":1528380045600},{"_id":"public/2018/04/08/Java并发编程——结构化并发应用程序/index.html","hash":"73098e0758b40dda423a00bfaa1be54ed848851c","modified":1528380045600},{"_id":"public/2018/04/08/MySQL查漏补缺（三）/index.html","hash":"64319a0751c9fa7aedc258c9f9b45de57eb53316","modified":1528380045600},{"_id":"public/2018/04/04/MySQL查漏补缺（二）/index.html","hash":"bd8692bff8abfa3c1445396db2170fa1b2009f47","modified":1528380045600},{"_id":"public/2018/04/03/《区块链原理、设计与应用》读书摘要/index.html","hash":"29f2807753bc3c59ebdcd0d2ff3d47a3eb9f7eae","modified":1528380045600},{"_id":"public/2018/04/03/MySQL查漏补缺（一）/index.html","hash":"b87316ffc2811884771de189b5f8142ca0f62646","modified":1528380045600},{"_id":"public/2018/03/29/KMP算法/index.html","hash":"bae8e618fa056c54f4d4a3c7dc15a5af5388159f","modified":1528380045600},{"_id":"public/2018/03/28/用hadoop构建豆瓣图书推荐系统/index.html","hash":"968855bd66fe337e5bdc116047de4b4da4310aad","modified":1528380045600},{"_id":"public/2018/03/24/今日头条2018春季实习生笔试题-BFS两道/index.html","hash":"e5e02c9f3e4de9b0f5c36675fccc0e457f944bfd","modified":1528380045595},{"_id":"public/2018/03/23/动态规划算法面试题-硬币组合问题/index.html","hash":"cfeff4f8ff29d98542675af1211d9bed53e33956","modified":1528380045600},{"_id":"public/2018/03/22/记录一道笔试算法题/index.html","hash":"9e4011eb3cb8f29f5d952226c138a38b0dabb071","modified":1528380045595},{"_id":"public/2018/03/21/关于HBase/index.html","hash":"223303cc0e78001791f413b362cbb5a174908b83","modified":1528380045600},{"_id":"public/2018/03/21/关于Crunch/index.html","hash":"2a1342abde0adea1d763a0e359f919912349931b","modified":1528380045600},{"_id":"public/2018/03/17/关于HIVE/index.html","hash":"dccbead17b38358bf4162a09d168b785322f2105","modified":1528380045600},{"_id":"public/archives/index.html","hash":"4fe4d4575eb3b5e0e2b1e1307fe8502376225190","modified":1528380045595},{"_id":"public/archives/page/2/index.html","hash":"cbab30be5296bd0367148e6da1097618013df381","modified":1528380045595},{"_id":"public/archives/page/3/index.html","hash":"0ca7660c31e9848ebea72d1e97db62237c6c5111","modified":1528380045595},{"_id":"public/archives/page/4/index.html","hash":"9b43036ed531aa6d04c5d8b29c2f5e6585b95bac","modified":1528380045595},{"_id":"public/archives/2018/index.html","hash":"cfb51dd6cd8415c7df2e8f889d6ac5ed9f9fc125","modified":1528380045595},{"_id":"public/archives/2018/page/2/index.html","hash":"87aa10838da2c3373fa42b444ec55937194fcf4d","modified":1528380045595},{"_id":"public/archives/2018/page/3/index.html","hash":"fb481135ce1e0c7d9c046317344c753bf5396479","modified":1528380045596},{"_id":"public/archives/2018/page/4/index.html","hash":"6289b19c15c365fd576cd3d59f7141b01d59b562","modified":1528380045595},{"_id":"public/archives/2018/03/index.html","hash":"25e8fb44530b6a1057cefcf4c4986e8b1dbe2cf7","modified":1528380045596},{"_id":"public/archives/2018/04/index.html","hash":"f787723059be43c9d40e0e9c6a1b832b511bf5c6","modified":1528380045596},{"_id":"public/archives/2018/04/page/2/index.html","hash":"5fc875a71a21236dc8c1e45d114a9faaa7585f0b","modified":1528380045596},{"_id":"public/archives/2018/05/index.html","hash":"df8200913a9cedb9eeff2f1d548f0ffb4b36c4d1","modified":1528380045596},{"_id":"public/archives/2018/06/index.html","hash":"e8c960c1ed341169b1f80f61276174f4380af205","modified":1528380045596},{"_id":"public/index.html","hash":"32eb070ff5a71cad01404288f0abc9c1af736083","modified":1528380404654},{"_id":"public/page/2/index.html","hash":"bd4b109fd35fb2572e8fe38b998738f82782398f","modified":1528380045601},{"_id":"public/page/3/index.html","hash":"ed203b368b6855fd1748973d68672518eedf657d","modified":1528380045601},{"_id":"public/page/4/index.html","hash":"7f1475af506cf243916f800b25366c527f9cf936","modified":1528380045601},{"_id":"public/tags/机器学习/index.html","hash":"d60635f28ba7eaa731b80a09837a0613bd3bb0fb","modified":1528380045596},{"_id":"public/tags/ElasticSearch/index.html","hash":"23d7e31ef714282baa571876abde644ea4211fc7","modified":1528380045596},{"_id":"public/tags/大数据/index.html","hash":"7106435d4fd739552ed384463f473df592a5961f","modified":1528380045596},{"_id":"public/tags/大数据/page/2/index.html","hash":"18fea6864ab5301973e1b360a15b6b7bbc19c4c9","modified":1528380045597},{"_id":"public/tags/区块链/index.html","hash":"015aa334fceda8537e1b97bd7617b7d6b5491ce6","modified":1528380045596},{"_id":"public/tags/Hive/index.html","hash":"62eb3f580aefad6839654b49827163ca6da12f2f","modified":1528380045596},{"_id":"public/tags/Hadoop/index.html","hash":"0f74390c3d818f91da171b27fe8428cda6f00c90","modified":1528380045596},{"_id":"public/tags/JVM/index.html","hash":"e4865b1d35110193a78b6be402850ab89ad038f2","modified":1528380045596},{"_id":"public/tags/Java/index.html","hash":"8ff8b9cef16e9e212fced323485fd191d25c800b","modified":1528380045596},{"_id":"public/tags/多线程/index.html","hash":"f16279655b4c00a5a7cabbc32da2fe13fd47e4ab","modified":1528380045597},{"_id":"public/tags/并发/index.html","hash":"206408b25957e6d223579d8e0baf4472ca2add84","modified":1528380045597},{"_id":"public/tags/算法/index.html","hash":"732b6b49641406994b581d9ea81f82f7b15b4217","modified":1528380045597},{"_id":"public/tags/字符串匹配/index.html","hash":"f3aa6e4d4ee951ae78ba41a6b92f35fb325fc514","modified":1528380045597},{"_id":"public/tags/MLib/index.html","hash":"7f5243b2b4b478bc7a11ca290db4bf7e216cfd6d","modified":1528380045597},{"_id":"public/tags/协同过滤/index.html","hash":"03c7d7d3a1cbff2f0baec52d7861ce95207042d5","modified":1528380045597},{"_id":"public/tags/数据库/index.html","hash":"1c7a4f3022c6e95e33126febd09f548152de743d","modified":1528380045597},{"_id":"public/tags/MySQL/index.html","hash":"eacfaa42aa1f81c594d55d97f471fa095698d5a6","modified":1528380045597},{"_id":"public/tags/MLlib/index.html","hash":"87e63501f1bc7698b40ff14a958e8c815ffdc3d9","modified":1528380045597},{"_id":"public/tags/scala/index.html","hash":"faa7992bb50e7bca7eca56687698b319a6456b89","modified":1528380045597},{"_id":"public/tags/Crunch/index.html","hash":"2778fec2b45bfd124004032cc93cb9d5b8366efe","modified":1528380045597},{"_id":"public/tags/HBase/index.html","hash":"b85745ffc079df96b2ff9cb50570775920d8d6e5","modified":1528380045597},{"_id":"public/tags/随笔/index.html","hash":"ec4590d5e507735ce666a649a175dea1b9c7e208","modified":1528380045597},{"_id":"public/tags/HTTP/index.html","hash":"52d1c2807b5c18c86cab3163ca0c683d3607321c","modified":1528380045597},{"_id":"public/tags/分布式算法/index.html","hash":"d585657cbf77be51a8e921130f9f6d0b4d8b724d","modified":1528380045598},{"_id":"public/tags/Spark/index.html","hash":"c713fa708b13bb882b25bb53a1a211799bdbb32d","modified":1528380045604},{"_id":"public/tags/推荐系统/index.html","hash":"a841b3c9cd01243540aa5dcd790d189d4e39cfc8","modified":1528380045598},{"_id":"public/tags/Mahout/index.html","hash":"701701be15e14e7ce61499c50e43ab3249465e6b","modified":1528380045598},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1528378507280},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1528378507280},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1528378507280},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1528378507280},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1528378507280},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1528378507280},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1528378507280},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1528378507280},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1528378507280},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1528378507280},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1528378507280},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1528378507280},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1528378507280},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1528378507280},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1528378507280},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1528378507280},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1528378507280},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1528378507280},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1528378507280},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1528378507280},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1528378507280},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1528378507280},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1528378507280},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1528378507280},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1528378507280},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1528378507280},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1528378507280},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1528378507280},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1528378507280},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1528378507280},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1528378507280},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1528378507280},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1528378507280},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1528378507284},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1528378507284},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1528378507280},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1528378507280},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1528378507280},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1528378507280},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1528378507280},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1528378507280},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1528378507280},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1528378507280},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1528378507284},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1528378507284},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1528378507280},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1528378507280},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1528378507284},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1528380045605},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1528380045605},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1528380045605},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1528380045605},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1528380045605},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1528380045605},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1528380045605},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1528380045605},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1528380045605},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1528380045605},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1528380046002},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1528380046038},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1528380046038},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1528380046038},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1528380046038},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1528380046038},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1528380046038},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1528380046038},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1528380046039},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1528380046039},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1528380046039},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1528380046049},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1528380046049}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"BoostTrees简介","date":"2018-05-27T16:11:25.000Z","_content":"本文翻译自陈天奇大神的英文ppt,喜欢看英文的同学可以[直接跳转](https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf),翻译当中也增加了一些个人的补充.\n\n## 一、监督学习的关键概念\n\n#### 监督学习中的元素\n\n$x_i \\in R^D$ :训练集中第i条记录\n\n**模型**： 根据$x_i$预测$\\hat y_i$\n<!-- more--> \n线性模型：$\\hat y_i = \\sum_j \\omega_jx_{ij}$（包括线性回归和逻辑回归）\n\n在不同的任务中$y^i$有不同的解释：\n\n- 线性回归中：$y^i$是预测得分\n- 逻辑回归中：$1/(1+exp(- \\hat y))$是结果为正例的概率\n- 其他任务，比如打分中，表示预测的分数\n\n**参数**：我们需要从数据中习得的东西\n\n线性模型：$\\Theta = \\lbrace\\omega_j|j=1,…,d\\rbrace$\n\n#### 目标函数\n\n$object(\\Theta) = L(\\Theta) + \\Omega(\\Theta)$\n\n**训练集的损失**：$L = \\sum_{i=1}^nl(y_i, \\hat y_i)$\n\n- 平方损失：$l(y_i, \\hat y_i) = (y_i - \\hat y_i)^2$\n- Logistic损失：$l(y_i, \\hat y_i) = y_iln(1+e^{-y^i}) + (1+e^{\\hat y_i})$\n\n**正则化项**：描述模型结构复杂程度\n\n- L2正则化：$\\Omega(\\omega) = \\lambda||\\omega||^2$\n- L1正则化：$\\Omega(\\omega) = \\lambda||\\omega||_1$ \n\n#### 已知的线性回归目标函数\n\n**岭回归**：$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||^2$\n\n​\t线性模型，平方损失， L2正则化\n\n**Lasso回归：**$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||_1$\n\n​\t线性回归， 平方损失， L1正则化\n\n**Logistic回归：**$\\sum_{i=1}^n[ y_iln(1+e^{-\\omega^Tx_i})+ (1+e^{\\omega^Tx_i})^2] - \\lambda||\\omega||^2$\n\n​\t线性回归， logistic损失， L2正则化\n\n模型，参数，目标之间的概念分离也为带来了工程上的好处。\n\n\n\n#### 方差与偏差的权衡\n\n- 偏差.\n\n  这里的偏指的是 **偏离** , 那么它偏离了什么到导致了误差? 潜意识上, 当谈到这个词时, 我们可能会认为它是偏离了某个潜在的 “标准”, 而这里这个 “标准” 也就是真实情况 (ground truth). 在分类任务中, 这个 “标准” 就是真实标签 (label).\n\n- 方差.\n\n  很多人应该都还记得在统计学中, 一个随机变量的方差描述的是它的离散程度, 也就是该随机变量在其期望值附近的 **波动程度** . \n\n先从下面的靶心图来对方差与偏差有个直观的感受：\n\n![img](https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-diagram.png)\n\n假设红色的靶心区域是学习算法完美的正确预测值, 蓝色点为每个数据集所训练出的模型对样本的预测值, 当我们从靶心逐渐向外移动时, 预测效果逐渐变差.\n\n很容易看出有两副图中蓝色点比较集中, 另外两幅中比较分散, 它们描述的是方差的两种情况. 比较集中的属于方差小的, 比较分散的属于方差大的情况.\n\n再从蓝色点与红色靶心区域的位置关系, 靠近红色靶心的属于偏差较小的情况, 远离靶心的属于偏差较大的情况.\n\n![img](https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-label-diagram.png)\n\n[本节偏差方差解释部分来自博客]https://blog.csdn.net/simple_the_best/article/details/71167786\n\n将目标函数分为损失函数和正则化项的原因在于：\n\n- 优化训练损失会激励预测模型\n\n  ​\t对训练数据集的良好拟合，至少可以让模型在训练数据上表现良好，有可能更接近数据的底层分布\n\n- 优化正则化项有利于产生简单的模型\n\n  ​\t简单的模型在预测数据上方差更小，使模型可靠性更强\n\n## 二、回归树和集成方法\n\n**回归树（CART,又叫分类回归树）**\n\n- 像决策树一样制定规则\n- 每个叶节点包含一个值\n\n例子：判断是否喜欢电脑游戏\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/74239098.jpg)\n\n\n\n**回归树集成：最终的得分是每个树得分的和**\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/14929391.jpg)\n\n\n\n**树集成方法 ——模型和参数**\n\n- 模型：假设我们有K个树\n\n  $\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$，F是包含所有回归树的函数空间\n\n考虑：回归树是将属性对应为得分的函数\n\n- 参数\n  - 包括每棵树的结构和叶子结点的得分\n  - 或简单的被当作参数适用：$\\Theta = \\lbrace f_1, f_2,…,f_K\\rbrace$\n  - 我们学习的是functions(trees)而不是$R^d$中的权重\n\n#### 在单变量上学习回归树\n\n- 如何学习目标函数？\n\n\n- 定义目标函数(loss， regularization),然后优化它。\n- 比如：\n  - 考虑在单输入t = (time)上的回归树\n  - 想要预测是否想在t时刻听浪漫音乐\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/86261125.jpg)\n\n- 需要学习的东西：\n\n  ![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/41162967.jpg)\n\n- 单变量回归树（阶梯函数）的目标：\n\n  - 训练损失：函数对点的拟合程度如何？\n  - 结构损失：如何定义函数的结构复杂度？\n    - 分裂点的数量，每段高度的L2正则化。\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-11/75298105.jpg)\n\n\n\n#### 集成回归树的目标函数\n\n- 模型：假设我们有K棵树\n\n  $\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$\n\n- 目标函数：\n\n  $Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(k)$\n\n- 定义$\\Omega$可能的方式：\n\n  - 树的节点数，深度\n  - L2正规项叶子权重的\n  - ...\n\n#### 客观性与启发式\n\n- 当谈及决策树时，经常是启发式的\n  - 同个信息增益进行分割\n  - 剪枝\n  - 最大化树深度\n  - 平滑叶节点\n- 大多数启发式方法都符合目标，采取正式的（客观）观点让我们知道我们正在学习什么：\n  - 信息增益 -》减少训练损失\n  - 剪枝 -》根据节点正则化\n  - 最大化树深度 -》函数空间的约束\n  - 平滑叶子value -》 叶子权重的L2正则化\n\n#### 回归树不仅仅是为了回归问题\n\n- 集成回归树定义了如何获取得分，可被用于分类，回归，打分等场景，取决于如何定义目标函数：\n\n  - 使用平方损失：梯度提升回归树（common gradient boosted machine）\n  - 使用Logistic损失：LogitBoost\n\n  ​\n\n### 三、Gradient Boosting\n\n- 目标函数：\n\n  ​\t$Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(f_k), f_k\\in F$\n\n- 我们不能使用梯度下降法来得到f，因为他们是树而不是简单的数值向量。\n\n- 解决办法：*additive training*(boosting)\n\n  - 从常量预测开始， 每次增加一个新的函数\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-11/97010343.jpg)\n\n\n\n#### 模型学习：additive training\n\n现在还剩下一个问题，我们如何选择每一轮加入什么f呢？答案是非常直接的，选取一个f来使得我们的目标函数尽量最大地降低。\n[![5](http://dataunion.org/wp-content/uploads/2015/04/510.png)](http://dataunion.org/wp-content/uploads/2015/04/510.png)\n这个公式可能有些过于抽象，我们可以考虑当l是平方误差的情况。这个时候我们的目标可以被写成下面这样的二次函数9：\n[![6](http://dataunion.org/wp-content/uploads/2015/04/61.png)](http://dataunion.org/wp-content/uploads/2015/04/61.png)\n更加一般的，对于不是平方误差的情况，我们会采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行这一步的计算。\n[![7](http://dataunion.org/wp-content/uploads/2015/04/72.png)](http://dataunion.org/wp-content/uploads/2015/04/72.png)\n当我们把常数项移除之后，我们会发现如下一个比较统一的目标函数。这一个目标函数有一个非常明显的特点，它只依赖于每个数据点的在误差函数上的一阶导数和二阶导数。有人可能会问，这个材料似乎比我们之前学过的决策树学习难懂。为什么要花这么多力气来做推导呢？\n[![8](http://dataunion.org/wp-content/uploads/2015/04/82.png)](http://dataunion.org/wp-content/uploads/2015/04/82.png)\n\n- 因为这样做使得我们可以很清楚地理解整个目标是什么，并且一步一步推导出如何进行树的学习。\n- 这一个抽象的形式对于实现机器学习工具也是非常有帮助的。传统的GBDT可能大家可以理解如优化平法a残差，但是这样一个形式包含可所有可以求导的目标函数。也就是说有了这个形式，我们写出来的代码可以用来求解包括回归，分类和排序的各种问题，**正式的推导可以使得机器学习的工具更加一般**。\n\n#### 树的复杂度\n\n到目前为止我们讨论了目标函数中训练误差的部分。接下来我们讨论如何定义树的复杂度。我们先对于f的定义做一下细化，把树拆分成结构部分q和叶子权重部分w。下图是一个具体的例子。结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。\n[![9](http://dataunion.org/wp-content/uploads/2015/04/94.png)](http://dataunion.org/wp-content/uploads/2015/04/94.png)\n当我们给定了如上定义之后，我们可以定义一棵树的复杂度如下。这个复杂度包含了一棵树里面节点的个数，以及每个树叶子节点上面输出分数的$L2$模平方。当然这不是唯一的一种定义方式，不过这一定义方式学习出的树效果一般都比较不错。下图还给出了复杂度计算的一个例子。\n\n[![10](http://dataunion.org/wp-content/uploads/2015/04/102.png)](http://dataunion.org/wp-content/uploads/2015/04/102.png)\n\n#### 重新审视目标\n\n- 定义叶子j上面样本集合$ I_j =\\lbrace i|q(x_i)=j\\rbrace$\n\n- 根据叶子重新组织目标\n\n  [![a](http://dataunion.org/wp-content/uploads/2015/04/a-1024x199.png)](http://dataunion.org/wp-content/uploads/2015/04/a.png)\n\n- 由二次函数零点定理,有:\n\n  ​\t$argmin_x$  $Gx+\\frac {1}{2}Hx^2 = -\\frac {G}{H}, H>0$\n\n- 二次函数的最低点性质有: $min_x$ $Gx+\\frac {1}{2}Hx^2 = -\\frac {1}{2}G^2/H$\n\n- 可以定义\n\n  ​\t[![QQ截图20150423163401](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png)](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png)\n\n  那么这个目标函数可以进一步改写成如下的形式[![QQ截图20150423163423](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png)](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png)\n\n  假设我们已经知道树的结构q(x)，我们可以通过这个目标函数来求解出最优的w，以及最好的w对应的目标函数最大的增益[![QQ截图20150423163446](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png)](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png)\n\n#### 结构分数的计算\n\nObj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)。你可以认为这个就是类似吉尼系数一样更加一般的对于树结构进行打分的函数。下面是一个具体的打分函数计算的例子\n[![1](http://dataunion.org/wp-content/uploads/2015/04/143.png)](http://dataunion.org/wp-content/uploads/2015/04/143.png)\n\n#### 枚举所有不同树结构\n\n- 枚举所有可能的树结构\n\n- 利用得分等式,计算q的结构分数\n\n  ​\t$Obj = -\\frac{1}{2}\\sum_{j=1}^T \\frac{G_j^2}{H_j+\\lambda} + \\gamma T$\n\n- 找到最好的树结构,使用最优的叶子权重 $\\omega_j^*=-\\frac{G_i}{H_j+\\lambda}$\n\n- 但是,可能有无穷尽的树结构,\n\n#### 树结构的贪心法\n\n常用的方法是贪心法，每一次尝试去对已有的叶子加入一个分割。\n\n- 从深度为0的树开始\n- 对每一个叶子节点尝试进行分割,我们可以获得的增益可以由如下公式计算\n\n[](http://www.52cs.org/wp-content/uploads/2015/04/12.png)[![image1](http://dataunion.org/wp-content/uploads/2015/04/image1.png)](http://dataunion.org/wp-content/uploads/2015/04/image1.png)\n对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？\n\n假设我们要枚举所有 x<a 这样的条件，对于某个特定的分割a我们要计算a左边和右边的导数和。\n[![13](http://dataunion.org/wp-content/uploads/2015/04/133.png)](http://dataunion.org/wp-content/uploads/2015/04/133.png)\n我们可以发现对于所有的a，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用上面的公式计算每个分割方案的分数就可以了。\n\n观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic而进行的操作了。\n\n#### 总操作概述\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-28/19435924.jpg)\n\n讲到这里文章进入了尾声，虽然有些长，希望对大家有所帮助，这篇文章介绍了如何通过目标函数优化的方法比较严格地推导出boosted tree的学习。因为有这样一般的推导，得到的算法可以直接应用到回归，分类排序等各个应用场景中去。\n\n","source":"_posts/BoostTrees简介.md","raw":"---\ntitle: BoostTrees简介\ndate: 2018-05-28 00:11:25\ntags: 机器学习\n---\n本文翻译自陈天奇大神的英文ppt,喜欢看英文的同学可以[直接跳转](https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf),翻译当中也增加了一些个人的补充.\n\n## 一、监督学习的关键概念\n\n#### 监督学习中的元素\n\n$x_i \\in R^D$ :训练集中第i条记录\n\n**模型**： 根据$x_i$预测$\\hat y_i$\n<!-- more--> \n线性模型：$\\hat y_i = \\sum_j \\omega_jx_{ij}$（包括线性回归和逻辑回归）\n\n在不同的任务中$y^i$有不同的解释：\n\n- 线性回归中：$y^i$是预测得分\n- 逻辑回归中：$1/(1+exp(- \\hat y))$是结果为正例的概率\n- 其他任务，比如打分中，表示预测的分数\n\n**参数**：我们需要从数据中习得的东西\n\n线性模型：$\\Theta = \\lbrace\\omega_j|j=1,…,d\\rbrace$\n\n#### 目标函数\n\n$object(\\Theta) = L(\\Theta) + \\Omega(\\Theta)$\n\n**训练集的损失**：$L = \\sum_{i=1}^nl(y_i, \\hat y_i)$\n\n- 平方损失：$l(y_i, \\hat y_i) = (y_i - \\hat y_i)^2$\n- Logistic损失：$l(y_i, \\hat y_i) = y_iln(1+e^{-y^i}) + (1+e^{\\hat y_i})$\n\n**正则化项**：描述模型结构复杂程度\n\n- L2正则化：$\\Omega(\\omega) = \\lambda||\\omega||^2$\n- L1正则化：$\\Omega(\\omega) = \\lambda||\\omega||_1$ \n\n#### 已知的线性回归目标函数\n\n**岭回归**：$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||^2$\n\n​\t线性模型，平方损失， L2正则化\n\n**Lasso回归：**$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||_1$\n\n​\t线性回归， 平方损失， L1正则化\n\n**Logistic回归：**$\\sum_{i=1}^n[ y_iln(1+e^{-\\omega^Tx_i})+ (1+e^{\\omega^Tx_i})^2] - \\lambda||\\omega||^2$\n\n​\t线性回归， logistic损失， L2正则化\n\n模型，参数，目标之间的概念分离也为带来了工程上的好处。\n\n\n\n#### 方差与偏差的权衡\n\n- 偏差.\n\n  这里的偏指的是 **偏离** , 那么它偏离了什么到导致了误差? 潜意识上, 当谈到这个词时, 我们可能会认为它是偏离了某个潜在的 “标准”, 而这里这个 “标准” 也就是真实情况 (ground truth). 在分类任务中, 这个 “标准” 就是真实标签 (label).\n\n- 方差.\n\n  很多人应该都还记得在统计学中, 一个随机变量的方差描述的是它的离散程度, 也就是该随机变量在其期望值附近的 **波动程度** . \n\n先从下面的靶心图来对方差与偏差有个直观的感受：\n\n![img](https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-diagram.png)\n\n假设红色的靶心区域是学习算法完美的正确预测值, 蓝色点为每个数据集所训练出的模型对样本的预测值, 当我们从靶心逐渐向外移动时, 预测效果逐渐变差.\n\n很容易看出有两副图中蓝色点比较集中, 另外两幅中比较分散, 它们描述的是方差的两种情况. 比较集中的属于方差小的, 比较分散的属于方差大的情况.\n\n再从蓝色点与红色靶心区域的位置关系, 靠近红色靶心的属于偏差较小的情况, 远离靶心的属于偏差较大的情况.\n\n![img](https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-label-diagram.png)\n\n[本节偏差方差解释部分来自博客]https://blog.csdn.net/simple_the_best/article/details/71167786\n\n将目标函数分为损失函数和正则化项的原因在于：\n\n- 优化训练损失会激励预测模型\n\n  ​\t对训练数据集的良好拟合，至少可以让模型在训练数据上表现良好，有可能更接近数据的底层分布\n\n- 优化正则化项有利于产生简单的模型\n\n  ​\t简单的模型在预测数据上方差更小，使模型可靠性更强\n\n## 二、回归树和集成方法\n\n**回归树（CART,又叫分类回归树）**\n\n- 像决策树一样制定规则\n- 每个叶节点包含一个值\n\n例子：判断是否喜欢电脑游戏\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/74239098.jpg)\n\n\n\n**回归树集成：最终的得分是每个树得分的和**\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/14929391.jpg)\n\n\n\n**树集成方法 ——模型和参数**\n\n- 模型：假设我们有K个树\n\n  $\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$，F是包含所有回归树的函数空间\n\n考虑：回归树是将属性对应为得分的函数\n\n- 参数\n  - 包括每棵树的结构和叶子结点的得分\n  - 或简单的被当作参数适用：$\\Theta = \\lbrace f_1, f_2,…,f_K\\rbrace$\n  - 我们学习的是functions(trees)而不是$R^d$中的权重\n\n#### 在单变量上学习回归树\n\n- 如何学习目标函数？\n\n\n- 定义目标函数(loss， regularization),然后优化它。\n- 比如：\n  - 考虑在单输入t = (time)上的回归树\n  - 想要预测是否想在t时刻听浪漫音乐\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/86261125.jpg)\n\n- 需要学习的东西：\n\n  ![](http://p5s7d12ls.bkt.clouddn.com/18-5-10/41162967.jpg)\n\n- 单变量回归树（阶梯函数）的目标：\n\n  - 训练损失：函数对点的拟合程度如何？\n  - 结构损失：如何定义函数的结构复杂度？\n    - 分裂点的数量，每段高度的L2正则化。\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-11/75298105.jpg)\n\n\n\n#### 集成回归树的目标函数\n\n- 模型：假设我们有K棵树\n\n  $\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$\n\n- 目标函数：\n\n  $Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(k)$\n\n- 定义$\\Omega$可能的方式：\n\n  - 树的节点数，深度\n  - L2正规项叶子权重的\n  - ...\n\n#### 客观性与启发式\n\n- 当谈及决策树时，经常是启发式的\n  - 同个信息增益进行分割\n  - 剪枝\n  - 最大化树深度\n  - 平滑叶节点\n- 大多数启发式方法都符合目标，采取正式的（客观）观点让我们知道我们正在学习什么：\n  - 信息增益 -》减少训练损失\n  - 剪枝 -》根据节点正则化\n  - 最大化树深度 -》函数空间的约束\n  - 平滑叶子value -》 叶子权重的L2正则化\n\n#### 回归树不仅仅是为了回归问题\n\n- 集成回归树定义了如何获取得分，可被用于分类，回归，打分等场景，取决于如何定义目标函数：\n\n  - 使用平方损失：梯度提升回归树（common gradient boosted machine）\n  - 使用Logistic损失：LogitBoost\n\n  ​\n\n### 三、Gradient Boosting\n\n- 目标函数：\n\n  ​\t$Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(f_k), f_k\\in F$\n\n- 我们不能使用梯度下降法来得到f，因为他们是树而不是简单的数值向量。\n\n- 解决办法：*additive training*(boosting)\n\n  - 从常量预测开始， 每次增加一个新的函数\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-11/97010343.jpg)\n\n\n\n#### 模型学习：additive training\n\n现在还剩下一个问题，我们如何选择每一轮加入什么f呢？答案是非常直接的，选取一个f来使得我们的目标函数尽量最大地降低。\n[![5](http://dataunion.org/wp-content/uploads/2015/04/510.png)](http://dataunion.org/wp-content/uploads/2015/04/510.png)\n这个公式可能有些过于抽象，我们可以考虑当l是平方误差的情况。这个时候我们的目标可以被写成下面这样的二次函数9：\n[![6](http://dataunion.org/wp-content/uploads/2015/04/61.png)](http://dataunion.org/wp-content/uploads/2015/04/61.png)\n更加一般的，对于不是平方误差的情况，我们会采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行这一步的计算。\n[![7](http://dataunion.org/wp-content/uploads/2015/04/72.png)](http://dataunion.org/wp-content/uploads/2015/04/72.png)\n当我们把常数项移除之后，我们会发现如下一个比较统一的目标函数。这一个目标函数有一个非常明显的特点，它只依赖于每个数据点的在误差函数上的一阶导数和二阶导数。有人可能会问，这个材料似乎比我们之前学过的决策树学习难懂。为什么要花这么多力气来做推导呢？\n[![8](http://dataunion.org/wp-content/uploads/2015/04/82.png)](http://dataunion.org/wp-content/uploads/2015/04/82.png)\n\n- 因为这样做使得我们可以很清楚地理解整个目标是什么，并且一步一步推导出如何进行树的学习。\n- 这一个抽象的形式对于实现机器学习工具也是非常有帮助的。传统的GBDT可能大家可以理解如优化平法a残差，但是这样一个形式包含可所有可以求导的目标函数。也就是说有了这个形式，我们写出来的代码可以用来求解包括回归，分类和排序的各种问题，**正式的推导可以使得机器学习的工具更加一般**。\n\n#### 树的复杂度\n\n到目前为止我们讨论了目标函数中训练误差的部分。接下来我们讨论如何定义树的复杂度。我们先对于f的定义做一下细化，把树拆分成结构部分q和叶子权重部分w。下图是一个具体的例子。结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。\n[![9](http://dataunion.org/wp-content/uploads/2015/04/94.png)](http://dataunion.org/wp-content/uploads/2015/04/94.png)\n当我们给定了如上定义之后，我们可以定义一棵树的复杂度如下。这个复杂度包含了一棵树里面节点的个数，以及每个树叶子节点上面输出分数的$L2$模平方。当然这不是唯一的一种定义方式，不过这一定义方式学习出的树效果一般都比较不错。下图还给出了复杂度计算的一个例子。\n\n[![10](http://dataunion.org/wp-content/uploads/2015/04/102.png)](http://dataunion.org/wp-content/uploads/2015/04/102.png)\n\n#### 重新审视目标\n\n- 定义叶子j上面样本集合$ I_j =\\lbrace i|q(x_i)=j\\rbrace$\n\n- 根据叶子重新组织目标\n\n  [![a](http://dataunion.org/wp-content/uploads/2015/04/a-1024x199.png)](http://dataunion.org/wp-content/uploads/2015/04/a.png)\n\n- 由二次函数零点定理,有:\n\n  ​\t$argmin_x$  $Gx+\\frac {1}{2}Hx^2 = -\\frac {G}{H}, H>0$\n\n- 二次函数的最低点性质有: $min_x$ $Gx+\\frac {1}{2}Hx^2 = -\\frac {1}{2}G^2/H$\n\n- 可以定义\n\n  ​\t[![QQ截图20150423163401](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png)](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png)\n\n  那么这个目标函数可以进一步改写成如下的形式[![QQ截图20150423163423](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png)](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png)\n\n  假设我们已经知道树的结构q(x)，我们可以通过这个目标函数来求解出最优的w，以及最好的w对应的目标函数最大的增益[![QQ截图20150423163446](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png)](http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png)\n\n#### 结构分数的计算\n\nObj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)。你可以认为这个就是类似吉尼系数一样更加一般的对于树结构进行打分的函数。下面是一个具体的打分函数计算的例子\n[![1](http://dataunion.org/wp-content/uploads/2015/04/143.png)](http://dataunion.org/wp-content/uploads/2015/04/143.png)\n\n#### 枚举所有不同树结构\n\n- 枚举所有可能的树结构\n\n- 利用得分等式,计算q的结构分数\n\n  ​\t$Obj = -\\frac{1}{2}\\sum_{j=1}^T \\frac{G_j^2}{H_j+\\lambda} + \\gamma T$\n\n- 找到最好的树结构,使用最优的叶子权重 $\\omega_j^*=-\\frac{G_i}{H_j+\\lambda}$\n\n- 但是,可能有无穷尽的树结构,\n\n#### 树结构的贪心法\n\n常用的方法是贪心法，每一次尝试去对已有的叶子加入一个分割。\n\n- 从深度为0的树开始\n- 对每一个叶子节点尝试进行分割,我们可以获得的增益可以由如下公式计算\n\n[](http://www.52cs.org/wp-content/uploads/2015/04/12.png)[![image1](http://dataunion.org/wp-content/uploads/2015/04/image1.png)](http://dataunion.org/wp-content/uploads/2015/04/image1.png)\n对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？\n\n假设我们要枚举所有 x<a 这样的条件，对于某个特定的分割a我们要计算a左边和右边的导数和。\n[![13](http://dataunion.org/wp-content/uploads/2015/04/133.png)](http://dataunion.org/wp-content/uploads/2015/04/133.png)\n我们可以发现对于所有的a，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用上面的公式计算每个分割方案的分数就可以了。\n\n观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic而进行的操作了。\n\n#### 总操作概述\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-28/19435924.jpg)\n\n讲到这里文章进入了尾声，虽然有些长，希望对大家有所帮助，这篇文章介绍了如何通过目标函数优化的方法比较严格地推导出boosted tree的学习。因为有这样一般的推导，得到的算法可以直接应用到回归，分类排序等各个应用场景中去。\n\n","slug":"BoostTrees简介","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i5u0000cf96r69nhl0x","content":"<p>本文翻译自陈天奇大神的英文ppt,喜欢看英文的同学可以<a href=\"https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf\" target=\"_blank\" rel=\"noopener\">直接跳转</a>,翻译当中也增加了一些个人的补充.</p>\n<h2 id=\"一、监督学习的关键概念\"><a href=\"#一、监督学习的关键概念\" class=\"headerlink\" title=\"一、监督学习的关键概念\"></a>一、监督学习的关键概念</h2><h4 id=\"监督学习中的元素\"><a href=\"#监督学习中的元素\" class=\"headerlink\" title=\"监督学习中的元素\"></a>监督学习中的元素</h4><p>$x_i \\in R^D$ :训练集中第i条记录</p>\n<p><strong>模型</strong>： 根据$x_i$预测$\\hat y_i$<br><a id=\"more\"></a><br>线性模型：$\\hat y_i = \\sum_j \\omega_jx_{ij}$（包括线性回归和逻辑回归）</p>\n<p>在不同的任务中$y^i$有不同的解释：</p>\n<ul>\n<li>线性回归中：$y^i$是预测得分</li>\n<li>逻辑回归中：$1/(1+exp(- \\hat y))$是结果为正例的概率</li>\n<li>其他任务，比如打分中，表示预测的分数</li>\n</ul>\n<p><strong>参数</strong>：我们需要从数据中习得的东西</p>\n<p>线性模型：$\\Theta = \\lbrace\\omega_j|j=1,…,d\\rbrace$</p>\n<h4 id=\"目标函数\"><a href=\"#目标函数\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h4><p>$object(\\Theta) = L(\\Theta) + \\Omega(\\Theta)$</p>\n<p><strong>训练集的损失</strong>：$L = \\sum_{i=1}^nl(y_i, \\hat y_i)$</p>\n<ul>\n<li>平方损失：$l(y_i, \\hat y_i) = (y_i - \\hat y_i)^2$</li>\n<li>Logistic损失：$l(y_i, \\hat y_i) = y_iln(1+e^{-y^i}) + (1+e^{\\hat y_i})$</li>\n</ul>\n<p><strong>正则化项</strong>：描述模型结构复杂程度</p>\n<ul>\n<li>L2正则化：$\\Omega(\\omega) = \\lambda||\\omega||^2$</li>\n<li>L1正则化：$\\Omega(\\omega) = \\lambda||\\omega||_1$ </li>\n</ul>\n<h4 id=\"已知的线性回归目标函数\"><a href=\"#已知的线性回归目标函数\" class=\"headerlink\" title=\"已知的线性回归目标函数\"></a>已知的线性回归目标函数</h4><p><strong>岭回归</strong>：$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||^2$</p>\n<p>​    线性模型，平方损失， L2正则化</p>\n<p><strong>Lasso回归：</strong>$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||_1$</p>\n<p>​    线性回归， 平方损失， L1正则化</p>\n<p><strong>Logistic回归：</strong>$\\sum_{i=1}^n[ y_iln(1+e^{-\\omega^Tx_i})+ (1+e^{\\omega^Tx_i})^2] - \\lambda||\\omega||^2$</p>\n<p>​    线性回归， logistic损失， L2正则化</p>\n<p>模型，参数，目标之间的概念分离也为带来了工程上的好处。</p>\n<h4 id=\"方差与偏差的权衡\"><a href=\"#方差与偏差的权衡\" class=\"headerlink\" title=\"方差与偏差的权衡\"></a>方差与偏差的权衡</h4><ul>\n<li><p>偏差.</p>\n<p>这里的偏指的是 <strong>偏离</strong> , 那么它偏离了什么到导致了误差? 潜意识上, 当谈到这个词时, 我们可能会认为它是偏离了某个潜在的 “标准”, 而这里这个 “标准” 也就是真实情况 (ground truth). 在分类任务中, 这个 “标准” 就是真实标签 (label).</p>\n</li>\n<li><p>方差.</p>\n<p>很多人应该都还记得在统计学中, 一个随机变量的方差描述的是它的离散程度, 也就是该随机变量在其期望值附近的 <strong>波动程度</strong> . </p>\n</li>\n</ul>\n<p>先从下面的靶心图来对方差与偏差有个直观的感受：</p>\n<p><img src=\"https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-diagram.png\" alt=\"img\"></p>\n<p>假设红色的靶心区域是学习算法完美的正确预测值, 蓝色点为每个数据集所训练出的模型对样本的预测值, 当我们从靶心逐渐向外移动时, 预测效果逐渐变差.</p>\n<p>很容易看出有两副图中蓝色点比较集中, 另外两幅中比较分散, 它们描述的是方差的两种情况. 比较集中的属于方差小的, 比较分散的属于方差大的情况.</p>\n<p>再从蓝色点与红色靶心区域的位置关系, 靠近红色靶心的属于偏差较小的情况, 远离靶心的属于偏差较大的情况.</p>\n<p><img src=\"https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-label-diagram.png\" alt=\"img\"></p>\n<p>[本节偏差方差解释部分来自博客]<a href=\"https://blog.csdn.net/simple_the_best/article/details/71167786\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/simple_the_best/article/details/71167786</a></p>\n<p>将目标函数分为损失函数和正则化项的原因在于：</p>\n<ul>\n<li><p>优化训练损失会激励预测模型</p>\n<p>​    对训练数据集的良好拟合，至少可以让模型在训练数据上表现良好，有可能更接近数据的底层分布</p>\n</li>\n<li><p>优化正则化项有利于产生简单的模型</p>\n<p>​    简单的模型在预测数据上方差更小，使模型可靠性更强</p>\n</li>\n</ul>\n<h2 id=\"二、回归树和集成方法\"><a href=\"#二、回归树和集成方法\" class=\"headerlink\" title=\"二、回归树和集成方法\"></a>二、回归树和集成方法</h2><p><strong>回归树（CART,又叫分类回归树）</strong></p>\n<ul>\n<li>像决策树一样制定规则</li>\n<li>每个叶节点包含一个值</li>\n</ul>\n<p>例子：判断是否喜欢电脑游戏</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/74239098.jpg\" alt=\"\"></p>\n<p><strong>回归树集成：最终的得分是每个树得分的和</strong><br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/14929391.jpg\" alt=\"\"></p>\n<p><strong>树集成方法 ——模型和参数</strong></p>\n<ul>\n<li><p>模型：假设我们有K个树</p>\n<p>$\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$，F是包含所有回归树的函数空间</p>\n</li>\n</ul>\n<p>考虑：回归树是将属性对应为得分的函数</p>\n<ul>\n<li>参数<ul>\n<li>包括每棵树的结构和叶子结点的得分</li>\n<li>或简单的被当作参数适用：$\\Theta = \\lbrace f_1, f_2,…,f_K\\rbrace$</li>\n<li>我们学习的是functions(trees)而不是$R^d$中的权重</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"在单变量上学习回归树\"><a href=\"#在单变量上学习回归树\" class=\"headerlink\" title=\"在单变量上学习回归树\"></a>在单变量上学习回归树</h4><ul>\n<li>如何学习目标函数？</li>\n</ul>\n<ul>\n<li>定义目标函数(loss， regularization),然后优化它。</li>\n<li>比如：<ul>\n<li>考虑在单输入t = (time)上的回归树</li>\n<li>想要预测是否想在t时刻听浪漫音乐</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/86261125.jpg\" alt=\"\"></p>\n<ul>\n<li><p>需要学习的东西：</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/41162967.jpg\" alt=\"\"></p>\n</li>\n<li><p>单变量回归树（阶梯函数）的目标：</p>\n<ul>\n<li>训练损失：函数对点的拟合程度如何？</li>\n<li>结构损失：如何定义函数的结构复杂度？<ul>\n<li>分裂点的数量，每段高度的L2正则化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-11/75298105.jpg\" alt=\"\"></p>\n<h4 id=\"集成回归树的目标函数\"><a href=\"#集成回归树的目标函数\" class=\"headerlink\" title=\"集成回归树的目标函数\"></a>集成回归树的目标函数</h4><ul>\n<li><p>模型：假设我们有K棵树</p>\n<p>$\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$</p>\n</li>\n<li><p>目标函数：</p>\n<p>$Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(k)$</p>\n</li>\n<li><p>定义$\\Omega$可能的方式：</p>\n<ul>\n<li>树的节点数，深度</li>\n<li>L2正规项叶子权重的</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"客观性与启发式\"><a href=\"#客观性与启发式\" class=\"headerlink\" title=\"客观性与启发式\"></a>客观性与启发式</h4><ul>\n<li>当谈及决策树时，经常是启发式的<ul>\n<li>同个信息增益进行分割</li>\n<li>剪枝</li>\n<li>最大化树深度</li>\n<li>平滑叶节点</li>\n</ul>\n</li>\n<li>大多数启发式方法都符合目标，采取正式的（客观）观点让我们知道我们正在学习什么：<ul>\n<li>信息增益 -》减少训练损失</li>\n<li>剪枝 -》根据节点正则化</li>\n<li>最大化树深度 -》函数空间的约束</li>\n<li>平滑叶子value -》 叶子权重的L2正则化</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"回归树不仅仅是为了回归问题\"><a href=\"#回归树不仅仅是为了回归问题\" class=\"headerlink\" title=\"回归树不仅仅是为了回归问题\"></a>回归树不仅仅是为了回归问题</h4><ul>\n<li><p>集成回归树定义了如何获取得分，可被用于分类，回归，打分等场景，取决于如何定义目标函数：</p>\n<ul>\n<li>使用平方损失：梯度提升回归树（common gradient boosted machine）</li>\n<li>使用Logistic损失：LogitBoost</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"三、Gradient-Boosting\"><a href=\"#三、Gradient-Boosting\" class=\"headerlink\" title=\"三、Gradient Boosting\"></a>三、Gradient Boosting</h3><ul>\n<li><p>目标函数：</p>\n<p>​    $Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(f_k), f_k\\in F$</p>\n</li>\n<li><p>我们不能使用梯度下降法来得到f，因为他们是树而不是简单的数值向量。</p>\n</li>\n<li><p>解决办法：<em>additive training</em>(boosting)</p>\n<ul>\n<li>从常量预测开始， 每次增加一个新的函数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-11/97010343.jpg\" alt=\"\"></p>\n<h4 id=\"模型学习：additive-training\"><a href=\"#模型学习：additive-training\" class=\"headerlink\" title=\"模型学习：additive training\"></a>模型学习：additive training</h4><p>现在还剩下一个问题，我们如何选择每一轮加入什么f呢？答案是非常直接的，选取一个f来使得我们的目标函数尽量最大地降低。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/510.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/510.png\" alt=\"5\"></a><br>这个公式可能有些过于抽象，我们可以考虑当l是平方误差的情况。这个时候我们的目标可以被写成下面这样的二次函数9：<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/61.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/61.png\" alt=\"6\"></a><br>更加一般的，对于不是平方误差的情况，我们会采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行这一步的计算。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/72.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/72.png\" alt=\"7\"></a><br>当我们把常数项移除之后，我们会发现如下一个比较统一的目标函数。这一个目标函数有一个非常明显的特点，它只依赖于每个数据点的在误差函数上的一阶导数和二阶导数。有人可能会问，这个材料似乎比我们之前学过的决策树学习难懂。为什么要花这么多力气来做推导呢？<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/82.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/82.png\" alt=\"8\"></a></p>\n<ul>\n<li>因为这样做使得我们可以很清楚地理解整个目标是什么，并且一步一步推导出如何进行树的学习。</li>\n<li>这一个抽象的形式对于实现机器学习工具也是非常有帮助的。传统的GBDT可能大家可以理解如优化平法a残差，但是这样一个形式包含可所有可以求导的目标函数。也就是说有了这个形式，我们写出来的代码可以用来求解包括回归，分类和排序的各种问题，<strong>正式的推导可以使得机器学习的工具更加一般</strong>。</li>\n</ul>\n<h4 id=\"树的复杂度\"><a href=\"#树的复杂度\" class=\"headerlink\" title=\"树的复杂度\"></a>树的复杂度</h4><p>到目前为止我们讨论了目标函数中训练误差的部分。接下来我们讨论如何定义树的复杂度。我们先对于f的定义做一下细化，把树拆分成结构部分q和叶子权重部分w。下图是一个具体的例子。结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/94.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/94.png\" alt=\"9\"></a><br>当我们给定了如上定义之后，我们可以定义一棵树的复杂度如下。这个复杂度包含了一棵树里面节点的个数，以及每个树叶子节点上面输出分数的$L2$模平方。当然这不是唯一的一种定义方式，不过这一定义方式学习出的树效果一般都比较不错。下图还给出了复杂度计算的一个例子。</p>\n<p><a href=\"http://dataunion.org/wp-content/uploads/2015/04/102.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/102.png\" alt=\"10\"></a></p>\n<h4 id=\"重新审视目标\"><a href=\"#重新审视目标\" class=\"headerlink\" title=\"重新审视目标\"></a>重新审视目标</h4><ul>\n<li><p>定义叶子j上面样本集合$ I_j =\\lbrace i|q(x_i)=j\\rbrace$</p>\n</li>\n<li><p>根据叶子重新组织目标</p>\n<p><a href=\"http://dataunion.org/wp-content/uploads/2015/04/a.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/a-1024x199.png\" alt=\"a\"></a></p>\n</li>\n<li><p>由二次函数零点定理,有:</p>\n<p>​    $argmin_x$  $Gx+\\frac {1}{2}Hx^2 = -\\frac {G}{H}, H&gt;0$</p>\n</li>\n<li><p>二次函数的最低点性质有: $min_x$ $Gx+\\frac {1}{2}Hx^2 = -\\frac {1}{2}G^2/H$</p>\n</li>\n<li><p>可以定义</p>\n<p>​    <a href=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png\" alt=\"QQ截图20150423163401\"></a></p>\n<p>那么这个目标函数可以进一步改写成如下的形式<a href=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png\" alt=\"QQ截图20150423163423\"></a></p>\n<p>假设我们已经知道树的结构q(x)，我们可以通过这个目标函数来求解出最优的w，以及最好的w对应的目标函数最大的增益<a href=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png\" alt=\"QQ截图20150423163446\"></a></p>\n</li>\n</ul>\n<h4 id=\"结构分数的计算\"><a href=\"#结构分数的计算\" class=\"headerlink\" title=\"结构分数的计算\"></a>结构分数的计算</h4><p>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)。你可以认为这个就是类似吉尼系数一样更加一般的对于树结构进行打分的函数。下面是一个具体的打分函数计算的例子<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/143.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/143.png\" alt=\"1\"></a></p>\n<h4 id=\"枚举所有不同树结构\"><a href=\"#枚举所有不同树结构\" class=\"headerlink\" title=\"枚举所有不同树结构\"></a>枚举所有不同树结构</h4><ul>\n<li><p>枚举所有可能的树结构</p>\n</li>\n<li><p>利用得分等式,计算q的结构分数</p>\n<p>​    $Obj = -\\frac{1}{2}\\sum_{j=1}^T \\frac{G_j^2}{H_j+\\lambda} + \\gamma T$</p>\n</li>\n<li><p>找到最好的树结构,使用最优的叶子权重 $\\omega_j^*=-\\frac{G_i}{H_j+\\lambda}$</p>\n</li>\n<li><p>但是,可能有无穷尽的树结构,</p>\n</li>\n</ul>\n<h4 id=\"树结构的贪心法\"><a href=\"#树结构的贪心法\" class=\"headerlink\" title=\"树结构的贪心法\"></a>树结构的贪心法</h4><p>常用的方法是贪心法，每一次尝试去对已有的叶子加入一个分割。</p>\n<ul>\n<li>从深度为0的树开始</li>\n<li>对每一个叶子节点尝试进行分割,我们可以获得的增益可以由如下公式计算</li>\n</ul>\n<p><a href=\"http://www.52cs.org/wp-content/uploads/2015/04/12.png\" target=\"_blank\" rel=\"noopener\"></a><a href=\"http://dataunion.org/wp-content/uploads/2015/04/image1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/image1.png\" alt=\"image1\"></a><br>对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？</p>\n<p>假设我们要枚举所有 x&lt;a 这样的条件，对于某个特定的分割a我们要计算a左边和右边的导数和。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/133.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/133.png\" alt=\"13\"></a><br>我们可以发现对于所有的a，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用上面的公式计算每个分割方案的分数就可以了。</p>\n<p>观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic而进行的操作了。</p>\n<h4 id=\"总操作概述\"><a href=\"#总操作概述\" class=\"headerlink\" title=\"总操作概述\"></a>总操作概述</h4><p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-28/19435924.jpg\" alt=\"\"></p>\n<p>讲到这里文章进入了尾声，虽然有些长，希望对大家有所帮助，这篇文章介绍了如何通过目标函数优化的方法比较严格地推导出boosted tree的学习。因为有这样一般的推导，得到的算法可以直接应用到回归，分类排序等各个应用场景中去。</p>\n","site":{"data":{}},"excerpt":"<p>本文翻译自陈天奇大神的英文ppt,喜欢看英文的同学可以<a href=\"https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf\" target=\"_blank\" rel=\"noopener\">直接跳转</a>,翻译当中也增加了一些个人的补充.</p>\n<h2 id=\"一、监督学习的关键概念\"><a href=\"#一、监督学习的关键概念\" class=\"headerlink\" title=\"一、监督学习的关键概念\"></a>一、监督学习的关键概念</h2><h4 id=\"监督学习中的元素\"><a href=\"#监督学习中的元素\" class=\"headerlink\" title=\"监督学习中的元素\"></a>监督学习中的元素</h4><p>$x_i \\in R^D$ :训练集中第i条记录</p>\n<p><strong>模型</strong>： 根据$x_i$预测$\\hat y_i$<br>","more":"<br>线性模型：$\\hat y_i = \\sum_j \\omega_jx_{ij}$（包括线性回归和逻辑回归）</p>\n<p>在不同的任务中$y^i$有不同的解释：</p>\n<ul>\n<li>线性回归中：$y^i$是预测得分</li>\n<li>逻辑回归中：$1/(1+exp(- \\hat y))$是结果为正例的概率</li>\n<li>其他任务，比如打分中，表示预测的分数</li>\n</ul>\n<p><strong>参数</strong>：我们需要从数据中习得的东西</p>\n<p>线性模型：$\\Theta = \\lbrace\\omega_j|j=1,…,d\\rbrace$</p>\n<h4 id=\"目标函数\"><a href=\"#目标函数\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h4><p>$object(\\Theta) = L(\\Theta) + \\Omega(\\Theta)$</p>\n<p><strong>训练集的损失</strong>：$L = \\sum_{i=1}^nl(y_i, \\hat y_i)$</p>\n<ul>\n<li>平方损失：$l(y_i, \\hat y_i) = (y_i - \\hat y_i)^2$</li>\n<li>Logistic损失：$l(y_i, \\hat y_i) = y_iln(1+e^{-y^i}) + (1+e^{\\hat y_i})$</li>\n</ul>\n<p><strong>正则化项</strong>：描述模型结构复杂程度</p>\n<ul>\n<li>L2正则化：$\\Omega(\\omega) = \\lambda||\\omega||^2$</li>\n<li>L1正则化：$\\Omega(\\omega) = \\lambda||\\omega||_1$ </li>\n</ul>\n<h4 id=\"已知的线性回归目标函数\"><a href=\"#已知的线性回归目标函数\" class=\"headerlink\" title=\"已知的线性回归目标函数\"></a>已知的线性回归目标函数</h4><p><strong>岭回归</strong>：$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||^2$</p>\n<p>​    线性模型，平方损失， L2正则化</p>\n<p><strong>Lasso回归：</strong>$\\sum_{i=1}^n(y_i-\\omega^Tx_i)^2 - \\lambda||\\omega||_1$</p>\n<p>​    线性回归， 平方损失， L1正则化</p>\n<p><strong>Logistic回归：</strong>$\\sum_{i=1}^n[ y_iln(1+e^{-\\omega^Tx_i})+ (1+e^{\\omega^Tx_i})^2] - \\lambda||\\omega||^2$</p>\n<p>​    线性回归， logistic损失， L2正则化</p>\n<p>模型，参数，目标之间的概念分离也为带来了工程上的好处。</p>\n<h4 id=\"方差与偏差的权衡\"><a href=\"#方差与偏差的权衡\" class=\"headerlink\" title=\"方差与偏差的权衡\"></a>方差与偏差的权衡</h4><ul>\n<li><p>偏差.</p>\n<p>这里的偏指的是 <strong>偏离</strong> , 那么它偏离了什么到导致了误差? 潜意识上, 当谈到这个词时, 我们可能会认为它是偏离了某个潜在的 “标准”, 而这里这个 “标准” 也就是真实情况 (ground truth). 在分类任务中, 这个 “标准” 就是真实标签 (label).</p>\n</li>\n<li><p>方差.</p>\n<p>很多人应该都还记得在统计学中, 一个随机变量的方差描述的是它的离散程度, 也就是该随机变量在其期望值附近的 <strong>波动程度</strong> . </p>\n</li>\n</ul>\n<p>先从下面的靶心图来对方差与偏差有个直观的感受：</p>\n<p><img src=\"https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-diagram.png\" alt=\"img\"></p>\n<p>假设红色的靶心区域是学习算法完美的正确预测值, 蓝色点为每个数据集所训练出的模型对样本的预测值, 当我们从靶心逐渐向外移动时, 预测效果逐渐变差.</p>\n<p>很容易看出有两副图中蓝色点比较集中, 另外两幅中比较分散, 它们描述的是方差的两种情况. 比较集中的属于方差小的, 比较分散的属于方差大的情况.</p>\n<p>再从蓝色点与红色靶心区域的位置关系, 靠近红色靶心的属于偏差较小的情况, 远离靶心的属于偏差较大的情况.</p>\n<p><img src=\"https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-label-diagram.png\" alt=\"img\"></p>\n<p>[本节偏差方差解释部分来自博客]<a href=\"https://blog.csdn.net/simple_the_best/article/details/71167786\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/simple_the_best/article/details/71167786</a></p>\n<p>将目标函数分为损失函数和正则化项的原因在于：</p>\n<ul>\n<li><p>优化训练损失会激励预测模型</p>\n<p>​    对训练数据集的良好拟合，至少可以让模型在训练数据上表现良好，有可能更接近数据的底层分布</p>\n</li>\n<li><p>优化正则化项有利于产生简单的模型</p>\n<p>​    简单的模型在预测数据上方差更小，使模型可靠性更强</p>\n</li>\n</ul>\n<h2 id=\"二、回归树和集成方法\"><a href=\"#二、回归树和集成方法\" class=\"headerlink\" title=\"二、回归树和集成方法\"></a>二、回归树和集成方法</h2><p><strong>回归树（CART,又叫分类回归树）</strong></p>\n<ul>\n<li>像决策树一样制定规则</li>\n<li>每个叶节点包含一个值</li>\n</ul>\n<p>例子：判断是否喜欢电脑游戏</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/74239098.jpg\" alt=\"\"></p>\n<p><strong>回归树集成：最终的得分是每个树得分的和</strong><br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/14929391.jpg\" alt=\"\"></p>\n<p><strong>树集成方法 ——模型和参数</strong></p>\n<ul>\n<li><p>模型：假设我们有K个树</p>\n<p>$\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$，F是包含所有回归树的函数空间</p>\n</li>\n</ul>\n<p>考虑：回归树是将属性对应为得分的函数</p>\n<ul>\n<li>参数<ul>\n<li>包括每棵树的结构和叶子结点的得分</li>\n<li>或简单的被当作参数适用：$\\Theta = \\lbrace f_1, f_2,…,f_K\\rbrace$</li>\n<li>我们学习的是functions(trees)而不是$R^d$中的权重</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"在单变量上学习回归树\"><a href=\"#在单变量上学习回归树\" class=\"headerlink\" title=\"在单变量上学习回归树\"></a>在单变量上学习回归树</h4><ul>\n<li>如何学习目标函数？</li>\n</ul>\n<ul>\n<li>定义目标函数(loss， regularization),然后优化它。</li>\n<li>比如：<ul>\n<li>考虑在单输入t = (time)上的回归树</li>\n<li>想要预测是否想在t时刻听浪漫音乐</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/86261125.jpg\" alt=\"\"></p>\n<ul>\n<li><p>需要学习的东西：</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-10/41162967.jpg\" alt=\"\"></p>\n</li>\n<li><p>单变量回归树（阶梯函数）的目标：</p>\n<ul>\n<li>训练损失：函数对点的拟合程度如何？</li>\n<li>结构损失：如何定义函数的结构复杂度？<ul>\n<li>分裂点的数量，每段高度的L2正则化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-11/75298105.jpg\" alt=\"\"></p>\n<h4 id=\"集成回归树的目标函数\"><a href=\"#集成回归树的目标函数\" class=\"headerlink\" title=\"集成回归树的目标函数\"></a>集成回归树的目标函数</h4><ul>\n<li><p>模型：假设我们有K棵树</p>\n<p>$\\hat y_i = \\sum_{k=1}^Kf_k(x_i)  ,  f_k\\in F$</p>\n</li>\n<li><p>目标函数：</p>\n<p>$Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(k)$</p>\n</li>\n<li><p>定义$\\Omega$可能的方式：</p>\n<ul>\n<li>树的节点数，深度</li>\n<li>L2正规项叶子权重的</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"客观性与启发式\"><a href=\"#客观性与启发式\" class=\"headerlink\" title=\"客观性与启发式\"></a>客观性与启发式</h4><ul>\n<li>当谈及决策树时，经常是启发式的<ul>\n<li>同个信息增益进行分割</li>\n<li>剪枝</li>\n<li>最大化树深度</li>\n<li>平滑叶节点</li>\n</ul>\n</li>\n<li>大多数启发式方法都符合目标，采取正式的（客观）观点让我们知道我们正在学习什么：<ul>\n<li>信息增益 -》减少训练损失</li>\n<li>剪枝 -》根据节点正则化</li>\n<li>最大化树深度 -》函数空间的约束</li>\n<li>平滑叶子value -》 叶子权重的L2正则化</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"回归树不仅仅是为了回归问题\"><a href=\"#回归树不仅仅是为了回归问题\" class=\"headerlink\" title=\"回归树不仅仅是为了回归问题\"></a>回归树不仅仅是为了回归问题</h4><ul>\n<li><p>集成回归树定义了如何获取得分，可被用于分类，回归，打分等场景，取决于如何定义目标函数：</p>\n<ul>\n<li>使用平方损失：梯度提升回归树（common gradient boosted machine）</li>\n<li>使用Logistic损失：LogitBoost</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"三、Gradient-Boosting\"><a href=\"#三、Gradient-Boosting\" class=\"headerlink\" title=\"三、Gradient Boosting\"></a>三、Gradient Boosting</h3><ul>\n<li><p>目标函数：</p>\n<p>​    $Obj = \\sum_{i=1}^nl(y,\\hat y_i) + \\sum_{k=1}^K\\Omega(f_k), f_k\\in F$</p>\n</li>\n<li><p>我们不能使用梯度下降法来得到f，因为他们是树而不是简单的数值向量。</p>\n</li>\n<li><p>解决办法：<em>additive training</em>(boosting)</p>\n<ul>\n<li>从常量预测开始， 每次增加一个新的函数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-11/97010343.jpg\" alt=\"\"></p>\n<h4 id=\"模型学习：additive-training\"><a href=\"#模型学习：additive-training\" class=\"headerlink\" title=\"模型学习：additive training\"></a>模型学习：additive training</h4><p>现在还剩下一个问题，我们如何选择每一轮加入什么f呢？答案是非常直接的，选取一个f来使得我们的目标函数尽量最大地降低。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/510.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/510.png\" alt=\"5\"></a><br>这个公式可能有些过于抽象，我们可以考虑当l是平方误差的情况。这个时候我们的目标可以被写成下面这样的二次函数9：<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/61.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/61.png\" alt=\"6\"></a><br>更加一般的，对于不是平方误差的情况，我们会采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行这一步的计算。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/72.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/72.png\" alt=\"7\"></a><br>当我们把常数项移除之后，我们会发现如下一个比较统一的目标函数。这一个目标函数有一个非常明显的特点，它只依赖于每个数据点的在误差函数上的一阶导数和二阶导数。有人可能会问，这个材料似乎比我们之前学过的决策树学习难懂。为什么要花这么多力气来做推导呢？<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/82.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/82.png\" alt=\"8\"></a></p>\n<ul>\n<li>因为这样做使得我们可以很清楚地理解整个目标是什么，并且一步一步推导出如何进行树的学习。</li>\n<li>这一个抽象的形式对于实现机器学习工具也是非常有帮助的。传统的GBDT可能大家可以理解如优化平法a残差，但是这样一个形式包含可所有可以求导的目标函数。也就是说有了这个形式，我们写出来的代码可以用来求解包括回归，分类和排序的各种问题，<strong>正式的推导可以使得机器学习的工具更加一般</strong>。</li>\n</ul>\n<h4 id=\"树的复杂度\"><a href=\"#树的复杂度\" class=\"headerlink\" title=\"树的复杂度\"></a>树的复杂度</h4><p>到目前为止我们讨论了目标函数中训练误差的部分。接下来我们讨论如何定义树的复杂度。我们先对于f的定义做一下细化，把树拆分成结构部分q和叶子权重部分w。下图是一个具体的例子。结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/94.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/94.png\" alt=\"9\"></a><br>当我们给定了如上定义之后，我们可以定义一棵树的复杂度如下。这个复杂度包含了一棵树里面节点的个数，以及每个树叶子节点上面输出分数的$L2$模平方。当然这不是唯一的一种定义方式，不过这一定义方式学习出的树效果一般都比较不错。下图还给出了复杂度计算的一个例子。</p>\n<p><a href=\"http://dataunion.org/wp-content/uploads/2015/04/102.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/102.png\" alt=\"10\"></a></p>\n<h4 id=\"重新审视目标\"><a href=\"#重新审视目标\" class=\"headerlink\" title=\"重新审视目标\"></a>重新审视目标</h4><ul>\n<li><p>定义叶子j上面样本集合$ I_j =\\lbrace i|q(x_i)=j\\rbrace$</p>\n</li>\n<li><p>根据叶子重新组织目标</p>\n<p><a href=\"http://dataunion.org/wp-content/uploads/2015/04/a.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/a-1024x199.png\" alt=\"a\"></a></p>\n</li>\n<li><p>由二次函数零点定理,有:</p>\n<p>​    $argmin_x$  $Gx+\\frac {1}{2}Hx^2 = -\\frac {G}{H}, H&gt;0$</p>\n</li>\n<li><p>二次函数的最低点性质有: $min_x$ $Gx+\\frac {1}{2}Hx^2 = -\\frac {1}{2}G^2/H$</p>\n</li>\n<li><p>可以定义</p>\n<p>​    <a href=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png\" alt=\"QQ截图20150423163401\"></a></p>\n<p>那么这个目标函数可以进一步改写成如下的形式<a href=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png\" alt=\"QQ截图20150423163423\"></a></p>\n<p>假设我们已经知道树的结构q(x)，我们可以通过这个目标函数来求解出最优的w，以及最好的w对应的目标函数最大的增益<a href=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png\" alt=\"QQ截图20150423163446\"></a></p>\n</li>\n</ul>\n<h4 id=\"结构分数的计算\"><a href=\"#结构分数的计算\" class=\"headerlink\" title=\"结构分数的计算\"></a>结构分数的计算</h4><p>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)。你可以认为这个就是类似吉尼系数一样更加一般的对于树结构进行打分的函数。下面是一个具体的打分函数计算的例子<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/143.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/143.png\" alt=\"1\"></a></p>\n<h4 id=\"枚举所有不同树结构\"><a href=\"#枚举所有不同树结构\" class=\"headerlink\" title=\"枚举所有不同树结构\"></a>枚举所有不同树结构</h4><ul>\n<li><p>枚举所有可能的树结构</p>\n</li>\n<li><p>利用得分等式,计算q的结构分数</p>\n<p>​    $Obj = -\\frac{1}{2}\\sum_{j=1}^T \\frac{G_j^2}{H_j+\\lambda} + \\gamma T$</p>\n</li>\n<li><p>找到最好的树结构,使用最优的叶子权重 $\\omega_j^*=-\\frac{G_i}{H_j+\\lambda}$</p>\n</li>\n<li><p>但是,可能有无穷尽的树结构,</p>\n</li>\n</ul>\n<h4 id=\"树结构的贪心法\"><a href=\"#树结构的贪心法\" class=\"headerlink\" title=\"树结构的贪心法\"></a>树结构的贪心法</h4><p>常用的方法是贪心法，每一次尝试去对已有的叶子加入一个分割。</p>\n<ul>\n<li>从深度为0的树开始</li>\n<li>对每一个叶子节点尝试进行分割,我们可以获得的增益可以由如下公式计算</li>\n</ul>\n<p><a href=\"http://www.52cs.org/wp-content/uploads/2015/04/12.png\" target=\"_blank\" rel=\"noopener\"></a><a href=\"http://dataunion.org/wp-content/uploads/2015/04/image1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/image1.png\" alt=\"image1\"></a><br>对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？</p>\n<p>假设我们要枚举所有 x&lt;a 这样的条件，对于某个特定的分割a我们要计算a左边和右边的导数和。<br><a href=\"http://dataunion.org/wp-content/uploads/2015/04/133.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://dataunion.org/wp-content/uploads/2015/04/133.png\" alt=\"13\"></a><br>我们可以发现对于所有的a，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用上面的公式计算每个分割方案的分数就可以了。</p>\n<p>观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic而进行的操作了。</p>\n<h4 id=\"总操作概述\"><a href=\"#总操作概述\" class=\"headerlink\" title=\"总操作概述\"></a>总操作概述</h4><p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-28/19435924.jpg\" alt=\"\"></p>\n<p>讲到这里文章进入了尾声，虽然有些长，希望对大家有所帮助，这篇文章介绍了如何通过目标函数优化的方法比较严格地推导出boosted tree的学习。因为有这样一般的推导，得到的算法可以直接应用到回归，分类排序等各个应用场景中去。</p>"},{"title":"ES分词器","date":"2018-06-03T16:15:12.000Z","_content":"\nES逗号分词\n1：新建分析器\n```\ncurl -XPOST 'http://172.18.0.4:9200/demo/?pretty' -d '\n{\n　　\"settings\":\n　　{\n　　　　\"analysis\":\n　　　　　　{\n　　　　　　　　\"analyzer\":\n　　　　　　　　　　{\n　　　　　　　　　　　　\"douhao\":\n　　　　　　　　　　　　　　{\n　　　　　　　　　　　　　　　　\"type\":\"pattern\",\n　　　　　　　　　　　　　　　　\"pattern\":\",\"\n　　　　　　　　　　　　　　}\n　　　　　　　　　}\n　　　　　　}\n　　}\n\n}'\n```\n <!-- more-->\n2：将分析器mapping到新的字段上（旧的字段上是无法修改mapping），当然最好的办法是使用别名，可以零停机切换\n```\ncurl -XPOST 'http://172.18.0.4:9200/demo/_mapping/master?pretty' -d '\n{\n　　\"properties\":\n　　{\n　　　　\"master_id\":\n　　　　{\n　　　　　　\"type\":\"string\",\n　　　　　　\"index\":\"not_analyzed\"\n　　　　},\n　　　　\"serve_regions\":\n　　　　{\n　　　　　　\"type\":\"string\",\n　　　　　　\"analyzer\":\"douhao\",\n　　　　　　\"search_analyzer\":\"douhao\"\n　　　　}\n　　}\n}'\n```\n\n3：同步MYSQL的数据到ES（或者手动添加两条数据）\n\ncurl -PUT 'http://172.18.0.4:9200/demo/master/?pretty' -d '{\"master_id\":\"123\",\"serve_regions\":\"1,2,3\"}'\n\ncurl -PUT 'http://172.18.0.4:9200/demo/master/?pretty' -d '{\"master_id\":\"321\",\"serve_regions\":\"1\"}'\n\ncurl -PUT 'http://172.18.0.4:9200/demo/master/?pretty' -d '{\"master_id\":\"231\",\"serve_regions\":\"2,3\"}'\n\n\n4：测试 http://172.18.0.4:9200/_plugin/head\n\n参考文档\n\n　　1：ES中如何使用逗号来分词[http://yangshangchuan.iteye.com/blog/2280720]\n","source":"_posts/ES分词器.md","raw":"---\ntitle: ES分词器\ndate: 2018-06-04 00:15:12\ntags: [ElasticSearch, 大数据]\n---\n\nES逗号分词\n1：新建分析器\n```\ncurl -XPOST 'http://172.18.0.4:9200/demo/?pretty' -d '\n{\n　　\"settings\":\n　　{\n　　　　\"analysis\":\n　　　　　　{\n　　　　　　　　\"analyzer\":\n　　　　　　　　　　{\n　　　　　　　　　　　　\"douhao\":\n　　　　　　　　　　　　　　{\n　　　　　　　　　　　　　　　　\"type\":\"pattern\",\n　　　　　　　　　　　　　　　　\"pattern\":\",\"\n　　　　　　　　　　　　　　}\n　　　　　　　　　}\n　　　　　　}\n　　}\n\n}'\n```\n <!-- more-->\n2：将分析器mapping到新的字段上（旧的字段上是无法修改mapping），当然最好的办法是使用别名，可以零停机切换\n```\ncurl -XPOST 'http://172.18.0.4:9200/demo/_mapping/master?pretty' -d '\n{\n　　\"properties\":\n　　{\n　　　　\"master_id\":\n　　　　{\n　　　　　　\"type\":\"string\",\n　　　　　　\"index\":\"not_analyzed\"\n　　　　},\n　　　　\"serve_regions\":\n　　　　{\n　　　　　　\"type\":\"string\",\n　　　　　　\"analyzer\":\"douhao\",\n　　　　　　\"search_analyzer\":\"douhao\"\n　　　　}\n　　}\n}'\n```\n\n3：同步MYSQL的数据到ES（或者手动添加两条数据）\n\ncurl -PUT 'http://172.18.0.4:9200/demo/master/?pretty' -d '{\"master_id\":\"123\",\"serve_regions\":\"1,2,3\"}'\n\ncurl -PUT 'http://172.18.0.4:9200/demo/master/?pretty' -d '{\"master_id\":\"321\",\"serve_regions\":\"1\"}'\n\ncurl -PUT 'http://172.18.0.4:9200/demo/master/?pretty' -d '{\"master_id\":\"231\",\"serve_regions\":\"2,3\"}'\n\n\n4：测试 http://172.18.0.4:9200/_plugin/head\n\n参考文档\n\n　　1：ES中如何使用逗号来分词[http://yangshangchuan.iteye.com/blog/2280720]\n","slug":"ES分词器","published":1,"updated":"2018-06-07T14:06:15.375Z","_id":"cji4l7i5z0001cf96px32hdz0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>ES逗号分词<br>1：新建分析器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -XPOST &apos;http://172.18.0.4:9200/demo/?pretty&apos; -d &apos;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　&quot;settings&quot;:</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　　　&quot;analysis&quot;:</span><br><span class=\"line\">　　　　　　&#123;</span><br><span class=\"line\">　　　　　　　　&quot;analyzer&quot;:</span><br><span class=\"line\">　　　　　　　　　　&#123;</span><br><span class=\"line\">　　　　　　　　　　　　&quot;douhao&quot;:</span><br><span class=\"line\">　　　　　　　　　　　　　　&#123;</span><br><span class=\"line\">　　　　　　　　　　　　　　　　&quot;type&quot;:&quot;pattern&quot;,</span><br><span class=\"line\">　　　　　　　　　　　　　　　　&quot;pattern&quot;:&quot;,&quot;</span><br><span class=\"line\">　　　　　　　　　　　　　　&#125;</span><br><span class=\"line\">　　　　　　　　　&#125;</span><br><span class=\"line\">　　　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;&apos;</span><br></pre></td></tr></table></figure></p>\n <a id=\"more\"></a>\n<p>2：将分析器mapping到新的字段上（旧的字段上是无法修改mapping），当然最好的办法是使用别名，可以零停机切换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -XPOST &apos;http://172.18.0.4:9200/demo/_mapping/master?pretty&apos; -d &apos;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　&quot;properties&quot;:</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　　　&quot;master_id&quot;:</span><br><span class=\"line\">　　　　&#123;</span><br><span class=\"line\">　　　　　　&quot;type&quot;:&quot;string&quot;,</span><br><span class=\"line\">　　　　　　&quot;index&quot;:&quot;not_analyzed&quot;</span><br><span class=\"line\">　　　　&#125;,</span><br><span class=\"line\">　　　　&quot;serve_regions&quot;:</span><br><span class=\"line\">　　　　&#123;</span><br><span class=\"line\">　　　　　　&quot;type&quot;:&quot;string&quot;,</span><br><span class=\"line\">　　　　　　&quot;analyzer&quot;:&quot;douhao&quot;,</span><br><span class=\"line\">　　　　　　&quot;search_analyzer&quot;:&quot;douhao&quot;</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;&apos;</span><br></pre></td></tr></table></figure></p>\n<p>3：同步MYSQL的数据到ES（或者手动添加两条数据）</p>\n<p>curl -PUT ‘<a href=\"http://172.18.0.4:9200/demo/master/?pretty&#39;\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/demo/master/?pretty&#39;</a> -d ‘{“master_id”:”123”,”serve_regions”:”1,2,3”}’</p>\n<p>curl -PUT ‘<a href=\"http://172.18.0.4:9200/demo/master/?pretty&#39;\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/demo/master/?pretty&#39;</a> -d ‘{“master_id”:”321”,”serve_regions”:”1”}’</p>\n<p>curl -PUT ‘<a href=\"http://172.18.0.4:9200/demo/master/?pretty&#39;\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/demo/master/?pretty&#39;</a> -d ‘{“master_id”:”231”,”serve_regions”:”2,3”}’</p>\n<p>4：测试 <a href=\"http://172.18.0.4:9200/_plugin/head\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/_plugin/head</a></p>\n<p>参考文档</p>\n<p>　　1：ES中如何使用逗号来分词[<a href=\"http://yangshangchuan.iteye.com/blog/2280720]\" target=\"_blank\" rel=\"noopener\">http://yangshangchuan.iteye.com/blog/2280720]</a></p>\n","site":{"data":{}},"excerpt":"<p>ES逗号分词<br>1：新建分析器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -XPOST &apos;http://172.18.0.4:9200/demo/?pretty&apos; -d &apos;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　&quot;settings&quot;:</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　　　&quot;analysis&quot;:</span><br><span class=\"line\">　　　　　　&#123;</span><br><span class=\"line\">　　　　　　　　&quot;analyzer&quot;:</span><br><span class=\"line\">　　　　　　　　　　&#123;</span><br><span class=\"line\">　　　　　　　　　　　　&quot;douhao&quot;:</span><br><span class=\"line\">　　　　　　　　　　　　　　&#123;</span><br><span class=\"line\">　　　　　　　　　　　　　　　　&quot;type&quot;:&quot;pattern&quot;,</span><br><span class=\"line\">　　　　　　　　　　　　　　　　&quot;pattern&quot;:&quot;,&quot;</span><br><span class=\"line\">　　　　　　　　　　　　　　&#125;</span><br><span class=\"line\">　　　　　　　　　&#125;</span><br><span class=\"line\">　　　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;&apos;</span><br></pre></td></tr></table></figure></p>","more":"<p>2：将分析器mapping到新的字段上（旧的字段上是无法修改mapping），当然最好的办法是使用别名，可以零停机切换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -XPOST &apos;http://172.18.0.4:9200/demo/_mapping/master?pretty&apos; -d &apos;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　&quot;properties&quot;:</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　　　&quot;master_id&quot;:</span><br><span class=\"line\">　　　　&#123;</span><br><span class=\"line\">　　　　　　&quot;type&quot;:&quot;string&quot;,</span><br><span class=\"line\">　　　　　　&quot;index&quot;:&quot;not_analyzed&quot;</span><br><span class=\"line\">　　　　&#125;,</span><br><span class=\"line\">　　　　&quot;serve_regions&quot;:</span><br><span class=\"line\">　　　　&#123;</span><br><span class=\"line\">　　　　　　&quot;type&quot;:&quot;string&quot;,</span><br><span class=\"line\">　　　　　　&quot;analyzer&quot;:&quot;douhao&quot;,</span><br><span class=\"line\">　　　　　　&quot;search_analyzer&quot;:&quot;douhao&quot;</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;&apos;</span><br></pre></td></tr></table></figure></p>\n<p>3：同步MYSQL的数据到ES（或者手动添加两条数据）</p>\n<p>curl -PUT ‘<a href=\"http://172.18.0.4:9200/demo/master/?pretty&#39;\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/demo/master/?pretty&#39;</a> -d ‘{“master_id”:”123”,”serve_regions”:”1,2,3”}’</p>\n<p>curl -PUT ‘<a href=\"http://172.18.0.4:9200/demo/master/?pretty&#39;\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/demo/master/?pretty&#39;</a> -d ‘{“master_id”:”321”,”serve_regions”:”1”}’</p>\n<p>curl -PUT ‘<a href=\"http://172.18.0.4:9200/demo/master/?pretty&#39;\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/demo/master/?pretty&#39;</a> -d ‘{“master_id”:”231”,”serve_regions”:”2,3”}’</p>\n<p>4：测试 <a href=\"http://172.18.0.4:9200/_plugin/head\" target=\"_blank\" rel=\"noopener\">http://172.18.0.4:9200/_plugin/head</a></p>\n<p>参考文档</p>\n<p>　　1：ES中如何使用逗号来分词[<a href=\"http://yangshangchuan.iteye.com/blog/2280720]\" target=\"_blank\" rel=\"noopener\">http://yangshangchuan.iteye.com/blog/2280720]</a></p>"},{"title":"Fabric启用网络","date":"2018-05-02T12:19:01.000Z","_content":"\n> 本博客是作者在安装Fabric时所作记录，并不全面，详细的安装流程请到[Fabric官方教程](http://hyperledger-fabric.readthedocs.io/en/release-1.1/getting_started.html)一步一步进行\n\n我们将使用cryptogen工具为我们的各种网络实体生成加密材料（x509证书和签名密钥）。 这些证书是身份的代表，它们允许在我们的实体进行通信和交易时进行签名/验证身份验证。\n\n**手动生成证书和配置交易**\n <!-- more-->\n- 生成证书和密钥：\n\n```\n../bin/cryptogen generate --config=./crypto-config.yaml\n```\n\n证书和密钥（即MSP材料）将被输出到第一个网络目录根目录下的一个目录 -  crypto-config中。\n\n- 需要告诉configtxgen工具在哪里查找它需要获取的configtx.yaml文件。\n\n  ```\n  export FABRIC_CFG_PATH=$PWD \n  ```\n\n- 调用configtxgen工具来创建ordererc初始块：\n\n  ```\n  ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block\n  ```\n\n**创建一个通道配置事务**\n\n```\nexport CHANNEL_NAME=mychannel  && ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME\n```\n\n- 接下来，我们将在我们正在构建的频道上为Org1定义锚点。\n\n  ```\n  ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP\n  ```\n\n- 为Org2定义锚点\n\n```\n../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP\n```\n\n**启动网络**\n\n```\ndocker-compose -f docker-compose-cli.yaml up -d\n```\n\n**环境变量**\n\n```\ndocker exec -it cli bash\n```\n\n- 之前，我们使用configtxgen工具生成了配置交易channel.tx。我们将会传递这个交易到orderer作为创建channel请求的一部分\n\n```\nexport CHANNEL_NAME=mychannel\n```\n\n```\npeer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem\n```\n\n```\n加入peer0.org1.example.com到通道。\n peer channel join -b mychannel.block\n```\n\n- 我们只需加入peer0.org2.example.com，以便我们可以正确更新我们通道中的锚点定义，而不是加入每个点。\n\n```\nCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=\"Org2MSP\" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block\n```\n\n- 应用程序通过链接代码与区块链分类帐进行交互。 因此，我们需要在每个将执行并支持我们的交易的对等方上安装链代码，然后在通道上实例化链代码。\n\n```\npeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/\n```\n\n- 接下来，实例化通道上的链式代码。 这将初始化通道上的链代码，设置链代码的认可政策，并为目标对等体启动链代码容器。 记下-P参数。 这是我们的政策，我们指定所需的交易背书水平，以验证此链代码。\n\n```\npeer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c '{\"Args\":[\"init\",\"a\", \"100\", \"b\",\"200\"]}' -P \"OR ('Org1MSP.peer','Org2MSP.peer')\"\n```\n\n- 让我们查询a的值以确保链代码已正确实例化并且状态DB已填充。 查询的语法如下所示：\n\n```\npeer chaincode query -C $CHANNEL_NAME -n mycc -c '{\"Args\":[\"query\",\"a\"]}'\n```\n\n- 现在让我们将10从a移动到b。 该事务将切断一个新块并更新状态DB。 invoke的语法如下所示：\n\n```\npeer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c '{\"Args\":[\"invoke\",\"a\",\"b\",\"10\"]}'\n```\n\n- 再查询\n\n  ```peer chaincode query -c $channel_name -n mycc -c '{\"args\":[\"query\",\"a\"]}'\n  peer chaincode query -C $CHANNEL_NAME -n mycc -c '{\"Args\":[\"query\",\"a\"]}'\n  ```\n","source":"_posts/Fabric启用网络.md","raw":"---\ntitle: Fabric启用网络\ndate: 2018-05-02 20:19:01\ntags: 区块链\n---\n\n> 本博客是作者在安装Fabric时所作记录，并不全面，详细的安装流程请到[Fabric官方教程](http://hyperledger-fabric.readthedocs.io/en/release-1.1/getting_started.html)一步一步进行\n\n我们将使用cryptogen工具为我们的各种网络实体生成加密材料（x509证书和签名密钥）。 这些证书是身份的代表，它们允许在我们的实体进行通信和交易时进行签名/验证身份验证。\n\n**手动生成证书和配置交易**\n <!-- more-->\n- 生成证书和密钥：\n\n```\n../bin/cryptogen generate --config=./crypto-config.yaml\n```\n\n证书和密钥（即MSP材料）将被输出到第一个网络目录根目录下的一个目录 -  crypto-config中。\n\n- 需要告诉configtxgen工具在哪里查找它需要获取的configtx.yaml文件。\n\n  ```\n  export FABRIC_CFG_PATH=$PWD \n  ```\n\n- 调用configtxgen工具来创建ordererc初始块：\n\n  ```\n  ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block\n  ```\n\n**创建一个通道配置事务**\n\n```\nexport CHANNEL_NAME=mychannel  && ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME\n```\n\n- 接下来，我们将在我们正在构建的频道上为Org1定义锚点。\n\n  ```\n  ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP\n  ```\n\n- 为Org2定义锚点\n\n```\n../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP\n```\n\n**启动网络**\n\n```\ndocker-compose -f docker-compose-cli.yaml up -d\n```\n\n**环境变量**\n\n```\ndocker exec -it cli bash\n```\n\n- 之前，我们使用configtxgen工具生成了配置交易channel.tx。我们将会传递这个交易到orderer作为创建channel请求的一部分\n\n```\nexport CHANNEL_NAME=mychannel\n```\n\n```\npeer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem\n```\n\n```\n加入peer0.org1.example.com到通道。\n peer channel join -b mychannel.block\n```\n\n- 我们只需加入peer0.org2.example.com，以便我们可以正确更新我们通道中的锚点定义，而不是加入每个点。\n\n```\nCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=\"Org2MSP\" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block\n```\n\n- 应用程序通过链接代码与区块链分类帐进行交互。 因此，我们需要在每个将执行并支持我们的交易的对等方上安装链代码，然后在通道上实例化链代码。\n\n```\npeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/\n```\n\n- 接下来，实例化通道上的链式代码。 这将初始化通道上的链代码，设置链代码的认可政策，并为目标对等体启动链代码容器。 记下-P参数。 这是我们的政策，我们指定所需的交易背书水平，以验证此链代码。\n\n```\npeer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c '{\"Args\":[\"init\",\"a\", \"100\", \"b\",\"200\"]}' -P \"OR ('Org1MSP.peer','Org2MSP.peer')\"\n```\n\n- 让我们查询a的值以确保链代码已正确实例化并且状态DB已填充。 查询的语法如下所示：\n\n```\npeer chaincode query -C $CHANNEL_NAME -n mycc -c '{\"Args\":[\"query\",\"a\"]}'\n```\n\n- 现在让我们将10从a移动到b。 该事务将切断一个新块并更新状态DB。 invoke的语法如下所示：\n\n```\npeer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c '{\"Args\":[\"invoke\",\"a\",\"b\",\"10\"]}'\n```\n\n- 再查询\n\n  ```peer chaincode query -c $channel_name -n mycc -c '{\"args\":[\"query\",\"a\"]}'\n  peer chaincode query -C $CHANNEL_NAME -n mycc -c '{\"Args\":[\"query\",\"a\"]}'\n  ```\n","slug":"Fabric启用网络","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i660003cf96eu5iifg5","content":"<blockquote>\n<p>本博客是作者在安装Fabric时所作记录，并不全面，详细的安装流程请到<a href=\"http://hyperledger-fabric.readthedocs.io/en/release-1.1/getting_started.html\" target=\"_blank\" rel=\"noopener\">Fabric官方教程</a>一步一步进行</p>\n</blockquote>\n<p>我们将使用cryptogen工具为我们的各种网络实体生成加密材料（x509证书和签名密钥）。 这些证书是身份的代表，它们允许在我们的实体进行通信和交易时进行签名/验证身份验证。</p>\n<p><strong>手动生成证书和配置交易</strong><br> <a id=\"more\"></a></p>\n<ul>\n<li>生成证书和密钥：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/cryptogen generate --config=./crypto-config.yaml</span><br></pre></td></tr></table></figure>\n<p>证书和密钥（即MSP材料）将被输出到第一个网络目录根目录下的一个目录 -  crypto-config中。</p>\n<ul>\n<li><p>需要告诉configtxgen工具在哪里查找它需要获取的configtx.yaml文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export FABRIC_CFG_PATH=$PWD</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用configtxgen工具来创建ordererc初始块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>创建一个通道配置事务</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export CHANNEL_NAME=mychannel  &amp;&amp; ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>接下来，我们将在我们正在构建的频道上为Org1定义锚点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为Org2定义锚点</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP</span><br></pre></td></tr></table></figure>\n<p><strong>启动网络</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure>\n<p><strong>环境变量</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it cli bash</span><br></pre></td></tr></table></figure>\n<ul>\n<li>之前，我们使用configtxgen工具生成了配置交易channel.tx。我们将会传递这个交易到orderer作为创建channel请求的一部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export CHANNEL_NAME=mychannel</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加入peer0.org1.example.com到通道。</span><br><span class=\"line\"> peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure>\n<ul>\n<li>我们只需加入peer0.org2.example.com，以便我们可以正确更新我们通道中的锚点定义，而不是加入每个点。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure>\n<ul>\n<li>应用程序通过链接代码与区块链分类帐进行交互。 因此，我们需要在每个将执行并支持我们的交易的对等方上安装链代码，然后在通道上实例化链代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>接下来，实例化通道上的链式代码。 这将初始化通道上的链代码，设置链代码的认可政策，并为目标对等体启动链代码容器。 记下-P参数。 这是我们的政策，我们指定所需的交易背书水平，以验证此链代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c &apos;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]&#125;&apos; -P &quot;OR (&apos;Org1MSP.peer&apos;,&apos;Org2MSP.peer&apos;)&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>让我们查询a的值以确保链代码已正确实例化并且状态DB已填充。 查询的语法如下所示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode query -C $CHANNEL_NAME -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>现在让我们将10从a移动到b。 该事务将切断一个新块并更新状态DB。 invoke的语法如下所示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>再查询</p>\n<figure class=\"highlight plain\"><figcaption><span>chaincode query -c $channel_name -n mycc -c '&#123;\"args\":[\"query\",\"a\"]&#125;'</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode query -C $CHANNEL_NAME -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本博客是作者在安装Fabric时所作记录，并不全面，详细的安装流程请到<a href=\"http://hyperledger-fabric.readthedocs.io/en/release-1.1/getting_started.html\" target=\"_blank\" rel=\"noopener\">Fabric官方教程</a>一步一步进行</p>\n</blockquote>\n<p>我们将使用cryptogen工具为我们的各种网络实体生成加密材料（x509证书和签名密钥）。 这些证书是身份的代表，它们允许在我们的实体进行通信和交易时进行签名/验证身份验证。</p>\n<p><strong>手动生成证书和配置交易</strong><br>","more":"</p>\n<ul>\n<li>生成证书和密钥：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/cryptogen generate --config=./crypto-config.yaml</span><br></pre></td></tr></table></figure>\n<p>证书和密钥（即MSP材料）将被输出到第一个网络目录根目录下的一个目录 -  crypto-config中。</p>\n<ul>\n<li><p>需要告诉configtxgen工具在哪里查找它需要获取的configtx.yaml文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export FABRIC_CFG_PATH=$PWD</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用configtxgen工具来创建ordererc初始块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>创建一个通道配置事务</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export CHANNEL_NAME=mychannel  &amp;&amp; ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>接下来，我们将在我们正在构建的频道上为Org1定义锚点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为Org2定义锚点</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP</span><br></pre></td></tr></table></figure>\n<p><strong>启动网络</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure>\n<p><strong>环境变量</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it cli bash</span><br></pre></td></tr></table></figure>\n<ul>\n<li>之前，我们使用configtxgen工具生成了配置交易channel.tx。我们将会传递这个交易到orderer作为创建channel请求的一部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export CHANNEL_NAME=mychannel</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加入peer0.org1.example.com到通道。</span><br><span class=\"line\"> peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure>\n<ul>\n<li>我们只需加入peer0.org2.example.com，以便我们可以正确更新我们通道中的锚点定义，而不是加入每个点。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure>\n<ul>\n<li>应用程序通过链接代码与区块链分类帐进行交互。 因此，我们需要在每个将执行并支持我们的交易的对等方上安装链代码，然后在通道上实例化链代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>接下来，实例化通道上的链式代码。 这将初始化通道上的链代码，设置链代码的认可政策，并为目标对等体启动链代码容器。 记下-P参数。 这是我们的政策，我们指定所需的交易背书水平，以验证此链代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c &apos;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]&#125;&apos; -P &quot;OR (&apos;Org1MSP.peer&apos;,&apos;Org2MSP.peer&apos;)&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>让我们查询a的值以确保链代码已正确实例化并且状态DB已填充。 查询的语法如下所示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode query -C $CHANNEL_NAME -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>现在让我们将10从a移动到b。 该事务将切断一个新块并更新状态DB。 invoke的语法如下所示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>再查询</p>\n<figure class=\"highlight plain\"><figcaption><span>chaincode query -c $channel_name -n mycc -c '&#123;\"args\":[\"query\",\"a\"]&#125;'</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">peer chaincode query -C $CHANNEL_NAME -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"Hive用户自定义聚合函数(UDAF)和表生成函数(UDTF)","date":"2018-05-30T13:45:40.000Z","_content":"\n在之前关于Hive的[博文](https://harold1994.github.io/2018/03/17/%E5%85%B3%E4%BA%8EHIVE/)中写到了UDAF和UDTF,不过只是简单的带过,在UDAF部分继承是已经被废弃的的UDAF类,因此在这片博文中详细说明一下新的继承类的使用方法,算是还技术债吧.\n\n#### 一. 用户自定义聚合函数\n\n聚合函数会分多个阶段进行处理,基于UDAF执行的转换不同,在不同的阶段返回值类型也可能不同.聚合过程是在map或者reduce任务中执行的,任务task是一个[有内存限制](https://blog.csdn.net/androidlushangderen/article/details/50002015)的Java进程,因此在聚合过程中存储大的数据结构会产生溢出错误.\n<!-- more--> \n> 写UDAF时可以通过配置参数mapred.child.java.opts调整执行过程的内存需求量,但是此方式并非总是奏效.\n\n##### 实例: 创建一个COLLECT UDAF来模拟GROUP_CONCAT\n\nMySQL中的函数GROUP_CONCAT可以将一组中所有的元素按照用户指定的分隔符组装成一个字符串.\n\n```sql\nmysql> create table people( name varchar(10), friendname varchar(10) );\nmysql> select * from people;\n+--------+------------+\n| name   | friendname |\n+--------+------------+\n| bob    | jone       |\n| jone   | sara       |\n| jone   | sara       |\n| harold | lili       |\n| bob    | sali       |\n| bob    | sali       |\n+--------+------------+\nmysql> select name, group_concat(friendname SEPARATOR ',') from people group by name;\n+--------+----------------------------------------+\n| name   | group_concat(friendname SEPARATOR ',') |\n+--------+----------------------------------------+\n| bob    | jone,sali,sali                         |\n| harold | lili                                   |\n| jone   | sara,sara                              |\n+--------+----------------------------------------+\n```\n\n在HIve中没有这个函数,但我们可以在Hive中无需增加新的语法实现同样的转换:\n\n```mysql\nhive> select name, concat_ws('|', collect_list(friend)) from people group by name;\nbob\tsara|john|ted\njohn\tsara\nted\tbob|sara\n//或者\nhive> select name, concat_ws('|', collect_set(friend)) from people group by name;\nbob\t[\"sara\",\"john\",\"ted\"]\njohn\t[\"sara\"]\nted\t[\"bob\",\"sara\"]\n```\n\nconcat_ws()的第一个参数是分隔符,其它参数可以是字符串或字符串数组,collect_list()和collect_set()均返回集合中元素的数组,不过collect_set会对数组进行排重.\n\ncollect_set的UDAF将所有输入加入到一个java.util.Set集合中,这里将使用collect_set中的代码来将Set的实例替换成ArrayList实例,这样就不会实现对输入排重,相当于我们要手动实现collect_list.\n\n用户聚合计算应该是允许数据任意划分为多个部分进行计算而不会影响结果的,使用的是分治的思想.\n\n聚合过程的所有输入必须是基本数据类型,返回的是GenericUDAFEvaluator的子类对象.编写通用型UDAF需要两个类：解析器和计算器。解析器负责UDAF的参数检查，操作符的重载以及对于给定的一组参数类型来查找正确的计算器，建议继承AbstractGenericUDAFResolver类，具体实现如下：\n\n```java\n@Description(name = \"collect\", value = \"_FUN_(x) - Returns a list of objects. \" +\n        \"CAUTION will easilly OOM on large data sets\")\npublic class GenericUDAFCollect extends AbstractGenericUDAFResolver {\n    static final Log LOG = LogFactory.getLog(GenericUDAFCollect.class.getName());\n\n    public GenericUDAFCollect() {\n    }\n\n    @Override\n    public GenericUDAFEvaluator getEvaluator(TypeInfo[] parameters) throws SemanticException {\n        if (parameters.length != 1) {\n            throw new UDFArgumentTypeException((parameters.length-1),\n                    \"Exactly one argument is expeted\");\n        }\n\n        if (parameters[0].getCategory() != ObjectInspector.Category.PRIMITIVE) {\n            throw new UDFArgumentTypeException(0,\n                    \"Only Primitive type arguments are accepted but \"\n            + parameters[0].getTypeName() + \" was passed as parameter 1.\");\n        }\n        return new GenericUDAFMkListEvaluator();\n    }\n}\n```\n\n计算器实现具体的计算逻辑，需要继承GenericUDAFEvaluator抽象类。\n\n计算器有4种模式，由枚举类GenericUDAFEvaluator.Mode定义：\n\n```java\npublic static enum Mode {  \n    PARTIAL1, //从原始数据到部分聚合数据的过程（map阶段），将调用iterate()和terminatePartial()方法。  \n    PARTIAL2, //从部分聚合数据到部分聚合数据的过程（map端的combiner阶段），将调用merge() 和terminatePartial()方法。      \n    FINAL,    //从部分聚合数据到全部聚合的过程（reduce阶段），将调用merge()和 terminate()方法。  \n    COMPLETE  //从原始数据直接到全部聚合的过程（表示只有map，没有reduce，map端直接出结果），将调用merge() 和 terminate()方法。  \n};  \n```\n\n计算器必须实现的方法：\n\n1、getNewAggregationBuffer()：返回存储临时聚合结果的AggregationBuffer对象。\n\n2、reset(AggregationBuffer agg)：重置聚合结果对象，以支持mapper和reducer的重用。\n\n3、iterate(AggregationBuffer agg,Object[] parameters)：迭代处理原始数据parameters并保存到agg中。\n\n4、terminatePartial(AggregationBuffer agg)：以持久化的方式返回agg表示的部分聚合结果，这里的持久化意味着返回值只能Java基础类型、数组、基础类型包装器、Hadoop的Writables、Lists和Maps。\n\n5、merge(AggregationBuffer agg,Object partial)：合并由partial表示的部分聚合结果到agg中。\n\n6、terminate(AggregationBuffer agg)：返回最终结果。\n\n通常还需要覆盖初始化方法ObjectInspector init(Mode m,ObjectInspector[] parameters)，需要注意的是，在不同的模式下parameters的含义是不同的，比如m为 PARTIAL1 和 COMPLETE 时，parameters为原始数据；m为 PARTIAL2 和 FINAL 时，parameters仅为部分聚合数据（只有一个元素）。在 PARTIAL1 和 PARTIAL2 模式下，ObjectInspector  用于terminatePartial方法的返回值，在FINAL和COMPLETE模式下ObjectInspector 用于terminate方法的返回值。\n\n```java\npublic class GenericUDAFMkListEvaluator extends GenericUDAFEvaluator {\n    private PrimitiveObjectInspector inputOI;\n    private StandardListObjectInspector loi;\n    private StandardListObjectInspector internalMergeOI;\n\n    //Hive会调用init方法来初始实例化一个UDAD的evaluator类\n    @Override\n    public ObjectInspector init(Mode m, ObjectInspector[] parameters) throws HiveException {\n        super.init(m, parameters);\n        if (m == Mode.PARTIAL1) {//map阶段\n            inputOI = (PrimitiveObjectInspector) parameters[0];\n            return ObjectInspectorFactory.getStandardListObjectInspector(\n                    (PrimitiveObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(inputOI)\n            );\n        } else {\n            if (!(parameters[0] instanceof StandardListObjectInspector)) {\n                inputOI = (PrimitiveObjectInspector) ObjectInspectorUtils\n                        .getStandardObjectInspector(parameters[0]);\n                return (StandardListObjectInspector) ObjectInspectorFactory\n                        .getStandardListObjectInspector(inputOI);\n            } else {\n                internalMergeOI = (StandardListObjectInspector) parameters[0];\n                inputOI = (PrimitiveObjectInspector) internalMergeOI.getListElementObjectInspector();\n                loi = (StandardListObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(internalMergeOI);\n                return loi;\n            }\n        }\n    }\n    static class MKArrayAggregationBuffer implements AggregationBuffer {\n        List<Object> container;\n    }\n\n    public void reset(AggregationBuffer agg) throws HiveException {\n        ((MKArrayAggregationBuffer) agg).container = new ArrayList<Object>();\n    }\n\n    public AggregationBuffer getNewAggregationBuffer() throws HiveException {\n        MKArrayAggregationBuffer ret = new MKArrayAggregationBuffer();\n        reset(ret);\n        return ret;\n    }\n\n    //map端\n    public void iterate(AggregationBuffer agg, Object[] parameters) throws HiveException {\n        /*\n        （1）assert [boolean 表达式]\n            如果[boolean表达式]为true，则程序继续执行。\n            如果为false，则程序抛出AssertionError，并终止执行。\n        （2）assert[boolean 表达式 : 错误表达式 （日志）]\n            如果[boolean表达式]为true，则程序继续执行。\n            如果为false，则程序抛出java.lang.AssertionError，输出[错误信息]。\n         */\n        assert (parameters.length == 1);\n        Object p = parameters[0];\n\n        if (p != null) {\n            MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n            putIntoList(p, myagg);\n        }\n    }\n\n    private void putIntoList(Object p, MKArrayAggregationBuffer myagg) {\n        Object cCopy = ObjectInspectorUtils.copyToStandardJavaObject(p, this.inputOI);\n        myagg.container.add(cCopy);\n    }\n    //map端\n    public Object terminatePartial(AggregationBuffer agg) throws HiveException {\n        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n        ArrayList<Object> ret = new ArrayList<Object>(myagg.container.size());\n        ret.addAll(myagg.container);\n        return ret;\n    }\n    //reduce端,将terminatePartial返回的中间部分聚合结果聚合到当前聚合中\n    public void merge(AggregationBuffer agg, Object partial) throws HiveException {\n        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n        ArrayList<Object> partialResult = (ArrayList<Object>) internalMergeOI.getList(partial);\n        for (Object i : partialResult) {\n            putIntoList(i, myagg);\n        }\n    }\n\n    public Object terminate(AggregationBuffer agg) throws HiveException {\n        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n        ArrayList<Object> ret = new ArrayList<Object>(myagg.container.size());\n        ret.addAll(myagg.container);\n        return ret;\n\n    }\n}\n```\n\nHIve尝试尽量避免通过new创建对象,Hadoop和HIve依据这个规则创建尽可能少的临时对象,这样可以减轻JVM的垃圾回收过程.\n\n使用collect函数的查询结果:\n\n```sql\nhive> select * from people;\nOK\nbob\tsara\nbob\tjohn\nbob\tted\njohn\tsara\nted\tbob\nted\tsara\nbob\tsara\nted\tbob\n//去重了\nhive> select name, concat_ws(\",\", collect_set(friend)) from people group by name;\nbob\tsara,john,ted\njohn\tsara\nted\tbob,sara\n\n```\n\n","source":"_posts/Hive用户自定义聚合函数UDAF和表生成函数UDTF.md","raw":"---\ntitle: Hive用户自定义聚合函数(UDAF)和表生成函数(UDTF)\ndate: 2018-05-30 21:45:40\ntags: [大数据, Hive, Hadoop]\n---\n\n在之前关于Hive的[博文](https://harold1994.github.io/2018/03/17/%E5%85%B3%E4%BA%8EHIVE/)中写到了UDAF和UDTF,不过只是简单的带过,在UDAF部分继承是已经被废弃的的UDAF类,因此在这片博文中详细说明一下新的继承类的使用方法,算是还技术债吧.\n\n#### 一. 用户自定义聚合函数\n\n聚合函数会分多个阶段进行处理,基于UDAF执行的转换不同,在不同的阶段返回值类型也可能不同.聚合过程是在map或者reduce任务中执行的,任务task是一个[有内存限制](https://blog.csdn.net/androidlushangderen/article/details/50002015)的Java进程,因此在聚合过程中存储大的数据结构会产生溢出错误.\n<!-- more--> \n> 写UDAF时可以通过配置参数mapred.child.java.opts调整执行过程的内存需求量,但是此方式并非总是奏效.\n\n##### 实例: 创建一个COLLECT UDAF来模拟GROUP_CONCAT\n\nMySQL中的函数GROUP_CONCAT可以将一组中所有的元素按照用户指定的分隔符组装成一个字符串.\n\n```sql\nmysql> create table people( name varchar(10), friendname varchar(10) );\nmysql> select * from people;\n+--------+------------+\n| name   | friendname |\n+--------+------------+\n| bob    | jone       |\n| jone   | sara       |\n| jone   | sara       |\n| harold | lili       |\n| bob    | sali       |\n| bob    | sali       |\n+--------+------------+\nmysql> select name, group_concat(friendname SEPARATOR ',') from people group by name;\n+--------+----------------------------------------+\n| name   | group_concat(friendname SEPARATOR ',') |\n+--------+----------------------------------------+\n| bob    | jone,sali,sali                         |\n| harold | lili                                   |\n| jone   | sara,sara                              |\n+--------+----------------------------------------+\n```\n\n在HIve中没有这个函数,但我们可以在Hive中无需增加新的语法实现同样的转换:\n\n```mysql\nhive> select name, concat_ws('|', collect_list(friend)) from people group by name;\nbob\tsara|john|ted\njohn\tsara\nted\tbob|sara\n//或者\nhive> select name, concat_ws('|', collect_set(friend)) from people group by name;\nbob\t[\"sara\",\"john\",\"ted\"]\njohn\t[\"sara\"]\nted\t[\"bob\",\"sara\"]\n```\n\nconcat_ws()的第一个参数是分隔符,其它参数可以是字符串或字符串数组,collect_list()和collect_set()均返回集合中元素的数组,不过collect_set会对数组进行排重.\n\ncollect_set的UDAF将所有输入加入到一个java.util.Set集合中,这里将使用collect_set中的代码来将Set的实例替换成ArrayList实例,这样就不会实现对输入排重,相当于我们要手动实现collect_list.\n\n用户聚合计算应该是允许数据任意划分为多个部分进行计算而不会影响结果的,使用的是分治的思想.\n\n聚合过程的所有输入必须是基本数据类型,返回的是GenericUDAFEvaluator的子类对象.编写通用型UDAF需要两个类：解析器和计算器。解析器负责UDAF的参数检查，操作符的重载以及对于给定的一组参数类型来查找正确的计算器，建议继承AbstractGenericUDAFResolver类，具体实现如下：\n\n```java\n@Description(name = \"collect\", value = \"_FUN_(x) - Returns a list of objects. \" +\n        \"CAUTION will easilly OOM on large data sets\")\npublic class GenericUDAFCollect extends AbstractGenericUDAFResolver {\n    static final Log LOG = LogFactory.getLog(GenericUDAFCollect.class.getName());\n\n    public GenericUDAFCollect() {\n    }\n\n    @Override\n    public GenericUDAFEvaluator getEvaluator(TypeInfo[] parameters) throws SemanticException {\n        if (parameters.length != 1) {\n            throw new UDFArgumentTypeException((parameters.length-1),\n                    \"Exactly one argument is expeted\");\n        }\n\n        if (parameters[0].getCategory() != ObjectInspector.Category.PRIMITIVE) {\n            throw new UDFArgumentTypeException(0,\n                    \"Only Primitive type arguments are accepted but \"\n            + parameters[0].getTypeName() + \" was passed as parameter 1.\");\n        }\n        return new GenericUDAFMkListEvaluator();\n    }\n}\n```\n\n计算器实现具体的计算逻辑，需要继承GenericUDAFEvaluator抽象类。\n\n计算器有4种模式，由枚举类GenericUDAFEvaluator.Mode定义：\n\n```java\npublic static enum Mode {  \n    PARTIAL1, //从原始数据到部分聚合数据的过程（map阶段），将调用iterate()和terminatePartial()方法。  \n    PARTIAL2, //从部分聚合数据到部分聚合数据的过程（map端的combiner阶段），将调用merge() 和terminatePartial()方法。      \n    FINAL,    //从部分聚合数据到全部聚合的过程（reduce阶段），将调用merge()和 terminate()方法。  \n    COMPLETE  //从原始数据直接到全部聚合的过程（表示只有map，没有reduce，map端直接出结果），将调用merge() 和 terminate()方法。  \n};  \n```\n\n计算器必须实现的方法：\n\n1、getNewAggregationBuffer()：返回存储临时聚合结果的AggregationBuffer对象。\n\n2、reset(AggregationBuffer agg)：重置聚合结果对象，以支持mapper和reducer的重用。\n\n3、iterate(AggregationBuffer agg,Object[] parameters)：迭代处理原始数据parameters并保存到agg中。\n\n4、terminatePartial(AggregationBuffer agg)：以持久化的方式返回agg表示的部分聚合结果，这里的持久化意味着返回值只能Java基础类型、数组、基础类型包装器、Hadoop的Writables、Lists和Maps。\n\n5、merge(AggregationBuffer agg,Object partial)：合并由partial表示的部分聚合结果到agg中。\n\n6、terminate(AggregationBuffer agg)：返回最终结果。\n\n通常还需要覆盖初始化方法ObjectInspector init(Mode m,ObjectInspector[] parameters)，需要注意的是，在不同的模式下parameters的含义是不同的，比如m为 PARTIAL1 和 COMPLETE 时，parameters为原始数据；m为 PARTIAL2 和 FINAL 时，parameters仅为部分聚合数据（只有一个元素）。在 PARTIAL1 和 PARTIAL2 模式下，ObjectInspector  用于terminatePartial方法的返回值，在FINAL和COMPLETE模式下ObjectInspector 用于terminate方法的返回值。\n\n```java\npublic class GenericUDAFMkListEvaluator extends GenericUDAFEvaluator {\n    private PrimitiveObjectInspector inputOI;\n    private StandardListObjectInspector loi;\n    private StandardListObjectInspector internalMergeOI;\n\n    //Hive会调用init方法来初始实例化一个UDAD的evaluator类\n    @Override\n    public ObjectInspector init(Mode m, ObjectInspector[] parameters) throws HiveException {\n        super.init(m, parameters);\n        if (m == Mode.PARTIAL1) {//map阶段\n            inputOI = (PrimitiveObjectInspector) parameters[0];\n            return ObjectInspectorFactory.getStandardListObjectInspector(\n                    (PrimitiveObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(inputOI)\n            );\n        } else {\n            if (!(parameters[0] instanceof StandardListObjectInspector)) {\n                inputOI = (PrimitiveObjectInspector) ObjectInspectorUtils\n                        .getStandardObjectInspector(parameters[0]);\n                return (StandardListObjectInspector) ObjectInspectorFactory\n                        .getStandardListObjectInspector(inputOI);\n            } else {\n                internalMergeOI = (StandardListObjectInspector) parameters[0];\n                inputOI = (PrimitiveObjectInspector) internalMergeOI.getListElementObjectInspector();\n                loi = (StandardListObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(internalMergeOI);\n                return loi;\n            }\n        }\n    }\n    static class MKArrayAggregationBuffer implements AggregationBuffer {\n        List<Object> container;\n    }\n\n    public void reset(AggregationBuffer agg) throws HiveException {\n        ((MKArrayAggregationBuffer) agg).container = new ArrayList<Object>();\n    }\n\n    public AggregationBuffer getNewAggregationBuffer() throws HiveException {\n        MKArrayAggregationBuffer ret = new MKArrayAggregationBuffer();\n        reset(ret);\n        return ret;\n    }\n\n    //map端\n    public void iterate(AggregationBuffer agg, Object[] parameters) throws HiveException {\n        /*\n        （1）assert [boolean 表达式]\n            如果[boolean表达式]为true，则程序继续执行。\n            如果为false，则程序抛出AssertionError，并终止执行。\n        （2）assert[boolean 表达式 : 错误表达式 （日志）]\n            如果[boolean表达式]为true，则程序继续执行。\n            如果为false，则程序抛出java.lang.AssertionError，输出[错误信息]。\n         */\n        assert (parameters.length == 1);\n        Object p = parameters[0];\n\n        if (p != null) {\n            MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n            putIntoList(p, myagg);\n        }\n    }\n\n    private void putIntoList(Object p, MKArrayAggregationBuffer myagg) {\n        Object cCopy = ObjectInspectorUtils.copyToStandardJavaObject(p, this.inputOI);\n        myagg.container.add(cCopy);\n    }\n    //map端\n    public Object terminatePartial(AggregationBuffer agg) throws HiveException {\n        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n        ArrayList<Object> ret = new ArrayList<Object>(myagg.container.size());\n        ret.addAll(myagg.container);\n        return ret;\n    }\n    //reduce端,将terminatePartial返回的中间部分聚合结果聚合到当前聚合中\n    public void merge(AggregationBuffer agg, Object partial) throws HiveException {\n        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n        ArrayList<Object> partialResult = (ArrayList<Object>) internalMergeOI.getList(partial);\n        for (Object i : partialResult) {\n            putIntoList(i, myagg);\n        }\n    }\n\n    public Object terminate(AggregationBuffer agg) throws HiveException {\n        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;\n        ArrayList<Object> ret = new ArrayList<Object>(myagg.container.size());\n        ret.addAll(myagg.container);\n        return ret;\n\n    }\n}\n```\n\nHIve尝试尽量避免通过new创建对象,Hadoop和HIve依据这个规则创建尽可能少的临时对象,这样可以减轻JVM的垃圾回收过程.\n\n使用collect函数的查询结果:\n\n```sql\nhive> select * from people;\nOK\nbob\tsara\nbob\tjohn\nbob\tted\njohn\tsara\nted\tbob\nted\tsara\nbob\tsara\nted\tbob\n//去重了\nhive> select name, concat_ws(\",\", collect_set(friend)) from people group by name;\nbob\tsara,john,ted\njohn\tsara\nted\tbob,sara\n\n```\n\n","slug":"Hive用户自定义聚合函数UDAF和表生成函数UDTF","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i670004cf963nv0m60w","content":"<p>在之前关于Hive的<a href=\"https://harold1994.github.io/2018/03/17/%E5%85%B3%E4%BA%8EHIVE/\" target=\"_blank\" rel=\"noopener\">博文</a>中写到了UDAF和UDTF,不过只是简单的带过,在UDAF部分继承是已经被废弃的的UDAF类,因此在这片博文中详细说明一下新的继承类的使用方法,算是还技术债吧.</p>\n<h4 id=\"一-用户自定义聚合函数\"><a href=\"#一-用户自定义聚合函数\" class=\"headerlink\" title=\"一. 用户自定义聚合函数\"></a>一. 用户自定义聚合函数</h4><p>聚合函数会分多个阶段进行处理,基于UDAF执行的转换不同,在不同的阶段返回值类型也可能不同.聚合过程是在map或者reduce任务中执行的,任务task是一个<a href=\"https://blog.csdn.net/androidlushangderen/article/details/50002015\" target=\"_blank\" rel=\"noopener\">有内存限制</a>的Java进程,因此在聚合过程中存储大的数据结构会产生溢出错误.<br><a id=\"more\"></a> </p>\n<blockquote>\n<p>写UDAF时可以通过配置参数mapred.child.java.opts调整执行过程的内存需求量,但是此方式并非总是奏效.</p>\n</blockquote>\n<h5 id=\"实例-创建一个COLLECT-UDAF来模拟GROUP-CONCAT\"><a href=\"#实例-创建一个COLLECT-UDAF来模拟GROUP-CONCAT\" class=\"headerlink\" title=\"实例: 创建一个COLLECT UDAF来模拟GROUP_CONCAT\"></a>实例: 创建一个COLLECT UDAF来模拟GROUP_CONCAT</h5><p>MySQL中的函数GROUP_CONCAT可以将一组中所有的元素按照用户指定的分隔符组装成一个字符串.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table people( name varchar(10), friendname varchar(10) );</span><br><span class=\"line\">mysql&gt; select * from people;</span><br><span class=\"line\">+<span class=\"comment\">--------+------------+</span></span><br><span class=\"line\">| name   | friendname |</span><br><span class=\"line\">+<span class=\"comment\">--------+------------+</span></span><br><span class=\"line\">| bob    | jone       |</span><br><span class=\"line\">| jone   | sara       |</span><br><span class=\"line\">| jone   | sara       |</span><br><span class=\"line\">| harold | lili       |</span><br><span class=\"line\">| bob    | sali       |</span><br><span class=\"line\">| bob    | sali       |</span><br><span class=\"line\">+<span class=\"comment\">--------+------------+</span></span><br><span class=\"line\">mysql&gt; select name, group_concat(friendname SEPARATOR ',') from people group by name;</span><br><span class=\"line\">+<span class=\"comment\">--------+----------------------------------------+</span></span><br><span class=\"line\">| name   | group_concat(friendname SEPARATOR ',') |</span><br><span class=\"line\">+<span class=\"comment\">--------+----------------------------------------+</span></span><br><span class=\"line\">| bob    | jone,sali,sali                         |</span><br><span class=\"line\">| harold | lili                                   |</span><br><span class=\"line\">| jone   | sara,sara                              |</span><br><span class=\"line\">+<span class=\"comment\">--------+----------------------------------------+</span></span><br></pre></td></tr></table></figure>\n<p>在HIve中没有这个函数,但我们可以在Hive中无需增加新的语法实现同样的转换:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; select name, concat_ws(&apos;|&apos;, collect_list(friend)) from people group by name;</span><br><span class=\"line\">bob\tsara|john|ted</span><br><span class=\"line\">john\tsara</span><br><span class=\"line\">ted\tbob|sara</span><br><span class=\"line\">//或者</span><br><span class=\"line\">hive&gt; select name, concat_ws(&apos;|&apos;, collect_set(friend)) from people group by name;</span><br><span class=\"line\">bob\t[&quot;sara&quot;,&quot;john&quot;,&quot;ted&quot;]</span><br><span class=\"line\">john\t[&quot;sara&quot;]</span><br><span class=\"line\">ted\t[&quot;bob&quot;,&quot;sara&quot;]</span><br></pre></td></tr></table></figure>\n<p>concat_ws()的第一个参数是分隔符,其它参数可以是字符串或字符串数组,collect_list()和collect_set()均返回集合中元素的数组,不过collect_set会对数组进行排重.</p>\n<p>collect_set的UDAF将所有输入加入到一个java.util.Set集合中,这里将使用collect_set中的代码来将Set的实例替换成ArrayList实例,这样就不会实现对输入排重,相当于我们要手动实现collect_list.</p>\n<p>用户聚合计算应该是允许数据任意划分为多个部分进行计算而不会影响结果的,使用的是分治的思想.</p>\n<p>聚合过程的所有输入必须是基本数据类型,返回的是GenericUDAFEvaluator的子类对象.编写通用型UDAF需要两个类：解析器和计算器。解析器负责UDAF的参数检查，操作符的重载以及对于给定的一组参数类型来查找正确的计算器，建议继承AbstractGenericUDAFResolver类，具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(name = <span class=\"string\">\"collect\"</span>, value = <span class=\"string\">\"_FUN_(x) - Returns a list of objects. \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"CAUTION will easilly OOM on large data sets\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericUDAFCollect</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractGenericUDAFResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log LOG = LogFactory.getLog(GenericUDAFCollect.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericUDAFCollect</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> GenericUDAFEvaluator <span class=\"title\">getEvaluator</span><span class=\"params\">(TypeInfo[] parameters)</span> <span class=\"keyword\">throws</span> SemanticException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameters.length != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UDFArgumentTypeException((parameters.length-<span class=\"number\">1</span>),</span><br><span class=\"line\">                    <span class=\"string\">\"Exactly one argument is expeted\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameters[<span class=\"number\">0</span>].getCategory() != ObjectInspector.Category.PRIMITIVE) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UDFArgumentTypeException(<span class=\"number\">0</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"Only Primitive type arguments are accepted but \"</span></span><br><span class=\"line\">            + parameters[<span class=\"number\">0</span>].getTypeName() + <span class=\"string\">\" was passed as parameter 1.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> GenericUDAFMkListEvaluator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>计算器实现具体的计算逻辑，需要继承GenericUDAFEvaluator抽象类。</p>\n<p>计算器有4种模式，由枚举类GenericUDAFEvaluator.Mode定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> Mode &#123;  </span><br><span class=\"line\">    PARTIAL1, <span class=\"comment\">//从原始数据到部分聚合数据的过程（map阶段），将调用iterate()和terminatePartial()方法。  </span></span><br><span class=\"line\">    PARTIAL2, <span class=\"comment\">//从部分聚合数据到部分聚合数据的过程（map端的combiner阶段），将调用merge() 和terminatePartial()方法。      </span></span><br><span class=\"line\">    FINAL,    <span class=\"comment\">//从部分聚合数据到全部聚合的过程（reduce阶段），将调用merge()和 terminate()方法。  </span></span><br><span class=\"line\">    COMPLETE  <span class=\"comment\">//从原始数据直接到全部聚合的过程（表示只有map，没有reduce，map端直接出结果），将调用merge() 和 terminate()方法。  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>计算器必须实现的方法：</p>\n<p>1、getNewAggregationBuffer()：返回存储临时聚合结果的AggregationBuffer对象。</p>\n<p>2、reset(AggregationBuffer agg)：重置聚合结果对象，以支持mapper和reducer的重用。</p>\n<p>3、iterate(AggregationBuffer agg,Object[] parameters)：迭代处理原始数据parameters并保存到agg中。</p>\n<p>4、terminatePartial(AggregationBuffer agg)：以持久化的方式返回agg表示的部分聚合结果，这里的持久化意味着返回值只能Java基础类型、数组、基础类型包装器、Hadoop的Writables、Lists和Maps。</p>\n<p>5、merge(AggregationBuffer agg,Object partial)：合并由partial表示的部分聚合结果到agg中。</p>\n<p>6、terminate(AggregationBuffer agg)：返回最终结果。</p>\n<p>通常还需要覆盖初始化方法ObjectInspector init(Mode m,ObjectInspector[] parameters)，需要注意的是，在不同的模式下parameters的含义是不同的，比如m为 PARTIAL1 和 COMPLETE 时，parameters为原始数据；m为 PARTIAL2 和 FINAL 时，parameters仅为部分聚合数据（只有一个元素）。在 PARTIAL1 和 PARTIAL2 模式下，ObjectInspector  用于terminatePartial方法的返回值，在FINAL和COMPLETE模式下ObjectInspector 用于terminate方法的返回值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericUDAFMkListEvaluator</span> <span class=\"keyword\">extends</span> <span class=\"title\">GenericUDAFEvaluator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PrimitiveObjectInspector inputOI;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> StandardListObjectInspector loi;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> StandardListObjectInspector internalMergeOI;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Hive会调用init方法来初始实例化一个UDAD的evaluator类</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ObjectInspector <span class=\"title\">init</span><span class=\"params\">(Mode m, ObjectInspector[] parameters)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(m, parameters);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m == Mode.PARTIAL1) &#123;<span class=\"comment\">//map阶段</span></span><br><span class=\"line\">            inputOI = (PrimitiveObjectInspector) parameters[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ObjectInspectorFactory.getStandardListObjectInspector(</span><br><span class=\"line\">                    (PrimitiveObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(inputOI)</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(parameters[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> StandardListObjectInspector)) &#123;</span><br><span class=\"line\">                inputOI = (PrimitiveObjectInspector) ObjectInspectorUtils</span><br><span class=\"line\">                        .getStandardObjectInspector(parameters[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (StandardListObjectInspector) ObjectInspectorFactory</span><br><span class=\"line\">                        .getStandardListObjectInspector(inputOI);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                internalMergeOI = (StandardListObjectInspector) parameters[<span class=\"number\">0</span>];</span><br><span class=\"line\">                inputOI = (PrimitiveObjectInspector) internalMergeOI.getListElementObjectInspector();</span><br><span class=\"line\">                loi = (StandardListObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(internalMergeOI);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> loi;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MKArrayAggregationBuffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">AggregationBuffer</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Object&gt; container;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">(AggregationBuffer agg)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        ((MKArrayAggregationBuffer) agg).container = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AggregationBuffer <span class=\"title\">getNewAggregationBuffer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer ret = <span class=\"keyword\">new</span> MKArrayAggregationBuffer();</span><br><span class=\"line\">        reset(ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//map端</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">iterate</span><span class=\"params\">(AggregationBuffer agg, Object[] parameters)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        （1）assert [boolean 表达式]</span></span><br><span class=\"line\"><span class=\"comment\">            如果[boolean表达式]为true，则程序继续执行。</span></span><br><span class=\"line\"><span class=\"comment\">            如果为false，则程序抛出AssertionError，并终止执行。</span></span><br><span class=\"line\"><span class=\"comment\">        （2）assert[boolean 表达式 : 错误表达式 （日志）]</span></span><br><span class=\"line\"><span class=\"comment\">            如果[boolean表达式]为true，则程序继续执行。</span></span><br><span class=\"line\"><span class=\"comment\">            如果为false，则程序抛出java.lang.AssertionError，输出[错误信息]。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (parameters.length == <span class=\"number\">1</span>);</span><br><span class=\"line\">        Object p = parameters[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">            putIntoList(p, myagg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">putIntoList</span><span class=\"params\">(Object p, MKArrayAggregationBuffer myagg)</span> </span>&#123;</span><br><span class=\"line\">        Object cCopy = ObjectInspectorUtils.copyToStandardJavaObject(p, <span class=\"keyword\">this</span>.inputOI);</span><br><span class=\"line\">        myagg.container.add(cCopy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//map端</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">terminatePartial</span><span class=\"params\">(AggregationBuffer agg)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;(myagg.container.size());</span><br><span class=\"line\">        ret.addAll(myagg.container);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//reduce端,将terminatePartial返回的中间部分聚合结果聚合到当前聚合中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(AggregationBuffer agg, Object partial)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; partialResult = (ArrayList&lt;Object&gt;) internalMergeOI.getList(partial);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object i : partialResult) &#123;</span><br><span class=\"line\">            putIntoList(i, myagg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">terminate</span><span class=\"params\">(AggregationBuffer agg)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;(myagg.container.size());</span><br><span class=\"line\">        ret.addAll(myagg.container);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HIve尝试尽量避免通过new创建对象,Hadoop和HIve依据这个规则创建尽可能少的临时对象,这样可以减轻JVM的垃圾回收过程.</p>\n<p>使用collect函数的查询结果:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; select * from people;</span><br><span class=\"line\">OK</span><br><span class=\"line\">bob\tsara</span><br><span class=\"line\">bob\tjohn</span><br><span class=\"line\">bob\tted</span><br><span class=\"line\">john\tsara</span><br><span class=\"line\">ted\tbob</span><br><span class=\"line\">ted\tsara</span><br><span class=\"line\">bob\tsara</span><br><span class=\"line\">ted\tbob</span><br><span class=\"line\">//去重了</span><br><span class=\"line\">hive&gt; select name, concat_ws(\",\", collect_set(friend)) from people group by name;</span><br><span class=\"line\">bob\tsara,john,ted</span><br><span class=\"line\">john\tsara</span><br><span class=\"line\">ted\tbob,sara</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在之前关于Hive的<a href=\"https://harold1994.github.io/2018/03/17/%E5%85%B3%E4%BA%8EHIVE/\" target=\"_blank\" rel=\"noopener\">博文</a>中写到了UDAF和UDTF,不过只是简单的带过,在UDAF部分继承是已经被废弃的的UDAF类,因此在这片博文中详细说明一下新的继承类的使用方法,算是还技术债吧.</p>\n<h4 id=\"一-用户自定义聚合函数\"><a href=\"#一-用户自定义聚合函数\" class=\"headerlink\" title=\"一. 用户自定义聚合函数\"></a>一. 用户自定义聚合函数</h4><p>聚合函数会分多个阶段进行处理,基于UDAF执行的转换不同,在不同的阶段返回值类型也可能不同.聚合过程是在map或者reduce任务中执行的,任务task是一个<a href=\"https://blog.csdn.net/androidlushangderen/article/details/50002015\" target=\"_blank\" rel=\"noopener\">有内存限制</a>的Java进程,因此在聚合过程中存储大的数据结构会产生溢出错误.<br>","more":"</p>\n<blockquote>\n<p>写UDAF时可以通过配置参数mapred.child.java.opts调整执行过程的内存需求量,但是此方式并非总是奏效.</p>\n</blockquote>\n<h5 id=\"实例-创建一个COLLECT-UDAF来模拟GROUP-CONCAT\"><a href=\"#实例-创建一个COLLECT-UDAF来模拟GROUP-CONCAT\" class=\"headerlink\" title=\"实例: 创建一个COLLECT UDAF来模拟GROUP_CONCAT\"></a>实例: 创建一个COLLECT UDAF来模拟GROUP_CONCAT</h5><p>MySQL中的函数GROUP_CONCAT可以将一组中所有的元素按照用户指定的分隔符组装成一个字符串.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table people( name varchar(10), friendname varchar(10) );</span><br><span class=\"line\">mysql&gt; select * from people;</span><br><span class=\"line\">+<span class=\"comment\">--------+------------+</span></span><br><span class=\"line\">| name   | friendname |</span><br><span class=\"line\">+<span class=\"comment\">--------+------------+</span></span><br><span class=\"line\">| bob    | jone       |</span><br><span class=\"line\">| jone   | sara       |</span><br><span class=\"line\">| jone   | sara       |</span><br><span class=\"line\">| harold | lili       |</span><br><span class=\"line\">| bob    | sali       |</span><br><span class=\"line\">| bob    | sali       |</span><br><span class=\"line\">+<span class=\"comment\">--------+------------+</span></span><br><span class=\"line\">mysql&gt; select name, group_concat(friendname SEPARATOR ',') from people group by name;</span><br><span class=\"line\">+<span class=\"comment\">--------+----------------------------------------+</span></span><br><span class=\"line\">| name   | group_concat(friendname SEPARATOR ',') |</span><br><span class=\"line\">+<span class=\"comment\">--------+----------------------------------------+</span></span><br><span class=\"line\">| bob    | jone,sali,sali                         |</span><br><span class=\"line\">| harold | lili                                   |</span><br><span class=\"line\">| jone   | sara,sara                              |</span><br><span class=\"line\">+<span class=\"comment\">--------+----------------------------------------+</span></span><br></pre></td></tr></table></figure>\n<p>在HIve中没有这个函数,但我们可以在Hive中无需增加新的语法实现同样的转换:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; select name, concat_ws(&apos;|&apos;, collect_list(friend)) from people group by name;</span><br><span class=\"line\">bob\tsara|john|ted</span><br><span class=\"line\">john\tsara</span><br><span class=\"line\">ted\tbob|sara</span><br><span class=\"line\">//或者</span><br><span class=\"line\">hive&gt; select name, concat_ws(&apos;|&apos;, collect_set(friend)) from people group by name;</span><br><span class=\"line\">bob\t[&quot;sara&quot;,&quot;john&quot;,&quot;ted&quot;]</span><br><span class=\"line\">john\t[&quot;sara&quot;]</span><br><span class=\"line\">ted\t[&quot;bob&quot;,&quot;sara&quot;]</span><br></pre></td></tr></table></figure>\n<p>concat_ws()的第一个参数是分隔符,其它参数可以是字符串或字符串数组,collect_list()和collect_set()均返回集合中元素的数组,不过collect_set会对数组进行排重.</p>\n<p>collect_set的UDAF将所有输入加入到一个java.util.Set集合中,这里将使用collect_set中的代码来将Set的实例替换成ArrayList实例,这样就不会实现对输入排重,相当于我们要手动实现collect_list.</p>\n<p>用户聚合计算应该是允许数据任意划分为多个部分进行计算而不会影响结果的,使用的是分治的思想.</p>\n<p>聚合过程的所有输入必须是基本数据类型,返回的是GenericUDAFEvaluator的子类对象.编写通用型UDAF需要两个类：解析器和计算器。解析器负责UDAF的参数检查，操作符的重载以及对于给定的一组参数类型来查找正确的计算器，建议继承AbstractGenericUDAFResolver类，具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(name = <span class=\"string\">\"collect\"</span>, value = <span class=\"string\">\"_FUN_(x) - Returns a list of objects. \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"CAUTION will easilly OOM on large data sets\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericUDAFCollect</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractGenericUDAFResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log LOG = LogFactory.getLog(GenericUDAFCollect.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericUDAFCollect</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> GenericUDAFEvaluator <span class=\"title\">getEvaluator</span><span class=\"params\">(TypeInfo[] parameters)</span> <span class=\"keyword\">throws</span> SemanticException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameters.length != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UDFArgumentTypeException((parameters.length-<span class=\"number\">1</span>),</span><br><span class=\"line\">                    <span class=\"string\">\"Exactly one argument is expeted\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameters[<span class=\"number\">0</span>].getCategory() != ObjectInspector.Category.PRIMITIVE) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UDFArgumentTypeException(<span class=\"number\">0</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"Only Primitive type arguments are accepted but \"</span></span><br><span class=\"line\">            + parameters[<span class=\"number\">0</span>].getTypeName() + <span class=\"string\">\" was passed as parameter 1.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> GenericUDAFMkListEvaluator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>计算器实现具体的计算逻辑，需要继承GenericUDAFEvaluator抽象类。</p>\n<p>计算器有4种模式，由枚举类GenericUDAFEvaluator.Mode定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> Mode &#123;  </span><br><span class=\"line\">    PARTIAL1, <span class=\"comment\">//从原始数据到部分聚合数据的过程（map阶段），将调用iterate()和terminatePartial()方法。  </span></span><br><span class=\"line\">    PARTIAL2, <span class=\"comment\">//从部分聚合数据到部分聚合数据的过程（map端的combiner阶段），将调用merge() 和terminatePartial()方法。      </span></span><br><span class=\"line\">    FINAL,    <span class=\"comment\">//从部分聚合数据到全部聚合的过程（reduce阶段），将调用merge()和 terminate()方法。  </span></span><br><span class=\"line\">    COMPLETE  <span class=\"comment\">//从原始数据直接到全部聚合的过程（表示只有map，没有reduce，map端直接出结果），将调用merge() 和 terminate()方法。  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>计算器必须实现的方法：</p>\n<p>1、getNewAggregationBuffer()：返回存储临时聚合结果的AggregationBuffer对象。</p>\n<p>2、reset(AggregationBuffer agg)：重置聚合结果对象，以支持mapper和reducer的重用。</p>\n<p>3、iterate(AggregationBuffer agg,Object[] parameters)：迭代处理原始数据parameters并保存到agg中。</p>\n<p>4、terminatePartial(AggregationBuffer agg)：以持久化的方式返回agg表示的部分聚合结果，这里的持久化意味着返回值只能Java基础类型、数组、基础类型包装器、Hadoop的Writables、Lists和Maps。</p>\n<p>5、merge(AggregationBuffer agg,Object partial)：合并由partial表示的部分聚合结果到agg中。</p>\n<p>6、terminate(AggregationBuffer agg)：返回最终结果。</p>\n<p>通常还需要覆盖初始化方法ObjectInspector init(Mode m,ObjectInspector[] parameters)，需要注意的是，在不同的模式下parameters的含义是不同的，比如m为 PARTIAL1 和 COMPLETE 时，parameters为原始数据；m为 PARTIAL2 和 FINAL 时，parameters仅为部分聚合数据（只有一个元素）。在 PARTIAL1 和 PARTIAL2 模式下，ObjectInspector  用于terminatePartial方法的返回值，在FINAL和COMPLETE模式下ObjectInspector 用于terminate方法的返回值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericUDAFMkListEvaluator</span> <span class=\"keyword\">extends</span> <span class=\"title\">GenericUDAFEvaluator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PrimitiveObjectInspector inputOI;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> StandardListObjectInspector loi;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> StandardListObjectInspector internalMergeOI;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Hive会调用init方法来初始实例化一个UDAD的evaluator类</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ObjectInspector <span class=\"title\">init</span><span class=\"params\">(Mode m, ObjectInspector[] parameters)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(m, parameters);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m == Mode.PARTIAL1) &#123;<span class=\"comment\">//map阶段</span></span><br><span class=\"line\">            inputOI = (PrimitiveObjectInspector) parameters[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ObjectInspectorFactory.getStandardListObjectInspector(</span><br><span class=\"line\">                    (PrimitiveObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(inputOI)</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(parameters[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> StandardListObjectInspector)) &#123;</span><br><span class=\"line\">                inputOI = (PrimitiveObjectInspector) ObjectInspectorUtils</span><br><span class=\"line\">                        .getStandardObjectInspector(parameters[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (StandardListObjectInspector) ObjectInspectorFactory</span><br><span class=\"line\">                        .getStandardListObjectInspector(inputOI);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                internalMergeOI = (StandardListObjectInspector) parameters[<span class=\"number\">0</span>];</span><br><span class=\"line\">                inputOI = (PrimitiveObjectInspector) internalMergeOI.getListElementObjectInspector();</span><br><span class=\"line\">                loi = (StandardListObjectInspector) ObjectInspectorUtils.getStandardObjectInspector(internalMergeOI);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> loi;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MKArrayAggregationBuffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">AggregationBuffer</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Object&gt; container;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">(AggregationBuffer agg)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        ((MKArrayAggregationBuffer) agg).container = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AggregationBuffer <span class=\"title\">getNewAggregationBuffer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer ret = <span class=\"keyword\">new</span> MKArrayAggregationBuffer();</span><br><span class=\"line\">        reset(ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//map端</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">iterate</span><span class=\"params\">(AggregationBuffer agg, Object[] parameters)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        （1）assert [boolean 表达式]</span></span><br><span class=\"line\"><span class=\"comment\">            如果[boolean表达式]为true，则程序继续执行。</span></span><br><span class=\"line\"><span class=\"comment\">            如果为false，则程序抛出AssertionError，并终止执行。</span></span><br><span class=\"line\"><span class=\"comment\">        （2）assert[boolean 表达式 : 错误表达式 （日志）]</span></span><br><span class=\"line\"><span class=\"comment\">            如果[boolean表达式]为true，则程序继续执行。</span></span><br><span class=\"line\"><span class=\"comment\">            如果为false，则程序抛出java.lang.AssertionError，输出[错误信息]。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (parameters.length == <span class=\"number\">1</span>);</span><br><span class=\"line\">        Object p = parameters[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">            putIntoList(p, myagg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">putIntoList</span><span class=\"params\">(Object p, MKArrayAggregationBuffer myagg)</span> </span>&#123;</span><br><span class=\"line\">        Object cCopy = ObjectInspectorUtils.copyToStandardJavaObject(p, <span class=\"keyword\">this</span>.inputOI);</span><br><span class=\"line\">        myagg.container.add(cCopy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//map端</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">terminatePartial</span><span class=\"params\">(AggregationBuffer agg)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;(myagg.container.size());</span><br><span class=\"line\">        ret.addAll(myagg.container);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//reduce端,将terminatePartial返回的中间部分聚合结果聚合到当前聚合中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(AggregationBuffer agg, Object partial)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; partialResult = (ArrayList&lt;Object&gt;) internalMergeOI.getList(partial);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object i : partialResult) &#123;</span><br><span class=\"line\">            putIntoList(i, myagg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">terminate</span><span class=\"params\">(AggregationBuffer agg)</span> <span class=\"keyword\">throws</span> HiveException </span>&#123;</span><br><span class=\"line\">        MKArrayAggregationBuffer myagg = (MKArrayAggregationBuffer) agg;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;(myagg.container.size());</span><br><span class=\"line\">        ret.addAll(myagg.container);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HIve尝试尽量避免通过new创建对象,Hadoop和HIve依据这个规则创建尽可能少的临时对象,这样可以减轻JVM的垃圾回收过程.</p>\n<p>使用collect函数的查询结果:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; select * from people;</span><br><span class=\"line\">OK</span><br><span class=\"line\">bob\tsara</span><br><span class=\"line\">bob\tjohn</span><br><span class=\"line\">bob\tted</span><br><span class=\"line\">john\tsara</span><br><span class=\"line\">ted\tbob</span><br><span class=\"line\">ted\tsara</span><br><span class=\"line\">bob\tsara</span><br><span class=\"line\">ted\tbob</span><br><span class=\"line\">//去重了</span><br><span class=\"line\">hive&gt; select name, concat_ws(\",\", collect_set(friend)) from people group by name;</span><br><span class=\"line\">bob\tsara,john,ted</span><br><span class=\"line\">john\tsara</span><br><span class=\"line\">ted\tbob,sara</span><br></pre></td></tr></table></figure>"},{"title":"JVM--Java内存区域与内存溢出异常","date":"2018-04-15T15:01:29.000Z","_content":"Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干不同的数据区域。\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-15/8172747.jpg)\n\n<!-- more-->\n\n程序计数器*：是一块较小的内存空间，可看做当前线程执行的字节码的行号指示器，在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n> 程序计数器是线程私有的：为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为“线程私有”的内存。\n\n*Java虚拟机栈*：线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n> 局部变量表存放了*编译器可知*的各种*基本数据类型*（boolean、byte、char、short、int、float、long、\ndouble)，*对象引用*和returnAddress类型。\n> 其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个。局部\n变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是\n完全确定的,在方法运行期间不会改变局部变量表的大小。\n\n*本地方法栈*：本地方法栈为虚拟机使用到的Native方法服务，线程独立\n> 与Java虚拟机栈对比：它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务\n\n*Java堆*：JVM管理的内存中最大的一块，*线程共享*，在JVM启动时创建，用来*存放实例对象*。java堆是垃圾回收的主要区域。\n> 从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代\n> 从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的*分配缓冲区*\n> Java堆可以处于物理上不连续的内存空间中，逻辑上连续即可\n> 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常。\n\n*Java方法区*：*线程共享*，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。又名“非堆”\n\n*运行时常量池*：是方法区的一部分，常量池存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n>Class文件内容：类的版本、字段、方法、接口、常量池\n>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编\n译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新\n的常量放入池中\n\n*直接内存*：直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区\n域。NIO(New Input/Output)类引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据。\n>本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。\n","source":"_posts/JVM-Java内存区域与内存溢出异常.md","raw":"---\ntitle: JVM--Java内存区域与内存溢出异常\ndate: 2018-04-15 23:01:29\ntags: [JVM,  Java]\n---\nJava虚拟机在执行Java程序的过程中会把它管理的内存划分为若干不同的数据区域。\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-15/8172747.jpg)\n\n<!-- more-->\n\n程序计数器*：是一块较小的内存空间，可看做当前线程执行的字节码的行号指示器，在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n> 程序计数器是线程私有的：为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为“线程私有”的内存。\n\n*Java虚拟机栈*：线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n> 局部变量表存放了*编译器可知*的各种*基本数据类型*（boolean、byte、char、short、int、float、long、\ndouble)，*对象引用*和returnAddress类型。\n> 其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个。局部\n变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是\n完全确定的,在方法运行期间不会改变局部变量表的大小。\n\n*本地方法栈*：本地方法栈为虚拟机使用到的Native方法服务，线程独立\n> 与Java虚拟机栈对比：它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务\n\n*Java堆*：JVM管理的内存中最大的一块，*线程共享*，在JVM启动时创建，用来*存放实例对象*。java堆是垃圾回收的主要区域。\n> 从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代\n> 从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的*分配缓冲区*\n> Java堆可以处于物理上不连续的内存空间中，逻辑上连续即可\n> 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常。\n\n*Java方法区*：*线程共享*，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。又名“非堆”\n\n*运行时常量池*：是方法区的一部分，常量池存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n>Class文件内容：类的版本、字段、方法、接口、常量池\n>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编\n译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新\n的常量放入池中\n\n*直接内存*：直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区\n域。NIO(New Input/Output)类引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据。\n>本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。\n","slug":"JVM-Java内存区域与内存溢出异常","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i680005cf96uhxkdzjw","content":"<p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干不同的数据区域。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-15/8172747.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>程序计数器*：是一块较小的内存空间，可看做当前线程执行的字节码的行号指示器，在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\n<blockquote>\n<p>程序计数器是线程私有的：为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为“线程私有”的内存。</p>\n</blockquote>\n<p><em>Java虚拟机栈</em>：线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<blockquote>\n<p>局部变量表存放了<em>编译器可知</em>的各种<em>基本数据类型</em>（boolean、byte、char、short、int、float、long、<br>double)，<em>对象引用</em>和returnAddress类型。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个。局部<br>变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是<br>完全确定的,在方法运行期间不会改变局部变量表的大小。</p>\n</blockquote>\n<p><em>本地方法栈</em>：本地方法栈为虚拟机使用到的Native方法服务，线程独立</p>\n<blockquote>\n<p>与Java虚拟机栈对比：它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务</p>\n</blockquote>\n<p><em>Java堆</em>：JVM管理的内存中最大的一块，<em>线程共享</em>，在JVM启动时创建，用来<em>存放实例对象</em>。java堆是垃圾回收的主要区域。</p>\n<blockquote>\n<p>从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代<br>从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的<em>分配缓冲区</em><br>Java堆可以处于物理上不连续的内存空间中，逻辑上连续即可<br>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常。</p>\n</blockquote>\n<p><em>Java方法区</em>：<em>线程共享</em>，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。又名“非堆”</p>\n<p><em>运行时常量池</em>：是方法区的一部分，常量池存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>\n<blockquote>\n<p>Class文件内容：类的版本、字段、方法、接口、常量池<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编<br>译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新<br>的常量放入池中</p>\n</blockquote>\n<p><em>直接内存</em>：直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区<br>域。NIO(New Input/Output)类引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据。</p>\n<blockquote>\n<p>本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干不同的数据区域。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-15/8172747.jpg\" alt=\"\"></p>","more":"<p>程序计数器*：是一块较小的内存空间，可看做当前线程执行的字节码的行号指示器，在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\n<blockquote>\n<p>程序计数器是线程私有的：为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为“线程私有”的内存。</p>\n</blockquote>\n<p><em>Java虚拟机栈</em>：线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<blockquote>\n<p>局部变量表存放了<em>编译器可知</em>的各种<em>基本数据类型</em>（boolean、byte、char、short、int、float、long、<br>double)，<em>对象引用</em>和returnAddress类型。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个。局部<br>变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是<br>完全确定的,在方法运行期间不会改变局部变量表的大小。</p>\n</blockquote>\n<p><em>本地方法栈</em>：本地方法栈为虚拟机使用到的Native方法服务，线程独立</p>\n<blockquote>\n<p>与Java虚拟机栈对比：它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务</p>\n</blockquote>\n<p><em>Java堆</em>：JVM管理的内存中最大的一块，<em>线程共享</em>，在JVM启动时创建，用来<em>存放实例对象</em>。java堆是垃圾回收的主要区域。</p>\n<blockquote>\n<p>从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代<br>从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的<em>分配缓冲区</em><br>Java堆可以处于物理上不连续的内存空间中，逻辑上连续即可<br>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常。</p>\n</blockquote>\n<p><em>Java方法区</em>：<em>线程共享</em>，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。又名“非堆”</p>\n<p><em>运行时常量池</em>：是方法区的一部分，常量池存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>\n<blockquote>\n<p>Class文件内容：类的版本、字段、方法、接口、常量池<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编<br>译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新<br>的常量放入池中</p>\n</blockquote>\n<p><em>直接内存</em>：直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区<br>域。NIO(New Input/Output)类引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据。</p>\n<blockquote>\n<p>本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。</p>\n</blockquote>"},{"title":"Java并发编程——并发基础构建模块","date":"2018-05-26T16:39:52.000Z","_content":"\n#### 一、同步容器类\n\n同步容器类包括Vector和HashTable，其封装器类由Collections.synchronizedXxx等工厂方法创建\n\n同步容器类实现线程安全的方式：将他们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能访问容器状态，即**串行化容器的访问**。\n\n同步容器类支持客户端加锁，因此可能会创建一些新的操作，同步容器类通过其自身的锁来保护他的每个方法。\n\n<!-- more--> \n\n**及时失败**：同步容器类的迭代器的并发修改问题，当容器在迭代过程中被修改时，会抛出ConcurrentModificationException异常。\n\n> 在迭代期间对容器加锁可以解决及时失败问题，但是长时间对容器加锁会降低程序的可伸缩性，持有锁时间越长，在锁上的竞争就越激烈，降低吞吐量和cpu利用率。\n\n> 另一种方式是“克隆容器”，并在副本上进行迭代，但这样存在明显的性能开销\n\n容器的隐藏迭代：容器的toString(), hashCode(), equals()，removeAll(), retainsAll()等方法都会间接迭代容器，可能会发生ConcurrentModificationException异常。\n\n#### 二、并发容器\n\n同步容器串行化容器的访问，严重降低并发性，当多个线程竞争容器锁时，吞吐量严重降低。\n\n并发容器是针对多个线程并发访问设计的。\n\n- ConcurrentHashMap\n\n  ConcurrentHashMap类似HashMap，也是基于散列的Map，它使用一种更细粒度的加锁机制——**分段锁**（Lock Striping）来实现更大程度的共享。任意数量的读取线程可以并发的访问Map，一定数量的写入线程可以并发修改Map，读写线程可以并发的访问Map。\n\n  > ConcurrentHashMap不会抛出ConcurrentModificationException异常\n\n  ConcurrentHashMap返回的迭代器具有弱一致性，可以容忍并发的修改，因此size(),isEmpty()等方法会返回近似值而不是精确值。\n\n  ConcurrentHashMap没有实现对Map加锁以提供独占访问，提高了代码的伸缩性，只有在需要独占访问Map时才不使用ConcurrentHashMap。\n\n  ConcurrentHashMap不能使用客户端加锁来创建新的原子操作。\n\n- CopyOnWriteArrayList\n\n  CopyOnWriteArrayList用于替代同步List，CopyOnWriteArraySet替代同步Set，提供了更好的并发性且不需要在迭代期间对容器加锁。\n\n  Copy-On-Write写入时复制：只要正确发布一个事实不可变的对象，那么访问该对象时就不需要再进一步的同步，每次修改时都会创建并重新发布一个新的容器副本，从而实现可变性。“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此多个线程可以同时对这个容器进行迭代，而不会彼此干扰活与修改容器的线程相互干扰。\n\n  > 每次修改容器时都会复制底层数组，需要一定开销。当迭代操作远多于修改操作时，才应该使用“写入时复制”\n\n#### 三、阻塞队列和生产者-消费者模式\n\n  BlockingQueue提供了可阻塞的put和take方法，支持定时的poll和offer方法，若对列已满，put方法将阻塞直到有空间可用；若对列为空，take方法将阻塞直到有元素可用。队列可有界也可以无界，无界对列的take方法永远不会阻塞。\n\n  阻塞队列简化了生产者-消费者设计模式，支持任意数量的生产者与消费者。\n\n  offer方法：如果数据不能被添加到队列，将返回一个失败状态。\n\n  BlockingQueue的实现：\n\n- LinkedBlockingQueue\n\n- ArrayBlockingQueue\n\n  -------------------以上两者为FIFO队列-----------------\n\n- PriorityBlockingQueue是一个按照优先级排序的队列，既可以根据自然顺序来比较元素，也可以使用Comparator来比较\n\n- SynchronousQueue:实际上不是一个真正的队列，因为它不会为队列中的元素维护存储空间，它维护一组线程，这些线程在等待元素加入或移出队列。类似于洗碗没有盘架，洗完直接放到烘干机，SynchronousQueue的put和take会一直阻塞，直到有另一个线程已准备好参与到交付过程。仅当有足够多的消费者，并且总有一个消费者主备好交付的工作时，才使用同步队列。\n\n  生产者——消费者模式的性能优势：生产者和消费者可以并发执行，如果一个是I/O密集型，一个是CPU密集型，那么并发执行的吞吐率高于串行的吞吐率。如果两者并行度不同，那么将他们紧密耦合会把整体并行度降低为二者中更小的并行度\n\n- 串行线程封闭\n\n  阻塞队列可以安全的将对象从生产者线程发布到消费者线程，线程封闭对象只能由单个线程拥有，但可以通过安全的发布对象来\"转移\"所有权.\n\n- 双端队列与工作密取\n\n  Deque和BlockingDeque分别扩展了Queue和BlockingQueue，Deque是一个双端队列，实现在队列头和队列尾高效插入和移出。具体实现包括ArrayDeque和LinkedBlockingDeque。\n\n  双端队列适用于工作密取模式（Work Stealing）：每个消费者都有自己的双端队列，如果一个消费者完成了自己双端队列中的全部工作，它可以从其他消费者的双端队列**末尾**秘密的获取工作。这样有更高的伸缩性，从其他消费者尾部获取工作降低了竞争程度，适用于即是消费者又是生产者问题\n\n#### 四、阻塞方法与中断方法\n\n导致线程阻塞或暂停的原因：\n    \n\n- 等待I/O操作结束\n- 等待获得一个锁\n- 等待从Thread.sleep方法中醒来\n- 等待另一个线程的计算结果\n\n线程阻塞后一般会被挂起，并处于某种阻塞状态（BLOCKED,WATING,TIMED_WATING）。\n\n阻塞线程与执行时间很长的操作的差别：被阻塞线程必须等待不受它控制的事件发生后才能继续执行。当某个外部事件发生时，线程状态被设置为RUNNABLE状态，并可以被再次调度执行。\n\n当某方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这方法被中断，那么他将努力提前结束阻塞状态。\n\nThread提供了Interrupt方法，用于中断线程或查询线程是否已被中断，每个线程都有一个bool类型的属性，表示线程的中断状态，当线程中断时设置这个状态。\n\n中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——前提是B愿意停下来。\n\n处理对中断的响应：\n\n- 传递InterruptedException：避开这个异常通常是最明智的策略，将InterruptedException传给方法的调用者\n- 恢复中断：捕获InterruptedException，并通过调用当前线程上的interrupt方法恢复中断状态\n\n#### 五、 同步工具类\n\n阻塞队列不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，直到队列达到期望的状态。\n\n同步工具类可以是任意对象，只要它根据自身情况状态来协调线程的控制流。\n同步工具类包括：\n\n1. 阻塞队列\n2. 信号量（Semaphore）\n3. 栅栏（Barrier）\n4. 闭锁（Latch）\n\n- 闭锁\n\n  闭锁可以延迟线程的进度直到其到达终止状态。相当于一扇门，在闭锁到达结束状态之前，门一直关闭，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再改变状态。闭锁可以确保某些活动直到其他活动都完成后才继续执行。\n\n  CountDownLatch是闭锁的一种实现，可以使一个或多个事件等待一组事件发生。闭锁状态包含一个计数器，初始化为一个正数，表示需要等待的事件的数量，countDown方法递减计数器，表示有一个事件已经发生，await方法等待计数器达到零，表示等待的事件均已发生。若计数器非零，await方法会一直阻塞到计数器为零，或者等待中的线程中断，或者等待超时。\n\n  ```java\n  public class TestHarness {\n  public long timeTasks (int nThreads, final Runnable task) throws InterruptedException {\n      final CountDownLatch startGate = new CountDownLatch(1);\n      final CountDownLatch endGate = new CountDownLatch(nThreads);\n\n      for (int i = 0; i<nThreads; i++) {\n          Thread t = new Thread() {\n              @Override\n              public void run() {\n                  try {\n                      startGate.await();\n                      try{\n                          task.run();\n                      } finally {\n                          endGate.countDown();\n                      }\n                  } catch (InterruptedException e) {\n                  }\n              }\n          };\n          t.start();\n      }\n      long start =System.nanoTime();\n      startGate.countDown();\n      endGate.await();\n      long end = System.nanoTime();\n      return end - start;\n  }\n  }\n  ```\n\n- FutureTask\n\nFutureTask也可以用作闭锁，表示的计算是通过Callable实现的，相当于一种可生成结果的Runnable，有三种状态：\n\n```\n1.等待运行——waiting to run\n\n2.正在运行——running\n\n3.运行完成——completed\n```\n\n当FutureTask进入完成状态后，会永远停止在这个状态上。\nFuture.get的行为取决于任务的状态，若已完成，会立即返回结果，否则会阻塞直到任务进入完成状态。FutureTask将计算结果从计算线程传递到获取结果的线程，而FutureTask能确保传递过程能实现结果的安全发布。\n\nFutureTask在Executor框架中表示异步任务，还可以用来表示一些时间较长的计算。\n\n```java\npublic class Preloader {\n    private final FutureTask<ProductInfo> future =\n            new FutureTask<ProductInfo>(new Callable<ProductInfo>() {\n                @Override\n                public ProductInfo call() throws Exception {\n                    return loadProductInfo();\n                }\n            });\n\n    private final Thread thread = new Thread(future);\n\n    public void start() {\n        thread.start();\n    }\n\n    public ProductInfo get() {\n        try {\n            return future.get();\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof  DataLoadException)\n                throw (DataLoadException) cause;\n            else \n                throw launderthrowable(cause);\n        }\n    }\n}\n```\n\nCallable表示的任务可以抛出受检查的或者未受检查的异常，并且任何代码都可能抛出一个Error，无论代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get中被重新排出。\n\n- 信号量 Semaphore\n\n  计数信号量用来控制访问某个特定资源的操作数量或者同时执行某个指定操作的数量\n\n  信号量管理着一组虚拟的许可(permit)，许可的数量可通过构造函数指定，在执行操作时可以首先获得许可，并在以后释放许可即可。若没有许可，那么acquire将阻塞直到有许可（或者直到被中断获操作超时）。release方法将返回一个许可给信号量。\n\n  **二值信号量**计算信号量的简化形式，初始值为1，二值信号量可以作为互斥体（mutex），并具备不可重入锁语义：谁唯一拥有了这个锁，谁就拥有了互斥锁。\n\n```java\n/**\n * @author harold\n * @Title: BoundedHashSet\n * @Description: 使用Semaphore为容器设置边界\n * @date 2018/5/23下午1:59\n */\npublic class BoundedHashSet<T> {\n    private final Set<T> set;\n    private final Semaphore sem;\n\n    public BoundedHashSet(int bound) {\n        this.set = Collections.synchronizedSet(new HashSet<T>());\n        sem = new Semaphore(bound);\n    }\n\n    public boolean add(T o) throws InterruptedException {\n        sem.acquire();\n        boolean wasAdded = false;\n        try {\n            wasAdded = set.add(o);\n            return wasAdded;\n        } finally {\n            if (!wasAdded) {\n                sem.release();\n            }\n        }\n    }\n    \n    public boolean remove(Object obj) {\n        boolean wasRemoved = set.remove(obj);\n        if (wasRemoved) {\n            sem.release();\n        }\n        return wasRemoved;\n    }\n}\n```\n\n- 栅栏Barrier\n\n  闭锁是一次性对象，一旦进入终止状态，就不能被重置。\n\n  栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于：所有线程必须**同时到达**栅栏位置，才能继续执行。闭锁用来等待事件，而栅栏用于等待其他线程。\n\n  CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集，在并行迭代算法中非常有用：这类算法通常将一个问题拆分成一系列相互独立的子问题。\n\n  当线程到达栅栏位置时将调用await方法，这方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，所有线程都被释放，栅栏将被重置以便下次使用。如果对await的调用超时，或者await的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。若成功通过栅栏，那么await将为每个线程返回一个唯一的到达索引号。\n\n  CyclicBarrier还可以将一个栅栏操作传递给构造函数，它是一个Runnable函数，当成功通过栅栏时会在一个子任务线程中执行它，但在阻塞线程被释放之前是不能执行的。\n\n```java\n //通过cyclicbarrier协调细胞自动衍生系统中的运算\npublic class CellularAotumata {\n    private final Board mainboard;\n    private final CyclicBarrier barrier;\n    private final Worker[] workers;\n\n    public CellularAotumata(Board mainboard) {\n        this.mainboard = mainboard;\n        int count = Runtime.getRuntime().availableProcessors();\n        this.barrier = new CyclicBarrier(count,\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        mainboard.commitNewValues();\n                    }\n                });\n        this.workers = new Worker[count];\n        for (int i=0; i<count; i++) \n            workers[i] = new Worker(mainboard.getSubBoard(count, i));\n    }\n    private class Worker implements Runnable{\n        private final Board board;\n\n        public Worker(Board board) {\n            this.board = board;\n        }\n\n        @Override\n        public void run() {\n            while(!board.hasConverged()) {\n                for (int i = 0; i < board.getMaxX(); i++){\n                    for (int j = 0; i < board.getMaxY(); j++) {\n                        board.setNewValue(x,y, compute(x,y));\n                    }\n                }\n                try {\n                    barrier.await();\n                } catch (InterruptedException ex) {\n                    return;\n                }\n                 catch (BrokenBarrierException ex) {\n                    return ;\n                 }\n            }\n        }\n    }\n    public void start() {\n        for (int i = 0; i< workers.length; i++) {\n            new Thread(workers[i]).start();\n        }\n        mainboard.waitForConvergence();\n    }\n}\n```\n\n```\n另一种形式的栅栏是Exchanger，是一种两方栅栏，各方在栅栏上交换数据，当两方执行不对称操作时，Exchanger非常有用。\n```\n\n#### 六、构建高效可伸缩结果缓存\n\n几乎所有服务器应用程序都会使用某种形式的缓存，重用之前的结果能降低延迟，提高吞吐量，但需要消耗更多的内存。\n\n程序清单：\n\n```java\n/**\n * @author harold\n * @Title:\n * @Description:  构建可伸缩缓存\n * @date 2018/5/23下午3:47\n */\ninterface Computerable<A, V> {\n    V compute(A arg) throws InterruptedException;\n}\n\nclass ExpensiveFunction implements Computerable<String, BigInteger> {\n    @Override\n    public BigInteger compute(String arg) throws InterruptedException {\n        //再经过长时间计算后\n        return new BigInteger(arg);\n    }\n}\n\n//使用HashMap和同步机制来初始化缓存\npublic class Memorizer1 <A, V> implements Computerable<A, V> {\n    private final Map<A,V> cache = new HashMap<A,V>();\n    private final Computerable<A, V> c;\n\n    public Memorizer1(Computerable<A, V> c) {\n        this.c = c;\n    }\n\n    @Override\n    public synchronized V compute(A arg) throws InterruptedException {\n        V result = cache.get(arg);\n        if (result == null) {\n            result = c.compute(arg);\n            cache.put(arg, result);\n        }\n        return  result;\n    }\n}\n//用ConcurrentHashMap代替HashMap\npublic class Memorizer2<A, V> implements Computerable<A, V> {\n    private final Map<A, V> cache = new ConcurrentHashMap<A, V>();\n    private final Computerable<A, V> c;\n\n    public Memorizer2(Computerable<A, V> c) {\n        this.c = c;\n    }\n\n    @Override\n    public V compute(A arg) throws InterruptedException {\n        V result = cache.get(arg);\n        if (result == null) {\n            result = c.compute(arg);\n            cache.put(arg, result);\n        }\n        return  result;\n    }\n}\n\n//基于FutureTask的Memorizing封装器\npublic class Memorizer3<A,V> implements Computerable<A, V> {\n    private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();\n    private final Computerable<A, V> c;\n\n    public Memorizer3(Computerable<A, V> c) {\n        this.c = c;\n    }\n\n    @Override\n    public V compute(A arg) throws InterruptedException {\n        Future<V> f = cache.get(arg);\n        if (f == null) {\n            Callable<V> eval = new Callable<V>() {\n                @Override\n                public V call() throws Exception {\n                    return c.compute(arg);\n                }\n            };\n            FutureTask<V> ft = new FutureTask<V>(eval);\n            f = ft;\n            cache.put(arg, ft);\n            ft.run();\n        }\n        try {\n            return f.get();\n        } catch (ExecutionException e) {\n           throw launderthrowable(e.getCause());\n        }\n    }\n}\n\npublic class Memorizer<A, V> implements Computerable<A, V> {\n    private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();\n    private final Computerable<A, V> c;\n\n    public Memorizer(Computerable<A, V> c) {\n        this.c = c;\n    }\n    @Override\n    public V compute(A arg) throws InterruptedException {\n        while (true) {\n            Future<V> f = cache.get(arg);\n            if (f == null) {\n                Callable<V> eval = new Callable<V>() {\n                    @Override\n                    public V call() throws Exception {\n                        return c.compute(arg);\n                    }\n                };\n                FutureTask<V> ft = new FutureTask<V>(eval);\n                f = cache.putIfAbsent(arg, ft);\n                if (f == null) {\n                    f = ft;\n                    ft.run();\n                }\n            }\n            try {\n                return f.get();\n            } catch (CancellationException e) {\n                cache.remove(arg,f);\n            } cache (ExecutionException e) {\n                throw launderThrowable(e.getCause());\n            }\n        }\n    }\n}\n```\n\nMemorizer1使用HashMap和同步机制来保存之前的计算结果，HashMap非线程安全，于是对整个compute方法同步，这样可能用的时间比没有缓存用的更长，效果不好。\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-23/48498421.jpg)\n\nMemorizer2用ConcurrentHashMap代替HashMap，多线程可以并发的使用它，但是当两个线程同时调用compute时存在一个漏洞，可能会导致重复计算，与我们缓存的初衷违背。\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-23/98285594.jpg)\n\nMemorizer3使用ConcurrentHashMap<A,Future<V>>，先检查某个相应的计算是否已经开始，若还未启动，就创建一个FutureTask，并注册到Map中，然后启动计算，若已启动，的等待现有的计算结果。但是有一个漏洞，仍然可能出现两个线程计算出相同的值，因为compute方法中的if代码块仍然是非原子的“先检查、再执行”操作。\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-23/36335384.jpg)\n\nMemorizer是缓存的最终实现，当缓存的是Future而不是值时，将导致缓存污染问题：如果某个计算被取消或失败，那么在计算这个结果时将指明计算过程被取消或者失败。为避免这种情况，如果Memorizer发现计算被取消，那么将把Future从缓存中移出，如果监测到RuntimeException，也会移出Future。","source":"_posts/Java并发编程——并发基础构建模块.md","raw":"---\ntitle: Java并发编程——并发基础构建模块\ndate: 2018-05-27 00:39:52\ntags: [Java, 多线程, 并发]\n---\n\n#### 一、同步容器类\n\n同步容器类包括Vector和HashTable，其封装器类由Collections.synchronizedXxx等工厂方法创建\n\n同步容器类实现线程安全的方式：将他们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能访问容器状态，即**串行化容器的访问**。\n\n同步容器类支持客户端加锁，因此可能会创建一些新的操作，同步容器类通过其自身的锁来保护他的每个方法。\n\n<!-- more--> \n\n**及时失败**：同步容器类的迭代器的并发修改问题，当容器在迭代过程中被修改时，会抛出ConcurrentModificationException异常。\n\n> 在迭代期间对容器加锁可以解决及时失败问题，但是长时间对容器加锁会降低程序的可伸缩性，持有锁时间越长，在锁上的竞争就越激烈，降低吞吐量和cpu利用率。\n\n> 另一种方式是“克隆容器”，并在副本上进行迭代，但这样存在明显的性能开销\n\n容器的隐藏迭代：容器的toString(), hashCode(), equals()，removeAll(), retainsAll()等方法都会间接迭代容器，可能会发生ConcurrentModificationException异常。\n\n#### 二、并发容器\n\n同步容器串行化容器的访问，严重降低并发性，当多个线程竞争容器锁时，吞吐量严重降低。\n\n并发容器是针对多个线程并发访问设计的。\n\n- ConcurrentHashMap\n\n  ConcurrentHashMap类似HashMap，也是基于散列的Map，它使用一种更细粒度的加锁机制——**分段锁**（Lock Striping）来实现更大程度的共享。任意数量的读取线程可以并发的访问Map，一定数量的写入线程可以并发修改Map，读写线程可以并发的访问Map。\n\n  > ConcurrentHashMap不会抛出ConcurrentModificationException异常\n\n  ConcurrentHashMap返回的迭代器具有弱一致性，可以容忍并发的修改，因此size(),isEmpty()等方法会返回近似值而不是精确值。\n\n  ConcurrentHashMap没有实现对Map加锁以提供独占访问，提高了代码的伸缩性，只有在需要独占访问Map时才不使用ConcurrentHashMap。\n\n  ConcurrentHashMap不能使用客户端加锁来创建新的原子操作。\n\n- CopyOnWriteArrayList\n\n  CopyOnWriteArrayList用于替代同步List，CopyOnWriteArraySet替代同步Set，提供了更好的并发性且不需要在迭代期间对容器加锁。\n\n  Copy-On-Write写入时复制：只要正确发布一个事实不可变的对象，那么访问该对象时就不需要再进一步的同步，每次修改时都会创建并重新发布一个新的容器副本，从而实现可变性。“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此多个线程可以同时对这个容器进行迭代，而不会彼此干扰活与修改容器的线程相互干扰。\n\n  > 每次修改容器时都会复制底层数组，需要一定开销。当迭代操作远多于修改操作时，才应该使用“写入时复制”\n\n#### 三、阻塞队列和生产者-消费者模式\n\n  BlockingQueue提供了可阻塞的put和take方法，支持定时的poll和offer方法，若对列已满，put方法将阻塞直到有空间可用；若对列为空，take方法将阻塞直到有元素可用。队列可有界也可以无界，无界对列的take方法永远不会阻塞。\n\n  阻塞队列简化了生产者-消费者设计模式，支持任意数量的生产者与消费者。\n\n  offer方法：如果数据不能被添加到队列，将返回一个失败状态。\n\n  BlockingQueue的实现：\n\n- LinkedBlockingQueue\n\n- ArrayBlockingQueue\n\n  -------------------以上两者为FIFO队列-----------------\n\n- PriorityBlockingQueue是一个按照优先级排序的队列，既可以根据自然顺序来比较元素，也可以使用Comparator来比较\n\n- SynchronousQueue:实际上不是一个真正的队列，因为它不会为队列中的元素维护存储空间，它维护一组线程，这些线程在等待元素加入或移出队列。类似于洗碗没有盘架，洗完直接放到烘干机，SynchronousQueue的put和take会一直阻塞，直到有另一个线程已准备好参与到交付过程。仅当有足够多的消费者，并且总有一个消费者主备好交付的工作时，才使用同步队列。\n\n  生产者——消费者模式的性能优势：生产者和消费者可以并发执行，如果一个是I/O密集型，一个是CPU密集型，那么并发执行的吞吐率高于串行的吞吐率。如果两者并行度不同，那么将他们紧密耦合会把整体并行度降低为二者中更小的并行度\n\n- 串行线程封闭\n\n  阻塞队列可以安全的将对象从生产者线程发布到消费者线程，线程封闭对象只能由单个线程拥有，但可以通过安全的发布对象来\"转移\"所有权.\n\n- 双端队列与工作密取\n\n  Deque和BlockingDeque分别扩展了Queue和BlockingQueue，Deque是一个双端队列，实现在队列头和队列尾高效插入和移出。具体实现包括ArrayDeque和LinkedBlockingDeque。\n\n  双端队列适用于工作密取模式（Work Stealing）：每个消费者都有自己的双端队列，如果一个消费者完成了自己双端队列中的全部工作，它可以从其他消费者的双端队列**末尾**秘密的获取工作。这样有更高的伸缩性，从其他消费者尾部获取工作降低了竞争程度，适用于即是消费者又是生产者问题\n\n#### 四、阻塞方法与中断方法\n\n导致线程阻塞或暂停的原因：\n    \n\n- 等待I/O操作结束\n- 等待获得一个锁\n- 等待从Thread.sleep方法中醒来\n- 等待另一个线程的计算结果\n\n线程阻塞后一般会被挂起，并处于某种阻塞状态（BLOCKED,WATING,TIMED_WATING）。\n\n阻塞线程与执行时间很长的操作的差别：被阻塞线程必须等待不受它控制的事件发生后才能继续执行。当某个外部事件发生时，线程状态被设置为RUNNABLE状态，并可以被再次调度执行。\n\n当某方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这方法被中断，那么他将努力提前结束阻塞状态。\n\nThread提供了Interrupt方法，用于中断线程或查询线程是否已被中断，每个线程都有一个bool类型的属性，表示线程的中断状态，当线程中断时设置这个状态。\n\n中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——前提是B愿意停下来。\n\n处理对中断的响应：\n\n- 传递InterruptedException：避开这个异常通常是最明智的策略，将InterruptedException传给方法的调用者\n- 恢复中断：捕获InterruptedException，并通过调用当前线程上的interrupt方法恢复中断状态\n\n#### 五、 同步工具类\n\n阻塞队列不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，直到队列达到期望的状态。\n\n同步工具类可以是任意对象，只要它根据自身情况状态来协调线程的控制流。\n同步工具类包括：\n\n1. 阻塞队列\n2. 信号量（Semaphore）\n3. 栅栏（Barrier）\n4. 闭锁（Latch）\n\n- 闭锁\n\n  闭锁可以延迟线程的进度直到其到达终止状态。相当于一扇门，在闭锁到达结束状态之前，门一直关闭，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再改变状态。闭锁可以确保某些活动直到其他活动都完成后才继续执行。\n\n  CountDownLatch是闭锁的一种实现，可以使一个或多个事件等待一组事件发生。闭锁状态包含一个计数器，初始化为一个正数，表示需要等待的事件的数量，countDown方法递减计数器，表示有一个事件已经发生，await方法等待计数器达到零，表示等待的事件均已发生。若计数器非零，await方法会一直阻塞到计数器为零，或者等待中的线程中断，或者等待超时。\n\n  ```java\n  public class TestHarness {\n  public long timeTasks (int nThreads, final Runnable task) throws InterruptedException {\n      final CountDownLatch startGate = new CountDownLatch(1);\n      final CountDownLatch endGate = new CountDownLatch(nThreads);\n\n      for (int i = 0; i<nThreads; i++) {\n          Thread t = new Thread() {\n              @Override\n              public void run() {\n                  try {\n                      startGate.await();\n                      try{\n                          task.run();\n                      } finally {\n                          endGate.countDown();\n                      }\n                  } catch (InterruptedException e) {\n                  }\n              }\n          };\n          t.start();\n      }\n      long start =System.nanoTime();\n      startGate.countDown();\n      endGate.await();\n      long end = System.nanoTime();\n      return end - start;\n  }\n  }\n  ```\n\n- FutureTask\n\nFutureTask也可以用作闭锁，表示的计算是通过Callable实现的，相当于一种可生成结果的Runnable，有三种状态：\n\n```\n1.等待运行——waiting to run\n\n2.正在运行——running\n\n3.运行完成——completed\n```\n\n当FutureTask进入完成状态后，会永远停止在这个状态上。\nFuture.get的行为取决于任务的状态，若已完成，会立即返回结果，否则会阻塞直到任务进入完成状态。FutureTask将计算结果从计算线程传递到获取结果的线程，而FutureTask能确保传递过程能实现结果的安全发布。\n\nFutureTask在Executor框架中表示异步任务，还可以用来表示一些时间较长的计算。\n\n```java\npublic class Preloader {\n    private final FutureTask<ProductInfo> future =\n            new FutureTask<ProductInfo>(new Callable<ProductInfo>() {\n                @Override\n                public ProductInfo call() throws Exception {\n                    return loadProductInfo();\n                }\n            });\n\n    private final Thread thread = new Thread(future);\n\n    public void start() {\n        thread.start();\n    }\n\n    public ProductInfo get() {\n        try {\n            return future.get();\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof  DataLoadException)\n                throw (DataLoadException) cause;\n            else \n                throw launderthrowable(cause);\n        }\n    }\n}\n```\n\nCallable表示的任务可以抛出受检查的或者未受检查的异常，并且任何代码都可能抛出一个Error，无论代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get中被重新排出。\n\n- 信号量 Semaphore\n\n  计数信号量用来控制访问某个特定资源的操作数量或者同时执行某个指定操作的数量\n\n  信号量管理着一组虚拟的许可(permit)，许可的数量可通过构造函数指定，在执行操作时可以首先获得许可，并在以后释放许可即可。若没有许可，那么acquire将阻塞直到有许可（或者直到被中断获操作超时）。release方法将返回一个许可给信号量。\n\n  **二值信号量**计算信号量的简化形式，初始值为1，二值信号量可以作为互斥体（mutex），并具备不可重入锁语义：谁唯一拥有了这个锁，谁就拥有了互斥锁。\n\n```java\n/**\n * @author harold\n * @Title: BoundedHashSet\n * @Description: 使用Semaphore为容器设置边界\n * @date 2018/5/23下午1:59\n */\npublic class BoundedHashSet<T> {\n    private final Set<T> set;\n    private final Semaphore sem;\n\n    public BoundedHashSet(int bound) {\n        this.set = Collections.synchronizedSet(new HashSet<T>());\n        sem = new Semaphore(bound);\n    }\n\n    public boolean add(T o) throws InterruptedException {\n        sem.acquire();\n        boolean wasAdded = false;\n        try {\n            wasAdded = set.add(o);\n            return wasAdded;\n        } finally {\n            if (!wasAdded) {\n                sem.release();\n            }\n        }\n    }\n    \n    public boolean remove(Object obj) {\n        boolean wasRemoved = set.remove(obj);\n        if (wasRemoved) {\n            sem.release();\n        }\n        return wasRemoved;\n    }\n}\n```\n\n- 栅栏Barrier\n\n  闭锁是一次性对象，一旦进入终止状态，就不能被重置。\n\n  栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于：所有线程必须**同时到达**栅栏位置，才能继续执行。闭锁用来等待事件，而栅栏用于等待其他线程。\n\n  CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集，在并行迭代算法中非常有用：这类算法通常将一个问题拆分成一系列相互独立的子问题。\n\n  当线程到达栅栏位置时将调用await方法，这方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，所有线程都被释放，栅栏将被重置以便下次使用。如果对await的调用超时，或者await的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。若成功通过栅栏，那么await将为每个线程返回一个唯一的到达索引号。\n\n  CyclicBarrier还可以将一个栅栏操作传递给构造函数，它是一个Runnable函数，当成功通过栅栏时会在一个子任务线程中执行它，但在阻塞线程被释放之前是不能执行的。\n\n```java\n //通过cyclicbarrier协调细胞自动衍生系统中的运算\npublic class CellularAotumata {\n    private final Board mainboard;\n    private final CyclicBarrier barrier;\n    private final Worker[] workers;\n\n    public CellularAotumata(Board mainboard) {\n        this.mainboard = mainboard;\n        int count = Runtime.getRuntime().availableProcessors();\n        this.barrier = new CyclicBarrier(count,\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        mainboard.commitNewValues();\n                    }\n                });\n        this.workers = new Worker[count];\n        for (int i=0; i<count; i++) \n            workers[i] = new Worker(mainboard.getSubBoard(count, i));\n    }\n    private class Worker implements Runnable{\n        private final Board board;\n\n        public Worker(Board board) {\n            this.board = board;\n        }\n\n        @Override\n        public void run() {\n            while(!board.hasConverged()) {\n                for (int i = 0; i < board.getMaxX(); i++){\n                    for (int j = 0; i < board.getMaxY(); j++) {\n                        board.setNewValue(x,y, compute(x,y));\n                    }\n                }\n                try {\n                    barrier.await();\n                } catch (InterruptedException ex) {\n                    return;\n                }\n                 catch (BrokenBarrierException ex) {\n                    return ;\n                 }\n            }\n        }\n    }\n    public void start() {\n        for (int i = 0; i< workers.length; i++) {\n            new Thread(workers[i]).start();\n        }\n        mainboard.waitForConvergence();\n    }\n}\n```\n\n```\n另一种形式的栅栏是Exchanger，是一种两方栅栏，各方在栅栏上交换数据，当两方执行不对称操作时，Exchanger非常有用。\n```\n\n#### 六、构建高效可伸缩结果缓存\n\n几乎所有服务器应用程序都会使用某种形式的缓存，重用之前的结果能降低延迟，提高吞吐量，但需要消耗更多的内存。\n\n程序清单：\n\n```java\n/**\n * @author harold\n * @Title:\n * @Description:  构建可伸缩缓存\n * @date 2018/5/23下午3:47\n */\ninterface Computerable<A, V> {\n    V compute(A arg) throws InterruptedException;\n}\n\nclass ExpensiveFunction implements Computerable<String, BigInteger> {\n    @Override\n    public BigInteger compute(String arg) throws InterruptedException {\n        //再经过长时间计算后\n        return new BigInteger(arg);\n    }\n}\n\n//使用HashMap和同步机制来初始化缓存\npublic class Memorizer1 <A, V> implements Computerable<A, V> {\n    private final Map<A,V> cache = new HashMap<A,V>();\n    private final Computerable<A, V> c;\n\n    public Memorizer1(Computerable<A, V> c) {\n        this.c = c;\n    }\n\n    @Override\n    public synchronized V compute(A arg) throws InterruptedException {\n        V result = cache.get(arg);\n        if (result == null) {\n            result = c.compute(arg);\n            cache.put(arg, result);\n        }\n        return  result;\n    }\n}\n//用ConcurrentHashMap代替HashMap\npublic class Memorizer2<A, V> implements Computerable<A, V> {\n    private final Map<A, V> cache = new ConcurrentHashMap<A, V>();\n    private final Computerable<A, V> c;\n\n    public Memorizer2(Computerable<A, V> c) {\n        this.c = c;\n    }\n\n    @Override\n    public V compute(A arg) throws InterruptedException {\n        V result = cache.get(arg);\n        if (result == null) {\n            result = c.compute(arg);\n            cache.put(arg, result);\n        }\n        return  result;\n    }\n}\n\n//基于FutureTask的Memorizing封装器\npublic class Memorizer3<A,V> implements Computerable<A, V> {\n    private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();\n    private final Computerable<A, V> c;\n\n    public Memorizer3(Computerable<A, V> c) {\n        this.c = c;\n    }\n\n    @Override\n    public V compute(A arg) throws InterruptedException {\n        Future<V> f = cache.get(arg);\n        if (f == null) {\n            Callable<V> eval = new Callable<V>() {\n                @Override\n                public V call() throws Exception {\n                    return c.compute(arg);\n                }\n            };\n            FutureTask<V> ft = new FutureTask<V>(eval);\n            f = ft;\n            cache.put(arg, ft);\n            ft.run();\n        }\n        try {\n            return f.get();\n        } catch (ExecutionException e) {\n           throw launderthrowable(e.getCause());\n        }\n    }\n}\n\npublic class Memorizer<A, V> implements Computerable<A, V> {\n    private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();\n    private final Computerable<A, V> c;\n\n    public Memorizer(Computerable<A, V> c) {\n        this.c = c;\n    }\n    @Override\n    public V compute(A arg) throws InterruptedException {\n        while (true) {\n            Future<V> f = cache.get(arg);\n            if (f == null) {\n                Callable<V> eval = new Callable<V>() {\n                    @Override\n                    public V call() throws Exception {\n                        return c.compute(arg);\n                    }\n                };\n                FutureTask<V> ft = new FutureTask<V>(eval);\n                f = cache.putIfAbsent(arg, ft);\n                if (f == null) {\n                    f = ft;\n                    ft.run();\n                }\n            }\n            try {\n                return f.get();\n            } catch (CancellationException e) {\n                cache.remove(arg,f);\n            } cache (ExecutionException e) {\n                throw launderThrowable(e.getCause());\n            }\n        }\n    }\n}\n```\n\nMemorizer1使用HashMap和同步机制来保存之前的计算结果，HashMap非线程安全，于是对整个compute方法同步，这样可能用的时间比没有缓存用的更长，效果不好。\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-23/48498421.jpg)\n\nMemorizer2用ConcurrentHashMap代替HashMap，多线程可以并发的使用它，但是当两个线程同时调用compute时存在一个漏洞，可能会导致重复计算，与我们缓存的初衷违背。\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-23/98285594.jpg)\n\nMemorizer3使用ConcurrentHashMap<A,Future<V>>，先检查某个相应的计算是否已经开始，若还未启动，就创建一个FutureTask，并注册到Map中，然后启动计算，若已启动，的等待现有的计算结果。但是有一个漏洞，仍然可能出现两个线程计算出相同的值，因为compute方法中的if代码块仍然是非原子的“先检查、再执行”操作。\n![](http://p5s7d12ls.bkt.clouddn.com/18-5-23/36335384.jpg)\n\nMemorizer是缓存的最终实现，当缓存的是Future而不是值时，将导致缓存污染问题：如果某个计算被取消或失败，那么在计算这个结果时将指明计算过程被取消或者失败。为避免这种情况，如果Memorizer发现计算被取消，那么将把Future从缓存中移出，如果监测到RuntimeException，也会移出Future。","slug":"Java并发编程——并发基础构建模块","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i690008cf969sm1fouv","content":"<h4 id=\"一、同步容器类\"><a href=\"#一、同步容器类\" class=\"headerlink\" title=\"一、同步容器类\"></a>一、同步容器类</h4><p>同步容器类包括Vector和HashTable，其封装器类由Collections.synchronizedXxx等工厂方法创建</p>\n<p>同步容器类实现线程安全的方式：将他们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能访问容器状态，即<strong>串行化容器的访问</strong>。</p>\n<p>同步容器类支持客户端加锁，因此可能会创建一些新的操作，同步容器类通过其自身的锁来保护他的每个方法。</p>\n<a id=\"more\"></a> \n<p><strong>及时失败</strong>：同步容器类的迭代器的并发修改问题，当容器在迭代过程中被修改时，会抛出ConcurrentModificationException异常。</p>\n<blockquote>\n<p>在迭代期间对容器加锁可以解决及时失败问题，但是长时间对容器加锁会降低程序的可伸缩性，持有锁时间越长，在锁上的竞争就越激烈，降低吞吐量和cpu利用率。</p>\n</blockquote>\n<blockquote>\n<p>另一种方式是“克隆容器”，并在副本上进行迭代，但这样存在明显的性能开销</p>\n</blockquote>\n<p>容器的隐藏迭代：容器的toString(), hashCode(), equals()，removeAll(), retainsAll()等方法都会间接迭代容器，可能会发生ConcurrentModificationException异常。</p>\n<h4 id=\"二、并发容器\"><a href=\"#二、并发容器\" class=\"headerlink\" title=\"二、并发容器\"></a>二、并发容器</h4><p>同步容器串行化容器的访问，严重降低并发性，当多个线程竞争容器锁时，吞吐量严重降低。</p>\n<p>并发容器是针对多个线程并发访问设计的。</p>\n<ul>\n<li><p>ConcurrentHashMap</p>\n<p>ConcurrentHashMap类似HashMap，也是基于散列的Map，它使用一种更细粒度的加锁机制——<strong>分段锁</strong>（Lock Striping）来实现更大程度的共享。任意数量的读取线程可以并发的访问Map，一定数量的写入线程可以并发修改Map，读写线程可以并发的访问Map。</p>\n<blockquote>\n<p>ConcurrentHashMap不会抛出ConcurrentModificationException异常</p>\n</blockquote>\n<p>ConcurrentHashMap返回的迭代器具有弱一致性，可以容忍并发的修改，因此size(),isEmpty()等方法会返回近似值而不是精确值。</p>\n<p>ConcurrentHashMap没有实现对Map加锁以提供独占访问，提高了代码的伸缩性，只有在需要独占访问Map时才不使用ConcurrentHashMap。</p>\n<p>ConcurrentHashMap不能使用客户端加锁来创建新的原子操作。</p>\n</li>\n<li><p>CopyOnWriteArrayList</p>\n<p>CopyOnWriteArrayList用于替代同步List，CopyOnWriteArraySet替代同步Set，提供了更好的并发性且不需要在迭代期间对容器加锁。</p>\n<p>Copy-On-Write写入时复制：只要正确发布一个事实不可变的对象，那么访问该对象时就不需要再进一步的同步，每次修改时都会创建并重新发布一个新的容器副本，从而实现可变性。“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此多个线程可以同时对这个容器进行迭代，而不会彼此干扰活与修改容器的线程相互干扰。</p>\n<blockquote>\n<p>每次修改容器时都会复制底层数组，需要一定开销。当迭代操作远多于修改操作时，才应该使用“写入时复制”</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"三、阻塞队列和生产者-消费者模式\"><a href=\"#三、阻塞队列和生产者-消费者模式\" class=\"headerlink\" title=\"三、阻塞队列和生产者-消费者模式\"></a>三、阻塞队列和生产者-消费者模式</h4><p>  BlockingQueue提供了可阻塞的put和take方法，支持定时的poll和offer方法，若对列已满，put方法将阻塞直到有空间可用；若对列为空，take方法将阻塞直到有元素可用。队列可有界也可以无界，无界对列的take方法永远不会阻塞。</p>\n<p>  阻塞队列简化了生产者-消费者设计模式，支持任意数量的生产者与消费者。</p>\n<p>  offer方法：如果数据不能被添加到队列，将返回一个失败状态。</p>\n<p>  BlockingQueue的实现：</p>\n<ul>\n<li><p>LinkedBlockingQueue</p>\n</li>\n<li><p>ArrayBlockingQueue</p>\n<p>——————-以上两者为FIFO队列—————–</p>\n</li>\n<li><p>PriorityBlockingQueue是一个按照优先级排序的队列，既可以根据自然顺序来比较元素，也可以使用Comparator来比较</p>\n</li>\n<li><p>SynchronousQueue:实际上不是一个真正的队列，因为它不会为队列中的元素维护存储空间，它维护一组线程，这些线程在等待元素加入或移出队列。类似于洗碗没有盘架，洗完直接放到烘干机，SynchronousQueue的put和take会一直阻塞，直到有另一个线程已准备好参与到交付过程。仅当有足够多的消费者，并且总有一个消费者主备好交付的工作时，才使用同步队列。</p>\n<p>生产者——消费者模式的性能优势：生产者和消费者可以并发执行，如果一个是I/O密集型，一个是CPU密集型，那么并发执行的吞吐率高于串行的吞吐率。如果两者并行度不同，那么将他们紧密耦合会把整体并行度降低为二者中更小的并行度</p>\n</li>\n<li><p>串行线程封闭</p>\n<p>阻塞队列可以安全的将对象从生产者线程发布到消费者线程，线程封闭对象只能由单个线程拥有，但可以通过安全的发布对象来”转移”所有权.</p>\n</li>\n<li><p>双端队列与工作密取</p>\n<p>Deque和BlockingDeque分别扩展了Queue和BlockingQueue，Deque是一个双端队列，实现在队列头和队列尾高效插入和移出。具体实现包括ArrayDeque和LinkedBlockingDeque。</p>\n<p>双端队列适用于工作密取模式（Work Stealing）：每个消费者都有自己的双端队列，如果一个消费者完成了自己双端队列中的全部工作，它可以从其他消费者的双端队列<strong>末尾</strong>秘密的获取工作。这样有更高的伸缩性，从其他消费者尾部获取工作降低了竞争程度，适用于即是消费者又是生产者问题</p>\n</li>\n</ul>\n<h4 id=\"四、阻塞方法与中断方法\"><a href=\"#四、阻塞方法与中断方法\" class=\"headerlink\" title=\"四、阻塞方法与中断方法\"></a>四、阻塞方法与中断方法</h4><p>导致线程阻塞或暂停的原因：</p>\n<ul>\n<li>等待I/O操作结束</li>\n<li>等待获得一个锁</li>\n<li>等待从Thread.sleep方法中醒来</li>\n<li>等待另一个线程的计算结果</li>\n</ul>\n<p>线程阻塞后一般会被挂起，并处于某种阻塞状态（BLOCKED,WATING,TIMED_WATING）。</p>\n<p>阻塞线程与执行时间很长的操作的差别：被阻塞线程必须等待不受它控制的事件发生后才能继续执行。当某个外部事件发生时，线程状态被设置为RUNNABLE状态，并可以被再次调度执行。</p>\n<p>当某方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这方法被中断，那么他将努力提前结束阻塞状态。</p>\n<p>Thread提供了Interrupt方法，用于中断线程或查询线程是否已被中断，每个线程都有一个bool类型的属性，表示线程的中断状态，当线程中断时设置这个状态。</p>\n<p>中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——前提是B愿意停下来。</p>\n<p>处理对中断的响应：</p>\n<ul>\n<li>传递InterruptedException：避开这个异常通常是最明智的策略，将InterruptedException传给方法的调用者</li>\n<li>恢复中断：捕获InterruptedException，并通过调用当前线程上的interrupt方法恢复中断状态</li>\n</ul>\n<h4 id=\"五、-同步工具类\"><a href=\"#五、-同步工具类\" class=\"headerlink\" title=\"五、 同步工具类\"></a>五、 同步工具类</h4><p>阻塞队列不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，直到队列达到期望的状态。</p>\n<p>同步工具类可以是任意对象，只要它根据自身情况状态来协调线程的控制流。<br>同步工具类包括：</p>\n<ol>\n<li>阻塞队列</li>\n<li>信号量（Semaphore）</li>\n<li>栅栏（Barrier）</li>\n<li>闭锁（Latch）</li>\n</ol>\n<ul>\n<li><p>闭锁</p>\n<p>闭锁可以延迟线程的进度直到其到达终止状态。相当于一扇门，在闭锁到达结束状态之前，门一直关闭，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再改变状态。闭锁可以确保某些活动直到其他活动都完成后才继续执行。</p>\n<p>CountDownLatch是闭锁的一种实现，可以使一个或多个事件等待一组事件发生。闭锁状态包含一个计数器，初始化为一个正数，表示需要等待的事件的数量，countDown方法递减计数器，表示有一个事件已经发生，await方法等待计数器达到零，表示等待的事件均已发生。若计数器非零，await方法会一直阻塞到计数器为零，或者等待中的线程中断，或者等待超时。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHarness</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">timeTasks</span> <span class=\"params\">(<span class=\"keyword\">int</span> nThreads, <span class=\"keyword\">final</span> Runnable task)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CountDownLatch startGate = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CountDownLatch endGate = <span class=\"keyword\">new</span> CountDownLatch(nThreads);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;nThreads; i++) &#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    startGate.await();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        endGate.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start =System.nanoTime();</span><br><span class=\"line\">    startGate.countDown();</span><br><span class=\"line\">    endGate.await();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.nanoTime();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end - start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>FutureTask</p>\n</li>\n</ul>\n<p>FutureTask也可以用作闭锁，表示的计算是通过Callable实现的，相当于一种可生成结果的Runnable，有三种状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.等待运行——waiting to run</span><br><span class=\"line\"></span><br><span class=\"line\">2.正在运行——running</span><br><span class=\"line\"></span><br><span class=\"line\">3.运行完成——completed</span><br></pre></td></tr></table></figure>\n<p>当FutureTask进入完成状态后，会永远停止在这个状态上。<br>Future.get的行为取决于任务的状态，若已完成，会立即返回结果，否则会阻塞直到任务进入完成状态。FutureTask将计算结果从计算线程传递到获取结果的线程，而FutureTask能确保传递过程能实现结果的安全发布。</p>\n<p>FutureTask在Executor框架中表示异步任务，还可以用来表示一些时间较长的计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preloader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FutureTask&lt;ProductInfo&gt; future =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> FutureTask&lt;ProductInfo&gt;(<span class=\"keyword\">new</span> Callable&lt;ProductInfo&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> ProductInfo <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> loadProductInfo();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Thread thread = <span class=\"keyword\">new</span> Thread(future);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProductInfo <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> future.get();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            Throwable cause = e.getCause();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cause <span class=\"keyword\">instanceof</span>  DataLoadException)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> (DataLoadException) cause;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">                <span class=\"keyword\">throw</span> launderthrowable(cause);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Callable表示的任务可以抛出受检查的或者未受检查的异常，并且任何代码都可能抛出一个Error，无论代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get中被重新排出。</p>\n<ul>\n<li><p>信号量 Semaphore</p>\n<p>计数信号量用来控制访问某个特定资源的操作数量或者同时执行某个指定操作的数量</p>\n<p>信号量管理着一组虚拟的许可(permit)，许可的数量可通过构造函数指定，在执行操作时可以首先获得许可，并在以后释放许可即可。若没有许可，那么acquire将阻塞直到有许可（或者直到被中断获操作超时）。release方法将返回一个许可给信号量。</p>\n<p><strong>二值信号量</strong>计算信号量的简化形式，初始值为1，二值信号量可以作为互斥体（mutex），并具备不可重入锁语义：谁唯一拥有了这个锁，谁就拥有了互斥锁。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: BoundedHashSet</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 使用Semaphore为容器设置边界</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/23下午1:59</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedHashSet</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;T&gt; set;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore sem;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BoundedHashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> bound)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.set = Collections.synchronizedSet(<span class=\"keyword\">new</span> HashSet&lt;T&gt;());</span><br><span class=\"line\">        sem = <span class=\"keyword\">new</span> Semaphore(bound);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(T o)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        sem.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> wasAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            wasAdded = set.add(o);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> wasAdded;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!wasAdded) &#123;</span><br><span class=\"line\">                sem.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> wasRemoved = set.remove(obj);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wasRemoved) &#123;</span><br><span class=\"line\">            sem.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wasRemoved;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>栅栏Barrier</p>\n<p>闭锁是一次性对象，一旦进入终止状态，就不能被重置。</p>\n<p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于：所有线程必须<strong>同时到达</strong>栅栏位置，才能继续执行。闭锁用来等待事件，而栅栏用于等待其他线程。</p>\n<p>CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集，在并行迭代算法中非常有用：这类算法通常将一个问题拆分成一系列相互独立的子问题。</p>\n<p>当线程到达栅栏位置时将调用await方法，这方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，所有线程都被释放，栅栏将被重置以便下次使用。如果对await的调用超时，或者await的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。若成功通过栅栏，那么await将为每个线程返回一个唯一的到达索引号。</p>\n<p>CyclicBarrier还可以将一个栅栏操作传递给构造函数，它是一个Runnable函数，当成功通过栅栏时会在一个子任务线程中执行它，但在阻塞线程被释放之前是不能执行的。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//通过cyclicbarrier协调细胞自动衍生系统中的运算</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CellularAotumata</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Board mainboard;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CyclicBarrier barrier;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Worker[] workers;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CellularAotumata</span><span class=\"params\">(Board mainboard)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mainboard = mainboard;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.barrier = <span class=\"keyword\">new</span> CyclicBarrier(count,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        mainboard.commitNewValues();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.workers = <span class=\"keyword\">new</span> Worker[count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;count; i++) </span><br><span class=\"line\">            workers[i] = <span class=\"keyword\">new</span> Worker(mainboard.getSubBoard(count, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Board board;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Worker</span><span class=\"params\">(Board board)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.board = board;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!board.hasConverged()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.getMaxX(); i++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; i &lt; board.getMaxY(); j++) &#123;</span><br><span class=\"line\">                        board.setNewValue(x,y, compute(x,y));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    barrier.await();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; workers.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(workers[i]).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mainboard.waitForConvergence();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一种形式的栅栏是Exchanger，是一种两方栅栏，各方在栅栏上交换数据，当两方执行不对称操作时，Exchanger非常有用。</span><br></pre></td></tr></table></figure>\n<h4 id=\"六、构建高效可伸缩结果缓存\"><a href=\"#六、构建高效可伸缩结果缓存\" class=\"headerlink\" title=\"六、构建高效可伸缩结果缓存\"></a>六、构建高效可伸缩结果缓存</h4><p>几乎所有服务器应用程序都会使用某种形式的缓存，重用之前的结果能降低延迟，提高吞吐量，但需要消耗更多的内存。</p>\n<p>程序清单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>:  构建可伸缩缓存</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/23下午3:47</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpensiveFunction</span> <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">BigInteger</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BigInteger <span class=\"title\">compute</span><span class=\"params\">(String arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//再经过长时间计算后</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BigInteger(arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用HashMap和同步机制来初始化缓存</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer1</span> &lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A,V&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;A,V&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer1</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        V result = cache.get(arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            result = c.compute(arg);</span><br><span class=\"line\">            cache.put(arg, result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用ConcurrentHashMap代替HashMap</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer2</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A, V&gt; cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;A, V&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer2</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        V result = cache.get(arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            result = c.compute(arg);</span><br><span class=\"line\">            cache.put(arg, result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//基于FutureTask的Memorizing封装器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer3</span>&lt;<span class=\"title\">A</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer3</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; eval = <span class=\"keyword\">new</span> Callable&lt;V&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> c.compute(arg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            FutureTask&lt;V&gt; ft = <span class=\"keyword\">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class=\"line\">            f = ft;</span><br><span class=\"line\">            cache.put(arg, ft);</span><br><span class=\"line\">            ft.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> f.get();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> launderthrowable(e.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Callable&lt;V&gt; eval = <span class=\"keyword\">new</span> Callable&lt;V&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> c.compute(arg);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                FutureTask&lt;V&gt; ft = <span class=\"keyword\">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class=\"line\">                f = cache.putIfAbsent(arg, ft);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    f = ft;</span><br><span class=\"line\">                    ft.run();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> f.get();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (CancellationException e) &#123;</span><br><span class=\"line\">                cache.remove(arg,f);</span><br><span class=\"line\">            &#125; cache (ExecutionException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> launderThrowable(e.getCause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Memorizer1使用HashMap和同步机制来保存之前的计算结果，HashMap非线程安全，于是对整个compute方法同步，这样可能用的时间比没有缓存用的更长，效果不好。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-23/48498421.jpg\" alt=\"\"></p>\n<p>Memorizer2用ConcurrentHashMap代替HashMap，多线程可以并发的使用它，但是当两个线程同时调用compute时存在一个漏洞，可能会导致重复计算，与我们缓存的初衷违背。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-23/98285594.jpg\" alt=\"\"></p>\n<p>Memorizer3使用ConcurrentHashMap&lt;A,Future<v>&gt;，先检查某个相应的计算是否已经开始，若还未启动，就创建一个FutureTask，并注册到Map中，然后启动计算，若已启动，的等待现有的计算结果。但是有一个漏洞，仍然可能出现两个线程计算出相同的值，因为compute方法中的if代码块仍然是非原子的“先检查、再执行”操作。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-23/36335384.jpg\" alt=\"\"></v></p>\n<p>Memorizer是缓存的最终实现，当缓存的是Future而不是值时，将导致缓存污染问题：如果某个计算被取消或失败，那么在计算这个结果时将指明计算过程被取消或者失败。为避免这种情况，如果Memorizer发现计算被取消，那么将把Future从缓存中移出，如果监测到RuntimeException，也会移出Future。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"一、同步容器类\"><a href=\"#一、同步容器类\" class=\"headerlink\" title=\"一、同步容器类\"></a>一、同步容器类</h4><p>同步容器类包括Vector和HashTable，其封装器类由Collections.synchronizedXxx等工厂方法创建</p>\n<p>同步容器类实现线程安全的方式：将他们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能访问容器状态，即<strong>串行化容器的访问</strong>。</p>\n<p>同步容器类支持客户端加锁，因此可能会创建一些新的操作，同步容器类通过其自身的锁来保护他的每个方法。</p>","more":"<p><strong>及时失败</strong>：同步容器类的迭代器的并发修改问题，当容器在迭代过程中被修改时，会抛出ConcurrentModificationException异常。</p>\n<blockquote>\n<p>在迭代期间对容器加锁可以解决及时失败问题，但是长时间对容器加锁会降低程序的可伸缩性，持有锁时间越长，在锁上的竞争就越激烈，降低吞吐量和cpu利用率。</p>\n</blockquote>\n<blockquote>\n<p>另一种方式是“克隆容器”，并在副本上进行迭代，但这样存在明显的性能开销</p>\n</blockquote>\n<p>容器的隐藏迭代：容器的toString(), hashCode(), equals()，removeAll(), retainsAll()等方法都会间接迭代容器，可能会发生ConcurrentModificationException异常。</p>\n<h4 id=\"二、并发容器\"><a href=\"#二、并发容器\" class=\"headerlink\" title=\"二、并发容器\"></a>二、并发容器</h4><p>同步容器串行化容器的访问，严重降低并发性，当多个线程竞争容器锁时，吞吐量严重降低。</p>\n<p>并发容器是针对多个线程并发访问设计的。</p>\n<ul>\n<li><p>ConcurrentHashMap</p>\n<p>ConcurrentHashMap类似HashMap，也是基于散列的Map，它使用一种更细粒度的加锁机制——<strong>分段锁</strong>（Lock Striping）来实现更大程度的共享。任意数量的读取线程可以并发的访问Map，一定数量的写入线程可以并发修改Map，读写线程可以并发的访问Map。</p>\n<blockquote>\n<p>ConcurrentHashMap不会抛出ConcurrentModificationException异常</p>\n</blockquote>\n<p>ConcurrentHashMap返回的迭代器具有弱一致性，可以容忍并发的修改，因此size(),isEmpty()等方法会返回近似值而不是精确值。</p>\n<p>ConcurrentHashMap没有实现对Map加锁以提供独占访问，提高了代码的伸缩性，只有在需要独占访问Map时才不使用ConcurrentHashMap。</p>\n<p>ConcurrentHashMap不能使用客户端加锁来创建新的原子操作。</p>\n</li>\n<li><p>CopyOnWriteArrayList</p>\n<p>CopyOnWriteArrayList用于替代同步List，CopyOnWriteArraySet替代同步Set，提供了更好的并发性且不需要在迭代期间对容器加锁。</p>\n<p>Copy-On-Write写入时复制：只要正确发布一个事实不可变的对象，那么访问该对象时就不需要再进一步的同步，每次修改时都会创建并重新发布一个新的容器副本，从而实现可变性。“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此多个线程可以同时对这个容器进行迭代，而不会彼此干扰活与修改容器的线程相互干扰。</p>\n<blockquote>\n<p>每次修改容器时都会复制底层数组，需要一定开销。当迭代操作远多于修改操作时，才应该使用“写入时复制”</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"三、阻塞队列和生产者-消费者模式\"><a href=\"#三、阻塞队列和生产者-消费者模式\" class=\"headerlink\" title=\"三、阻塞队列和生产者-消费者模式\"></a>三、阻塞队列和生产者-消费者模式</h4><p>  BlockingQueue提供了可阻塞的put和take方法，支持定时的poll和offer方法，若对列已满，put方法将阻塞直到有空间可用；若对列为空，take方法将阻塞直到有元素可用。队列可有界也可以无界，无界对列的take方法永远不会阻塞。</p>\n<p>  阻塞队列简化了生产者-消费者设计模式，支持任意数量的生产者与消费者。</p>\n<p>  offer方法：如果数据不能被添加到队列，将返回一个失败状态。</p>\n<p>  BlockingQueue的实现：</p>\n<ul>\n<li><p>LinkedBlockingQueue</p>\n</li>\n<li><p>ArrayBlockingQueue</p>\n<p>——————-以上两者为FIFO队列—————–</p>\n</li>\n<li><p>PriorityBlockingQueue是一个按照优先级排序的队列，既可以根据自然顺序来比较元素，也可以使用Comparator来比较</p>\n</li>\n<li><p>SynchronousQueue:实际上不是一个真正的队列，因为它不会为队列中的元素维护存储空间，它维护一组线程，这些线程在等待元素加入或移出队列。类似于洗碗没有盘架，洗完直接放到烘干机，SynchronousQueue的put和take会一直阻塞，直到有另一个线程已准备好参与到交付过程。仅当有足够多的消费者，并且总有一个消费者主备好交付的工作时，才使用同步队列。</p>\n<p>生产者——消费者模式的性能优势：生产者和消费者可以并发执行，如果一个是I/O密集型，一个是CPU密集型，那么并发执行的吞吐率高于串行的吞吐率。如果两者并行度不同，那么将他们紧密耦合会把整体并行度降低为二者中更小的并行度</p>\n</li>\n<li><p>串行线程封闭</p>\n<p>阻塞队列可以安全的将对象从生产者线程发布到消费者线程，线程封闭对象只能由单个线程拥有，但可以通过安全的发布对象来”转移”所有权.</p>\n</li>\n<li><p>双端队列与工作密取</p>\n<p>Deque和BlockingDeque分别扩展了Queue和BlockingQueue，Deque是一个双端队列，实现在队列头和队列尾高效插入和移出。具体实现包括ArrayDeque和LinkedBlockingDeque。</p>\n<p>双端队列适用于工作密取模式（Work Stealing）：每个消费者都有自己的双端队列，如果一个消费者完成了自己双端队列中的全部工作，它可以从其他消费者的双端队列<strong>末尾</strong>秘密的获取工作。这样有更高的伸缩性，从其他消费者尾部获取工作降低了竞争程度，适用于即是消费者又是生产者问题</p>\n</li>\n</ul>\n<h4 id=\"四、阻塞方法与中断方法\"><a href=\"#四、阻塞方法与中断方法\" class=\"headerlink\" title=\"四、阻塞方法与中断方法\"></a>四、阻塞方法与中断方法</h4><p>导致线程阻塞或暂停的原因：</p>\n<ul>\n<li>等待I/O操作结束</li>\n<li>等待获得一个锁</li>\n<li>等待从Thread.sleep方法中醒来</li>\n<li>等待另一个线程的计算结果</li>\n</ul>\n<p>线程阻塞后一般会被挂起，并处于某种阻塞状态（BLOCKED,WATING,TIMED_WATING）。</p>\n<p>阻塞线程与执行时间很长的操作的差别：被阻塞线程必须等待不受它控制的事件发生后才能继续执行。当某个外部事件发生时，线程状态被设置为RUNNABLE状态，并可以被再次调度执行。</p>\n<p>当某方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这方法被中断，那么他将努力提前结束阻塞状态。</p>\n<p>Thread提供了Interrupt方法，用于中断线程或查询线程是否已被中断，每个线程都有一个bool类型的属性，表示线程的中断状态，当线程中断时设置这个状态。</p>\n<p>中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——前提是B愿意停下来。</p>\n<p>处理对中断的响应：</p>\n<ul>\n<li>传递InterruptedException：避开这个异常通常是最明智的策略，将InterruptedException传给方法的调用者</li>\n<li>恢复中断：捕获InterruptedException，并通过调用当前线程上的interrupt方法恢复中断状态</li>\n</ul>\n<h4 id=\"五、-同步工具类\"><a href=\"#五、-同步工具类\" class=\"headerlink\" title=\"五、 同步工具类\"></a>五、 同步工具类</h4><p>阻塞队列不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，直到队列达到期望的状态。</p>\n<p>同步工具类可以是任意对象，只要它根据自身情况状态来协调线程的控制流。<br>同步工具类包括：</p>\n<ol>\n<li>阻塞队列</li>\n<li>信号量（Semaphore）</li>\n<li>栅栏（Barrier）</li>\n<li>闭锁（Latch）</li>\n</ol>\n<ul>\n<li><p>闭锁</p>\n<p>闭锁可以延迟线程的进度直到其到达终止状态。相当于一扇门，在闭锁到达结束状态之前，门一直关闭，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再改变状态。闭锁可以确保某些活动直到其他活动都完成后才继续执行。</p>\n<p>CountDownLatch是闭锁的一种实现，可以使一个或多个事件等待一组事件发生。闭锁状态包含一个计数器，初始化为一个正数，表示需要等待的事件的数量，countDown方法递减计数器，表示有一个事件已经发生，await方法等待计数器达到零，表示等待的事件均已发生。若计数器非零，await方法会一直阻塞到计数器为零，或者等待中的线程中断，或者等待超时。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHarness</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">timeTasks</span> <span class=\"params\">(<span class=\"keyword\">int</span> nThreads, <span class=\"keyword\">final</span> Runnable task)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CountDownLatch startGate = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CountDownLatch endGate = <span class=\"keyword\">new</span> CountDownLatch(nThreads);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;nThreads; i++) &#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    startGate.await();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        endGate.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start =System.nanoTime();</span><br><span class=\"line\">    startGate.countDown();</span><br><span class=\"line\">    endGate.await();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.nanoTime();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> end - start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>FutureTask</p>\n</li>\n</ul>\n<p>FutureTask也可以用作闭锁，表示的计算是通过Callable实现的，相当于一种可生成结果的Runnable，有三种状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.等待运行——waiting to run</span><br><span class=\"line\"></span><br><span class=\"line\">2.正在运行——running</span><br><span class=\"line\"></span><br><span class=\"line\">3.运行完成——completed</span><br></pre></td></tr></table></figure>\n<p>当FutureTask进入完成状态后，会永远停止在这个状态上。<br>Future.get的行为取决于任务的状态，若已完成，会立即返回结果，否则会阻塞直到任务进入完成状态。FutureTask将计算结果从计算线程传递到获取结果的线程，而FutureTask能确保传递过程能实现结果的安全发布。</p>\n<p>FutureTask在Executor框架中表示异步任务，还可以用来表示一些时间较长的计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preloader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FutureTask&lt;ProductInfo&gt; future =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> FutureTask&lt;ProductInfo&gt;(<span class=\"keyword\">new</span> Callable&lt;ProductInfo&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> ProductInfo <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> loadProductInfo();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Thread thread = <span class=\"keyword\">new</span> Thread(future);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProductInfo <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> future.get();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            Throwable cause = e.getCause();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cause <span class=\"keyword\">instanceof</span>  DataLoadException)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> (DataLoadException) cause;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">                <span class=\"keyword\">throw</span> launderthrowable(cause);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Callable表示的任务可以抛出受检查的或者未受检查的异常，并且任何代码都可能抛出一个Error，无论代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get中被重新排出。</p>\n<ul>\n<li><p>信号量 Semaphore</p>\n<p>计数信号量用来控制访问某个特定资源的操作数量或者同时执行某个指定操作的数量</p>\n<p>信号量管理着一组虚拟的许可(permit)，许可的数量可通过构造函数指定，在执行操作时可以首先获得许可，并在以后释放许可即可。若没有许可，那么acquire将阻塞直到有许可（或者直到被中断获操作超时）。release方法将返回一个许可给信号量。</p>\n<p><strong>二值信号量</strong>计算信号量的简化形式，初始值为1，二值信号量可以作为互斥体（mutex），并具备不可重入锁语义：谁唯一拥有了这个锁，谁就拥有了互斥锁。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: BoundedHashSet</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 使用Semaphore为容器设置边界</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/23下午1:59</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedHashSet</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;T&gt; set;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore sem;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BoundedHashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> bound)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.set = Collections.synchronizedSet(<span class=\"keyword\">new</span> HashSet&lt;T&gt;());</span><br><span class=\"line\">        sem = <span class=\"keyword\">new</span> Semaphore(bound);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(T o)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        sem.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> wasAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            wasAdded = set.add(o);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> wasAdded;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!wasAdded) &#123;</span><br><span class=\"line\">                sem.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> wasRemoved = set.remove(obj);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wasRemoved) &#123;</span><br><span class=\"line\">            sem.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wasRemoved;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>栅栏Barrier</p>\n<p>闭锁是一次性对象，一旦进入终止状态，就不能被重置。</p>\n<p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于：所有线程必须<strong>同时到达</strong>栅栏位置，才能继续执行。闭锁用来等待事件，而栅栏用于等待其他线程。</p>\n<p>CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集，在并行迭代算法中非常有用：这类算法通常将一个问题拆分成一系列相互独立的子问题。</p>\n<p>当线程到达栅栏位置时将调用await方法，这方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，所有线程都被释放，栅栏将被重置以便下次使用。如果对await的调用超时，或者await的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。若成功通过栅栏，那么await将为每个线程返回一个唯一的到达索引号。</p>\n<p>CyclicBarrier还可以将一个栅栏操作传递给构造函数，它是一个Runnable函数，当成功通过栅栏时会在一个子任务线程中执行它，但在阻塞线程被释放之前是不能执行的。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//通过cyclicbarrier协调细胞自动衍生系统中的运算</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CellularAotumata</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Board mainboard;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CyclicBarrier barrier;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Worker[] workers;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CellularAotumata</span><span class=\"params\">(Board mainboard)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mainboard = mainboard;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.barrier = <span class=\"keyword\">new</span> CyclicBarrier(count,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        mainboard.commitNewValues();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.workers = <span class=\"keyword\">new</span> Worker[count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;count; i++) </span><br><span class=\"line\">            workers[i] = <span class=\"keyword\">new</span> Worker(mainboard.getSubBoard(count, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Board board;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Worker</span><span class=\"params\">(Board board)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.board = board;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!board.hasConverged()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.getMaxX(); i++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; i &lt; board.getMaxY(); j++) &#123;</span><br><span class=\"line\">                        board.setNewValue(x,y, compute(x,y));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    barrier.await();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; workers.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(workers[i]).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mainboard.waitForConvergence();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一种形式的栅栏是Exchanger，是一种两方栅栏，各方在栅栏上交换数据，当两方执行不对称操作时，Exchanger非常有用。</span><br></pre></td></tr></table></figure>\n<h4 id=\"六、构建高效可伸缩结果缓存\"><a href=\"#六、构建高效可伸缩结果缓存\" class=\"headerlink\" title=\"六、构建高效可伸缩结果缓存\"></a>六、构建高效可伸缩结果缓存</h4><p>几乎所有服务器应用程序都会使用某种形式的缓存，重用之前的结果能降低延迟，提高吞吐量，但需要消耗更多的内存。</p>\n<p>程序清单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>:  构建可伸缩缓存</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/23下午3:47</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpensiveFunction</span> <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">BigInteger</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BigInteger <span class=\"title\">compute</span><span class=\"params\">(String arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//再经过长时间计算后</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BigInteger(arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用HashMap和同步机制来初始化缓存</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer1</span> &lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A,V&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;A,V&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer1</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        V result = cache.get(arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            result = c.compute(arg);</span><br><span class=\"line\">            cache.put(arg, result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用ConcurrentHashMap代替HashMap</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer2</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A, V&gt; cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;A, V&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer2</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        V result = cache.get(arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            result = c.compute(arg);</span><br><span class=\"line\">            cache.put(arg, result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//基于FutureTask的Memorizing封装器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer3</span>&lt;<span class=\"title\">A</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer3</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; eval = <span class=\"keyword\">new</span> Callable&lt;V&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> c.compute(arg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            FutureTask&lt;V&gt; ft = <span class=\"keyword\">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class=\"line\">            f = ft;</span><br><span class=\"line\">            cache.put(arg, ft);</span><br><span class=\"line\">            ft.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> f.get();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> launderthrowable(e.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memorizer</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computerable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computerable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memorizer</span><span class=\"params\">(Computerable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Callable&lt;V&gt; eval = <span class=\"keyword\">new</span> Callable&lt;V&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> c.compute(arg);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                FutureTask&lt;V&gt; ft = <span class=\"keyword\">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class=\"line\">                f = cache.putIfAbsent(arg, ft);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    f = ft;</span><br><span class=\"line\">                    ft.run();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> f.get();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (CancellationException e) &#123;</span><br><span class=\"line\">                cache.remove(arg,f);</span><br><span class=\"line\">            &#125; cache (ExecutionException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> launderThrowable(e.getCause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Memorizer1使用HashMap和同步机制来保存之前的计算结果，HashMap非线程安全，于是对整个compute方法同步，这样可能用的时间比没有缓存用的更长，效果不好。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-23/48498421.jpg\" alt=\"\"></p>\n<p>Memorizer2用ConcurrentHashMap代替HashMap，多线程可以并发的使用它，但是当两个线程同时调用compute时存在一个漏洞，可能会导致重复计算，与我们缓存的初衷违背。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-23/98285594.jpg\" alt=\"\"></p>\n<p>Memorizer3使用ConcurrentHashMap&lt;A,Future<v>&gt;，先检查某个相应的计算是否已经开始，若还未启动，就创建一个FutureTask，并注册到Map中，然后启动计算，若已启动，的等待现有的计算结果。但是有一个漏洞，仍然可能出现两个线程计算出相同的值，因为compute方法中的if代码块仍然是非原子的“先检查、再执行”操作。<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-5-23/36335384.jpg\" alt=\"\"></v></p>\n<p>Memorizer是缓存的最终实现，当缓存的是Future而不是值时，将导致缓存污染问题：如果某个计算被取消或失败，那么在计算这个结果时将指明计算过程被取消或者失败。为避免这种情况，如果Memorizer发现计算被取消，那么将把Future从缓存中移出，如果监测到RuntimeException，也会移出Future。</p>"},{"title":"Java并发编程——线程池的使用","date":"2018-06-03T16:07:56.000Z","_content":"\n#### 一、在任务与执行策略之间的隐性耦合\nExecutor框架可以将任务的提交与任务的执行策略解耦开来，虽然Executor框架为制定和修改执行策略都提供了相当大的灵活性，但并非所有任务都适用于所有执行策略，有些类型的任务需要明确指定执行策略：\n* 依赖性任务： 在线程池中执行独立的任务时，可以随意的改变线程池的大小和配置，这只会影响其执行性能。但是若提交到线程池的任务依赖于其他的任务，那么就隐含的给执行策略带来了约束。\n<!-- more--> \n* 使用线程封闭机制的任务： 单线程的Executor能够对并发性做出更强的承诺，他们能保证任务不会并发的执行，对象可以封闭在任务线程中，使得在该线程中执行的任务在访问该对象时不需要同步。这种情形将在任务与执行策略之间形成隐式的耦合——任务要求其执行所在的Executor是单线程的。\n* 对响应时间敏感的任务：将一个耗时的任务提交到单线程Executor中或者将多个耗时任务提交到包含少量线程的线程池中，将降低服务的响应性。\n* 使用ThreadLocal的任务： 只要条件允许，Executor可以自由的重用其中的线程，当执行需求较低时将回收空闲线程，当需求增加时将添加新的线程，并且如果从任务中抛出一个未检查异常，那么将用一个新的工作者线程来替代抛出异常的线程。只有当线程本地值的生命周期受限于任务的生命周期时，在线程池中使用ThreadLocal才有意义。\n\n只有当任务都是同类型并且相互独立时，线程池的性能才能达到最佳，如果运行的任务耗时差别很大，那么除非线程池很大，否则将引起**“拥塞”**。如果提交的任务有依赖关系，那么除非线程池无限大，否则将引起**死锁**。\n\n**1.线程饥饿死锁**\n\n在线程池中，如果任务依赖于其他任务，那么可能产生死锁。\n线程饥饿死锁（Thread Starvation Deadlock）: 只要线程池中的任务需要无限期的等待一些必须由池中其他任务才能提供的资源或条件，那么除非线程池足够大，否则将发生线程饥饿死锁。\n> 如果线程池不够大，那么当多个任务通过栅栏机制彼此协调时，将导致线程饥饿死锁\n\n饥饿死锁示例：\n```java\n/**\n * @author harold\n * @Title:\n * @Description: 在单线程Executor中任务发生死锁\n * @date 2018/6/1下午6:19\n */\npublic class ThreadDeadlocl {\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    public class RenderpageTask implements Callable<String> {\n        @Override\n        public String call() throws Exception {\n            Future<String> header, footer;\n            header = executorService.submit(new loadFileTask(\"head.txt\"));\n            footer = executorService.submit(new loadFileTask(\"foot.txt\"));\n            //将发生死锁——由于任务在等待子任务完成\n            return header.get() + footer.get();\n        }\n    }\n    \n}\n```\n> 除了线程池大小的显示限制外，还可能由于其他资源上的约束而存在隐式限制，例如JDBC的连接池。\n\n**2.运行时间较长的任务**\n\n执行时间较长的任务不仅会造成线程池拥塞，甚至还会增加执行事件较短任务的服务时间。解决办法：限定等待资源的时间。在平台类库的大多数可阻塞方法中，都同时定义了限时版本和不限时版本，如Thread.join,BlockingQueue.put,CountDownLatch.await等。如果等待超市，那么可以把任务标识为失败，然后终止任务或者将任务重新放回队列以便随后执行。\n\n#### 二、设置线程池大小\n线程池的理想大小取决于被提交任务的类型以及所部属系统的特性，通常在代码中不会固定线程池大小，而应该通过某种配置机制来提供，或者根据Runtime。availableProcessors来动态配置。\n> 线程池过大：大量线程将在相对较少的cpu和内存资源上发生竞争，这会导致高内存使用量，还可能导致资源耗尽。\n\n> 线程池过小：许多空闲的处理器无法执行工作，从而降低吞吐率\n\n对于计算密集型的任务，在拥有N_cpu个处理器的系统上，当线程池大小为N_cpu+1时，通常能实现最优的利用率。\n\n#### 3.配置ThreadPollExetutor\n\nThreadPoolExecutor为一些Executor提供了基本的实现，这些Executor是有Executors中的newCachedThreadPool，newFixedThreadPool和newScheduledThreadPool等工厂方法返回的。ThreadPoolExecutor很灵活，允许各种定制。 \n\n**1.线程的创建与销毁**\n\n通用的ThreadPoolExecutor构造函数：\n```java\n/**\n     * Creates a new {@code ThreadPoolExecutor} with the given initial\n     * parameters.\n     *\n     * @param corePoolSize the number of threads to keep in the pool, even\n     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set\n     * @param maximumPoolSize the maximum number of threads to allow in the\n     *        pool\n     * @param keepAliveTime when the number of threads is greater than\n     *        the core, this is the maximum time that excess idle threads\n     *        will wait for new tasks before terminating.\n     * @param unit the time unit for the {@code keepAliveTime} argument\n     * @param workQueue the queue to use for holding tasks before they are\n     *        executed.  This queue will hold only the {@code Runnable}\n     *        tasks submitted by the {@code execute} method.\n     * @param threadFactory the factory to use when the executor\n     *        creates a new thread\n     * @param handler the handler to use when execution is blocked\n     *        because the thread bounds and queue capacities are reached\n     * @throws IllegalArgumentException if one of the following holds:<br>\n     *         {@code corePoolSize < 0}<br>\n     *         {@code keepAliveTime < 0}<br>\n     *         {@code maximumPoolSize <= 0}<br>\n     *         {@code maximumPoolSize < corePoolSize}\n     * @throws NullPointerException if {@code workQueue}\n     *         or {@code threadFactory} or {@code handler} is null\n     */\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) { ... }\n```\n各参数的详细解释参照代码中的注释即可。\n> newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n> newCachedThreadPool工厂方法将线程池的最大大小设置为Integer.MAX_VALUE,而将基本大小设置为0，并将超时设置为1分钟，这种方法创建出来的线程可以被无限扩展，并且在需求降低时自动收缩。\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n\n**2.管理任务队列**\n\n在线程池中，任务请求会在一个由Executor管理的Runnable队列中等待，而不是像线程那样去竞争cpu资源，通过一个Runnable和一个链表节点来表现一个等待中的任务，开销比用线程表示低很多，但如果客户端提交给服务器请求的速率超过了服务器的处理速率，那么仍可能会耗尽资源。\n\nThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务，基本任务队列有三种：\n* 无界队列：newFixedThreadPool和newSingleThreadExecutor默认使用LinkedBlockingQueue，如果所有工作者线程都忙碌，那么任务将在队列中等候，缺点是队列可能无限制增加，造成资源耗尽。\n* 有界队列：如ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽，但是如果队列满了，新来的任务的处理成为了问题，**饱和策略**可以解决此类问题。\n* 同步移交（SynchronousQueue）:直接将任务从公生产者移交给工作者线程，SynchronousQueue是一种线程之间的移交机制，要将一个元素放入SynchronousQueue，必须有另外一个线程正在等待接受这个元素。如果没有线程正在等待并且线程池当前大小小于最大值，SynchronousQueue将创建一个新线程，否则根据饱和策略，这个任务将被拒绝。newCachedThreadPool工厂方法中使用了SynchronousQueue。\n\n> 只有当任务相互独立时，为线程池工作队列设置界限才是合理的。若任务之间存在依赖关系，那么有界队列可能导致“饥饿”死锁问题，此时应该使用无界线程池，如newCachedThreadPool.\n\n**3.饱和策略**\n当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor饱和策略可以通过setRejectedExecutionHandler来修改。（若某个任务被提交到已经关闭的Executor，也会用到饱和策略）。\n\n* **中止（Abort）**：默认的饱和策略，该策略将会抛出未受检查的RejectedEcecutionExeption，调用者捕获后可以自行处理\n* **抛弃（Discard）**：该策略会悄悄抛弃该任务\n* **抛弃最旧的（Discard-Oldest）**：抛弃下一个将被执行的任务，然后尝试重新提交新任务。\n* **调用者运行（Caller-Runs）**：实现了一种调节机制，既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者，由调用者执行，从而降低新任务的流量。\n","source":"_posts/Java并发编程——线程池的使用.md","raw":"---\ntitle: Java并发编程——线程池的使用\ndate: 2018-06-04 00:07:56\ntags: [Java, 多线程, 并发]\n---\n\n#### 一、在任务与执行策略之间的隐性耦合\nExecutor框架可以将任务的提交与任务的执行策略解耦开来，虽然Executor框架为制定和修改执行策略都提供了相当大的灵活性，但并非所有任务都适用于所有执行策略，有些类型的任务需要明确指定执行策略：\n* 依赖性任务： 在线程池中执行独立的任务时，可以随意的改变线程池的大小和配置，这只会影响其执行性能。但是若提交到线程池的任务依赖于其他的任务，那么就隐含的给执行策略带来了约束。\n<!-- more--> \n* 使用线程封闭机制的任务： 单线程的Executor能够对并发性做出更强的承诺，他们能保证任务不会并发的执行，对象可以封闭在任务线程中，使得在该线程中执行的任务在访问该对象时不需要同步。这种情形将在任务与执行策略之间形成隐式的耦合——任务要求其执行所在的Executor是单线程的。\n* 对响应时间敏感的任务：将一个耗时的任务提交到单线程Executor中或者将多个耗时任务提交到包含少量线程的线程池中，将降低服务的响应性。\n* 使用ThreadLocal的任务： 只要条件允许，Executor可以自由的重用其中的线程，当执行需求较低时将回收空闲线程，当需求增加时将添加新的线程，并且如果从任务中抛出一个未检查异常，那么将用一个新的工作者线程来替代抛出异常的线程。只有当线程本地值的生命周期受限于任务的生命周期时，在线程池中使用ThreadLocal才有意义。\n\n只有当任务都是同类型并且相互独立时，线程池的性能才能达到最佳，如果运行的任务耗时差别很大，那么除非线程池很大，否则将引起**“拥塞”**。如果提交的任务有依赖关系，那么除非线程池无限大，否则将引起**死锁**。\n\n**1.线程饥饿死锁**\n\n在线程池中，如果任务依赖于其他任务，那么可能产生死锁。\n线程饥饿死锁（Thread Starvation Deadlock）: 只要线程池中的任务需要无限期的等待一些必须由池中其他任务才能提供的资源或条件，那么除非线程池足够大，否则将发生线程饥饿死锁。\n> 如果线程池不够大，那么当多个任务通过栅栏机制彼此协调时，将导致线程饥饿死锁\n\n饥饿死锁示例：\n```java\n/**\n * @author harold\n * @Title:\n * @Description: 在单线程Executor中任务发生死锁\n * @date 2018/6/1下午6:19\n */\npublic class ThreadDeadlocl {\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    public class RenderpageTask implements Callable<String> {\n        @Override\n        public String call() throws Exception {\n            Future<String> header, footer;\n            header = executorService.submit(new loadFileTask(\"head.txt\"));\n            footer = executorService.submit(new loadFileTask(\"foot.txt\"));\n            //将发生死锁——由于任务在等待子任务完成\n            return header.get() + footer.get();\n        }\n    }\n    \n}\n```\n> 除了线程池大小的显示限制外，还可能由于其他资源上的约束而存在隐式限制，例如JDBC的连接池。\n\n**2.运行时间较长的任务**\n\n执行时间较长的任务不仅会造成线程池拥塞，甚至还会增加执行事件较短任务的服务时间。解决办法：限定等待资源的时间。在平台类库的大多数可阻塞方法中，都同时定义了限时版本和不限时版本，如Thread.join,BlockingQueue.put,CountDownLatch.await等。如果等待超市，那么可以把任务标识为失败，然后终止任务或者将任务重新放回队列以便随后执行。\n\n#### 二、设置线程池大小\n线程池的理想大小取决于被提交任务的类型以及所部属系统的特性，通常在代码中不会固定线程池大小，而应该通过某种配置机制来提供，或者根据Runtime。availableProcessors来动态配置。\n> 线程池过大：大量线程将在相对较少的cpu和内存资源上发生竞争，这会导致高内存使用量，还可能导致资源耗尽。\n\n> 线程池过小：许多空闲的处理器无法执行工作，从而降低吞吐率\n\n对于计算密集型的任务，在拥有N_cpu个处理器的系统上，当线程池大小为N_cpu+1时，通常能实现最优的利用率。\n\n#### 3.配置ThreadPollExetutor\n\nThreadPoolExecutor为一些Executor提供了基本的实现，这些Executor是有Executors中的newCachedThreadPool，newFixedThreadPool和newScheduledThreadPool等工厂方法返回的。ThreadPoolExecutor很灵活，允许各种定制。 \n\n**1.线程的创建与销毁**\n\n通用的ThreadPoolExecutor构造函数：\n```java\n/**\n     * Creates a new {@code ThreadPoolExecutor} with the given initial\n     * parameters.\n     *\n     * @param corePoolSize the number of threads to keep in the pool, even\n     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set\n     * @param maximumPoolSize the maximum number of threads to allow in the\n     *        pool\n     * @param keepAliveTime when the number of threads is greater than\n     *        the core, this is the maximum time that excess idle threads\n     *        will wait for new tasks before terminating.\n     * @param unit the time unit for the {@code keepAliveTime} argument\n     * @param workQueue the queue to use for holding tasks before they are\n     *        executed.  This queue will hold only the {@code Runnable}\n     *        tasks submitted by the {@code execute} method.\n     * @param threadFactory the factory to use when the executor\n     *        creates a new thread\n     * @param handler the handler to use when execution is blocked\n     *        because the thread bounds and queue capacities are reached\n     * @throws IllegalArgumentException if one of the following holds:<br>\n     *         {@code corePoolSize < 0}<br>\n     *         {@code keepAliveTime < 0}<br>\n     *         {@code maximumPoolSize <= 0}<br>\n     *         {@code maximumPoolSize < corePoolSize}\n     * @throws NullPointerException if {@code workQueue}\n     *         or {@code threadFactory} or {@code handler} is null\n     */\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) { ... }\n```\n各参数的详细解释参照代码中的注释即可。\n> newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n> newCachedThreadPool工厂方法将线程池的最大大小设置为Integer.MAX_VALUE,而将基本大小设置为0，并将超时设置为1分钟，这种方法创建出来的线程可以被无限扩展，并且在需求降低时自动收缩。\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n\n**2.管理任务队列**\n\n在线程池中，任务请求会在一个由Executor管理的Runnable队列中等待，而不是像线程那样去竞争cpu资源，通过一个Runnable和一个链表节点来表现一个等待中的任务，开销比用线程表示低很多，但如果客户端提交给服务器请求的速率超过了服务器的处理速率，那么仍可能会耗尽资源。\n\nThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务，基本任务队列有三种：\n* 无界队列：newFixedThreadPool和newSingleThreadExecutor默认使用LinkedBlockingQueue，如果所有工作者线程都忙碌，那么任务将在队列中等候，缺点是队列可能无限制增加，造成资源耗尽。\n* 有界队列：如ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽，但是如果队列满了，新来的任务的处理成为了问题，**饱和策略**可以解决此类问题。\n* 同步移交（SynchronousQueue）:直接将任务从公生产者移交给工作者线程，SynchronousQueue是一种线程之间的移交机制，要将一个元素放入SynchronousQueue，必须有另外一个线程正在等待接受这个元素。如果没有线程正在等待并且线程池当前大小小于最大值，SynchronousQueue将创建一个新线程，否则根据饱和策略，这个任务将被拒绝。newCachedThreadPool工厂方法中使用了SynchronousQueue。\n\n> 只有当任务相互独立时，为线程池工作队列设置界限才是合理的。若任务之间存在依赖关系，那么有界队列可能导致“饥饿”死锁问题，此时应该使用无界线程池，如newCachedThreadPool.\n\n**3.饱和策略**\n当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor饱和策略可以通过setRejectedExecutionHandler来修改。（若某个任务被提交到已经关闭的Executor，也会用到饱和策略）。\n\n* **中止（Abort）**：默认的饱和策略，该策略将会抛出未受检查的RejectedEcecutionExeption，调用者捕获后可以自行处理\n* **抛弃（Discard）**：该策略会悄悄抛弃该任务\n* **抛弃最旧的（Discard-Oldest）**：抛弃下一个将被执行的任务，然后尝试重新提交新任务。\n* **调用者运行（Caller-Runs）**：实现了一种调节机制，既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者，由调用者执行，从而降低新任务的流量。\n","slug":"Java并发编程——线程池的使用","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6c0009cf968b2zqxpb","content":"<h4 id=\"一、在任务与执行策略之间的隐性耦合\"><a href=\"#一、在任务与执行策略之间的隐性耦合\" class=\"headerlink\" title=\"一、在任务与执行策略之间的隐性耦合\"></a>一、在任务与执行策略之间的隐性耦合</h4><p>Executor框架可以将任务的提交与任务的执行策略解耦开来，虽然Executor框架为制定和修改执行策略都提供了相当大的灵活性，但并非所有任务都适用于所有执行策略，有些类型的任务需要明确指定执行策略：</p>\n<ul>\n<li>依赖性任务： 在线程池中执行独立的任务时，可以随意的改变线程池的大小和配置，这只会影响其执行性能。但是若提交到线程池的任务依赖于其他的任务，那么就隐含的给执行策略带来了约束。<a id=\"more\"></a> </li>\n<li>使用线程封闭机制的任务： 单线程的Executor能够对并发性做出更强的承诺，他们能保证任务不会并发的执行，对象可以封闭在任务线程中，使得在该线程中执行的任务在访问该对象时不需要同步。这种情形将在任务与执行策略之间形成隐式的耦合——任务要求其执行所在的Executor是单线程的。</li>\n<li>对响应时间敏感的任务：将一个耗时的任务提交到单线程Executor中或者将多个耗时任务提交到包含少量线程的线程池中，将降低服务的响应性。</li>\n<li>使用ThreadLocal的任务： 只要条件允许，Executor可以自由的重用其中的线程，当执行需求较低时将回收空闲线程，当需求增加时将添加新的线程，并且如果从任务中抛出一个未检查异常，那么将用一个新的工作者线程来替代抛出异常的线程。只有当线程本地值的生命周期受限于任务的生命周期时，在线程池中使用ThreadLocal才有意义。</li>\n</ul>\n<p>只有当任务都是同类型并且相互独立时，线程池的性能才能达到最佳，如果运行的任务耗时差别很大，那么除非线程池很大，否则将引起<strong>“拥塞”</strong>。如果提交的任务有依赖关系，那么除非线程池无限大，否则将引起<strong>死锁</strong>。</p>\n<p><strong>1.线程饥饿死锁</strong></p>\n<p>在线程池中，如果任务依赖于其他任务，那么可能产生死锁。<br>线程饥饿死锁（Thread Starvation Deadlock）: 只要线程池中的任务需要无限期的等待一些必须由池中其他任务才能提供的资源或条件，那么除非线程池足够大，否则将发生线程饥饿死锁。</p>\n<blockquote>\n<p>如果线程池不够大，那么当多个任务通过栅栏机制彼此协调时，将导致线程饥饿死锁</p>\n</blockquote>\n<p>饥饿死锁示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 在单线程Executor中任务发生死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/1下午6:19</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDeadlocl</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RenderpageTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            Future&lt;String&gt; header, footer;</span><br><span class=\"line\">            header = executorService.submit(<span class=\"keyword\">new</span> loadFileTask(<span class=\"string\">\"head.txt\"</span>));</span><br><span class=\"line\">            footer = executorService.submit(<span class=\"keyword\">new</span> loadFileTask(<span class=\"string\">\"foot.txt\"</span>));</span><br><span class=\"line\">            <span class=\"comment\">//将发生死锁——由于任务在等待子任务完成</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> header.get() + footer.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>除了线程池大小的显示限制外，还可能由于其他资源上的约束而存在隐式限制，例如JDBC的连接池。</p>\n</blockquote>\n<p><strong>2.运行时间较长的任务</strong></p>\n<p>执行时间较长的任务不仅会造成线程池拥塞，甚至还会增加执行事件较短任务的服务时间。解决办法：限定等待资源的时间。在平台类库的大多数可阻塞方法中，都同时定义了限时版本和不限时版本，如Thread.join,BlockingQueue.put,CountDownLatch.await等。如果等待超市，那么可以把任务标识为失败，然后终止任务或者将任务重新放回队列以便随后执行。</p>\n<h4 id=\"二、设置线程池大小\"><a href=\"#二、设置线程池大小\" class=\"headerlink\" title=\"二、设置线程池大小\"></a>二、设置线程池大小</h4><p>线程池的理想大小取决于被提交任务的类型以及所部属系统的特性，通常在代码中不会固定线程池大小，而应该通过某种配置机制来提供，或者根据Runtime。availableProcessors来动态配置。</p>\n<blockquote>\n<p>线程池过大：大量线程将在相对较少的cpu和内存资源上发生竞争，这会导致高内存使用量，还可能导致资源耗尽。</p>\n</blockquote>\n<blockquote>\n<p>线程池过小：许多空闲的处理器无法执行工作，从而降低吞吐率</p>\n</blockquote>\n<p>对于计算密集型的任务，在拥有N_cpu个处理器的系统上，当线程池大小为N_cpu+1时，通常能实现最优的利用率。</p>\n<h4 id=\"3-配置ThreadPollExetutor\"><a href=\"#3-配置ThreadPollExetutor\" class=\"headerlink\" title=\"3.配置ThreadPollExetutor\"></a>3.配置ThreadPollExetutor</h4><p>ThreadPoolExecutor为一些Executor提供了基本的实现，这些Executor是有Executors中的newCachedThreadPool，newFixedThreadPool和newScheduledThreadPool等工厂方法返回的。ThreadPoolExecutor很灵活，允许各种定制。 </p>\n<p><strong>1.线程的创建与销毁</strong></p>\n<p>通用的ThreadPoolExecutor构造函数：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a new &#123;<span class=\"doctag\">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class=\"line\"><span class=\"comment\">     * parameters.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class=\"line\"><span class=\"comment\">     *        if they are idle, unless &#123;<span class=\"doctag\">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class=\"line\"><span class=\"comment\">     *        pool</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class=\"line\"><span class=\"comment\">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class=\"line\"><span class=\"comment\">     *        will wait for new tasks before terminating.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit the time unit for the &#123;<span class=\"doctag\">@code</span> keepAliveTime&#125; argument</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class=\"line\"><span class=\"comment\">     *        executed.  This queue will hold only the &#123;<span class=\"doctag\">@code</span> Runnable&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     *        tasks submitted by the &#123;<span class=\"doctag\">@code</span> execute&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> threadFactory the factory to use when the executor</span></span><br><span class=\"line\"><span class=\"comment\">     *        creates a new thread</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> handler the handler to use when execution is blocked</span></span><br><span class=\"line\"><span class=\"comment\">     *        because the thread bounds and queue capacities are reached</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> NullPointerException if &#123;<span class=\"doctag\">@code</span> workQueue&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     *         or &#123;<span class=\"doctag\">@code</span> threadFactory&#125; or &#123;<span class=\"doctag\">@code</span> handler&#125; is null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              RejectedExecutionHandler handler)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>\n<p>各参数的详细解释参照代码中的注释即可。</p>\n<blockquote>\n<p>newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                      <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>newCachedThreadPool工厂方法将线程池的最大大小设置为Integer.MAX_VALUE,而将基本大小设置为0，并将超时设置为1分钟，这种方法创建出来的线程可以被无限扩展，并且在需求降低时自动收缩。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                      <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.管理任务队列</strong></p>\n<p>在线程池中，任务请求会在一个由Executor管理的Runnable队列中等待，而不是像线程那样去竞争cpu资源，通过一个Runnable和一个链表节点来表现一个等待中的任务，开销比用线程表示低很多，但如果客户端提交给服务器请求的速率超过了服务器的处理速率，那么仍可能会耗尽资源。</p>\n<p>ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务，基本任务队列有三种：</p>\n<ul>\n<li>无界队列：newFixedThreadPool和newSingleThreadExecutor默认使用LinkedBlockingQueue，如果所有工作者线程都忙碌，那么任务将在队列中等候，缺点是队列可能无限制增加，造成资源耗尽。</li>\n<li>有界队列：如ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽，但是如果队列满了，新来的任务的处理成为了问题，<strong>饱和策略</strong>可以解决此类问题。</li>\n<li>同步移交（SynchronousQueue）:直接将任务从公生产者移交给工作者线程，SynchronousQueue是一种线程之间的移交机制，要将一个元素放入SynchronousQueue，必须有另外一个线程正在等待接受这个元素。如果没有线程正在等待并且线程池当前大小小于最大值，SynchronousQueue将创建一个新线程，否则根据饱和策略，这个任务将被拒绝。newCachedThreadPool工厂方法中使用了SynchronousQueue。</li>\n</ul>\n<blockquote>\n<p>只有当任务相互独立时，为线程池工作队列设置界限才是合理的。若任务之间存在依赖关系，那么有界队列可能导致“饥饿”死锁问题，此时应该使用无界线程池，如newCachedThreadPool.</p>\n</blockquote>\n<p><strong>3.饱和策略</strong><br>当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor饱和策略可以通过setRejectedExecutionHandler来修改。（若某个任务被提交到已经关闭的Executor，也会用到饱和策略）。</p>\n<ul>\n<li><strong>中止（Abort）</strong>：默认的饱和策略，该策略将会抛出未受检查的RejectedEcecutionExeption，调用者捕获后可以自行处理</li>\n<li><strong>抛弃（Discard）</strong>：该策略会悄悄抛弃该任务</li>\n<li><strong>抛弃最旧的（Discard-Oldest）</strong>：抛弃下一个将被执行的任务，然后尝试重新提交新任务。</li>\n<li><strong>调用者运行（Caller-Runs）</strong>：实现了一种调节机制，既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者，由调用者执行，从而降低新任务的流量。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"一、在任务与执行策略之间的隐性耦合\"><a href=\"#一、在任务与执行策略之间的隐性耦合\" class=\"headerlink\" title=\"一、在任务与执行策略之间的隐性耦合\"></a>一、在任务与执行策略之间的隐性耦合</h4><p>Executor框架可以将任务的提交与任务的执行策略解耦开来，虽然Executor框架为制定和修改执行策略都提供了相当大的灵活性，但并非所有任务都适用于所有执行策略，有些类型的任务需要明确指定执行策略：</p>\n<ul>\n<li>依赖性任务： 在线程池中执行独立的任务时，可以随意的改变线程池的大小和配置，这只会影响其执行性能。但是若提交到线程池的任务依赖于其他的任务，那么就隐含的给执行策略带来了约束。","more":"</li>\n<li>使用线程封闭机制的任务： 单线程的Executor能够对并发性做出更强的承诺，他们能保证任务不会并发的执行，对象可以封闭在任务线程中，使得在该线程中执行的任务在访问该对象时不需要同步。这种情形将在任务与执行策略之间形成隐式的耦合——任务要求其执行所在的Executor是单线程的。</li>\n<li>对响应时间敏感的任务：将一个耗时的任务提交到单线程Executor中或者将多个耗时任务提交到包含少量线程的线程池中，将降低服务的响应性。</li>\n<li>使用ThreadLocal的任务： 只要条件允许，Executor可以自由的重用其中的线程，当执行需求较低时将回收空闲线程，当需求增加时将添加新的线程，并且如果从任务中抛出一个未检查异常，那么将用一个新的工作者线程来替代抛出异常的线程。只有当线程本地值的生命周期受限于任务的生命周期时，在线程池中使用ThreadLocal才有意义。</li>\n</ul>\n<p>只有当任务都是同类型并且相互独立时，线程池的性能才能达到最佳，如果运行的任务耗时差别很大，那么除非线程池很大，否则将引起<strong>“拥塞”</strong>。如果提交的任务有依赖关系，那么除非线程池无限大，否则将引起<strong>死锁</strong>。</p>\n<p><strong>1.线程饥饿死锁</strong></p>\n<p>在线程池中，如果任务依赖于其他任务，那么可能产生死锁。<br>线程饥饿死锁（Thread Starvation Deadlock）: 只要线程池中的任务需要无限期的等待一些必须由池中其他任务才能提供的资源或条件，那么除非线程池足够大，否则将发生线程饥饿死锁。</p>\n<blockquote>\n<p>如果线程池不够大，那么当多个任务通过栅栏机制彼此协调时，将导致线程饥饿死锁</p>\n</blockquote>\n<p>饥饿死锁示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 在单线程Executor中任务发生死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/1下午6:19</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDeadlocl</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RenderpageTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            Future&lt;String&gt; header, footer;</span><br><span class=\"line\">            header = executorService.submit(<span class=\"keyword\">new</span> loadFileTask(<span class=\"string\">\"head.txt\"</span>));</span><br><span class=\"line\">            footer = executorService.submit(<span class=\"keyword\">new</span> loadFileTask(<span class=\"string\">\"foot.txt\"</span>));</span><br><span class=\"line\">            <span class=\"comment\">//将发生死锁——由于任务在等待子任务完成</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> header.get() + footer.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>除了线程池大小的显示限制外，还可能由于其他资源上的约束而存在隐式限制，例如JDBC的连接池。</p>\n</blockquote>\n<p><strong>2.运行时间较长的任务</strong></p>\n<p>执行时间较长的任务不仅会造成线程池拥塞，甚至还会增加执行事件较短任务的服务时间。解决办法：限定等待资源的时间。在平台类库的大多数可阻塞方法中，都同时定义了限时版本和不限时版本，如Thread.join,BlockingQueue.put,CountDownLatch.await等。如果等待超市，那么可以把任务标识为失败，然后终止任务或者将任务重新放回队列以便随后执行。</p>\n<h4 id=\"二、设置线程池大小\"><a href=\"#二、设置线程池大小\" class=\"headerlink\" title=\"二、设置线程池大小\"></a>二、设置线程池大小</h4><p>线程池的理想大小取决于被提交任务的类型以及所部属系统的特性，通常在代码中不会固定线程池大小，而应该通过某种配置机制来提供，或者根据Runtime。availableProcessors来动态配置。</p>\n<blockquote>\n<p>线程池过大：大量线程将在相对较少的cpu和内存资源上发生竞争，这会导致高内存使用量，还可能导致资源耗尽。</p>\n</blockquote>\n<blockquote>\n<p>线程池过小：许多空闲的处理器无法执行工作，从而降低吞吐率</p>\n</blockquote>\n<p>对于计算密集型的任务，在拥有N_cpu个处理器的系统上，当线程池大小为N_cpu+1时，通常能实现最优的利用率。</p>\n<h4 id=\"3-配置ThreadPollExetutor\"><a href=\"#3-配置ThreadPollExetutor\" class=\"headerlink\" title=\"3.配置ThreadPollExetutor\"></a>3.配置ThreadPollExetutor</h4><p>ThreadPoolExecutor为一些Executor提供了基本的实现，这些Executor是有Executors中的newCachedThreadPool，newFixedThreadPool和newScheduledThreadPool等工厂方法返回的。ThreadPoolExecutor很灵活，允许各种定制。 </p>\n<p><strong>1.线程的创建与销毁</strong></p>\n<p>通用的ThreadPoolExecutor构造函数：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a new &#123;<span class=\"doctag\">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class=\"line\"><span class=\"comment\">     * parameters.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class=\"line\"><span class=\"comment\">     *        if they are idle, unless &#123;<span class=\"doctag\">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class=\"line\"><span class=\"comment\">     *        pool</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class=\"line\"><span class=\"comment\">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class=\"line\"><span class=\"comment\">     *        will wait for new tasks before terminating.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit the time unit for the &#123;<span class=\"doctag\">@code</span> keepAliveTime&#125; argument</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class=\"line\"><span class=\"comment\">     *        executed.  This queue will hold only the &#123;<span class=\"doctag\">@code</span> Runnable&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     *        tasks submitted by the &#123;<span class=\"doctag\">@code</span> execute&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> threadFactory the factory to use when the executor</span></span><br><span class=\"line\"><span class=\"comment\">     *        creates a new thread</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> handler the handler to use when execution is blocked</span></span><br><span class=\"line\"><span class=\"comment\">     *        because the thread bounds and queue capacities are reached</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *         &#123;<span class=\"doctag\">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> NullPointerException if &#123;<span class=\"doctag\">@code</span> workQueue&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     *         or &#123;<span class=\"doctag\">@code</span> threadFactory&#125; or &#123;<span class=\"doctag\">@code</span> handler&#125; is null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              RejectedExecutionHandler handler)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>\n<p>各参数的详细解释参照代码中的注释即可。</p>\n<blockquote>\n<p>newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                      <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>newCachedThreadPool工厂方法将线程池的最大大小设置为Integer.MAX_VALUE,而将基本大小设置为0，并将超时设置为1分钟，这种方法创建出来的线程可以被无限扩展，并且在需求降低时自动收缩。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                      <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.管理任务队列</strong></p>\n<p>在线程池中，任务请求会在一个由Executor管理的Runnable队列中等待，而不是像线程那样去竞争cpu资源，通过一个Runnable和一个链表节点来表现一个等待中的任务，开销比用线程表示低很多，但如果客户端提交给服务器请求的速率超过了服务器的处理速率，那么仍可能会耗尽资源。</p>\n<p>ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务，基本任务队列有三种：</p>\n<ul>\n<li>无界队列：newFixedThreadPool和newSingleThreadExecutor默认使用LinkedBlockingQueue，如果所有工作者线程都忙碌，那么任务将在队列中等候，缺点是队列可能无限制增加，造成资源耗尽。</li>\n<li>有界队列：如ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽，但是如果队列满了，新来的任务的处理成为了问题，<strong>饱和策略</strong>可以解决此类问题。</li>\n<li>同步移交（SynchronousQueue）:直接将任务从公生产者移交给工作者线程，SynchronousQueue是一种线程之间的移交机制，要将一个元素放入SynchronousQueue，必须有另外一个线程正在等待接受这个元素。如果没有线程正在等待并且线程池当前大小小于最大值，SynchronousQueue将创建一个新线程，否则根据饱和策略，这个任务将被拒绝。newCachedThreadPool工厂方法中使用了SynchronousQueue。</li>\n</ul>\n<blockquote>\n<p>只有当任务相互独立时，为线程池工作队列设置界限才是合理的。若任务之间存在依赖关系，那么有界队列可能导致“饥饿”死锁问题，此时应该使用无界线程池，如newCachedThreadPool.</p>\n</blockquote>\n<p><strong>3.饱和策略</strong><br>当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor饱和策略可以通过setRejectedExecutionHandler来修改。（若某个任务被提交到已经关闭的Executor，也会用到饱和策略）。</p>\n<ul>\n<li><strong>中止（Abort）</strong>：默认的饱和策略，该策略将会抛出未受检查的RejectedEcecutionExeption，调用者捕获后可以自行处理</li>\n<li><strong>抛弃（Discard）</strong>：该策略会悄悄抛弃该任务</li>\n<li><strong>抛弃最旧的（Discard-Oldest）</strong>：抛弃下一个将被执行的任务，然后尝试重新提交新任务。</li>\n<li><strong>调用者运行（Caller-Runs）</strong>：实现了一种调节机制，既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者，由调用者执行，从而降低新任务的流量。</li>\n</ul>"},{"title":"Java并发编程——线程的取消与关闭","date":"2018-06-03T16:10:55.000Z","_content":"\nJava没有提供任何机制来安全的终止线程，但是提供了**中断**（Interruption），这是一种协作机制，能够使一个线程终止另外一个线程。\n#### 一、任务取消\n* 可取消操作：如果外部代码能在某个正常操作完成之前将其置入“完成”状态，称这个任务可取消\n* 取消某个操作的原因：\n<!-- more--> \n    * 用户请求取消\n    * 有时间限制的操作：计时器超时时，取消正在进行的任务\n    * 应用程序事件；应用程序对某个问题空间进行分解并搜索，从而不同任务可以搜索问题空间中的不同区域当其中一个任务找到了解决方案时，其他所有正在搜索的任务都要被取消\n    * 错误\n    * 关闭\n\nJava中没有安全的抢占式方法来停止线程，只有一些协作的机制，其中一种协作机制能设置某个“已请求取消”标志，而任务将定期的查看该标志。如果设置了这个标志，任务将提前结束\n```java\n/**\n * @author  harold\n * @Title:\n * @Description: 使用volatile类型的域来保存取消状态\n * @date 2018/5/29下午5:18\n */\n\npublic class PrimeGenerator implements Runnable {\n    private final List<BigInteger> primes = new ArrayList<BigInteger>();\n    private volatile boolean cancled;\n    //持续的枚举素数\n    @Override\n    public void run() {\n        BigInteger p = BigInteger.ONE;\n        while (!cancled) {\n            p = p.nextProbablePrime();\n            synchronized (this) {\n                primes.add(p);\n            }\n        }\n    }\n    public void cancel() {\n        cancled = true;\n    }\n\n    public synchronized List<BigInteger> get() {\n        return new ArrayList<BigInteger>(primes);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        //让素数生成器1s后取消\n        PrimeGenerator generator = new PrimeGenerator();\n        new Thread(generator).start();\n        try {\n            SECONDS.sleep(1);\n        } finally {\n            generator.cancel();\n        }\n        System.out.println(generator.get());\n    }\n}\n```\n\n**1.中断**\n\nPrimeGenerator中的取消机制最终会使得任务退出，但退出时需要花费一定时间。更严重的是，当使用这种方法的任务调用了一个阻塞方法，如BlockingQueue.put，任务可能永远不会检查取消标志，因此永远不会结束。\n```java\n/**\n * @author harold\n * @Title: BrokenPrimeProducer\n * @Description: 不可靠的取消操作将把生产者置于阻塞的操作中\n * @date 2018/5/29下午5:38\n */\npublic class BrokenPrimeProducer extends Thread {\n    private final BlockingQueue<BigInteger> queue;\n    private volatile boolean cancelled = false;\n\n    public BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BigInteger p = BigInteger.ONE;\n            while (!cancelled) {\n                queue.put(p = p.nextProbablePrime());\n            }\n        } catch (InterruptedException consumed){\n            \n        }\n    }\n    \n    public void cancel() {\n        cancelled = true;\n    }\n    //消费者\n    void consumerPrimes() throws InterruptedException {\n        BlockingQueue<BigInteger> primes = new BlockingQueue<BigInteger>() {\n          ...\n        };\n        BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);\n        producer.start();\n        try {\n            while (needMorePrimes()) {\n                consume(primes.take());\n            }\n        } finally {\n            producer.cancel();\n        }\n    }\n}\n```\n一些特殊的阻塞库的方法支持中断，线程可以通过这种机制来通知另一个线程，告诉它在合适的时候停止当前工作，并转而执行其他工作。\n\n每个线程都有一个boolean类型的中断状态，线程中断时，这个状态将被设置为true。在Thread中包含了**中断线程**和*查询中断*的方法。\n> Thread中的中断方法：\n>\n> public void interrupt():中断目标线程\n>\n> public boolean isInterrupted():查询目标线程的中断状态\n>\n> public static boolean interrupted():清除当前线程的中断状态，并返回它之前的值\n\n阻塞库方法，如Thread.sleep()和Object.wait()等，都会检查线程何时中断，并在发现中断时提前返回。\n\n* 阻塞库方法响应中断执行的操作包括：\n    * 清除中断状态 \n    * 抛出InterruptedException异常\n    * 表示阻塞操作由于中断而提前结束\n\n当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。\n> 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。\n\n> 注意：使用静态方法interrupted时应该小心，它会清除当前线程的中断状态。如果在调用interrupted时返回了true，除非想要屏蔽这个中断，否则必须对它作出处理——可以抛出InterruptedException或者再次调用interrupt来恢复中断状态。\n\n通常，中断是取消的最合理方式。\n ```java\n /**\n * @author lihe\n * @Title: PrimeProducer\n * @Description: 通过中断来取消\n * @date 2018/5/29下午6:48\n */\npublic class PrimeProducer extends Thread {\n    private final BlockingQueue<BigInteger> queue;\n\n    public PrimeProducer(BlockingQueue<BigInteger> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BigInteger p = BigInteger.ONE;\n            //显式执行检测可以使代码对中断有更高的响应性\n            while (!Thread.currentThread().isInterrupted()) {\n                queue.put(p.nextProbablePrime());\n            }\n        } catch (InterruptedException e) {\n           //允许线程退出\n        }\n    }\n\n    public void cancel() {\n        interrupt();\n    }\n}\n```\n**2.中断策略**\n\n中断策略指定线程如何解释某个中断请求，最合理的中断策略是某种形式的线程级（thread——level）取消操作或者服务级（Service-Level）取消操作：尽快退出，在必要时清理，通知某个所有者该线程已经退出。\n\n一个中断请求可以有一个或多个接收者，中断线程池中的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如shutdown方法。\n\n**3.响应中断**\n\n在调用可中断的阻塞函数时，有两种策略可用于处理InterruptedException：\n* 传递异常，从而使你的方法也成为可中断的方法，通过throws InterruptedException\n* 恢复中断状态，从而使调用栈上层代码能够对其进行处理，通过再次调用interrut()方法\n\n> 只有实现了线程中断策略的代码才可以屏蔽中断请求（catch块中捕获异常却不做处理），在常规的任务和库代码中都不应该屏蔽中断请求‘\n\n对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法。并在发现中断后重新尝试。这种情况下，应该在本地保存中断状态，并在返回前恢复中断状态而不是在捕获InterruptedException时恢复状态，如果过早的设置中断状态，可能会引起无限循环，因为大多数阻塞方法会在入口处检查中断状态，摒弃在发现该状态已被设置时会立即抛出interruptedException.\n```java\n/**\n * @author harold\n * @Title: getNextTask\n * @Description: 不可取消的任务在退出前恢复中断\n * @date 2018/5/31下午2:10\n */\n\npublic Task getNextTask(BlockingQueue<Task> queue) {\n    boolean interrupted = false;\n    try {\n        while (true) {\n            try {\n                return queue.take();\n            } catch (InterruptedException e) {\n                interrupted = true;\n            }\n        }\n    }\n    finally {\n        if (interrupted)\n            Thread.currentThread().interrupt();\n    }\n}\n```\n**4.通过Future实现取消**\n\nExecutorService.submit将返回一个Future来描述任务。Future.cancel带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功（只是表示任务能否接收中断，而不是表示任务能否检测并处理中断）。\n\n**5.处理不可中断的阻塞**\n并非所有方法或阻塞机制都能响应中断，例如一个线程执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，此外没有其他作用。对于由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，前提是知道线程阻塞的原因：\n\n* Java.io包中的同步Socket I/O：虽然InputStream，OutputStream中的read、write方法不会响应中断，但关闭底层的套接字，可以使得正在执行read和write等方法而被阻塞的线程抛出SocketException\n* Java.io包中的同步I/O：当中断一个正在InterruptableChannel上等待的线程时，会抛出closedByInterruptedException并关闭链路。\n* 获取某个锁：如果一个线程由于等待某个内置锁而阻塞，他将无法响应中断，因为线程默认它肯定会获得锁，所以不会理会中断请求。但在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。\n```java\n/**\n * @author harold\n * @Title: ReaderThread\n * @Description: 通过改写interrupt方法将给标准的取消操作封装在Thread中\n * @date 2018/6/1下午1:12\n */\npublic class ReaderThread  extends Thread {\n    private final Socket socket;\n    private final InputStream inputStream;\n\n    public ReaderThread(Socket socket, InputStream inputStream) {\n        this.socket = socket;\n        this.inputStream = inputStream;\n    }\n\n    @Override\n    public void interrupt() {//既能处理标准中断，又能关闭底层套接字\n        try {\n            socket.close();\n        } catch (IOException e) {\n        }\n        finally {\n            super.interrupt();\n        }\n    }\n\n    @Override\n    public void run() {\n        byte [] mbuffer = new byte[128];\n        while (true) {\n            try {\n                int count = inputStream.read(mbuffer);\n                if (count < 0)\n                    break;\n                else if (count > 0) {\n                    processBuffer(buf, count);\n                }\n            } catch (IOException e) {\n                /*\n                允许线程退出\n                 */\n            }\n        }\n    }\n}\n```\n**6.采用newTaskFor来封装非标准的取消**\nnewTaskFor是一个工厂方法，他将创建Future来创建任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable。通过定制表示任务的Future可以改变Future.cancel行为\n","source":"_posts/Java并发编程——线程的取消与关闭.md","raw":"---\ntitle: Java并发编程——线程的取消与关闭\ndate: 2018-06-04 00:10:55\ntags: [Java, 多线程, 并发]\n---\n\nJava没有提供任何机制来安全的终止线程，但是提供了**中断**（Interruption），这是一种协作机制，能够使一个线程终止另外一个线程。\n#### 一、任务取消\n* 可取消操作：如果外部代码能在某个正常操作完成之前将其置入“完成”状态，称这个任务可取消\n* 取消某个操作的原因：\n<!-- more--> \n    * 用户请求取消\n    * 有时间限制的操作：计时器超时时，取消正在进行的任务\n    * 应用程序事件；应用程序对某个问题空间进行分解并搜索，从而不同任务可以搜索问题空间中的不同区域当其中一个任务找到了解决方案时，其他所有正在搜索的任务都要被取消\n    * 错误\n    * 关闭\n\nJava中没有安全的抢占式方法来停止线程，只有一些协作的机制，其中一种协作机制能设置某个“已请求取消”标志，而任务将定期的查看该标志。如果设置了这个标志，任务将提前结束\n```java\n/**\n * @author  harold\n * @Title:\n * @Description: 使用volatile类型的域来保存取消状态\n * @date 2018/5/29下午5:18\n */\n\npublic class PrimeGenerator implements Runnable {\n    private final List<BigInteger> primes = new ArrayList<BigInteger>();\n    private volatile boolean cancled;\n    //持续的枚举素数\n    @Override\n    public void run() {\n        BigInteger p = BigInteger.ONE;\n        while (!cancled) {\n            p = p.nextProbablePrime();\n            synchronized (this) {\n                primes.add(p);\n            }\n        }\n    }\n    public void cancel() {\n        cancled = true;\n    }\n\n    public synchronized List<BigInteger> get() {\n        return new ArrayList<BigInteger>(primes);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        //让素数生成器1s后取消\n        PrimeGenerator generator = new PrimeGenerator();\n        new Thread(generator).start();\n        try {\n            SECONDS.sleep(1);\n        } finally {\n            generator.cancel();\n        }\n        System.out.println(generator.get());\n    }\n}\n```\n\n**1.中断**\n\nPrimeGenerator中的取消机制最终会使得任务退出，但退出时需要花费一定时间。更严重的是，当使用这种方法的任务调用了一个阻塞方法，如BlockingQueue.put，任务可能永远不会检查取消标志，因此永远不会结束。\n```java\n/**\n * @author harold\n * @Title: BrokenPrimeProducer\n * @Description: 不可靠的取消操作将把生产者置于阻塞的操作中\n * @date 2018/5/29下午5:38\n */\npublic class BrokenPrimeProducer extends Thread {\n    private final BlockingQueue<BigInteger> queue;\n    private volatile boolean cancelled = false;\n\n    public BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BigInteger p = BigInteger.ONE;\n            while (!cancelled) {\n                queue.put(p = p.nextProbablePrime());\n            }\n        } catch (InterruptedException consumed){\n            \n        }\n    }\n    \n    public void cancel() {\n        cancelled = true;\n    }\n    //消费者\n    void consumerPrimes() throws InterruptedException {\n        BlockingQueue<BigInteger> primes = new BlockingQueue<BigInteger>() {\n          ...\n        };\n        BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);\n        producer.start();\n        try {\n            while (needMorePrimes()) {\n                consume(primes.take());\n            }\n        } finally {\n            producer.cancel();\n        }\n    }\n}\n```\n一些特殊的阻塞库的方法支持中断，线程可以通过这种机制来通知另一个线程，告诉它在合适的时候停止当前工作，并转而执行其他工作。\n\n每个线程都有一个boolean类型的中断状态，线程中断时，这个状态将被设置为true。在Thread中包含了**中断线程**和*查询中断*的方法。\n> Thread中的中断方法：\n>\n> public void interrupt():中断目标线程\n>\n> public boolean isInterrupted():查询目标线程的中断状态\n>\n> public static boolean interrupted():清除当前线程的中断状态，并返回它之前的值\n\n阻塞库方法，如Thread.sleep()和Object.wait()等，都会检查线程何时中断，并在发现中断时提前返回。\n\n* 阻塞库方法响应中断执行的操作包括：\n    * 清除中断状态 \n    * 抛出InterruptedException异常\n    * 表示阻塞操作由于中断而提前结束\n\n当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。\n> 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。\n\n> 注意：使用静态方法interrupted时应该小心，它会清除当前线程的中断状态。如果在调用interrupted时返回了true，除非想要屏蔽这个中断，否则必须对它作出处理——可以抛出InterruptedException或者再次调用interrupt来恢复中断状态。\n\n通常，中断是取消的最合理方式。\n ```java\n /**\n * @author lihe\n * @Title: PrimeProducer\n * @Description: 通过中断来取消\n * @date 2018/5/29下午6:48\n */\npublic class PrimeProducer extends Thread {\n    private final BlockingQueue<BigInteger> queue;\n\n    public PrimeProducer(BlockingQueue<BigInteger> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BigInteger p = BigInteger.ONE;\n            //显式执行检测可以使代码对中断有更高的响应性\n            while (!Thread.currentThread().isInterrupted()) {\n                queue.put(p.nextProbablePrime());\n            }\n        } catch (InterruptedException e) {\n           //允许线程退出\n        }\n    }\n\n    public void cancel() {\n        interrupt();\n    }\n}\n```\n**2.中断策略**\n\n中断策略指定线程如何解释某个中断请求，最合理的中断策略是某种形式的线程级（thread——level）取消操作或者服务级（Service-Level）取消操作：尽快退出，在必要时清理，通知某个所有者该线程已经退出。\n\n一个中断请求可以有一个或多个接收者，中断线程池中的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如shutdown方法。\n\n**3.响应中断**\n\n在调用可中断的阻塞函数时，有两种策略可用于处理InterruptedException：\n* 传递异常，从而使你的方法也成为可中断的方法，通过throws InterruptedException\n* 恢复中断状态，从而使调用栈上层代码能够对其进行处理，通过再次调用interrut()方法\n\n> 只有实现了线程中断策略的代码才可以屏蔽中断请求（catch块中捕获异常却不做处理），在常规的任务和库代码中都不应该屏蔽中断请求‘\n\n对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法。并在发现中断后重新尝试。这种情况下，应该在本地保存中断状态，并在返回前恢复中断状态而不是在捕获InterruptedException时恢复状态，如果过早的设置中断状态，可能会引起无限循环，因为大多数阻塞方法会在入口处检查中断状态，摒弃在发现该状态已被设置时会立即抛出interruptedException.\n```java\n/**\n * @author harold\n * @Title: getNextTask\n * @Description: 不可取消的任务在退出前恢复中断\n * @date 2018/5/31下午2:10\n */\n\npublic Task getNextTask(BlockingQueue<Task> queue) {\n    boolean interrupted = false;\n    try {\n        while (true) {\n            try {\n                return queue.take();\n            } catch (InterruptedException e) {\n                interrupted = true;\n            }\n        }\n    }\n    finally {\n        if (interrupted)\n            Thread.currentThread().interrupt();\n    }\n}\n```\n**4.通过Future实现取消**\n\nExecutorService.submit将返回一个Future来描述任务。Future.cancel带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功（只是表示任务能否接收中断，而不是表示任务能否检测并处理中断）。\n\n**5.处理不可中断的阻塞**\n并非所有方法或阻塞机制都能响应中断，例如一个线程执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，此外没有其他作用。对于由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，前提是知道线程阻塞的原因：\n\n* Java.io包中的同步Socket I/O：虽然InputStream，OutputStream中的read、write方法不会响应中断，但关闭底层的套接字，可以使得正在执行read和write等方法而被阻塞的线程抛出SocketException\n* Java.io包中的同步I/O：当中断一个正在InterruptableChannel上等待的线程时，会抛出closedByInterruptedException并关闭链路。\n* 获取某个锁：如果一个线程由于等待某个内置锁而阻塞，他将无法响应中断，因为线程默认它肯定会获得锁，所以不会理会中断请求。但在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。\n```java\n/**\n * @author harold\n * @Title: ReaderThread\n * @Description: 通过改写interrupt方法将给标准的取消操作封装在Thread中\n * @date 2018/6/1下午1:12\n */\npublic class ReaderThread  extends Thread {\n    private final Socket socket;\n    private final InputStream inputStream;\n\n    public ReaderThread(Socket socket, InputStream inputStream) {\n        this.socket = socket;\n        this.inputStream = inputStream;\n    }\n\n    @Override\n    public void interrupt() {//既能处理标准中断，又能关闭底层套接字\n        try {\n            socket.close();\n        } catch (IOException e) {\n        }\n        finally {\n            super.interrupt();\n        }\n    }\n\n    @Override\n    public void run() {\n        byte [] mbuffer = new byte[128];\n        while (true) {\n            try {\n                int count = inputStream.read(mbuffer);\n                if (count < 0)\n                    break;\n                else if (count > 0) {\n                    processBuffer(buf, count);\n                }\n            } catch (IOException e) {\n                /*\n                允许线程退出\n                 */\n            }\n        }\n    }\n}\n```\n**6.采用newTaskFor来封装非标准的取消**\nnewTaskFor是一个工厂方法，他将创建Future来创建任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable。通过定制表示任务的Future可以改变Future.cancel行为\n","slug":"Java并发编程——线程的取消与关闭","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6e000bcf96zkvg9446","content":"<p>Java没有提供任何机制来安全的终止线程，但是提供了<strong>中断</strong>（Interruption），这是一种协作机制，能够使一个线程终止另外一个线程。</p>\n<h4 id=\"一、任务取消\"><a href=\"#一、任务取消\" class=\"headerlink\" title=\"一、任务取消\"></a>一、任务取消</h4><ul>\n<li>可取消操作：如果外部代码能在某个正常操作完成之前将其置入“完成”状态，称这个任务可取消</li>\n<li>取消某个操作的原因：<a id=\"more\"></a> \n<ul>\n<li>用户请求取消</li>\n<li>有时间限制的操作：计时器超时时，取消正在进行的任务</li>\n<li>应用程序事件；应用程序对某个问题空间进行分解并搜索，从而不同任务可以搜索问题空间中的不同区域当其中一个任务找到了解决方案时，其他所有正在搜索的任务都要被取消</li>\n<li>错误</li>\n<li>关闭</li>\n</ul>\n</li>\n</ul>\n<p>Java中没有安全的抢占式方法来停止线程，只有一些协作的机制，其中一种协作机制能设置某个“已请求取消”标志，而任务将定期的查看该标志。如果设置了这个标志，任务将提前结束<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>  harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 使用volatile类型的域来保存取消状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/29下午5:18</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimeGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;BigInteger&gt; primes = <span class=\"keyword\">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> cancled;</span><br><span class=\"line\">    <span class=\"comment\">//持续的枚举素数</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        BigInteger p = BigInteger.ONE;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!cancled) &#123;</span><br><span class=\"line\">            p = p.nextProbablePrime();</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                primes.add(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cancled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> List&lt;BigInteger&gt; <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//让素数生成器1s后取消</span></span><br><span class=\"line\">        PrimeGenerator generator = <span class=\"keyword\">new</span> PrimeGenerator();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(generator).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            generator.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(generator.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>1.中断</strong></p>\n<p>PrimeGenerator中的取消机制最终会使得任务退出，但退出时需要花费一定时间。更严重的是，当使用这种方法的任务调用了一个阻塞方法，如BlockingQueue.put，任务可能永远不会检查取消标志，因此永远不会结束。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: BrokenPrimeProducer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 不可靠的取消操作将把生产者置于阻塞的操作中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/29下午5:38</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrokenPrimeProducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> cancelled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BrokenPrimeProducer</span><span class=\"params\">(BlockingQueue&lt;BigInteger&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            BigInteger p = BigInteger.ONE;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!cancelled) &#123;</span><br><span class=\"line\">                queue.put(p = p.nextProbablePrime());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException consumed)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cancelled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">consumerPrimes</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;BigInteger&gt; primes = <span class=\"keyword\">new</span> BlockingQueue&lt;BigInteger&gt;() &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        BrokenPrimeProducer producer = <span class=\"keyword\">new</span> BrokenPrimeProducer(primes);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (needMorePrimes()) &#123;</span><br><span class=\"line\">                consume(primes.take());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            producer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一些特殊的阻塞库的方法支持中断，线程可以通过这种机制来通知另一个线程，告诉它在合适的时候停止当前工作，并转而执行其他工作。</p>\n<p>每个线程都有一个boolean类型的中断状态，线程中断时，这个状态将被设置为true。在Thread中包含了<strong>中断线程</strong>和<em>查询中断</em>的方法。</p>\n<blockquote>\n<p>Thread中的中断方法：</p>\n<p>public void interrupt():中断目标线程</p>\n<p>public boolean isInterrupted():查询目标线程的中断状态</p>\n<p>public static boolean interrupted():清除当前线程的中断状态，并返回它之前的值</p>\n</blockquote>\n<p>阻塞库方法，如Thread.sleep()和Object.wait()等，都会检查线程何时中断，并在发现中断时提前返回。</p>\n<ul>\n<li>阻塞库方法响应中断执行的操作包括：<ul>\n<li>清除中断状态 </li>\n<li>抛出InterruptedException异常</li>\n<li>表示阻塞操作由于中断而提前结束</li>\n</ul>\n</li>\n</ul>\n<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。</p>\n<blockquote>\n<p>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p>\n</blockquote>\n<blockquote>\n<p>注意：使用静态方法interrupted时应该小心，它会清除当前线程的中断状态。如果在调用interrupted时返回了true，除非想要屏蔽这个中断，否则必须对它作出处理——可以抛出InterruptedException或者再次调用interrupt来恢复中断状态。</p>\n</blockquote>\n<p>通常，中断是取消的最合理方式。<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: PrimeProducer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 通过中断来取消</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/29下午6:48</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimeProducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PrimeProducer</span><span class=\"params\">(BlockingQueue&lt;BigInteger&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            BigInteger p = BigInteger.ONE;</span><br><span class=\"line\">            <span class=\"comment\">//显式执行检测可以使代码对中断有更高的响应性</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">                queue.put(p.nextProbablePrime());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//允许线程退出</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.中断策略</strong></p>\n<p>中断策略指定线程如何解释某个中断请求，最合理的中断策略是某种形式的线程级（thread——level）取消操作或者服务级（Service-Level）取消操作：尽快退出，在必要时清理，通知某个所有者该线程已经退出。</p>\n<p>一个中断请求可以有一个或多个接收者，中断线程池中的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如shutdown方法。</p>\n<p><strong>3.响应中断</strong></p>\n<p>在调用可中断的阻塞函数时，有两种策略可用于处理InterruptedException：</p>\n<ul>\n<li>传递异常，从而使你的方法也成为可中断的方法，通过throws InterruptedException</li>\n<li>恢复中断状态，从而使调用栈上层代码能够对其进行处理，通过再次调用interrut()方法</li>\n</ul>\n<blockquote>\n<p>只有实现了线程中断策略的代码才可以屏蔽中断请求（catch块中捕获异常却不做处理），在常规的任务和库代码中都不应该屏蔽中断请求‘</p>\n</blockquote>\n<p>对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法。并在发现中断后重新尝试。这种情况下，应该在本地保存中断状态，并在返回前恢复中断状态而不是在捕获InterruptedException时恢复状态，如果过早的设置中断状态，可能会引起无限循环，因为大多数阻塞方法会在入口处检查中断状态，摒弃在发现该状态已被设置时会立即抛出interruptedException.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: getNextTask</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 不可取消的任务在退出前恢复中断</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/31下午2:10</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Task <span class=\"title\">getNextTask</span><span class=\"params\">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> queue.take();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>4.通过Future实现取消</strong></p>\n<p>ExecutorService.submit将返回一个Future来描述任务。Future.cancel带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功（只是表示任务能否接收中断，而不是表示任务能否检测并处理中断）。</p>\n<p><strong>5.处理不可中断的阻塞</strong><br>并非所有方法或阻塞机制都能响应中断，例如一个线程执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，此外没有其他作用。对于由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，前提是知道线程阻塞的原因：</p>\n<ul>\n<li>Java.io包中的同步Socket I/O：虽然InputStream，OutputStream中的read、write方法不会响应中断，但关闭底层的套接字，可以使得正在执行read和write等方法而被阻塞的线程抛出SocketException</li>\n<li>Java.io包中的同步I/O：当中断一个正在InterruptableChannel上等待的线程时，会抛出closedByInterruptedException并关闭链路。</li>\n<li>获取某个锁：如果一个线程由于等待某个内置锁而阻塞，他将无法响应中断，因为线程默认它肯定会获得锁，所以不会理会中断请求。但在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: ReaderThread</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 通过改写interrupt方法将给标准的取消操作封装在Thread中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/1下午1:12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderThread</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Socket socket;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> InputStream inputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReaderThread</span><span class=\"params\">(Socket socket, InputStream inputStream)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.socket = socket;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.inputStream = inputStream;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//既能处理标准中断，又能关闭底层套接字</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            socket.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span> [] mbuffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = inputStream.read(mbuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    processBuffer(buf, count);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                允许线程退出</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>6.采用newTaskFor来封装非标准的取消</strong><br>newTaskFor是一个工厂方法，他将创建Future来创建任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable。通过定制表示任务的Future可以改变Future.cancel行为</p>\n","site":{"data":{}},"excerpt":"<p>Java没有提供任何机制来安全的终止线程，但是提供了<strong>中断</strong>（Interruption），这是一种协作机制，能够使一个线程终止另外一个线程。</p>\n<h4 id=\"一、任务取消\"><a href=\"#一、任务取消\" class=\"headerlink\" title=\"一、任务取消\"></a>一、任务取消</h4><ul>\n<li>可取消操作：如果外部代码能在某个正常操作完成之前将其置入“完成”状态，称这个任务可取消</li>\n<li>取消某个操作的原因：","more":"<ul>\n<li>用户请求取消</li>\n<li>有时间限制的操作：计时器超时时，取消正在进行的任务</li>\n<li>应用程序事件；应用程序对某个问题空间进行分解并搜索，从而不同任务可以搜索问题空间中的不同区域当其中一个任务找到了解决方案时，其他所有正在搜索的任务都要被取消</li>\n<li>错误</li>\n<li>关闭</li>\n</ul>\n</li>\n</ul>\n<p>Java中没有安全的抢占式方法来停止线程，只有一些协作的机制，其中一种协作机制能设置某个“已请求取消”标志，而任务将定期的查看该标志。如果设置了这个标志，任务将提前结束<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>  harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 使用volatile类型的域来保存取消状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/29下午5:18</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimeGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;BigInteger&gt; primes = <span class=\"keyword\">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> cancled;</span><br><span class=\"line\">    <span class=\"comment\">//持续的枚举素数</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        BigInteger p = BigInteger.ONE;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!cancled) &#123;</span><br><span class=\"line\">            p = p.nextProbablePrime();</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                primes.add(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cancled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> List&lt;BigInteger&gt; <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//让素数生成器1s后取消</span></span><br><span class=\"line\">        PrimeGenerator generator = <span class=\"keyword\">new</span> PrimeGenerator();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(generator).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            generator.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(generator.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>1.中断</strong></p>\n<p>PrimeGenerator中的取消机制最终会使得任务退出，但退出时需要花费一定时间。更严重的是，当使用这种方法的任务调用了一个阻塞方法，如BlockingQueue.put，任务可能永远不会检查取消标志，因此永远不会结束。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: BrokenPrimeProducer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 不可靠的取消操作将把生产者置于阻塞的操作中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/29下午5:38</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrokenPrimeProducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> cancelled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BrokenPrimeProducer</span><span class=\"params\">(BlockingQueue&lt;BigInteger&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            BigInteger p = BigInteger.ONE;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!cancelled) &#123;</span><br><span class=\"line\">                queue.put(p = p.nextProbablePrime());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException consumed)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cancelled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">consumerPrimes</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;BigInteger&gt; primes = <span class=\"keyword\">new</span> BlockingQueue&lt;BigInteger&gt;() &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        BrokenPrimeProducer producer = <span class=\"keyword\">new</span> BrokenPrimeProducer(primes);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (needMorePrimes()) &#123;</span><br><span class=\"line\">                consume(primes.take());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            producer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一些特殊的阻塞库的方法支持中断，线程可以通过这种机制来通知另一个线程，告诉它在合适的时候停止当前工作，并转而执行其他工作。</p>\n<p>每个线程都有一个boolean类型的中断状态，线程中断时，这个状态将被设置为true。在Thread中包含了<strong>中断线程</strong>和<em>查询中断</em>的方法。</p>\n<blockquote>\n<p>Thread中的中断方法：</p>\n<p>public void interrupt():中断目标线程</p>\n<p>public boolean isInterrupted():查询目标线程的中断状态</p>\n<p>public static boolean interrupted():清除当前线程的中断状态，并返回它之前的值</p>\n</blockquote>\n<p>阻塞库方法，如Thread.sleep()和Object.wait()等，都会检查线程何时中断，并在发现中断时提前返回。</p>\n<ul>\n<li>阻塞库方法响应中断执行的操作包括：<ul>\n<li>清除中断状态 </li>\n<li>抛出InterruptedException异常</li>\n<li>表示阻塞操作由于中断而提前结束</li>\n</ul>\n</li>\n</ul>\n<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。</p>\n<blockquote>\n<p>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p>\n</blockquote>\n<blockquote>\n<p>注意：使用静态方法interrupted时应该小心，它会清除当前线程的中断状态。如果在调用interrupted时返回了true，除非想要屏蔽这个中断，否则必须对它作出处理——可以抛出InterruptedException或者再次调用interrupt来恢复中断状态。</p>\n</blockquote>\n<p>通常，中断是取消的最合理方式。<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: PrimeProducer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 通过中断来取消</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/29下午6:48</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimeProducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PrimeProducer</span><span class=\"params\">(BlockingQueue&lt;BigInteger&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            BigInteger p = BigInteger.ONE;</span><br><span class=\"line\">            <span class=\"comment\">//显式执行检测可以使代码对中断有更高的响应性</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">                queue.put(p.nextProbablePrime());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//允许线程退出</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.中断策略</strong></p>\n<p>中断策略指定线程如何解释某个中断请求，最合理的中断策略是某种形式的线程级（thread——level）取消操作或者服务级（Service-Level）取消操作：尽快退出，在必要时清理，通知某个所有者该线程已经退出。</p>\n<p>一个中断请求可以有一个或多个接收者，中断线程池中的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如shutdown方法。</p>\n<p><strong>3.响应中断</strong></p>\n<p>在调用可中断的阻塞函数时，有两种策略可用于处理InterruptedException：</p>\n<ul>\n<li>传递异常，从而使你的方法也成为可中断的方法，通过throws InterruptedException</li>\n<li>恢复中断状态，从而使调用栈上层代码能够对其进行处理，通过再次调用interrut()方法</li>\n</ul>\n<blockquote>\n<p>只有实现了线程中断策略的代码才可以屏蔽中断请求（catch块中捕获异常却不做处理），在常规的任务和库代码中都不应该屏蔽中断请求‘</p>\n</blockquote>\n<p>对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法。并在发现中断后重新尝试。这种情况下，应该在本地保存中断状态，并在返回前恢复中断状态而不是在捕获InterruptedException时恢复状态，如果过早的设置中断状态，可能会引起无限循环，因为大多数阻塞方法会在入口处检查中断状态，摒弃在发现该状态已被设置时会立即抛出interruptedException.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: getNextTask</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 不可取消的任务在退出前恢复中断</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/31下午2:10</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Task <span class=\"title\">getNextTask</span><span class=\"params\">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> queue.take();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>4.通过Future实现取消</strong></p>\n<p>ExecutorService.submit将返回一个Future来描述任务。Future.cancel带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功（只是表示任务能否接收中断，而不是表示任务能否检测并处理中断）。</p>\n<p><strong>5.处理不可中断的阻塞</strong><br>并非所有方法或阻塞机制都能响应中断，例如一个线程执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，此外没有其他作用。对于由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，前提是知道线程阻塞的原因：</p>\n<ul>\n<li>Java.io包中的同步Socket I/O：虽然InputStream，OutputStream中的read、write方法不会响应中断，但关闭底层的套接字，可以使得正在执行read和write等方法而被阻塞的线程抛出SocketException</li>\n<li>Java.io包中的同步I/O：当中断一个正在InterruptableChannel上等待的线程时，会抛出closedByInterruptedException并关闭链路。</li>\n<li>获取某个锁：如果一个线程由于等待某个内置锁而阻塞，他将无法响应中断，因为线程默认它肯定会获得锁，所以不会理会中断请求。但在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>: ReaderThread</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 通过改写interrupt方法将给标准的取消操作封装在Thread中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/1下午1:12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderThread</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Socket socket;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> InputStream inputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReaderThread</span><span class=\"params\">(Socket socket, InputStream inputStream)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.socket = socket;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.inputStream = inputStream;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//既能处理标准中断，又能关闭底层套接字</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            socket.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span> [] mbuffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = inputStream.read(mbuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    processBuffer(buf, count);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                允许线程退出</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>6.采用newTaskFor来封装非标准的取消</strong><br>newTaskFor是一个工厂方法，他将创建Future来创建任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable。通过定制表示任务的Future可以改变Future.cancel行为</p>"},{"title":"Java并发编程——结构化并发应用程序(一)","date":"2018-04-08T13:08:17.000Z","_content":"\n## 一、任务执行（Task Execution）\n\n---\n\n任务通常是一些抽象且离散的工作单元，通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。\n\n### 1.在线程中执行任务\n当围绕“任务执行”来设计应用程序时，第一步就是要找到清晰的任务边界。大多数服务器应用程序都以*独立的客户请求*为边界.将独立的请求作为任务边界，即可以实现任务的独立性，又可以实现合理的任务规模。\n<!-- more-->\n* 串行的执行任务\n```java\npublic class SingleThreadWebServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket socket = new ServerSocket(80);\n        while (true) {\n            Socket conn = socket.accept();\n            handleREquest(conn);\n        }\n    }\n}\n```\n\n串行处理机制通常无法提供高吞吐率或快速响应性，每次只能处理一个请求。在Web请求的处理中包含了一组不同的运算与I/O操作。服务器必须处理套接字I/O以读取请求和写回响应，这些操作通常会由于网络拥塞或连通性问题而被阻塞，此外服务器还可能处理文件I/O或者数据库请求,这些操作同样会阻塞。单线程服务器中，阻塞会推迟当前请求的完成时间，还会彻底阻止等待中的请求被处理。如果阻塞时间过长，用户将认为服务器是不可用的，同时服务器的资源利用率非常低，因为线程在等待I/O操作完成时，CPU将处于空闲状态。\n\n* 显式地为任务创建线程\n\n  ```java\n  public class ThreadPerTaskWebServer {\n      public static void main(String[] args) throws IOException {\n          ServerSocket socket = new ServerSocket(80);\n          while (true) {\n              final Socket connection = socket.accept();\n              Runnable task = new Runnable() {\n                  @Override\n                  public void run() {\n                      handleRequest(connection);\n                  }\n              };\n              new Thread(task).start();\n          }\n      }\n  }\n  ```\n\n>* 任务处理过程从主线程分离出来，使得主循环能够更快的等待下一个到来的连接，提高响应性\n>* 任务可以并行处理，从而同时服务多个请求\n>* 任务处理代码必须是线程安全的因为当有多个任务时会并发的调用这段代码\n\n* 无限制创建线程的不足\n> *线程生命周期的开销非常高*：线程的创建和销毁并不是没有代价的，平台不同，开销也不同。但线程的创建过程都需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。\n>\n> *资源消耗*:活跃的线程会消耗系统资源，尤其是内存。如果可用线程数量多于可用CPU的数量，有些线程将闲置。大量的空闲线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。\n>\n> *稳定性*：在可创建线程的数量上存在一個限制，与平台相关，并受JVM的启动参数、Thread构造函数中请求的栈大小以及底层操作系统对线程的限制等约束。破坏了限制可能抛出OutOfMemoryError异常。\n\n为每个任务创建一个线程”的问题在于没有限制可创建线程的数量，只限制了远程用户提交HTTP请求的速率。\n### 2.Executer框架\n线程池简化了线程的管理工作，Executor框架能支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程与执行过程解耦开来，用Runnable表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。\nExecutor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。\n\n#### 线程池\n\n线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程（Work Thread）从工作队列中获取一个任务，执行任务，然后返回线程池等待下一个任务。\n使用线程池的好处：\n>. 通过重用而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销\n>. 请求到达时，工作线程通常已经存在，不会由于等待创建线程而延迟任务的执行，提高了响应性\n>. 通过适当调整线程池的大小，可以使处理器保持忙碌状态，还可以放置过多线程相互竞争资源而使应用程序耗尽内存或失败\n\n可以通过Executors中的静态工厂方法创建线程池：\n*newFixedThreadPool*:固定长度的线程池\n\n*newCachedThreadPool*:可缓存线程池，如果线程池的当前规模超过了处理需求时，将回收空闲的线程，当需求增加时，可以增加新的线程，线程池的规模不存在限制\n\n*newSingleThreadExecutor*：单线程Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，他会创建另外一個线程来代替。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。\n\n*newScheduledThreadPool*:创建一个固定长度的线程池，以延迟或定时的方式执行任务。\n\n#### Executord的生命周期\nJVM只有在所有线程（非守护）全部终止才会退出，如果无法正确的关闭Executor，那么JVM将无法结束。\n* 最平缓的关闭过程： 完成所有已启动的任务，并且不再接受任何新的任务\n* 最粗暴的关闭方式： 直接断电\n\nExecutor扩展了ExecutorService来解决执行服务的生命周期问题。ExecutorService的生命周期有三种状态：运行、关闭和已终止。\nExecutorService在初建时期处于运行状态。shutdown将执行平缓的关闭过程：不再接受新的任务，同时等待已提交任务完成，包括那些还未执行的任务。shutdownNow方法将执行粗暴的关闭过程：尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。\n\n所有任务执行完毕，ExecutorService会进入终止状态。可调用awaitTermination来等待ExecutorService到达终止状态。或者通过isTerminated方法轮询是否已經终止。通常在调用awaitTermination后会立即调用shutdown，从而产生同步的关闭ExecutorService的效果。\n```java\nclass lifecycleWebServer {\n    private static final int NTHREADS = 100;\n    private static final ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);\n\n    public void start() throws IOException {\n        ServerSocket socket = new ServerSocket(80);\n        while (!exec.isShutdown()) {\n            try {\n                final Socket conn = socket.accept();\n                exec.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        handleRequest(conn);\n                    }\n                });\n            } catch (RejectedExecutionException) {\n                if (!exec.isShutdown()) {\n                    System.out.println(\"task submission rejected\");\n                }\n            }\n        }\n    }\n\n    public void stop() {\n        exec.shutdown();\n    }\n\n    void handleRequest(Socket connection) {\n        Request req = readRequest(connection);\n        if (isShutDownRequest(req)) {\n            stop();\n        }\n        else {\n            dispatchRequest(req);\n        }\n    }\n}\n\npublic class OutOfTime {\n    public static void main(String[] args) throws InterruptedException {\n        Timer timer = new Timer();\n        timer.schedule(new ThrowTask(), 1);\n        SECONDS.sleep(1);\n        timer.schedule(new ThrowTask(), 1);\n        SECONDS.sleep(5);\n    }\n\n    static class ThrowTask extends TimerTask {\n        @Override\n        public void run() {\n            throw new RuntimeException();\n        }\n    }\n}\n```\n\n报错：\n\n```java\nException in thread \"Timer-0\" java.lang.RuntimeException\n\tat com.OutOfTime$ThrowTask.run(OutOfTime.java:23)\n\tat java.util.TimerThread.mainLoop(Timer.java:555)\n\tat java.util.TimerThread.run(Timer.java:505)\nException in thread \"main\" java.lang.IllegalStateException: Timer already cancelled.\n\tat java.util.Timer.sched(Timer.java:397)\n\tat java.util.Timer.schedule(Timer.java:193)\n\tat com.OutOfTime.main(OutOfTime.java:15)\n```\n\n \t要构建自己的调度服务，可以使用DelayQueue，它实现了BlockingQueue,并为ScheduledThreadPoolExecutor提供了调度功能。DelayQueue管理着一组Delayed对象，每个对象有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据他们的延迟时间进行排序。\n\n### 找出可利用并行性\n有时候任务边界并非显而易见，即使是服务器应用程序，在单个客户请求中任可能存在可挖掘的并发性。\n#### 携带结果的任务Callable与Future\nRunnable局限：不能返回一个值或者抛出受检查的异常，在延迟计算上有弱点，如数据库查询、获取网络资源等\nCallable：认为主入口点（即call）将返回一个值，并可抛出一个异常。\nExecutor执行的任务有四个生命周期阶段：创建、提交、开始和完成。\n在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当他们能响应中断时，才能取消。\nFuture表示一个任务的生命周期，并提供了相应的方法来判断任务是否已经完成或者取消，以及获取任务的结果和取消任务等。Future规范包含的隐含含义是：任务的生命周期只能前进，不能后退。\nExecutorService中的所有submit方法都将返回一个Future，从而将一个Rrunnable或Callable提交给Executor，并得到一个Future来获得任务执行结果或者取消任务。FutureTask实现了Runnable，可以将它提交给Executor来执行，或者直接调用他的run方法。\n#### 在异构任务并行化中存在的局限\n两个问题：\n1. 将不同类型的任务平均分配给每个线程并不容易，当线程数增加时，如何确保他们相互协作而不是相互妨碍，或者在重新分配任务时并不是容易的问题\n2. 任务的大小可能完全不同，相差太大的话性能提升不多;当有多个线程分解任务时，还需要一定的任务协调开销，为了使任务分解提高性能，这种开销不饿能高于并行实现的提升。","source":"_posts/Java并发编程——结构化并发应用程序.md","raw":"---\ntitle: Java并发编程——结构化并发应用程序(一)\ndate: 2018-04-08 21:08:17\ntags: [Java, 多线程, 并发]\n---\n\n## 一、任务执行（Task Execution）\n\n---\n\n任务通常是一些抽象且离散的工作单元，通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。\n\n### 1.在线程中执行任务\n当围绕“任务执行”来设计应用程序时，第一步就是要找到清晰的任务边界。大多数服务器应用程序都以*独立的客户请求*为边界.将独立的请求作为任务边界，即可以实现任务的独立性，又可以实现合理的任务规模。\n<!-- more-->\n* 串行的执行任务\n```java\npublic class SingleThreadWebServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket socket = new ServerSocket(80);\n        while (true) {\n            Socket conn = socket.accept();\n            handleREquest(conn);\n        }\n    }\n}\n```\n\n串行处理机制通常无法提供高吞吐率或快速响应性，每次只能处理一个请求。在Web请求的处理中包含了一组不同的运算与I/O操作。服务器必须处理套接字I/O以读取请求和写回响应，这些操作通常会由于网络拥塞或连通性问题而被阻塞，此外服务器还可能处理文件I/O或者数据库请求,这些操作同样会阻塞。单线程服务器中，阻塞会推迟当前请求的完成时间，还会彻底阻止等待中的请求被处理。如果阻塞时间过长，用户将认为服务器是不可用的，同时服务器的资源利用率非常低，因为线程在等待I/O操作完成时，CPU将处于空闲状态。\n\n* 显式地为任务创建线程\n\n  ```java\n  public class ThreadPerTaskWebServer {\n      public static void main(String[] args) throws IOException {\n          ServerSocket socket = new ServerSocket(80);\n          while (true) {\n              final Socket connection = socket.accept();\n              Runnable task = new Runnable() {\n                  @Override\n                  public void run() {\n                      handleRequest(connection);\n                  }\n              };\n              new Thread(task).start();\n          }\n      }\n  }\n  ```\n\n>* 任务处理过程从主线程分离出来，使得主循环能够更快的等待下一个到来的连接，提高响应性\n>* 任务可以并行处理，从而同时服务多个请求\n>* 任务处理代码必须是线程安全的因为当有多个任务时会并发的调用这段代码\n\n* 无限制创建线程的不足\n> *线程生命周期的开销非常高*：线程的创建和销毁并不是没有代价的，平台不同，开销也不同。但线程的创建过程都需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。\n>\n> *资源消耗*:活跃的线程会消耗系统资源，尤其是内存。如果可用线程数量多于可用CPU的数量，有些线程将闲置。大量的空闲线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。\n>\n> *稳定性*：在可创建线程的数量上存在一個限制，与平台相关，并受JVM的启动参数、Thread构造函数中请求的栈大小以及底层操作系统对线程的限制等约束。破坏了限制可能抛出OutOfMemoryError异常。\n\n为每个任务创建一个线程”的问题在于没有限制可创建线程的数量，只限制了远程用户提交HTTP请求的速率。\n### 2.Executer框架\n线程池简化了线程的管理工作，Executor框架能支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程与执行过程解耦开来，用Runnable表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。\nExecutor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。\n\n#### 线程池\n\n线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程（Work Thread）从工作队列中获取一个任务，执行任务，然后返回线程池等待下一个任务。\n使用线程池的好处：\n>. 通过重用而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销\n>. 请求到达时，工作线程通常已经存在，不会由于等待创建线程而延迟任务的执行，提高了响应性\n>. 通过适当调整线程池的大小，可以使处理器保持忙碌状态，还可以放置过多线程相互竞争资源而使应用程序耗尽内存或失败\n\n可以通过Executors中的静态工厂方法创建线程池：\n*newFixedThreadPool*:固定长度的线程池\n\n*newCachedThreadPool*:可缓存线程池，如果线程池的当前规模超过了处理需求时，将回收空闲的线程，当需求增加时，可以增加新的线程，线程池的规模不存在限制\n\n*newSingleThreadExecutor*：单线程Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，他会创建另外一個线程来代替。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。\n\n*newScheduledThreadPool*:创建一个固定长度的线程池，以延迟或定时的方式执行任务。\n\n#### Executord的生命周期\nJVM只有在所有线程（非守护）全部终止才会退出，如果无法正确的关闭Executor，那么JVM将无法结束。\n* 最平缓的关闭过程： 完成所有已启动的任务，并且不再接受任何新的任务\n* 最粗暴的关闭方式： 直接断电\n\nExecutor扩展了ExecutorService来解决执行服务的生命周期问题。ExecutorService的生命周期有三种状态：运行、关闭和已终止。\nExecutorService在初建时期处于运行状态。shutdown将执行平缓的关闭过程：不再接受新的任务，同时等待已提交任务完成，包括那些还未执行的任务。shutdownNow方法将执行粗暴的关闭过程：尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。\n\n所有任务执行完毕，ExecutorService会进入终止状态。可调用awaitTermination来等待ExecutorService到达终止状态。或者通过isTerminated方法轮询是否已經终止。通常在调用awaitTermination后会立即调用shutdown，从而产生同步的关闭ExecutorService的效果。\n```java\nclass lifecycleWebServer {\n    private static final int NTHREADS = 100;\n    private static final ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);\n\n    public void start() throws IOException {\n        ServerSocket socket = new ServerSocket(80);\n        while (!exec.isShutdown()) {\n            try {\n                final Socket conn = socket.accept();\n                exec.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        handleRequest(conn);\n                    }\n                });\n            } catch (RejectedExecutionException) {\n                if (!exec.isShutdown()) {\n                    System.out.println(\"task submission rejected\");\n                }\n            }\n        }\n    }\n\n    public void stop() {\n        exec.shutdown();\n    }\n\n    void handleRequest(Socket connection) {\n        Request req = readRequest(connection);\n        if (isShutDownRequest(req)) {\n            stop();\n        }\n        else {\n            dispatchRequest(req);\n        }\n    }\n}\n\npublic class OutOfTime {\n    public static void main(String[] args) throws InterruptedException {\n        Timer timer = new Timer();\n        timer.schedule(new ThrowTask(), 1);\n        SECONDS.sleep(1);\n        timer.schedule(new ThrowTask(), 1);\n        SECONDS.sleep(5);\n    }\n\n    static class ThrowTask extends TimerTask {\n        @Override\n        public void run() {\n            throw new RuntimeException();\n        }\n    }\n}\n```\n\n报错：\n\n```java\nException in thread \"Timer-0\" java.lang.RuntimeException\n\tat com.OutOfTime$ThrowTask.run(OutOfTime.java:23)\n\tat java.util.TimerThread.mainLoop(Timer.java:555)\n\tat java.util.TimerThread.run(Timer.java:505)\nException in thread \"main\" java.lang.IllegalStateException: Timer already cancelled.\n\tat java.util.Timer.sched(Timer.java:397)\n\tat java.util.Timer.schedule(Timer.java:193)\n\tat com.OutOfTime.main(OutOfTime.java:15)\n```\n\n \t要构建自己的调度服务，可以使用DelayQueue，它实现了BlockingQueue,并为ScheduledThreadPoolExecutor提供了调度功能。DelayQueue管理着一组Delayed对象，每个对象有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据他们的延迟时间进行排序。\n\n### 找出可利用并行性\n有时候任务边界并非显而易见，即使是服务器应用程序，在单个客户请求中任可能存在可挖掘的并发性。\n#### 携带结果的任务Callable与Future\nRunnable局限：不能返回一个值或者抛出受检查的异常，在延迟计算上有弱点，如数据库查询、获取网络资源等\nCallable：认为主入口点（即call）将返回一个值，并可抛出一个异常。\nExecutor执行的任务有四个生命周期阶段：创建、提交、开始和完成。\n在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当他们能响应中断时，才能取消。\nFuture表示一个任务的生命周期，并提供了相应的方法来判断任务是否已经完成或者取消，以及获取任务的结果和取消任务等。Future规范包含的隐含含义是：任务的生命周期只能前进，不能后退。\nExecutorService中的所有submit方法都将返回一个Future，从而将一个Rrunnable或Callable提交给Executor，并得到一个Future来获得任务执行结果或者取消任务。FutureTask实现了Runnable，可以将它提交给Executor来执行，或者直接调用他的run方法。\n#### 在异构任务并行化中存在的局限\n两个问题：\n1. 将不同类型的任务平均分配给每个线程并不容易，当线程数增加时，如何确保他们相互协作而不是相互妨碍，或者在重新分配任务时并不是容易的问题\n2. 任务的大小可能完全不同，相差太大的话性能提升不多;当有多个线程分解任务时，还需要一定的任务协调开销，为了使任务分解提高性能，这种开销不饿能高于并行实现的提升。","slug":"Java并发编程——结构化并发应用程序","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6f000ccf96qjinvj5e","content":"<h2 id=\"一、任务执行（Task-Execution）\"><a href=\"#一、任务执行（Task-Execution）\" class=\"headerlink\" title=\"一、任务执行（Task Execution）\"></a>一、任务执行（Task Execution）</h2><hr>\n<p>任务通常是一些抽象且离散的工作单元，通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。</p>\n<h3 id=\"1-在线程中执行任务\"><a href=\"#1-在线程中执行任务\" class=\"headerlink\" title=\"1.在线程中执行任务\"></a>1.在线程中执行任务</h3><p>当围绕“任务执行”来设计应用程序时，第一步就是要找到清晰的任务边界。大多数服务器应用程序都以<em>独立的客户请求</em>为边界.将独立的请求作为任务边界，即可以实现任务的独立性，又可以实现合理的任务规模。<br><a id=\"more\"></a></p>\n<ul>\n<li>串行的执行任务<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleThreadWebServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket socket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Socket conn = socket.accept();</span><br><span class=\"line\">            handleREquest(conn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>串行处理机制通常无法提供高吞吐率或快速响应性，每次只能处理一个请求。在Web请求的处理中包含了一组不同的运算与I/O操作。服务器必须处理套接字I/O以读取请求和写回响应，这些操作通常会由于网络拥塞或连通性问题而被阻塞，此外服务器还可能处理文件I/O或者数据库请求,这些操作同样会阻塞。单线程服务器中，阻塞会推迟当前请求的完成时间，还会彻底阻止等待中的请求被处理。如果阻塞时间过长，用户将认为服务器是不可用的，同时服务器的资源利用率非常低，因为线程在等待I/O操作完成时，CPU将处于空闲状态。</p>\n<ul>\n<li><p>显式地为任务创建线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket socket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Socket connection = socket.accept();</span><br><span class=\"line\">            Runnable task = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    handleRequest(connection);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(task).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>任务处理过程从主线程分离出来，使得主循环能够更快的等待下一个到来的连接，提高响应性</li>\n<li>任务可以并行处理，从而同时服务多个请求</li>\n<li>任务处理代码必须是线程安全的因为当有多个任务时会并发的调用这段代码</li>\n</ul>\n</blockquote>\n<ul>\n<li>无限制创建线程的不足<blockquote>\n<p><em>线程生命周期的开销非常高</em>：线程的创建和销毁并不是没有代价的，平台不同，开销也不同。但线程的创建过程都需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。</p>\n<p><em>资源消耗</em>:活跃的线程会消耗系统资源，尤其是内存。如果可用线程数量多于可用CPU的数量，有些线程将闲置。大量的空闲线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。</p>\n<p><em>稳定性</em>：在可创建线程的数量上存在一個限制，与平台相关，并受JVM的启动参数、Thread构造函数中请求的栈大小以及底层操作系统对线程的限制等约束。破坏了限制可能抛出OutOfMemoryError异常。</p>\n</blockquote>\n</li>\n</ul>\n<p>为每个任务创建一个线程”的问题在于没有限制可创建线程的数量，只限制了远程用户提交HTTP请求的速率。</p>\n<h3 id=\"2-Executer框架\"><a href=\"#2-Executer框架\" class=\"headerlink\" title=\"2.Executer框架\"></a>2.Executer框架</h3><p>线程池简化了线程的管理工作，Executor框架能支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程与执行过程解耦开来，用Runnable表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。<br>Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</p>\n<h4 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h4><p>线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程（Work Thread）从工作队列中获取一个任务，执行任务，然后返回线程池等待下一个任务。<br>使用线程池的好处：</p>\n<blockquote>\n<p>. 通过重用而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销<br>. 请求到达时，工作线程通常已经存在，不会由于等待创建线程而延迟任务的执行，提高了响应性<br>. 通过适当调整线程池的大小，可以使处理器保持忙碌状态，还可以放置过多线程相互竞争资源而使应用程序耗尽内存或失败</p>\n</blockquote>\n<p>可以通过Executors中的静态工厂方法创建线程池：<br><em>newFixedThreadPool</em>:固定长度的线程池</p>\n<p><em>newCachedThreadPool</em>:可缓存线程池，如果线程池的当前规模超过了处理需求时，将回收空闲的线程，当需求增加时，可以增加新的线程，线程池的规模不存在限制</p>\n<p><em>newSingleThreadExecutor</em>：单线程Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，他会创建另外一個线程来代替。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。</p>\n<p><em>newScheduledThreadPool</em>:创建一个固定长度的线程池，以延迟或定时的方式执行任务。</p>\n<h4 id=\"Executord的生命周期\"><a href=\"#Executord的生命周期\" class=\"headerlink\" title=\"Executord的生命周期\"></a>Executord的生命周期</h4><p>JVM只有在所有线程（非守护）全部终止才会退出，如果无法正确的关闭Executor，那么JVM将无法结束。</p>\n<ul>\n<li>最平缓的关闭过程： 完成所有已启动的任务，并且不再接受任何新的任务</li>\n<li>最粗暴的关闭方式： 直接断电</li>\n</ul>\n<p>Executor扩展了ExecutorService来解决执行服务的生命周期问题。ExecutorService的生命周期有三种状态：运行、关闭和已终止。<br>ExecutorService在初建时期处于运行状态。shutdown将执行平缓的关闭过程：不再接受新的任务，同时等待已提交任务完成，包括那些还未执行的任务。shutdownNow方法将执行粗暴的关闭过程：尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>\n<p>所有任务执行完毕，ExecutorService会进入终止状态。可调用awaitTermination来等待ExecutorService到达终止状态。或者通过isTerminated方法轮询是否已經终止。通常在调用awaitTermination后会立即调用shutdown，从而产生同步的关闭ExecutorService的效果。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">lifecycleWebServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NTHREADS = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket socket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!exec.isShutdown()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Socket conn = socket.accept();</span><br><span class=\"line\">                exec.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        handleRequest(conn);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!exec.isShutdown()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"task submission rejected\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleRequest</span><span class=\"params\">(Socket connection)</span> </span>&#123;</span><br><span class=\"line\">        Request req = readRequest(connection);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isShutDownRequest(req)) &#123;</span><br><span class=\"line\">            stop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            dispatchRequest(req);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutOfTime</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> ThrowTask(), <span class=\"number\">1</span>);</span><br><span class=\"line\">        SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> ThrowTask(), <span class=\"number\">1</span>);</span><br><span class=\"line\">        SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThrowTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>报错：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"Timer-0\"</span> java.lang.RuntimeException</span><br><span class=\"line\">\tat com.OutOfTime$ThrowTask.run(OutOfTime.java:<span class=\"number\">23</span>)</span><br><span class=\"line\">\tat java.util.TimerThread.mainLoop(Timer.java:<span class=\"number\">555</span>)</span><br><span class=\"line\">\tat java.util.TimerThread.run(Timer.java:<span class=\"number\">505</span>)</span><br><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.IllegalStateException: Timer already cancelled.</span><br><span class=\"line\">\tat java.util.Timer.sched(Timer.java:<span class=\"number\">397</span>)</span><br><span class=\"line\">\tat java.util.Timer.schedule(Timer.java:<span class=\"number\">193</span>)</span><br><span class=\"line\">\tat com.OutOfTime.main(OutOfTime.java:<span class=\"number\">15</span>)</span><br></pre></td></tr></table></figure>\n<pre><code>要构建自己的调度服务，可以使用DelayQueue，它实现了BlockingQueue,并为ScheduledThreadPoolExecutor提供了调度功能。DelayQueue管理着一组Delayed对象，每个对象有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据他们的延迟时间进行排序。\n</code></pre><h3 id=\"找出可利用并行性\"><a href=\"#找出可利用并行性\" class=\"headerlink\" title=\"找出可利用并行性\"></a>找出可利用并行性</h3><p>有时候任务边界并非显而易见，即使是服务器应用程序，在单个客户请求中任可能存在可挖掘的并发性。</p>\n<h4 id=\"携带结果的任务Callable与Future\"><a href=\"#携带结果的任务Callable与Future\" class=\"headerlink\" title=\"携带结果的任务Callable与Future\"></a>携带结果的任务Callable与Future</h4><p>Runnable局限：不能返回一个值或者抛出受检查的异常，在延迟计算上有弱点，如数据库查询、获取网络资源等<br>Callable：认为主入口点（即call）将返回一个值，并可抛出一个异常。<br>Executor执行的任务有四个生命周期阶段：创建、提交、开始和完成。<br>在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当他们能响应中断时，才能取消。<br>Future表示一个任务的生命周期，并提供了相应的方法来判断任务是否已经完成或者取消，以及获取任务的结果和取消任务等。Future规范包含的隐含含义是：任务的生命周期只能前进，不能后退。<br>ExecutorService中的所有submit方法都将返回一个Future，从而将一个Rrunnable或Callable提交给Executor，并得到一个Future来获得任务执行结果或者取消任务。FutureTask实现了Runnable，可以将它提交给Executor来执行，或者直接调用他的run方法。</p>\n<h4 id=\"在异构任务并行化中存在的局限\"><a href=\"#在异构任务并行化中存在的局限\" class=\"headerlink\" title=\"在异构任务并行化中存在的局限\"></a>在异构任务并行化中存在的局限</h4><p>两个问题：</p>\n<ol>\n<li>将不同类型的任务平均分配给每个线程并不容易，当线程数增加时，如何确保他们相互协作而不是相互妨碍，或者在重新分配任务时并不是容易的问题</li>\n<li>任务的大小可能完全不同，相差太大的话性能提升不多;当有多个线程分解任务时，还需要一定的任务协调开销，为了使任务分解提高性能，这种开销不饿能高于并行实现的提升。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、任务执行（Task-Execution）\"><a href=\"#一、任务执行（Task-Execution）\" class=\"headerlink\" title=\"一、任务执行（Task Execution）\"></a>一、任务执行（Task Execution）</h2><hr>\n<p>任务通常是一些抽象且离散的工作单元，通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。</p>\n<h3 id=\"1-在线程中执行任务\"><a href=\"#1-在线程中执行任务\" class=\"headerlink\" title=\"1.在线程中执行任务\"></a>1.在线程中执行任务</h3><p>当围绕“任务执行”来设计应用程序时，第一步就是要找到清晰的任务边界。大多数服务器应用程序都以<em>独立的客户请求</em>为边界.将独立的请求作为任务边界，即可以实现任务的独立性，又可以实现合理的任务规模。<br>","more":"</p>\n<ul>\n<li>串行的执行任务<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleThreadWebServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket socket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Socket conn = socket.accept();</span><br><span class=\"line\">            handleREquest(conn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>串行处理机制通常无法提供高吞吐率或快速响应性，每次只能处理一个请求。在Web请求的处理中包含了一组不同的运算与I/O操作。服务器必须处理套接字I/O以读取请求和写回响应，这些操作通常会由于网络拥塞或连通性问题而被阻塞，此外服务器还可能处理文件I/O或者数据库请求,这些操作同样会阻塞。单线程服务器中，阻塞会推迟当前请求的完成时间，还会彻底阻止等待中的请求被处理。如果阻塞时间过长，用户将认为服务器是不可用的，同时服务器的资源利用率非常低，因为线程在等待I/O操作完成时，CPU将处于空闲状态。</p>\n<ul>\n<li><p>显式地为任务创建线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket socket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Socket connection = socket.accept();</span><br><span class=\"line\">            Runnable task = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    handleRequest(connection);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(task).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>任务处理过程从主线程分离出来，使得主循环能够更快的等待下一个到来的连接，提高响应性</li>\n<li>任务可以并行处理，从而同时服务多个请求</li>\n<li>任务处理代码必须是线程安全的因为当有多个任务时会并发的调用这段代码</li>\n</ul>\n</blockquote>\n<ul>\n<li>无限制创建线程的不足<blockquote>\n<p><em>线程生命周期的开销非常高</em>：线程的创建和销毁并不是没有代价的，平台不同，开销也不同。但线程的创建过程都需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。</p>\n<p><em>资源消耗</em>:活跃的线程会消耗系统资源，尤其是内存。如果可用线程数量多于可用CPU的数量，有些线程将闲置。大量的空闲线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。</p>\n<p><em>稳定性</em>：在可创建线程的数量上存在一個限制，与平台相关，并受JVM的启动参数、Thread构造函数中请求的栈大小以及底层操作系统对线程的限制等约束。破坏了限制可能抛出OutOfMemoryError异常。</p>\n</blockquote>\n</li>\n</ul>\n<p>为每个任务创建一个线程”的问题在于没有限制可创建线程的数量，只限制了远程用户提交HTTP请求的速率。</p>\n<h3 id=\"2-Executer框架\"><a href=\"#2-Executer框架\" class=\"headerlink\" title=\"2.Executer框架\"></a>2.Executer框架</h3><p>线程池简化了线程的管理工作，Executor框架能支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程与执行过程解耦开来，用Runnable表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。<br>Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</p>\n<h4 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h4><p>线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程（Work Thread）从工作队列中获取一个任务，执行任务，然后返回线程池等待下一个任务。<br>使用线程池的好处：</p>\n<blockquote>\n<p>. 通过重用而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销<br>. 请求到达时，工作线程通常已经存在，不会由于等待创建线程而延迟任务的执行，提高了响应性<br>. 通过适当调整线程池的大小，可以使处理器保持忙碌状态，还可以放置过多线程相互竞争资源而使应用程序耗尽内存或失败</p>\n</blockquote>\n<p>可以通过Executors中的静态工厂方法创建线程池：<br><em>newFixedThreadPool</em>:固定长度的线程池</p>\n<p><em>newCachedThreadPool</em>:可缓存线程池，如果线程池的当前规模超过了处理需求时，将回收空闲的线程，当需求增加时，可以增加新的线程，线程池的规模不存在限制</p>\n<p><em>newSingleThreadExecutor</em>：单线程Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，他会创建另外一個线程来代替。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。</p>\n<p><em>newScheduledThreadPool</em>:创建一个固定长度的线程池，以延迟或定时的方式执行任务。</p>\n<h4 id=\"Executord的生命周期\"><a href=\"#Executord的生命周期\" class=\"headerlink\" title=\"Executord的生命周期\"></a>Executord的生命周期</h4><p>JVM只有在所有线程（非守护）全部终止才会退出，如果无法正确的关闭Executor，那么JVM将无法结束。</p>\n<ul>\n<li>最平缓的关闭过程： 完成所有已启动的任务，并且不再接受任何新的任务</li>\n<li>最粗暴的关闭方式： 直接断电</li>\n</ul>\n<p>Executor扩展了ExecutorService来解决执行服务的生命周期问题。ExecutorService的生命周期有三种状态：运行、关闭和已终止。<br>ExecutorService在初建时期处于运行状态。shutdown将执行平缓的关闭过程：不再接受新的任务，同时等待已提交任务完成，包括那些还未执行的任务。shutdownNow方法将执行粗暴的关闭过程：尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>\n<p>所有任务执行完毕，ExecutorService会进入终止状态。可调用awaitTermination来等待ExecutorService到达终止状态。或者通过isTerminated方法轮询是否已經终止。通常在调用awaitTermination后会立即调用shutdown，从而产生同步的关闭ExecutorService的效果。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">lifecycleWebServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NTHREADS = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket socket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!exec.isShutdown()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Socket conn = socket.accept();</span><br><span class=\"line\">                exec.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        handleRequest(conn);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!exec.isShutdown()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"task submission rejected\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleRequest</span><span class=\"params\">(Socket connection)</span> </span>&#123;</span><br><span class=\"line\">        Request req = readRequest(connection);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isShutDownRequest(req)) &#123;</span><br><span class=\"line\">            stop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            dispatchRequest(req);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutOfTime</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> ThrowTask(), <span class=\"number\">1</span>);</span><br><span class=\"line\">        SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> ThrowTask(), <span class=\"number\">1</span>);</span><br><span class=\"line\">        SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThrowTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>报错：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"Timer-0\"</span> java.lang.RuntimeException</span><br><span class=\"line\">\tat com.OutOfTime$ThrowTask.run(OutOfTime.java:<span class=\"number\">23</span>)</span><br><span class=\"line\">\tat java.util.TimerThread.mainLoop(Timer.java:<span class=\"number\">555</span>)</span><br><span class=\"line\">\tat java.util.TimerThread.run(Timer.java:<span class=\"number\">505</span>)</span><br><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.IllegalStateException: Timer already cancelled.</span><br><span class=\"line\">\tat java.util.Timer.sched(Timer.java:<span class=\"number\">397</span>)</span><br><span class=\"line\">\tat java.util.Timer.schedule(Timer.java:<span class=\"number\">193</span>)</span><br><span class=\"line\">\tat com.OutOfTime.main(OutOfTime.java:<span class=\"number\">15</span>)</span><br></pre></td></tr></table></figure>\n<pre><code>要构建自己的调度服务，可以使用DelayQueue，它实现了BlockingQueue,并为ScheduledThreadPoolExecutor提供了调度功能。DelayQueue管理着一组Delayed对象，每个对象有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据他们的延迟时间进行排序。\n</code></pre><h3 id=\"找出可利用并行性\"><a href=\"#找出可利用并行性\" class=\"headerlink\" title=\"找出可利用并行性\"></a>找出可利用并行性</h3><p>有时候任务边界并非显而易见，即使是服务器应用程序，在单个客户请求中任可能存在可挖掘的并发性。</p>\n<h4 id=\"携带结果的任务Callable与Future\"><a href=\"#携带结果的任务Callable与Future\" class=\"headerlink\" title=\"携带结果的任务Callable与Future\"></a>携带结果的任务Callable与Future</h4><p>Runnable局限：不能返回一个值或者抛出受检查的异常，在延迟计算上有弱点，如数据库查询、获取网络资源等<br>Callable：认为主入口点（即call）将返回一个值，并可抛出一个异常。<br>Executor执行的任务有四个生命周期阶段：创建、提交、开始和完成。<br>在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当他们能响应中断时，才能取消。<br>Future表示一个任务的生命周期，并提供了相应的方法来判断任务是否已经完成或者取消，以及获取任务的结果和取消任务等。Future规范包含的隐含含义是：任务的生命周期只能前进，不能后退。<br>ExecutorService中的所有submit方法都将返回一个Future，从而将一个Rrunnable或Callable提交给Executor，并得到一个Future来获得任务执行结果或者取消任务。FutureTask实现了Runnable，可以将它提交给Executor来执行，或者直接调用他的run方法。</p>\n<h4 id=\"在异构任务并行化中存在的局限\"><a href=\"#在异构任务并行化中存在的局限\" class=\"headerlink\" title=\"在异构任务并行化中存在的局限\"></a>在异构任务并行化中存在的局限</h4><p>两个问题：</p>\n<ol>\n<li>将不同类型的任务平均分配给每个线程并不容易，当线程数增加时，如何确保他们相互协作而不是相互妨碍，或者在重新分配任务时并不是容易的问题</li>\n<li>任务的大小可能完全不同，相差太大的话性能提升不多;当有多个线程分解任务时，还需要一定的任务协调开销，为了使任务分解提高性能，这种开销不饿能高于并行实现的提升。</li>\n</ol>"},{"title":"Java并发编程——结构化并发应用程序(二)","date":"2018-05-26T16:36:58.000Z","_content":"\n#### CompletionService：Executor和BlockingQueue\n\n若向Executor提交了一组计算任务，并希望在计算技术之后获得结果，有一下两种方法：\n\n> - 保留与任务关联的Future，反复使用get方法，同时将参数timeout指定为0，从而通过轮训判断任务是否完成\n> - 使用完成服务（CompletionService）\n\n**CompletionService：**                     CompletionService将Executor和BlockingQueue功能结合起来，可以将Callable任务提交给它来执行，然后使用类似队列操作的take和poll等方法获得已经完成的结果，这些结果会**在完成时**被封装为Future。\n<!-- more--> \nExecutorCompletionService实现了CompletionService，并将计算部分委托给了一个Executor。实现方式：在构造函数中创建一个BlockingQueue来保存完成的结果，计算完成时，调用Future-Task中的done方法，当提交某个任务时，该任务首先将包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，将结果放入BlockingQueue中。take和poll方法委托给了BlockingQueue，这些方法会在得出结果之前阻塞。\n\n```java\n//ExecutorCompletionService部分源码\npublic class ExecutorCompletionService<V> implements CompletionService<V> {\n    private final Executor executor;\n    private final AbstractExecutorService aes;\n    private final BlockingQueue<Future<V>> completionQueue;\n\n    /**\n     * FutureTask extension to enqueue upon completion\n     */\n    private class QueueingFuture extends FutureTask<Void> {\n        QueueingFuture(RunnableFuture<V> task) {\n            super(task, null);\n            this.task = task;\n        }\n        protected void done() { completionQueue.add(task); }\n        private final Future<V> task;\n    }\n...\n public Future<V> take() throws InterruptedException {\n        return completionQueue.take();\n    }\n\n    public Future<V> poll() {\n        return completionQueue.poll();\n    }\n\n    public Future<V> poll(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        return completionQueue.poll(timeout, unit);\n    }\n```\n\n- 示例：使用CompletionService实现页面渲染\n\n通过CompletionService从**缩短总运行时间**和**提高相应性**两个方面提高渲染性能，为每幅图像下载创建一个独立的任务，并在线程池中执行他们，从而将串行的下载转换为并行的过程，这将减少总下载时间；通过CompletionService中获取结果以及使每张图片在下载完后立刻显示出来，提高了响应性。\n\n```java\n/**\n * @author harold\n * @Title:\n * @Description: 使用CompletionService实现页面渲染\n * @date 2018/5/24上午11:17\n */\npublic class Renderer {\n    public final ExecutorService executor;\n    Renderer(ExecutorService executor) {\n        this.executor = executor;\n    }\n    \n    void renderPage(CharSequence source) {\n        List<ImageInfo> info = scanForImageInfo(source);\n        CompletionService <ImageData> completionService = new ExecutorCompletionService<ImageData>(executor);\n        for (final ImageInfo imageInfo : info) {\n            completionService.submit(new Callable<ImageData>() {\n                @Override\n                public ImageData call() throws Exception {\n                    return imageInfo.downloadImage();\n                }\n            });\n        }\n        renderText(source);\n        try {\n            for (t = 0, n = info.size(); t<n; t++) {\n                Future<ImageData> f = completionService.take();\n                ImageData imageData = f.get();\n                renderImage(imageData);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } catch (ExecutionException e) {\n            throw launderThrowable(e.getCause());\n        }\n    }\n}\n```\n\n多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。\n\n#### 为任务设置时限\n\n有时候，如果某个任务无法在指定时间内完成，将不再需要它的结果，此时可以放弃这个任务。在有限时间内执行任务的难点在于：要确保得到答案的时间不会超出限定的时间，或者在限定的时间内无法获得答案。Future.get支持这种需求：当结果可用时，他将立即返回，若在指定时间没有计算出来，将抛出TimeoutException。\n\n传递给get的timeout参数的计算方式是将指定时限减去当前时间，这可能会得到负数，但java.util.concurrent中所有与时限相关的方法都将视负数为0.\n\nFuture.cancel参数为true表示任务线程可以在啊运行过程中中断。\n\n```java\n//在指定时间内获取广告时间\n    Page renderPageWithAd() throws InterruptedException {\n        long endNanos = System.nanoTime() + TIME_BUGET;\n        Future<Ad> f = executor.submit(new FetchAdTask());\n        //在等待广告时显示页面\n        Page page = renderPageBody();\n        Ad ad;\n        try {\n            //只等待指定时间长度\n            long timeLeft = endNanos - System.nanoTime();\n            ad = f.get(timeLeft, TimeUnit.NANOSECONDS);\n        } catch (ExecutionException e) {\n            ad = DEFAULT_AD;\n        } catch (TimeoutException e) {\n            ad = DEFAULT_AD;\n            f.cancel(true);\n        }\n        page.setAd(ad);\n        return page;\n    }\n}\n```\n\n- invokeAll\n  创建n个线程，将其提交到一个线程池，保留n个Future，并使用现实的get方法通过Future串行的获取每一个结果，这个过程可以通过更简单的invokeAll实现。\n\n  invokeAll方法的参数为一组任务，并返回一组Future。这两个集合有着相同的结构。invokeAll按照任务集合中迭代器的顺序将所有Future添加到返回集合中，从而使调用者可以将各个Future与其表示的Callable关联起来。当所有任务都执行完毕后，或者调用线程被中断时没或者超过指定时间，invokeAll将返回。当超过指定时限后，任何还未完成的任务都会取消。当invokeAll返回后，每个任务要么正常执行完毕，要么被取消。客户端代码可以用get或isCanceled判断情况。\n\n\n\n","source":"_posts/Java并发编程——结构化并发应用程序2.md","raw":"---\ntitle: Java并发编程——结构化并发应用程序(二)\ndate: 2018-05-27 00:36:58\ntags: [Java, 多线程, 并发]\n---\n\n#### CompletionService：Executor和BlockingQueue\n\n若向Executor提交了一组计算任务，并希望在计算技术之后获得结果，有一下两种方法：\n\n> - 保留与任务关联的Future，反复使用get方法，同时将参数timeout指定为0，从而通过轮训判断任务是否完成\n> - 使用完成服务（CompletionService）\n\n**CompletionService：**                     CompletionService将Executor和BlockingQueue功能结合起来，可以将Callable任务提交给它来执行，然后使用类似队列操作的take和poll等方法获得已经完成的结果，这些结果会**在完成时**被封装为Future。\n<!-- more--> \nExecutorCompletionService实现了CompletionService，并将计算部分委托给了一个Executor。实现方式：在构造函数中创建一个BlockingQueue来保存完成的结果，计算完成时，调用Future-Task中的done方法，当提交某个任务时，该任务首先将包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，将结果放入BlockingQueue中。take和poll方法委托给了BlockingQueue，这些方法会在得出结果之前阻塞。\n\n```java\n//ExecutorCompletionService部分源码\npublic class ExecutorCompletionService<V> implements CompletionService<V> {\n    private final Executor executor;\n    private final AbstractExecutorService aes;\n    private final BlockingQueue<Future<V>> completionQueue;\n\n    /**\n     * FutureTask extension to enqueue upon completion\n     */\n    private class QueueingFuture extends FutureTask<Void> {\n        QueueingFuture(RunnableFuture<V> task) {\n            super(task, null);\n            this.task = task;\n        }\n        protected void done() { completionQueue.add(task); }\n        private final Future<V> task;\n    }\n...\n public Future<V> take() throws InterruptedException {\n        return completionQueue.take();\n    }\n\n    public Future<V> poll() {\n        return completionQueue.poll();\n    }\n\n    public Future<V> poll(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        return completionQueue.poll(timeout, unit);\n    }\n```\n\n- 示例：使用CompletionService实现页面渲染\n\n通过CompletionService从**缩短总运行时间**和**提高相应性**两个方面提高渲染性能，为每幅图像下载创建一个独立的任务，并在线程池中执行他们，从而将串行的下载转换为并行的过程，这将减少总下载时间；通过CompletionService中获取结果以及使每张图片在下载完后立刻显示出来，提高了响应性。\n\n```java\n/**\n * @author harold\n * @Title:\n * @Description: 使用CompletionService实现页面渲染\n * @date 2018/5/24上午11:17\n */\npublic class Renderer {\n    public final ExecutorService executor;\n    Renderer(ExecutorService executor) {\n        this.executor = executor;\n    }\n    \n    void renderPage(CharSequence source) {\n        List<ImageInfo> info = scanForImageInfo(source);\n        CompletionService <ImageData> completionService = new ExecutorCompletionService<ImageData>(executor);\n        for (final ImageInfo imageInfo : info) {\n            completionService.submit(new Callable<ImageData>() {\n                @Override\n                public ImageData call() throws Exception {\n                    return imageInfo.downloadImage();\n                }\n            });\n        }\n        renderText(source);\n        try {\n            for (t = 0, n = info.size(); t<n; t++) {\n                Future<ImageData> f = completionService.take();\n                ImageData imageData = f.get();\n                renderImage(imageData);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } catch (ExecutionException e) {\n            throw launderThrowable(e.getCause());\n        }\n    }\n}\n```\n\n多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。\n\n#### 为任务设置时限\n\n有时候，如果某个任务无法在指定时间内完成，将不再需要它的结果，此时可以放弃这个任务。在有限时间内执行任务的难点在于：要确保得到答案的时间不会超出限定的时间，或者在限定的时间内无法获得答案。Future.get支持这种需求：当结果可用时，他将立即返回，若在指定时间没有计算出来，将抛出TimeoutException。\n\n传递给get的timeout参数的计算方式是将指定时限减去当前时间，这可能会得到负数，但java.util.concurrent中所有与时限相关的方法都将视负数为0.\n\nFuture.cancel参数为true表示任务线程可以在啊运行过程中中断。\n\n```java\n//在指定时间内获取广告时间\n    Page renderPageWithAd() throws InterruptedException {\n        long endNanos = System.nanoTime() + TIME_BUGET;\n        Future<Ad> f = executor.submit(new FetchAdTask());\n        //在等待广告时显示页面\n        Page page = renderPageBody();\n        Ad ad;\n        try {\n            //只等待指定时间长度\n            long timeLeft = endNanos - System.nanoTime();\n            ad = f.get(timeLeft, TimeUnit.NANOSECONDS);\n        } catch (ExecutionException e) {\n            ad = DEFAULT_AD;\n        } catch (TimeoutException e) {\n            ad = DEFAULT_AD;\n            f.cancel(true);\n        }\n        page.setAd(ad);\n        return page;\n    }\n}\n```\n\n- invokeAll\n  创建n个线程，将其提交到一个线程池，保留n个Future，并使用现实的get方法通过Future串行的获取每一个结果，这个过程可以通过更简单的invokeAll实现。\n\n  invokeAll方法的参数为一组任务，并返回一组Future。这两个集合有着相同的结构。invokeAll按照任务集合中迭代器的顺序将所有Future添加到返回集合中，从而使调用者可以将各个Future与其表示的Callable关联起来。当所有任务都执行完毕后，或者调用线程被中断时没或者超过指定时间，invokeAll将返回。当超过指定时限后，任何还未完成的任务都会取消。当invokeAll返回后，每个任务要么正常执行完毕，要么被取消。客户端代码可以用get或isCanceled判断情况。\n\n\n\n","slug":"Java并发编程——结构化并发应用程序2","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6g000ecf96i5ex4dn1","content":"<h4 id=\"CompletionService：Executor和BlockingQueue\"><a href=\"#CompletionService：Executor和BlockingQueue\" class=\"headerlink\" title=\"CompletionService：Executor和BlockingQueue\"></a>CompletionService：Executor和BlockingQueue</h4><p>若向Executor提交了一组计算任务，并希望在计算技术之后获得结果，有一下两种方法：</p>\n<blockquote>\n<ul>\n<li>保留与任务关联的Future，反复使用get方法，同时将参数timeout指定为0，从而通过轮训判断任务是否完成</li>\n<li>使用完成服务（CompletionService）</li>\n</ul>\n</blockquote>\n<p><strong>CompletionService：</strong>                     CompletionService将Executor和BlockingQueue功能结合起来，可以将Callable任务提交给它来执行，然后使用类似队列操作的take和poll等方法获得已经完成的结果，这些结果会<strong>在完成时</strong>被封装为Future。<br><a id=\"more\"></a><br>ExecutorCompletionService实现了CompletionService，并将计算部分委托给了一个Executor。实现方式：在构造函数中创建一个BlockingQueue来保存完成的结果，计算完成时，调用Future-Task中的done方法，当提交某个任务时，该任务首先将包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，将结果放入BlockingQueue中。take和poll方法委托给了BlockingQueue，这些方法会在得出结果之前阻塞。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ExecutorCompletionService部分源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorCompletionService</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CompletionService</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Executor executor;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractExecutorService aes;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * FutureTask extension to enqueue upon completion</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueingFuture</span> <span class=\"keyword\">extends</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">Void</span>&gt; </span>&#123;</span><br><span class=\"line\">        QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Future&lt;V&gt; task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> completionQueue.take();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> completionQueue.poll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> completionQueue.poll(timeout, unit);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>示例：使用CompletionService实现页面渲染</li>\n</ul>\n<p>通过CompletionService从<strong>缩短总运行时间</strong>和<strong>提高相应性</strong>两个方面提高渲染性能，为每幅图像下载创建一个独立的任务，并在线程池中执行他们，从而将串行的下载转换为并行的过程，这将减少总下载时间；通过CompletionService中获取结果以及使每张图片在下载完后立刻显示出来，提高了响应性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 使用CompletionService实现页面渲染</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/24上午11:17</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Renderer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ExecutorService executor;</span><br><span class=\"line\">    Renderer(ExecutorService executor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">renderPage</span><span class=\"params\">(CharSequence source)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class=\"line\">        CompletionService &lt;ImageData&gt; completionService = <span class=\"keyword\">new</span> ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> ImageInfo imageInfo : info) &#123;</span><br><span class=\"line\">            completionService.submit(<span class=\"keyword\">new</span> Callable&lt;ImageData&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> ImageData <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> imageInfo.downloadImage();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        renderText(source);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (t = <span class=\"number\">0</span>, n = info.size(); t&lt;n; t++) &#123;</span><br><span class=\"line\">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class=\"line\">                ImageData imageData = f.get();</span><br><span class=\"line\">                renderImage(imageData);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> launderThrowable(e.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。</p>\n<h4 id=\"为任务设置时限\"><a href=\"#为任务设置时限\" class=\"headerlink\" title=\"为任务设置时限\"></a>为任务设置时限</h4><p>有时候，如果某个任务无法在指定时间内完成，将不再需要它的结果，此时可以放弃这个任务。在有限时间内执行任务的难点在于：要确保得到答案的时间不会超出限定的时间，或者在限定的时间内无法获得答案。Future.get支持这种需求：当结果可用时，他将立即返回，若在指定时间没有计算出来，将抛出TimeoutException。</p>\n<p>传递给get的timeout参数的计算方式是将指定时限减去当前时间，这可能会得到负数，但java.util.concurrent中所有与时限相关的方法都将视负数为0.</p>\n<p>Future.cancel参数为true表示任务线程可以在啊运行过程中中断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在指定时间内获取广告时间</span></span><br><span class=\"line\">    <span class=\"function\">Page <span class=\"title\">renderPageWithAd</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> endNanos = System.nanoTime() + TIME_BUGET;</span><br><span class=\"line\">        Future&lt;Ad&gt; f = executor.submit(<span class=\"keyword\">new</span> FetchAdTask());</span><br><span class=\"line\">        <span class=\"comment\">//在等待广告时显示页面</span></span><br><span class=\"line\">        Page page = renderPageBody();</span><br><span class=\"line\">        Ad ad;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//只等待指定时间长度</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class=\"line\">            ad = f.get(timeLeft, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            ad = DEFAULT_AD;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">            ad = DEFAULT_AD;</span><br><span class=\"line\">            f.cancel(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        page.setAd(ad);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> page;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>invokeAll<br>创建n个线程，将其提交到一个线程池，保留n个Future，并使用现实的get方法通过Future串行的获取每一个结果，这个过程可以通过更简单的invokeAll实现。</p>\n<p>invokeAll方法的参数为一组任务，并返回一组Future。这两个集合有着相同的结构。invokeAll按照任务集合中迭代器的顺序将所有Future添加到返回集合中，从而使调用者可以将各个Future与其表示的Callable关联起来。当所有任务都执行完毕后，或者调用线程被中断时没或者超过指定时间，invokeAll将返回。当超过指定时限后，任何还未完成的任务都会取消。当invokeAll返回后，每个任务要么正常执行完毕，要么被取消。客户端代码可以用get或isCanceled判断情况。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"CompletionService：Executor和BlockingQueue\"><a href=\"#CompletionService：Executor和BlockingQueue\" class=\"headerlink\" title=\"CompletionService：Executor和BlockingQueue\"></a>CompletionService：Executor和BlockingQueue</h4><p>若向Executor提交了一组计算任务，并希望在计算技术之后获得结果，有一下两种方法：</p>\n<blockquote>\n<ul>\n<li>保留与任务关联的Future，反复使用get方法，同时将参数timeout指定为0，从而通过轮训判断任务是否完成</li>\n<li>使用完成服务（CompletionService）</li>\n</ul>\n</blockquote>\n<p><strong>CompletionService：</strong>                     CompletionService将Executor和BlockingQueue功能结合起来，可以将Callable任务提交给它来执行，然后使用类似队列操作的take和poll等方法获得已经完成的结果，这些结果会<strong>在完成时</strong>被封装为Future。<br>","more":"<br>ExecutorCompletionService实现了CompletionService，并将计算部分委托给了一个Executor。实现方式：在构造函数中创建一个BlockingQueue来保存完成的结果，计算完成时，调用Future-Task中的done方法，当提交某个任务时，该任务首先将包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，将结果放入BlockingQueue中。take和poll方法委托给了BlockingQueue，这些方法会在得出结果之前阻塞。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ExecutorCompletionService部分源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorCompletionService</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CompletionService</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Executor executor;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractExecutorService aes;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * FutureTask extension to enqueue upon completion</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueingFuture</span> <span class=\"keyword\">extends</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">Void</span>&gt; </span>&#123;</span><br><span class=\"line\">        QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Future&lt;V&gt; task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> completionQueue.take();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> completionQueue.poll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> completionQueue.poll(timeout, unit);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>示例：使用CompletionService实现页面渲染</li>\n</ul>\n<p>通过CompletionService从<strong>缩短总运行时间</strong>和<strong>提高相应性</strong>两个方面提高渲染性能，为每幅图像下载创建一个独立的任务，并在线程池中执行他们，从而将串行的下载转换为并行的过程，这将减少总下载时间；通过CompletionService中获取结果以及使每张图片在下载完后立刻显示出来，提高了响应性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 使用CompletionService实现页面渲染</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/5/24上午11:17</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Renderer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ExecutorService executor;</span><br><span class=\"line\">    Renderer(ExecutorService executor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">renderPage</span><span class=\"params\">(CharSequence source)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class=\"line\">        CompletionService &lt;ImageData&gt; completionService = <span class=\"keyword\">new</span> ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> ImageInfo imageInfo : info) &#123;</span><br><span class=\"line\">            completionService.submit(<span class=\"keyword\">new</span> Callable&lt;ImageData&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> ImageData <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> imageInfo.downloadImage();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        renderText(source);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (t = <span class=\"number\">0</span>, n = info.size(); t&lt;n; t++) &#123;</span><br><span class=\"line\">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class=\"line\">                ImageData imageData = f.get();</span><br><span class=\"line\">                renderImage(imageData);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> launderThrowable(e.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。</p>\n<h4 id=\"为任务设置时限\"><a href=\"#为任务设置时限\" class=\"headerlink\" title=\"为任务设置时限\"></a>为任务设置时限</h4><p>有时候，如果某个任务无法在指定时间内完成，将不再需要它的结果，此时可以放弃这个任务。在有限时间内执行任务的难点在于：要确保得到答案的时间不会超出限定的时间，或者在限定的时间内无法获得答案。Future.get支持这种需求：当结果可用时，他将立即返回，若在指定时间没有计算出来，将抛出TimeoutException。</p>\n<p>传递给get的timeout参数的计算方式是将指定时限减去当前时间，这可能会得到负数，但java.util.concurrent中所有与时限相关的方法都将视负数为0.</p>\n<p>Future.cancel参数为true表示任务线程可以在啊运行过程中中断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在指定时间内获取广告时间</span></span><br><span class=\"line\">    <span class=\"function\">Page <span class=\"title\">renderPageWithAd</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> endNanos = System.nanoTime() + TIME_BUGET;</span><br><span class=\"line\">        Future&lt;Ad&gt; f = executor.submit(<span class=\"keyword\">new</span> FetchAdTask());</span><br><span class=\"line\">        <span class=\"comment\">//在等待广告时显示页面</span></span><br><span class=\"line\">        Page page = renderPageBody();</span><br><span class=\"line\">        Ad ad;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//只等待指定时间长度</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class=\"line\">            ad = f.get(timeLeft, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            ad = DEFAULT_AD;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">            ad = DEFAULT_AD;</span><br><span class=\"line\">            f.cancel(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        page.setAd(ad);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> page;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>invokeAll<br>创建n个线程，将其提交到一个线程池，保留n个Future，并使用现实的get方法通过Future串行的获取每一个结果，这个过程可以通过更简单的invokeAll实现。</p>\n<p>invokeAll方法的参数为一组任务，并返回一组Future。这两个集合有着相同的结构。invokeAll按照任务集合中迭代器的顺序将所有Future添加到返回集合中，从而使调用者可以将各个Future与其表示的Callable关联起来。当所有任务都执行完毕后，或者调用线程被中断时没或者超过指定时间，invokeAll将返回。当超过指定时限后，任何还未完成的任务都会取消。当invokeAll返回后，每个任务要么正常执行完毕，要么被取消。客户端代码可以用get或isCanceled判断情况。</p>\n</li>\n</ul>"},{"title":"KMP算法","date":"2018-03-29T12:28:00.000Z","_content":"在编辑文本程序过程中，经常需要在文本中找到某个模式的所有出现位置。典型情况是，一段正在被编辑的文本构成一个文件，而所要搜寻的模式是用户正在输入的特定的关键字。有效的解决这个问题的算法叫做字符串匹配算法，该算法能极大提高编辑文本程序时的响应效率。\n\n\nKMP算法是一种改进的字符串匹配算法，它的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。我们以一道字符串匹配的题目来学习KMP算法。\n  <!-- more-->\n***题目：***\n对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。\n**样例1**：\n*输入* \"abab\"\n*输出* True\n*样例解释：*输入可由\"ab\"重复两次组成\n --\n**样例2**：\n*输入* \"aba\"\n*输出* False\n\n***思路1：***\n笔者在看到题的第一眼产生的想法是非常质朴的遍历，枚举出字符串所有长度为lenSub的子串，然后将字符串分割成长度为lenSub的串，挨个与字串比较，如果相同则返回true，否则返回false\n\n***代码1***\n```java\npublic static int strStr(String source) {\n        int n = source.length();\n       for (int i=1; i<=source.length()/2; i++) {\n           String substr = source.substring(0,i);\n           boolean flag = true;\n           if ((n-i) % i == 0){\n               int div = n/i;\n               String other = null;\n               for (int j=1; j<div; j++){\n                   other = source.substring(i*j,i*j+i);\n                   if (!other.equals(substr)) {\n                       flag = false;\n                       break;\n                   }\n               }\n               if (flag == true)\n                   return 1;\n           }\n       }\n       return -1;\n    }```\n***思路2：KMP算法***\n由kmp算法中的next数组实现。\n1. 字符串s的下标从0到n-1，n为字符串长度，记s(i)表示s的第i位字符，s(i,j)表示从s的第i位到第j位的子字符串，若i>j，则s(i,j)=””(空串）。\n1. next数组的定义为：next(i)=p，表示p为小于i且满足s(0 , p) = s(i-p , i)的最大的p，如果不存在这样的p，则next(i) = -1，显然next(0) = -1。我们可以用O(n)的时间计算出next数组。假设我们已知next(0)，next(1)，……，next(i-1) ，现在要求next(i)，不妨设next(i-1) = j0，则由next数组定义可知s(0 , j0) = s(i-1-j0 , i-1)。\n * 若s(j0+1) = s(i)，则结合s(0 , j0) = s(i-1-j0 , i-1)可知s(0 , j0+1) = s(i - (j0+1) , i)，由此可知，next(i)=j0+1。\n\n  * 若s(j0+1)!=s(i)但s(next(j0)+1)=s(i)，记j1=next(j0)，则s(j1+1)=s(i)，由next数组的定义，s(0 , j1) = s(j0 - j1 , j0) = s(i - 1 - j1 , i - 1)，即s(0，j1) = s(i - 1 - j1 , i - 1)，由假设s(j1+1) = s(i)，则s(0 , j1+1) = s(i - (j1+1) , i)，故next(i) = j1+1。\n\n * 同前两步的分析，如果我们能找到一个k，使得对于所有小于k的k0，s(j(k0)+1)!=s(i)，但有s(j(k)+1) = s(i)，则由next数组的定义可以得到next(i)=j(k)+1，否则需进一步考虑j(k+1) = next(j(k))，如果我们找不到这样的k，则next(i)=-1。\n\n1. 对于字符串s，如果j满足，0<=j<=n-1，且s(0，j) = s(n-1-j，n-1)，令k=n-1-j，若k整除n，不妨设n=mk，则s(0，(m-1)k - 1) = s(k，mk - 1)，即s(0，k-1) = s(k，2k-1) = …… = s((m-1)k - 1，mk - 1)，即s满足题设条件。故要判断s是否为重复子串组成，只需找到满足上述条件的j，且k整除n，即说明s满足条件，否则不满足。\n\n1. 利用已算出的next(n-1)，令k=n-1-next(n-1)，由c可知，若k整除n，且k<n，则s满足条件，否则不满足。上述算法的复杂度可证明为O(n)。\n\n***代码2***\n```java\npublic static int KMP(String source) {\n        int l = source.length();\n        int [] next = new int[l];\n        next[0] = -1;\n        int i, j=-1;\n        for (i = 1; i < l; i++) {\n            while (j >= 0 && source.charAt(i) != source.charAt(j+1)) {\n                j = next[j];\n            }\n            if (source.charAt(i) == source.charAt(j+1)) {\n                j++;\n            }\n            next[i] = j;\n        }\n        int lenSub = l-1-next[l - 1];\n        return lenSub != l && l%lenSub == 0 ? 1 : -1;\n    }```","source":"_posts/KMP算法.md","raw":"---\ntitle: KMP算法\ndate: 2018-03-29 20:28:00\ntags: [算法, 字符串匹配]\n---\n在编辑文本程序过程中，经常需要在文本中找到某个模式的所有出现位置。典型情况是，一段正在被编辑的文本构成一个文件，而所要搜寻的模式是用户正在输入的特定的关键字。有效的解决这个问题的算法叫做字符串匹配算法，该算法能极大提高编辑文本程序时的响应效率。\n\n\nKMP算法是一种改进的字符串匹配算法，它的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。我们以一道字符串匹配的题目来学习KMP算法。\n  <!-- more-->\n***题目：***\n对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。\n**样例1**：\n*输入* \"abab\"\n*输出* True\n*样例解释：*输入可由\"ab\"重复两次组成\n --\n**样例2**：\n*输入* \"aba\"\n*输出* False\n\n***思路1：***\n笔者在看到题的第一眼产生的想法是非常质朴的遍历，枚举出字符串所有长度为lenSub的子串，然后将字符串分割成长度为lenSub的串，挨个与字串比较，如果相同则返回true，否则返回false\n\n***代码1***\n```java\npublic static int strStr(String source) {\n        int n = source.length();\n       for (int i=1; i<=source.length()/2; i++) {\n           String substr = source.substring(0,i);\n           boolean flag = true;\n           if ((n-i) % i == 0){\n               int div = n/i;\n               String other = null;\n               for (int j=1; j<div; j++){\n                   other = source.substring(i*j,i*j+i);\n                   if (!other.equals(substr)) {\n                       flag = false;\n                       break;\n                   }\n               }\n               if (flag == true)\n                   return 1;\n           }\n       }\n       return -1;\n    }```\n***思路2：KMP算法***\n由kmp算法中的next数组实现。\n1. 字符串s的下标从0到n-1，n为字符串长度，记s(i)表示s的第i位字符，s(i,j)表示从s的第i位到第j位的子字符串，若i>j，则s(i,j)=””(空串）。\n1. next数组的定义为：next(i)=p，表示p为小于i且满足s(0 , p) = s(i-p , i)的最大的p，如果不存在这样的p，则next(i) = -1，显然next(0) = -1。我们可以用O(n)的时间计算出next数组。假设我们已知next(0)，next(1)，……，next(i-1) ，现在要求next(i)，不妨设next(i-1) = j0，则由next数组定义可知s(0 , j0) = s(i-1-j0 , i-1)。\n * 若s(j0+1) = s(i)，则结合s(0 , j0) = s(i-1-j0 , i-1)可知s(0 , j0+1) = s(i - (j0+1) , i)，由此可知，next(i)=j0+1。\n\n  * 若s(j0+1)!=s(i)但s(next(j0)+1)=s(i)，记j1=next(j0)，则s(j1+1)=s(i)，由next数组的定义，s(0 , j1) = s(j0 - j1 , j0) = s(i - 1 - j1 , i - 1)，即s(0，j1) = s(i - 1 - j1 , i - 1)，由假设s(j1+1) = s(i)，则s(0 , j1+1) = s(i - (j1+1) , i)，故next(i) = j1+1。\n\n * 同前两步的分析，如果我们能找到一个k，使得对于所有小于k的k0，s(j(k0)+1)!=s(i)，但有s(j(k)+1) = s(i)，则由next数组的定义可以得到next(i)=j(k)+1，否则需进一步考虑j(k+1) = next(j(k))，如果我们找不到这样的k，则next(i)=-1。\n\n1. 对于字符串s，如果j满足，0<=j<=n-1，且s(0，j) = s(n-1-j，n-1)，令k=n-1-j，若k整除n，不妨设n=mk，则s(0，(m-1)k - 1) = s(k，mk - 1)，即s(0，k-1) = s(k，2k-1) = …… = s((m-1)k - 1，mk - 1)，即s满足题设条件。故要判断s是否为重复子串组成，只需找到满足上述条件的j，且k整除n，即说明s满足条件，否则不满足。\n\n1. 利用已算出的next(n-1)，令k=n-1-next(n-1)，由c可知，若k整除n，且k<n，则s满足条件，否则不满足。上述算法的复杂度可证明为O(n)。\n\n***代码2***\n```java\npublic static int KMP(String source) {\n        int l = source.length();\n        int [] next = new int[l];\n        next[0] = -1;\n        int i, j=-1;\n        for (i = 1; i < l; i++) {\n            while (j >= 0 && source.charAt(i) != source.charAt(j+1)) {\n                j = next[j];\n            }\n            if (source.charAt(i) == source.charAt(j+1)) {\n                j++;\n            }\n            next[i] = j;\n        }\n        int lenSub = l-1-next[l - 1];\n        return lenSub != l && l%lenSub == 0 ? 1 : -1;\n    }```","slug":"KMP算法","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6i000gcf960bpdaodu","content":"<p>在编辑文本程序过程中，经常需要在文本中找到某个模式的所有出现位置。典型情况是，一段正在被编辑的文本构成一个文件，而所要搜寻的模式是用户正在输入的特定的关键字。有效的解决这个问题的算法叫做字符串匹配算法，该算法能极大提高编辑文本程序时的响应效率。</p>\n<p>KMP算法是一种改进的字符串匹配算法，它的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。我们以一道字符串匹配的题目来学习KMP算法。<br>  <a id=\"more\"></a><br><strong><em>题目：</em></strong><br>对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。<br><strong>样例1</strong>：<br><em>输入</em> “abab”<br><em>输出</em> True</p>\n<h2 id=\"样例解释：输入可由”ab”重复两次组成\"><a href=\"#样例解释：输入可由”ab”重复两次组成\" class=\"headerlink\" title=\"样例解释：输入可由”ab”重复两次组成\"></a><em>样例解释：</em>输入可由”ab”重复两次组成</h2><p><strong>样例2</strong>：<br><em>输入</em> “aba”<br><em>输出</em> False</p>\n<p><strong><em>思路1：</em></strong><br>笔者在看到题的第一眼产生的想法是非常质朴的遍历，枚举出字符串所有长度为lenSub的子串，然后将字符串分割成长度为lenSub的串，挨个与字串比较，如果相同则返回true，否则返回false</p>\n<p><strong><em>代码1</em></strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = source.length();</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=source.length()/<span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">           String substr = source.substring(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">           <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((n-i) % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> div = n/i;</span><br><span class=\"line\">               String other = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;div; j++)&#123;</span><br><span class=\"line\">                   other = source.substring(i*j,i*j+i);</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (!other.equals(substr)) &#123;</span><br><span class=\"line\">                       flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (flag == <span class=\"keyword\">true</span>)</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>思路2：KMP算法</em></strong><br>由kmp算法中的next数组实现。</p>\n<ol>\n<li>字符串s的下标从0到n-1，n为字符串长度，记s(i)表示s的第i位字符，s(i,j)表示从s的第i位到第j位的子字符串，若i&gt;j，则s(i,j)=””(空串）。</li>\n<li><p>next数组的定义为：next(i)=p，表示p为小于i且满足s(0 , p) = s(i-p , i)的最大的p，如果不存在这样的p，则next(i) = -1，显然next(0) = -1。我们可以用O(n)的时间计算出next数组。假设我们已知next(0)，next(1)，……，next(i-1) ，现在要求next(i)，不妨设next(i-1) = j0，则由next数组定义可知s(0 , j0) = s(i-1-j0 , i-1)。</p>\n<ul>\n<li><p>若s(j0+1) = s(i)，则结合s(0 , j0) = s(i-1-j0 , i-1)可知s(0 , j0+1) = s(i - (j0+1) , i)，由此可知，next(i)=j0+1。</p>\n</li>\n<li><p>若s(j0+1)!=s(i)但s(next(j0)+1)=s(i)，记j1=next(j0)，则s(j1+1)=s(i)，由next数组的定义，s(0 , j1) = s(j0 - j1 , j0) = s(i - 1 - j1 , i - 1)，即s(0，j1) = s(i - 1 - j1 , i - 1)，由假设s(j1+1) = s(i)，则s(0 , j1+1) = s(i - (j1+1) , i)，故next(i) = j1+1。</p>\n</li>\n<li><p>同前两步的分析，如果我们能找到一个k，使得对于所有小于k的k0，s(j(k0)+1)!=s(i)，但有s(j(k)+1) = s(i)，则由next数组的定义可以得到next(i)=j(k)+1，否则需进一步考虑j(k+1) = next(j(k))，如果我们找不到这样的k，则next(i)=-1。</p>\n</li>\n</ul>\n</li>\n<li><p>对于字符串s，如果j满足，0&lt;=j&lt;=n-1，且s(0，j) = s(n-1-j，n-1)，令k=n-1-j，若k整除n，不妨设n=mk，则s(0，(m-1)k - 1) = s(k，mk - 1)，即s(0，k-1) = s(k，2k-1) = …… = s((m-1)k - 1，mk - 1)，即s满足题设条件。故要判断s是否为重复子串组成，只需找到满足上述条件的j，且k整除n，即说明s满足条件，否则不满足。</p>\n</li>\n<li><p>利用已算出的next(n-1)，令k=n-1-next(n-1)，由c可知，若k整除n，且k&lt;n，则s满足条件，否则不满足。上述算法的复杂度可证明为O(n)。</p>\n</li>\n</ol>\n<p><strong><em>代码2</em></strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(String source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = source.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> [] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[l];</span><br><span class=\"line\">        next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j=-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; source.charAt(i) != source.charAt(j+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (source.charAt(i) == source.charAt(j+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenSub = l-<span class=\"number\">1</span>-next[l - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lenSub != l &amp;&amp; l%lenSub == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>在编辑文本程序过程中，经常需要在文本中找到某个模式的所有出现位置。典型情况是，一段正在被编辑的文本构成一个文件，而所要搜寻的模式是用户正在输入的特定的关键字。有效的解决这个问题的算法叫做字符串匹配算法，该算法能极大提高编辑文本程序时的响应效率。</p>\n<p>KMP算法是一种改进的字符串匹配算法，它的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。我们以一道字符串匹配的题目来学习KMP算法。<br>","more":"<br><strong><em>题目：</em></strong><br>对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。<br><strong>样例1</strong>：<br><em>输入</em> “abab”<br><em>输出</em> True</p>\n<h2 id=\"样例解释：输入可由”ab”重复两次组成\"><a href=\"#样例解释：输入可由”ab”重复两次组成\" class=\"headerlink\" title=\"样例解释：输入可由”ab”重复两次组成\"></a><em>样例解释：</em>输入可由”ab”重复两次组成</h2><p><strong>样例2</strong>：<br><em>输入</em> “aba”<br><em>输出</em> False</p>\n<p><strong><em>思路1：</em></strong><br>笔者在看到题的第一眼产生的想法是非常质朴的遍历，枚举出字符串所有长度为lenSub的子串，然后将字符串分割成长度为lenSub的串，挨个与字串比较，如果相同则返回true，否则返回false</p>\n<p><strong><em>代码1</em></strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = source.length();</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=source.length()/<span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">           String substr = source.substring(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">           <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((n-i) % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> div = n/i;</span><br><span class=\"line\">               String other = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;div; j++)&#123;</span><br><span class=\"line\">                   other = source.substring(i*j,i*j+i);</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (!other.equals(substr)) &#123;</span><br><span class=\"line\">                       flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (flag == <span class=\"keyword\">true</span>)</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>思路2：KMP算法</em></strong><br>由kmp算法中的next数组实现。</p>\n<ol>\n<li>字符串s的下标从0到n-1，n为字符串长度，记s(i)表示s的第i位字符，s(i,j)表示从s的第i位到第j位的子字符串，若i&gt;j，则s(i,j)=””(空串）。</li>\n<li><p>next数组的定义为：next(i)=p，表示p为小于i且满足s(0 , p) = s(i-p , i)的最大的p，如果不存在这样的p，则next(i) = -1，显然next(0) = -1。我们可以用O(n)的时间计算出next数组。假设我们已知next(0)，next(1)，……，next(i-1) ，现在要求next(i)，不妨设next(i-1) = j0，则由next数组定义可知s(0 , j0) = s(i-1-j0 , i-1)。</p>\n<ul>\n<li><p>若s(j0+1) = s(i)，则结合s(0 , j0) = s(i-1-j0 , i-1)可知s(0 , j0+1) = s(i - (j0+1) , i)，由此可知，next(i)=j0+1。</p>\n</li>\n<li><p>若s(j0+1)!=s(i)但s(next(j0)+1)=s(i)，记j1=next(j0)，则s(j1+1)=s(i)，由next数组的定义，s(0 , j1) = s(j0 - j1 , j0) = s(i - 1 - j1 , i - 1)，即s(0，j1) = s(i - 1 - j1 , i - 1)，由假设s(j1+1) = s(i)，则s(0 , j1+1) = s(i - (j1+1) , i)，故next(i) = j1+1。</p>\n</li>\n<li><p>同前两步的分析，如果我们能找到一个k，使得对于所有小于k的k0，s(j(k0)+1)!=s(i)，但有s(j(k)+1) = s(i)，则由next数组的定义可以得到next(i)=j(k)+1，否则需进一步考虑j(k+1) = next(j(k))，如果我们找不到这样的k，则next(i)=-1。</p>\n</li>\n</ul>\n</li>\n<li><p>对于字符串s，如果j满足，0&lt;=j&lt;=n-1，且s(0，j) = s(n-1-j，n-1)，令k=n-1-j，若k整除n，不妨设n=mk，则s(0，(m-1)k - 1) = s(k，mk - 1)，即s(0，k-1) = s(k，2k-1) = …… = s((m-1)k - 1，mk - 1)，即s满足题设条件。故要判断s是否为重复子串组成，只需找到满足上述条件的j，且k整除n，即说明s满足条件，否则不满足。</p>\n</li>\n<li><p>利用已算出的next(n-1)，令k=n-1-next(n-1)，由c可知，若k整除n，且k&lt;n，则s满足条件，否则不满足。上述算法的复杂度可证明为O(n)。</p>\n</li>\n</ol>\n<p><strong><em>代码2</em></strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(String source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = source.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> [] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[l];</span><br><span class=\"line\">        next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j=-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; source.charAt(i) != source.charAt(j+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (source.charAt(i) == source.charAt(j+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenSub = l-<span class=\"number\">1</span>-next[l - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lenSub != l &amp;&amp; l%lenSub == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"Kafka中Consumer的多线程实现","date":"2018-05-26T16:21:12.000Z","_content":"\n【转自：http://www.cnblogs.com/huxi2b/p/6124937.html】\n\nKafka 0.9版本开始推出了Java版本的consumer，优化了coordinator的设计以及摆脱了对zookeeper的依赖。社区最近也在探讨正式用这套consumer API替换Scala版本的consumer的计划。鉴于目前这方面的资料并不是很多，本文将尝试给出一个利用KafkaConsumer编写的多线程消费者实例，希望对大家有所帮助。\n\n<!-- more-->    这套API最重要的入口就是KafkaConsumer(o.a.k.clients.consumer.KafkaConsumer)，普通的单线程使用方法官网API已有介绍，这里不再赘述了。因此，我们直奔主题——讨论一下如何创建多线程的方式来使用KafkaConsumer。KafkaConsumer和KafkaProducer不同，后者是线程安全的，因此我们鼓励用户在多个线程中共享一个KafkaProducer实例，这样通常都要比每个线程维护一个KafkaProducer实例效率要高。但对于KafkaConsumer而言，它不是线程安全的，所以实现多线程时通常由两种实现方法：\n\n1 每个线程维护一个KafkaConsumer\n\n![img](https://images2015.cnblogs.com/blog/735367/201612/735367-20161202105906443-1609157006.png)\n\n2  维护一个或多个KafkaConsumer，同时维护多个事件处理线程(worker thread)\n\n![img](https://images2015.cnblogs.com/blog/735367/201612/735367-20161202110008787-550483601.png)\n\n当然，这种方法还可以有多个变种：比如每个worker线程有自己的处理队列。consumer根据某种规则或逻辑将消息放入不同的队列。不过总体思想还是相同的，故这里不做过多展开讨论了。\n\n　　下表总结了两种方法的优缺点： \n\n|                                              | 优点                                                         | 缺点                                                         |\n| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 方法1(每个线程维护一个KafkaConsumer)         | 方便实现速度较快，因为不需要任何线程间交互易于维护分区内的消息顺序 | 更多的TCP连接开销(每个线程都要维护若干个TCP连接)consumer数受限于topic分区数，扩展性差频繁请求导致吞吐量下降线程自己处理消费到的消息可能会导致超时，从而造成rebalance |\n| 方法2 (单个(或多个)consumer，多个worker线程) | 可独立扩展consumer数和worker数，伸缩性好                     | 实现麻烦通常难于维护分区内的消息顺序处理链路变长，导致难以保证提交位移的语义正确性 |\n\n \n\n下面我们分别实现这两种方法。需要指出的是，下面的代码都是最基本的实现，并没有考虑很多编程细节，比如如何处理错误等。\n\n**方法1**\n\n**ConsumerRunnable类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 import org.apache.kafka.clients.consumer.ConsumerRecord;\n 2 import org.apache.kafka.clients.consumer.ConsumerRecords;\n 3 import org.apache.kafka.clients.consumer.KafkaConsumer;\n 4 \n 5 import java.util.Arrays;\n 6 import java.util.Properties;\n 7 \n 8 public class ConsumerRunnable implements Runnable {\n 9 \n10     // 每个线程维护私有的KafkaConsumer实例\n11     private final KafkaConsumer<String, String> consumer;\n12 \n13     public ConsumerRunnable(String brokerList, String groupId, String topic) {\n14         Properties props = new Properties();\n15         props.put(\"bootstrap.servers\", brokerList);\n16         props.put(\"group.id\", groupId);\n17         props.put(\"enable.auto.commit\", \"true\");        //本例使用自动提交位移\n18         props.put(\"auto.commit.interval.ms\", \"1000\");\n19         props.put(\"session.timeout.ms\", \"30000\");\n20         props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n21         props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n22         this.consumer = new KafkaConsumer<>(props);\n23         consumer.subscribe(Arrays.asList(topic));   // 本例使用分区副本自动分配策略\n24     }\n25 \n26     @Override\n27     public void run() {\n28         while (true) {\n29             ConsumerRecords<String, String> records = consumer.poll(200);   // 本例使用200ms作为获取超时时间\n30             for (ConsumerRecord<String, String> record : records) {\n31                 // 这里面写处理消息的逻辑，本例中只是简单地打印消息\n32                 System.out.println(Thread.currentThread().getName() + \" consumed \" + record.partition() +\n33                         \"th message with offset: \" + record.offset());\n34             }\n35         }\n36     }\n37 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**ConsumerGroup类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 package com.my.kafka.test;\n 2 \n 3 import java.util.ArrayList;\n 4 import java.util.List;\n 5 \n 6 public class ConsumerGroup {\n 7 \n 8     private List<ConsumerRunnable> consumers;\n 9 \n10     public ConsumerGroup(int consumerNum, String groupId, String topic, String brokerList) {\n11         consumers = new ArrayList<>(consumerNum);\n12         for (int i = 0; i < consumerNum; ++i) {\n13             ConsumerRunnable consumerThread = new ConsumerRunnable(brokerList, groupId, topic);\n14             consumers.add(consumerThread);\n15         }\n16     }\n17 \n18     public void execute() {\n19         for (ConsumerRunnable task : consumers) {\n20             new Thread(task).start();\n21         }\n22     }\n23 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**ConsumerMain类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 public class ConsumerMain {\n 2 \n 3     public static void main(String[] args) {\n 4         String brokerList = \"localhost:9092\";\n 5         String groupId = \"testGroup1\";\n 6         String topic = \"test-topic\";\n 7         int consumerNum = 3;\n 8 \n 9         ConsumerGroup consumerGroup = new ConsumerGroup(consumerNum, groupId, topic, brokerList);\n10         consumerGroup.execute();\n11     }\n12 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n \n\n**方法2**\n\n**Worker类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 import org.apache.kafka.clients.consumer.ConsumerRecord;\n 2 \n 3 public class Worker implements Runnable {\n 4 \n 5     private ConsumerRecord<String, String> consumerRecord;\n 6 \n 7     public Worker(ConsumerRecord record) {\n 8         this.consumerRecord = record;\n 9     }\n10 \n11     @Override\n12     public void run() {\n13         // 这里写你的消息处理逻辑，本例中只是简单地打印消息\n14         System.out.println(Thread.currentThread().getName() + \" consumed \" + consumerRecord.partition()\n15             + \"th message with offset: \" + consumerRecord.offset());\n16     }\n17 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**ConsumerHandler类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 import org.apache.kafka.clients.consumer.ConsumerRecord;\n 2 import org.apache.kafka.clients.consumer.ConsumerRecords;\n 3 import org.apache.kafka.clients.consumer.KafkaConsumer;\n 4 \n 5 import java.util.Arrays;\n 6 import java.util.Properties;\n 7 import java.util.concurrent.ArrayBlockingQueue;\n 8 import java.util.concurrent.ExecutorService;\n 9 import java.util.concurrent.ThreadPoolExecutor;\n10 import java.util.concurrent.TimeUnit;\n11 \n12 public class ConsumerHandler {\n13 \n14     // 本例中使用一个consumer将消息放入后端队列，你当然可以使用前一种方法中的多实例按照某张规则同时把消息放入后端队列\n15     private final KafkaConsumer<String, String> consumer;\n16     private ExecutorService executors;\n17 \n18     public ConsumerHandler(String brokerList, String groupId, String topic) {\n19         Properties props = new Properties();\n20         props.put(\"bootstrap.servers\", brokerList);\n21         props.put(\"group.id\", groupId);\n22         props.put(\"enable.auto.commit\", \"true\");\n23         props.put(\"auto.commit.interval.ms\", \"1000\");\n24         props.put(\"session.timeout.ms\", \"30000\");\n25         props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n26         props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n27         consumer = new KafkaConsumer<>(props);\n28         consumer.subscribe(Arrays.asList(topic));\n29     }\n30 \n31     public void execute(int workerNum) {\n32         executors = new ThreadPoolExecutor(workerNum, workerNum, 0L, TimeUnit.MILLISECONDS,\n33                 new ArrayBlockingQueue<>(1000), new ThreadPoolExecutor.CallerRunsPolicy());\n34 \n35         while (true) {\n36             ConsumerRecords<String, String> records = consumer.poll(200);\n37             for (final ConsumerRecord record : records) {\n38                 executors.submit(new Worker(record));\n39             }\n40         }\n41     }\n42 \n43     public void shutdown() {\n44         if (consumer != null) {\n45             consumer.close();\n46         }\n47         if (executors != null) {\n48             executors.shutdown();\n49         }\n50         try {\n51             if (!executors.awaitTermination(10, TimeUnit.SECONDS)) {\n52                 System.out.println(\"Timeout.... Ignore for this case\");\n53             }\n54         } catch (InterruptedException ignored) {\n55             System.out.println(\"Other thread interrupted this shutdown, ignore for this case.\");\n56             Thread.currentThread().interrupt();\n57         }\n58     }\n59 \n60 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**Main类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 public class Main {\n 2 \n 3     public static void main(String[] args) {\n 4         String brokerList = \"localhost:9092,localhost:9093,localhost:9094\";\n 5         String groupId = \"group2\";\n 6         String topic = \"test-topic\";\n 7         int workerNum = 5;\n 8 \n 9         ConsumerHandler consumers = new ConsumerHandler(brokerList, groupId, topic);\n10         consumers.execute(workerNum);\n11         try {\n12             Thread.sleep(1000000);\n13         } catch (InterruptedException ignored) {}\n14         consumers.shutdown();\n15     }\n16 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n　　总结一下，这两种方法或是模型都有各自的优缺点，在具体使用时需要根据自己实际的业务特点来选取对应的方法。就我个人而言，我比较推崇第二种方法以及背后的思想，即不要将很重的处理逻辑放入消费者的代码中，很多Kafka consumer使用者碰到的各种rebalance超时、coordinator重新选举、心跳无法维持等问题都来源于此。","source":"_posts/Kafka中Consumer的多线程实现.md","raw":"---\ntitle: Kafka中Consumer的多线程实现\ndate: 2018-05-27 00:21:12\ntags: 大数据\n---\n\n【转自：http://www.cnblogs.com/huxi2b/p/6124937.html】\n\nKafka 0.9版本开始推出了Java版本的consumer，优化了coordinator的设计以及摆脱了对zookeeper的依赖。社区最近也在探讨正式用这套consumer API替换Scala版本的consumer的计划。鉴于目前这方面的资料并不是很多，本文将尝试给出一个利用KafkaConsumer编写的多线程消费者实例，希望对大家有所帮助。\n\n<!-- more-->    这套API最重要的入口就是KafkaConsumer(o.a.k.clients.consumer.KafkaConsumer)，普通的单线程使用方法官网API已有介绍，这里不再赘述了。因此，我们直奔主题——讨论一下如何创建多线程的方式来使用KafkaConsumer。KafkaConsumer和KafkaProducer不同，后者是线程安全的，因此我们鼓励用户在多个线程中共享一个KafkaProducer实例，这样通常都要比每个线程维护一个KafkaProducer实例效率要高。但对于KafkaConsumer而言，它不是线程安全的，所以实现多线程时通常由两种实现方法：\n\n1 每个线程维护一个KafkaConsumer\n\n![img](https://images2015.cnblogs.com/blog/735367/201612/735367-20161202105906443-1609157006.png)\n\n2  维护一个或多个KafkaConsumer，同时维护多个事件处理线程(worker thread)\n\n![img](https://images2015.cnblogs.com/blog/735367/201612/735367-20161202110008787-550483601.png)\n\n当然，这种方法还可以有多个变种：比如每个worker线程有自己的处理队列。consumer根据某种规则或逻辑将消息放入不同的队列。不过总体思想还是相同的，故这里不做过多展开讨论了。\n\n　　下表总结了两种方法的优缺点： \n\n|                                              | 优点                                                         | 缺点                                                         |\n| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 方法1(每个线程维护一个KafkaConsumer)         | 方便实现速度较快，因为不需要任何线程间交互易于维护分区内的消息顺序 | 更多的TCP连接开销(每个线程都要维护若干个TCP连接)consumer数受限于topic分区数，扩展性差频繁请求导致吞吐量下降线程自己处理消费到的消息可能会导致超时，从而造成rebalance |\n| 方法2 (单个(或多个)consumer，多个worker线程) | 可独立扩展consumer数和worker数，伸缩性好                     | 实现麻烦通常难于维护分区内的消息顺序处理链路变长，导致难以保证提交位移的语义正确性 |\n\n \n\n下面我们分别实现这两种方法。需要指出的是，下面的代码都是最基本的实现，并没有考虑很多编程细节，比如如何处理错误等。\n\n**方法1**\n\n**ConsumerRunnable类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 import org.apache.kafka.clients.consumer.ConsumerRecord;\n 2 import org.apache.kafka.clients.consumer.ConsumerRecords;\n 3 import org.apache.kafka.clients.consumer.KafkaConsumer;\n 4 \n 5 import java.util.Arrays;\n 6 import java.util.Properties;\n 7 \n 8 public class ConsumerRunnable implements Runnable {\n 9 \n10     // 每个线程维护私有的KafkaConsumer实例\n11     private final KafkaConsumer<String, String> consumer;\n12 \n13     public ConsumerRunnable(String brokerList, String groupId, String topic) {\n14         Properties props = new Properties();\n15         props.put(\"bootstrap.servers\", brokerList);\n16         props.put(\"group.id\", groupId);\n17         props.put(\"enable.auto.commit\", \"true\");        //本例使用自动提交位移\n18         props.put(\"auto.commit.interval.ms\", \"1000\");\n19         props.put(\"session.timeout.ms\", \"30000\");\n20         props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n21         props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n22         this.consumer = new KafkaConsumer<>(props);\n23         consumer.subscribe(Arrays.asList(topic));   // 本例使用分区副本自动分配策略\n24     }\n25 \n26     @Override\n27     public void run() {\n28         while (true) {\n29             ConsumerRecords<String, String> records = consumer.poll(200);   // 本例使用200ms作为获取超时时间\n30             for (ConsumerRecord<String, String> record : records) {\n31                 // 这里面写处理消息的逻辑，本例中只是简单地打印消息\n32                 System.out.println(Thread.currentThread().getName() + \" consumed \" + record.partition() +\n33                         \"th message with offset: \" + record.offset());\n34             }\n35         }\n36     }\n37 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**ConsumerGroup类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 package com.my.kafka.test;\n 2 \n 3 import java.util.ArrayList;\n 4 import java.util.List;\n 5 \n 6 public class ConsumerGroup {\n 7 \n 8     private List<ConsumerRunnable> consumers;\n 9 \n10     public ConsumerGroup(int consumerNum, String groupId, String topic, String brokerList) {\n11         consumers = new ArrayList<>(consumerNum);\n12         for (int i = 0; i < consumerNum; ++i) {\n13             ConsumerRunnable consumerThread = new ConsumerRunnable(brokerList, groupId, topic);\n14             consumers.add(consumerThread);\n15         }\n16     }\n17 \n18     public void execute() {\n19         for (ConsumerRunnable task : consumers) {\n20             new Thread(task).start();\n21         }\n22     }\n23 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**ConsumerMain类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 public class ConsumerMain {\n 2 \n 3     public static void main(String[] args) {\n 4         String brokerList = \"localhost:9092\";\n 5         String groupId = \"testGroup1\";\n 6         String topic = \"test-topic\";\n 7         int consumerNum = 3;\n 8 \n 9         ConsumerGroup consumerGroup = new ConsumerGroup(consumerNum, groupId, topic, brokerList);\n10         consumerGroup.execute();\n11     }\n12 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n \n\n**方法2**\n\n**Worker类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 import org.apache.kafka.clients.consumer.ConsumerRecord;\n 2 \n 3 public class Worker implements Runnable {\n 4 \n 5     private ConsumerRecord<String, String> consumerRecord;\n 6 \n 7     public Worker(ConsumerRecord record) {\n 8         this.consumerRecord = record;\n 9     }\n10 \n11     @Override\n12     public void run() {\n13         // 这里写你的消息处理逻辑，本例中只是简单地打印消息\n14         System.out.println(Thread.currentThread().getName() + \" consumed \" + consumerRecord.partition()\n15             + \"th message with offset: \" + consumerRecord.offset());\n16     }\n17 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**ConsumerHandler类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 import org.apache.kafka.clients.consumer.ConsumerRecord;\n 2 import org.apache.kafka.clients.consumer.ConsumerRecords;\n 3 import org.apache.kafka.clients.consumer.KafkaConsumer;\n 4 \n 5 import java.util.Arrays;\n 6 import java.util.Properties;\n 7 import java.util.concurrent.ArrayBlockingQueue;\n 8 import java.util.concurrent.ExecutorService;\n 9 import java.util.concurrent.ThreadPoolExecutor;\n10 import java.util.concurrent.TimeUnit;\n11 \n12 public class ConsumerHandler {\n13 \n14     // 本例中使用一个consumer将消息放入后端队列，你当然可以使用前一种方法中的多实例按照某张规则同时把消息放入后端队列\n15     private final KafkaConsumer<String, String> consumer;\n16     private ExecutorService executors;\n17 \n18     public ConsumerHandler(String brokerList, String groupId, String topic) {\n19         Properties props = new Properties();\n20         props.put(\"bootstrap.servers\", brokerList);\n21         props.put(\"group.id\", groupId);\n22         props.put(\"enable.auto.commit\", \"true\");\n23         props.put(\"auto.commit.interval.ms\", \"1000\");\n24         props.put(\"session.timeout.ms\", \"30000\");\n25         props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n26         props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\");\n27         consumer = new KafkaConsumer<>(props);\n28         consumer.subscribe(Arrays.asList(topic));\n29     }\n30 \n31     public void execute(int workerNum) {\n32         executors = new ThreadPoolExecutor(workerNum, workerNum, 0L, TimeUnit.MILLISECONDS,\n33                 new ArrayBlockingQueue<>(1000), new ThreadPoolExecutor.CallerRunsPolicy());\n34 \n35         while (true) {\n36             ConsumerRecords<String, String> records = consumer.poll(200);\n37             for (final ConsumerRecord record : records) {\n38                 executors.submit(new Worker(record));\n39             }\n40         }\n41     }\n42 \n43     public void shutdown() {\n44         if (consumer != null) {\n45             consumer.close();\n46         }\n47         if (executors != null) {\n48             executors.shutdown();\n49         }\n50         try {\n51             if (!executors.awaitTermination(10, TimeUnit.SECONDS)) {\n52                 System.out.println(\"Timeout.... Ignore for this case\");\n53             }\n54         } catch (InterruptedException ignored) {\n55             System.out.println(\"Other thread interrupted this shutdown, ignore for this case.\");\n56             Thread.currentThread().interrupt();\n57         }\n58     }\n59 \n60 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n**Main类**\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n 1 public class Main {\n 2 \n 3     public static void main(String[] args) {\n 4         String brokerList = \"localhost:9092,localhost:9093,localhost:9094\";\n 5         String groupId = \"group2\";\n 6         String topic = \"test-topic\";\n 7         int workerNum = 5;\n 8 \n 9         ConsumerHandler consumers = new ConsumerHandler(brokerList, groupId, topic);\n10         consumers.execute(workerNum);\n11         try {\n12             Thread.sleep(1000000);\n13         } catch (InterruptedException ignored) {}\n14         consumers.shutdown();\n15     }\n16 }\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n　　总结一下，这两种方法或是模型都有各自的优缺点，在具体使用时需要根据自己实际的业务特点来选取对应的方法。就我个人而言，我比较推崇第二种方法以及背后的思想，即不要将很重的处理逻辑放入消费者的代码中，很多Kafka consumer使用者碰到的各种rebalance超时、coordinator重新选举、心跳无法维持等问题都来源于此。","slug":"Kafka中Consumer的多线程实现","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6j000jcf96m56lq1w7","content":"<p>【转自：<a href=\"http://www.cnblogs.com/huxi2b/p/6124937.html】\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/huxi2b/p/6124937.html】</a></p>\n<p>Kafka 0.9版本开始推出了Java版本的consumer，优化了coordinator的设计以及摆脱了对zookeeper的依赖。社区最近也在探讨正式用这套consumer API替换Scala版本的consumer的计划。鉴于目前这方面的资料并不是很多，本文将尝试给出一个利用KafkaConsumer编写的多线程消费者实例，希望对大家有所帮助。</p>\n<a id=\"more\"></a>    这套API最重要的入口就是KafkaConsumer(o.a.k.clients.consumer.KafkaConsumer)，普通的单线程使用方法官网API已有介绍，这里不再赘述了。因此，我们直奔主题——讨论一下如何创建多线程的方式来使用KafkaConsumer。KafkaConsumer和KafkaProducer不同，后者是线程安全的，因此我们鼓励用户在多个线程中共享一个KafkaProducer实例，这样通常都要比每个线程维护一个KafkaProducer实例效率要高。但对于KafkaConsumer而言，它不是线程安全的，所以实现多线程时通常由两种实现方法：<br><br>1 每个线程维护一个KafkaConsumer<br><br><img src=\"https://images2015.cnblogs.com/blog/735367/201612/735367-20161202105906443-1609157006.png\" alt=\"img\"><br><br>2  维护一个或多个KafkaConsumer，同时维护多个事件处理线程(worker thread)<br><br><img src=\"https://images2015.cnblogs.com/blog/735367/201612/735367-20161202110008787-550483601.png\" alt=\"img\"><br><br>当然，这种方法还可以有多个变种：比如每个worker线程有自己的处理队列。consumer根据某种规则或逻辑将消息放入不同的队列。不过总体思想还是相同的，故这里不做过多展开讨论了。<br><br>　　下表总结了两种方法的优缺点：<br><br>|                                              | 优点                                                         | 缺点                                                         |<br>| ——————————————– | ———————————————————— | ———————————————————— |<br>| 方法1(每个线程维护一个KafkaConsumer)         | 方便实现速度较快，因为不需要任何线程间交互易于维护分区内的消息顺序 | 更多的TCP连接开销(每个线程都要维护若干个TCP连接)consumer数受限于topic分区数，扩展性差频繁请求导致吞吐量下降线程自己处理消费到的消息可能会导致超时，从而造成rebalance |<br>| 方法2 (单个(或多个)consumer，多个worker线程) | 可独立扩展consumer数和worker数，伸缩性好                     | 实现麻烦通常难于维护分区内的消息顺序处理链路变长，导致难以保证提交位移的语义正确性 |<br><br><br><br>下面我们分别实现这两种方法。需要指出的是，下面的代码都是最基本的实现，并没有考虑很多编程细节，比如如何处理错误等。<br><br><strong>方法1</strong><br><br><strong>ConsumerRunnable类</strong><br><br><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class=\"line\"> 2 import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class=\"line\"> 3 import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class=\"line\"> 4 </span><br><span class=\"line\"> 5 import java.util.Arrays;</span><br><span class=\"line\"> 6 import java.util.Properties;</span><br><span class=\"line\"> 7 </span><br><span class=\"line\"> 8 public class ConsumerRunnable implements Runnable &#123;</span><br><span class=\"line\"> 9 </span><br><span class=\"line\">10     // 每个线程维护私有的KafkaConsumer实例</span><br><span class=\"line\">11     private final KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class=\"line\">12 </span><br><span class=\"line\">13     public ConsumerRunnable(String brokerList, String groupId, String topic) &#123;</span><br><span class=\"line\">14         Properties props = new Properties();</span><br><span class=\"line\">15         props.put(&quot;bootstrap.servers&quot;, brokerList);</span><br><span class=\"line\">16         props.put(&quot;group.id&quot;, groupId);</span><br><span class=\"line\">17         props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);        //本例使用自动提交位移</span><br><span class=\"line\">18         props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class=\"line\">19         props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);</span><br><span class=\"line\">20         props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">21         props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">22         this.consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class=\"line\">23         consumer.subscribe(Arrays.asList(topic));   // 本例使用分区副本自动分配策略</span><br><span class=\"line\">24     &#125;</span><br><span class=\"line\">25 </span><br><span class=\"line\">26     @Override</span><br><span class=\"line\">27     public void run() &#123;</span><br><span class=\"line\">28         while (true) &#123;</span><br><span class=\"line\">29             ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);   // 本例使用200ms作为获取超时时间</span><br><span class=\"line\">30             for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class=\"line\">31                 // 这里面写处理消息的逻辑，本例中只是简单地打印消息</span><br><span class=\"line\">32                 System.out.println(Thread.currentThread().getName() + &quot; consumed &quot; + record.partition() +</span><br><span class=\"line\">33                         &quot;th message with offset: &quot; + record.offset());</span><br><span class=\"line\">34             &#125;</span><br><span class=\"line\">35         &#125;</span><br><span class=\"line\">36     &#125;</span><br><span class=\"line\">37 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>ConsumerGroup类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 package com.my.kafka.test;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3 import java.util.ArrayList;</span><br><span class=\"line\"> 4 import java.util.List;</span><br><span class=\"line\"> 5 </span><br><span class=\"line\"> 6 public class ConsumerGroup &#123;</span><br><span class=\"line\"> 7 </span><br><span class=\"line\"> 8     private List&lt;ConsumerRunnable&gt; consumers;</span><br><span class=\"line\"> 9 </span><br><span class=\"line\">10     public ConsumerGroup(int consumerNum, String groupId, String topic, String brokerList) &#123;</span><br><span class=\"line\">11         consumers = new ArrayList&lt;&gt;(consumerNum);</span><br><span class=\"line\">12         for (int i = 0; i &lt; consumerNum; ++i) &#123;</span><br><span class=\"line\">13             ConsumerRunnable consumerThread = new ConsumerRunnable(brokerList, groupId, topic);</span><br><span class=\"line\">14             consumers.add(consumerThread);</span><br><span class=\"line\">15         &#125;</span><br><span class=\"line\">16     &#125;</span><br><span class=\"line\">17 </span><br><span class=\"line\">18     public void execute() &#123;</span><br><span class=\"line\">19         for (ConsumerRunnable task : consumers) &#123;</span><br><span class=\"line\">20             new Thread(task).start();</span><br><span class=\"line\">21         &#125;</span><br><span class=\"line\">22     &#125;</span><br><span class=\"line\">23 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>ConsumerMain类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 public class ConsumerMain &#123;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3     public static void main(String[] args) &#123;</span><br><span class=\"line\"> 4         String brokerList = &quot;localhost:9092&quot;;</span><br><span class=\"line\"> 5         String groupId = &quot;testGroup1&quot;;</span><br><span class=\"line\"> 6         String topic = &quot;test-topic&quot;;</span><br><span class=\"line\"> 7         int consumerNum = 3;</span><br><span class=\"line\"> 8 </span><br><span class=\"line\"> 9         ConsumerGroup consumerGroup = new ConsumerGroup(consumerNum, groupId, topic, brokerList);</span><br><span class=\"line\">10         consumerGroup.execute();</span><br><span class=\"line\">11     &#125;</span><br><span class=\"line\">12 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>方法2</strong></p>\n<p><strong>Worker类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3 public class Worker implements Runnable &#123;</span><br><span class=\"line\"> 4 </span><br><span class=\"line\"> 5     private ConsumerRecord&lt;String, String&gt; consumerRecord;</span><br><span class=\"line\"> 6 </span><br><span class=\"line\"> 7     public Worker(ConsumerRecord record) &#123;</span><br><span class=\"line\"> 8         this.consumerRecord = record;</span><br><span class=\"line\"> 9     &#125;</span><br><span class=\"line\">10 </span><br><span class=\"line\">11     @Override</span><br><span class=\"line\">12     public void run() &#123;</span><br><span class=\"line\">13         // 这里写你的消息处理逻辑，本例中只是简单地打印消息</span><br><span class=\"line\">14         System.out.println(Thread.currentThread().getName() + &quot; consumed &quot; + consumerRecord.partition()</span><br><span class=\"line\">15             + &quot;th message with offset: &quot; + consumerRecord.offset());</span><br><span class=\"line\">16     &#125;</span><br><span class=\"line\">17 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>ConsumerHandler类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class=\"line\"> 2 import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class=\"line\"> 3 import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class=\"line\"> 4 </span><br><span class=\"line\"> 5 import java.util.Arrays;</span><br><span class=\"line\"> 6 import java.util.Properties;</span><br><span class=\"line\"> 7 import java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"> 8 import java.util.concurrent.ExecutorService;</span><br><span class=\"line\"> 9 import java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\">10 import java.util.concurrent.TimeUnit;</span><br><span class=\"line\">11 </span><br><span class=\"line\">12 public class ConsumerHandler &#123;</span><br><span class=\"line\">13 </span><br><span class=\"line\">14     // 本例中使用一个consumer将消息放入后端队列，你当然可以使用前一种方法中的多实例按照某张规则同时把消息放入后端队列</span><br><span class=\"line\">15     private final KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class=\"line\">16     private ExecutorService executors;</span><br><span class=\"line\">17 </span><br><span class=\"line\">18     public ConsumerHandler(String brokerList, String groupId, String topic) &#123;</span><br><span class=\"line\">19         Properties props = new Properties();</span><br><span class=\"line\">20         props.put(&quot;bootstrap.servers&quot;, brokerList);</span><br><span class=\"line\">21         props.put(&quot;group.id&quot;, groupId);</span><br><span class=\"line\">22         props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class=\"line\">23         props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class=\"line\">24         props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);</span><br><span class=\"line\">25         props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">26         props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">27         consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class=\"line\">28         consumer.subscribe(Arrays.asList(topic));</span><br><span class=\"line\">29     &#125;</span><br><span class=\"line\">30 </span><br><span class=\"line\">31     public void execute(int workerNum) &#123;</span><br><span class=\"line\">32         executors = new ThreadPoolExecutor(workerNum, workerNum, 0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">33                 new ArrayBlockingQueue&lt;&gt;(1000), new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class=\"line\">34 </span><br><span class=\"line\">35         while (true) &#123;</span><br><span class=\"line\">36             ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);</span><br><span class=\"line\">37             for (final ConsumerRecord record : records) &#123;</span><br><span class=\"line\">38                 executors.submit(new Worker(record));</span><br><span class=\"line\">39             &#125;</span><br><span class=\"line\">40         &#125;</span><br><span class=\"line\">41     &#125;</span><br><span class=\"line\">42 </span><br><span class=\"line\">43     public void shutdown() &#123;</span><br><span class=\"line\">44         if (consumer != null) &#123;</span><br><span class=\"line\">45             consumer.close();</span><br><span class=\"line\">46         &#125;</span><br><span class=\"line\">47         if (executors != null) &#123;</span><br><span class=\"line\">48             executors.shutdown();</span><br><span class=\"line\">49         &#125;</span><br><span class=\"line\">50         try &#123;</span><br><span class=\"line\">51             if (!executors.awaitTermination(10, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">52                 System.out.println(&quot;Timeout.... Ignore for this case&quot;);</span><br><span class=\"line\">53             &#125;</span><br><span class=\"line\">54         &#125; catch (InterruptedException ignored) &#123;</span><br><span class=\"line\">55             System.out.println(&quot;Other thread interrupted this shutdown, ignore for this case.&quot;);</span><br><span class=\"line\">56             Thread.currentThread().interrupt();</span><br><span class=\"line\">57         &#125;</span><br><span class=\"line\">58     &#125;</span><br><span class=\"line\">59 </span><br><span class=\"line\">60 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>Main类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 public class Main &#123;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3     public static void main(String[] args) &#123;</span><br><span class=\"line\"> 4         String brokerList = &quot;localhost:9092,localhost:9093,localhost:9094&quot;;</span><br><span class=\"line\"> 5         String groupId = &quot;group2&quot;;</span><br><span class=\"line\"> 6         String topic = &quot;test-topic&quot;;</span><br><span class=\"line\"> 7         int workerNum = 5;</span><br><span class=\"line\"> 8 </span><br><span class=\"line\"> 9         ConsumerHandler consumers = new ConsumerHandler(brokerList, groupId, topic);</span><br><span class=\"line\">10         consumers.execute(workerNum);</span><br><span class=\"line\">11         try &#123;</span><br><span class=\"line\">12             Thread.sleep(1000000);</span><br><span class=\"line\">13         &#125; catch (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">14         consumers.shutdown();</span><br><span class=\"line\">15     &#125;</span><br><span class=\"line\">16 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p>　　总结一下，这两种方法或是模型都有各自的优缺点，在具体使用时需要根据自己实际的业务特点来选取对应的方法。就我个人而言，我比较推崇第二种方法以及背后的思想，即不要将很重的处理逻辑放入消费者的代码中，很多Kafka consumer使用者碰到的各种rebalance超时、coordinator重新选举、心跳无法维持等问题都来源于此。</p>\n","site":{"data":{}},"excerpt":"<p>【转自：<a href=\"http://www.cnblogs.com/huxi2b/p/6124937.html】\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/huxi2b/p/6124937.html】</a></p>\n<p>Kafka 0.9版本开始推出了Java版本的consumer，优化了coordinator的设计以及摆脱了对zookeeper的依赖。社区最近也在探讨正式用这套consumer API替换Scala版本的consumer的计划。鉴于目前这方面的资料并不是很多，本文将尝试给出一个利用KafkaConsumer编写的多线程消费者实例，希望对大家有所帮助。</p>","more":"这套API最重要的入口就是KafkaConsumer(o.a.k.clients.consumer.KafkaConsumer)，普通的单线程使用方法官网API已有介绍，这里不再赘述了。因此，我们直奔主题——讨论一下如何创建多线程的方式来使用KafkaConsumer。KafkaConsumer和KafkaProducer不同，后者是线程安全的，因此我们鼓励用户在多个线程中共享一个KafkaProducer实例，这样通常都要比每个线程维护一个KafkaProducer实例效率要高。但对于KafkaConsumer而言，它不是线程安全的，所以实现多线程时通常由两种实现方法：<br><br>1 每个线程维护一个KafkaConsumer<br><br><img src=\"https://images2015.cnblogs.com/blog/735367/201612/735367-20161202105906443-1609157006.png\" alt=\"img\"><br><br>2  维护一个或多个KafkaConsumer，同时维护多个事件处理线程(worker thread)<br><br><img src=\"https://images2015.cnblogs.com/blog/735367/201612/735367-20161202110008787-550483601.png\" alt=\"img\"><br><br>当然，这种方法还可以有多个变种：比如每个worker线程有自己的处理队列。consumer根据某种规则或逻辑将消息放入不同的队列。不过总体思想还是相同的，故这里不做过多展开讨论了。<br><br>　　下表总结了两种方法的优缺点：<br><br>|                                              | 优点                                                         | 缺点                                                         |<br>| ——————————————– | ———————————————————— | ———————————————————— |<br>| 方法1(每个线程维护一个KafkaConsumer)         | 方便实现速度较快，因为不需要任何线程间交互易于维护分区内的消息顺序 | 更多的TCP连接开销(每个线程都要维护若干个TCP连接)consumer数受限于topic分区数，扩展性差频繁请求导致吞吐量下降线程自己处理消费到的消息可能会导致超时，从而造成rebalance |<br>| 方法2 (单个(或多个)consumer，多个worker线程) | 可独立扩展consumer数和worker数，伸缩性好                     | 实现麻烦通常难于维护分区内的消息顺序处理链路变长，导致难以保证提交位移的语义正确性 |<br><br><br><br>下面我们分别实现这两种方法。需要指出的是，下面的代码都是最基本的实现，并没有考虑很多编程细节，比如如何处理错误等。<br><br><strong>方法1</strong><br><br><strong>ConsumerRunnable类</strong><br><br><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class=\"line\"> 2 import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class=\"line\"> 3 import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class=\"line\"> 4 </span><br><span class=\"line\"> 5 import java.util.Arrays;</span><br><span class=\"line\"> 6 import java.util.Properties;</span><br><span class=\"line\"> 7 </span><br><span class=\"line\"> 8 public class ConsumerRunnable implements Runnable &#123;</span><br><span class=\"line\"> 9 </span><br><span class=\"line\">10     // 每个线程维护私有的KafkaConsumer实例</span><br><span class=\"line\">11     private final KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class=\"line\">12 </span><br><span class=\"line\">13     public ConsumerRunnable(String brokerList, String groupId, String topic) &#123;</span><br><span class=\"line\">14         Properties props = new Properties();</span><br><span class=\"line\">15         props.put(&quot;bootstrap.servers&quot;, brokerList);</span><br><span class=\"line\">16         props.put(&quot;group.id&quot;, groupId);</span><br><span class=\"line\">17         props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);        //本例使用自动提交位移</span><br><span class=\"line\">18         props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class=\"line\">19         props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);</span><br><span class=\"line\">20         props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">21         props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">22         this.consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class=\"line\">23         consumer.subscribe(Arrays.asList(topic));   // 本例使用分区副本自动分配策略</span><br><span class=\"line\">24     &#125;</span><br><span class=\"line\">25 </span><br><span class=\"line\">26     @Override</span><br><span class=\"line\">27     public void run() &#123;</span><br><span class=\"line\">28         while (true) &#123;</span><br><span class=\"line\">29             ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);   // 本例使用200ms作为获取超时时间</span><br><span class=\"line\">30             for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class=\"line\">31                 // 这里面写处理消息的逻辑，本例中只是简单地打印消息</span><br><span class=\"line\">32                 System.out.println(Thread.currentThread().getName() + &quot; consumed &quot; + record.partition() +</span><br><span class=\"line\">33                         &quot;th message with offset: &quot; + record.offset());</span><br><span class=\"line\">34             &#125;</span><br><span class=\"line\">35         &#125;</span><br><span class=\"line\">36     &#125;</span><br><span class=\"line\">37 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>ConsumerGroup类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 package com.my.kafka.test;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3 import java.util.ArrayList;</span><br><span class=\"line\"> 4 import java.util.List;</span><br><span class=\"line\"> 5 </span><br><span class=\"line\"> 6 public class ConsumerGroup &#123;</span><br><span class=\"line\"> 7 </span><br><span class=\"line\"> 8     private List&lt;ConsumerRunnable&gt; consumers;</span><br><span class=\"line\"> 9 </span><br><span class=\"line\">10     public ConsumerGroup(int consumerNum, String groupId, String topic, String brokerList) &#123;</span><br><span class=\"line\">11         consumers = new ArrayList&lt;&gt;(consumerNum);</span><br><span class=\"line\">12         for (int i = 0; i &lt; consumerNum; ++i) &#123;</span><br><span class=\"line\">13             ConsumerRunnable consumerThread = new ConsumerRunnable(brokerList, groupId, topic);</span><br><span class=\"line\">14             consumers.add(consumerThread);</span><br><span class=\"line\">15         &#125;</span><br><span class=\"line\">16     &#125;</span><br><span class=\"line\">17 </span><br><span class=\"line\">18     public void execute() &#123;</span><br><span class=\"line\">19         for (ConsumerRunnable task : consumers) &#123;</span><br><span class=\"line\">20             new Thread(task).start();</span><br><span class=\"line\">21         &#125;</span><br><span class=\"line\">22     &#125;</span><br><span class=\"line\">23 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>ConsumerMain类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 public class ConsumerMain &#123;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3     public static void main(String[] args) &#123;</span><br><span class=\"line\"> 4         String brokerList = &quot;localhost:9092&quot;;</span><br><span class=\"line\"> 5         String groupId = &quot;testGroup1&quot;;</span><br><span class=\"line\"> 6         String topic = &quot;test-topic&quot;;</span><br><span class=\"line\"> 7         int consumerNum = 3;</span><br><span class=\"line\"> 8 </span><br><span class=\"line\"> 9         ConsumerGroup consumerGroup = new ConsumerGroup(consumerNum, groupId, topic, brokerList);</span><br><span class=\"line\">10         consumerGroup.execute();</span><br><span class=\"line\">11     &#125;</span><br><span class=\"line\">12 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>方法2</strong></p>\n<p><strong>Worker类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3 public class Worker implements Runnable &#123;</span><br><span class=\"line\"> 4 </span><br><span class=\"line\"> 5     private ConsumerRecord&lt;String, String&gt; consumerRecord;</span><br><span class=\"line\"> 6 </span><br><span class=\"line\"> 7     public Worker(ConsumerRecord record) &#123;</span><br><span class=\"line\"> 8         this.consumerRecord = record;</span><br><span class=\"line\"> 9     &#125;</span><br><span class=\"line\">10 </span><br><span class=\"line\">11     @Override</span><br><span class=\"line\">12     public void run() &#123;</span><br><span class=\"line\">13         // 这里写你的消息处理逻辑，本例中只是简单地打印消息</span><br><span class=\"line\">14         System.out.println(Thread.currentThread().getName() + &quot; consumed &quot; + consumerRecord.partition()</span><br><span class=\"line\">15             + &quot;th message with offset: &quot; + consumerRecord.offset());</span><br><span class=\"line\">16     &#125;</span><br><span class=\"line\">17 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>ConsumerHandler类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class=\"line\"> 2 import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class=\"line\"> 3 import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class=\"line\"> 4 </span><br><span class=\"line\"> 5 import java.util.Arrays;</span><br><span class=\"line\"> 6 import java.util.Properties;</span><br><span class=\"line\"> 7 import java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"> 8 import java.util.concurrent.ExecutorService;</span><br><span class=\"line\"> 9 import java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\">10 import java.util.concurrent.TimeUnit;</span><br><span class=\"line\">11 </span><br><span class=\"line\">12 public class ConsumerHandler &#123;</span><br><span class=\"line\">13 </span><br><span class=\"line\">14     // 本例中使用一个consumer将消息放入后端队列，你当然可以使用前一种方法中的多实例按照某张规则同时把消息放入后端队列</span><br><span class=\"line\">15     private final KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class=\"line\">16     private ExecutorService executors;</span><br><span class=\"line\">17 </span><br><span class=\"line\">18     public ConsumerHandler(String brokerList, String groupId, String topic) &#123;</span><br><span class=\"line\">19         Properties props = new Properties();</span><br><span class=\"line\">20         props.put(&quot;bootstrap.servers&quot;, brokerList);</span><br><span class=\"line\">21         props.put(&quot;group.id&quot;, groupId);</span><br><span class=\"line\">22         props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class=\"line\">23         props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class=\"line\">24         props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);</span><br><span class=\"line\">25         props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">26         props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class=\"line\">27         consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class=\"line\">28         consumer.subscribe(Arrays.asList(topic));</span><br><span class=\"line\">29     &#125;</span><br><span class=\"line\">30 </span><br><span class=\"line\">31     public void execute(int workerNum) &#123;</span><br><span class=\"line\">32         executors = new ThreadPoolExecutor(workerNum, workerNum, 0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">33                 new ArrayBlockingQueue&lt;&gt;(1000), new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class=\"line\">34 </span><br><span class=\"line\">35         while (true) &#123;</span><br><span class=\"line\">36             ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);</span><br><span class=\"line\">37             for (final ConsumerRecord record : records) &#123;</span><br><span class=\"line\">38                 executors.submit(new Worker(record));</span><br><span class=\"line\">39             &#125;</span><br><span class=\"line\">40         &#125;</span><br><span class=\"line\">41     &#125;</span><br><span class=\"line\">42 </span><br><span class=\"line\">43     public void shutdown() &#123;</span><br><span class=\"line\">44         if (consumer != null) &#123;</span><br><span class=\"line\">45             consumer.close();</span><br><span class=\"line\">46         &#125;</span><br><span class=\"line\">47         if (executors != null) &#123;</span><br><span class=\"line\">48             executors.shutdown();</span><br><span class=\"line\">49         &#125;</span><br><span class=\"line\">50         try &#123;</span><br><span class=\"line\">51             if (!executors.awaitTermination(10, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">52                 System.out.println(&quot;Timeout.... Ignore for this case&quot;);</span><br><span class=\"line\">53             &#125;</span><br><span class=\"line\">54         &#125; catch (InterruptedException ignored) &#123;</span><br><span class=\"line\">55             System.out.println(&quot;Other thread interrupted this shutdown, ignore for this case.&quot;);</span><br><span class=\"line\">56             Thread.currentThread().interrupt();</span><br><span class=\"line\">57         &#125;</span><br><span class=\"line\">58     &#125;</span><br><span class=\"line\">59 </span><br><span class=\"line\">60 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p><strong>Main类</strong></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 public class Main &#123;</span><br><span class=\"line\"> 2 </span><br><span class=\"line\"> 3     public static void main(String[] args) &#123;</span><br><span class=\"line\"> 4         String brokerList = &quot;localhost:9092,localhost:9093,localhost:9094&quot;;</span><br><span class=\"line\"> 5         String groupId = &quot;group2&quot;;</span><br><span class=\"line\"> 6         String topic = &quot;test-topic&quot;;</span><br><span class=\"line\"> 7         int workerNum = 5;</span><br><span class=\"line\"> 8 </span><br><span class=\"line\"> 9         ConsumerHandler consumers = new ConsumerHandler(brokerList, groupId, topic);</span><br><span class=\"line\">10         consumers.execute(workerNum);</span><br><span class=\"line\">11         try &#123;</span><br><span class=\"line\">12             Thread.sleep(1000000);</span><br><span class=\"line\">13         &#125; catch (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">14         consumers.shutdown();</span><br><span class=\"line\">15     &#125;</span><br><span class=\"line\">16 &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p>　　总结一下，这两种方法或是模型都有各自的优缺点，在具体使用时需要根据自己实际的业务特点来选取对应的方法。就我个人而言，我比较推崇第二种方法以及背后的思想，即不要将很重的处理逻辑放入消费者的代码中，很多Kafka consumer使用者碰到的各种rebalance超时、coordinator重新选举、心跳无法维持等问题都来源于此。</p>"},{"title":"MLlib----协同过滤算法","date":"2018-05-06T15:48:26.000Z","_content":"\n协同过滤算法是最常用的推荐算法,主要有两种形式:基于用户和基于物品的推荐算法.\n\nALS(alternate least square)是交替最小二乘法的简称,也是MLlib的基础推荐算法.\n\n**一. 协同过滤**\n\n协同过滤算法是一种基于群体用户或物品的典型推荐算法,主要有两种:\n\n> - 通过考察具有相同爱好的用户对相同物品的评分标准进行计算\n> - 考察具有相同特质的物品从而推荐给选择了某件物品的用户\n\n不足:\n\n> * 基于用户: 针对热点物品的处理不够准确,一些常用的物品其推荐结果往往排在首位,但是这样没有实际意义.其次,数据量大,计算费事\n\n> * 基于物品: 存在推荐同类物品的问题\n\n**二. 相似度度量**\n\n* 基于欧几里德距离的相似度计算\n\n  欧式距离表示空间中两个点的真实距离,![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D272/sign=824f524b36292df593c3ab128e305ce2/9e3df8dcd100baa1dbb0d0df4b10b912c8fc2e31.jpg),在相似度计算中,不同的物品或用户可将其定义成不同的坐标点,特定目标定位成坐标原点.因为欧式距离越大,相近度越小,因此一般以`1/(ρ+1)`作为相似度近似值\n\n* 基于余弦角度的相似度\n\n  余弦相似度通过计算两个向量的夹角余弦值来评估他们的相似度\n\n  ![img](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=ff93f325064f78f0940692a118586130/e850352ac65c1038573da3b3b7119313b07e897b.jpg)\n\n计算公式:![img](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D187/sign=50b538a78244ebf869716037eef8d736/0df431adcbef760970e3983b2bdda3cc7dd99ead.jpg)\n\n余弦值大小在[-1,1],值大小与夹角成正比\n\n* 欧式距离相似度与余弦相似度比较\n\n欧式相似度以目标绝对距离作为衡量标准,余弦相似度以目标差异大小作为衡量标准.余弦相似度更多的目标的方向趋势上区分,而随特定坐标数字不敏感.\n\n* 余弦相似度实战\n\n  步骤:\n\n  a. 输入数据\n\n  b.建立相似度算法公式\n\n  c.计算不同用户之间的相似度\n","source":"_posts/MLlib-协同过滤算法.md","raw":"---\ntitle: MLlib----协同过滤算法\ndate: 2018-05-06 23:48:26\ntags: [MLib, 大数据, 机器学习, 协同过滤]\n---\n\n协同过滤算法是最常用的推荐算法,主要有两种形式:基于用户和基于物品的推荐算法.\n\nALS(alternate least square)是交替最小二乘法的简称,也是MLlib的基础推荐算法.\n\n**一. 协同过滤**\n\n协同过滤算法是一种基于群体用户或物品的典型推荐算法,主要有两种:\n\n> - 通过考察具有相同爱好的用户对相同物品的评分标准进行计算\n> - 考察具有相同特质的物品从而推荐给选择了某件物品的用户\n\n不足:\n\n> * 基于用户: 针对热点物品的处理不够准确,一些常用的物品其推荐结果往往排在首位,但是这样没有实际意义.其次,数据量大,计算费事\n\n> * 基于物品: 存在推荐同类物品的问题\n\n**二. 相似度度量**\n\n* 基于欧几里德距离的相似度计算\n\n  欧式距离表示空间中两个点的真实距离,![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D272/sign=824f524b36292df593c3ab128e305ce2/9e3df8dcd100baa1dbb0d0df4b10b912c8fc2e31.jpg),在相似度计算中,不同的物品或用户可将其定义成不同的坐标点,特定目标定位成坐标原点.因为欧式距离越大,相近度越小,因此一般以`1/(ρ+1)`作为相似度近似值\n\n* 基于余弦角度的相似度\n\n  余弦相似度通过计算两个向量的夹角余弦值来评估他们的相似度\n\n  ![img](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=ff93f325064f78f0940692a118586130/e850352ac65c1038573da3b3b7119313b07e897b.jpg)\n\n计算公式:![img](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D187/sign=50b538a78244ebf869716037eef8d736/0df431adcbef760970e3983b2bdda3cc7dd99ead.jpg)\n\n余弦值大小在[-1,1],值大小与夹角成正比\n\n* 欧式距离相似度与余弦相似度比较\n\n欧式相似度以目标绝对距离作为衡量标准,余弦相似度以目标差异大小作为衡量标准.余弦相似度更多的目标的方向趋势上区分,而随特定坐标数字不敏感.\n\n* 余弦相似度实战\n\n  步骤:\n\n  a. 输入数据\n\n  b.建立相似度算法公式\n\n  c.计算不同用户之间的相似度\n","slug":"MLlib-协同过滤算法","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6l000lcf96b93ido9a","content":"<p>协同过滤算法是最常用的推荐算法,主要有两种形式:基于用户和基于物品的推荐算法.</p>\n<p>ALS(alternate least square)是交替最小二乘法的简称,也是MLlib的基础推荐算法.</p>\n<p><strong>一. 协同过滤</strong></p>\n<p>协同过滤算法是一种基于群体用户或物品的典型推荐算法,主要有两种:</p>\n<blockquote>\n<ul>\n<li>通过考察具有相同爱好的用户对相同物品的评分标准进行计算</li>\n<li>考察具有相同特质的物品从而推荐给选择了某件物品的用户</li>\n</ul>\n</blockquote>\n<p>不足:</p>\n<blockquote>\n<ul>\n<li>基于用户: 针对热点物品的处理不够准确,一些常用的物品其推荐结果往往排在首位,但是这样没有实际意义.其次,数据量大,计算费事</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>基于物品: 存在推荐同类物品的问题</li>\n</ul>\n</blockquote>\n<p><strong>二. 相似度度量</strong></p>\n<ul>\n<li><p>基于欧几里德距离的相似度计算</p>\n<p>欧式距离表示空间中两个点的真实距离,<img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D272/sign=824f524b36292df593c3ab128e305ce2/9e3df8dcd100baa1dbb0d0df4b10b912c8fc2e31.jpg\" alt=\"img\">,在相似度计算中,不同的物品或用户可将其定义成不同的坐标点,特定目标定位成坐标原点.因为欧式距离越大,相近度越小,因此一般以<code>1/(ρ+1)</code>作为相似度近似值</p>\n</li>\n<li><p>基于余弦角度的相似度</p>\n<p>余弦相似度通过计算两个向量的夹角余弦值来评估他们的相似度</p>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=ff93f325064f78f0940692a118586130/e850352ac65c1038573da3b3b7119313b07e897b.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p>计算公式:<img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D187/sign=50b538a78244ebf869716037eef8d736/0df431adcbef760970e3983b2bdda3cc7dd99ead.jpg\" alt=\"img\"></p>\n<p>余弦值大小在[-1,1],值大小与夹角成正比</p>\n<ul>\n<li>欧式距离相似度与余弦相似度比较</li>\n</ul>\n<p>欧式相似度以目标绝对距离作为衡量标准,余弦相似度以目标差异大小作为衡量标准.余弦相似度更多的目标的方向趋势上区分,而随特定坐标数字不敏感.</p>\n<ul>\n<li><p>余弦相似度实战</p>\n<p>步骤:</p>\n<p>a. 输入数据</p>\n<p>b.建立相似度算法公式</p>\n<p>c.计算不同用户之间的相似度</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>协同过滤算法是最常用的推荐算法,主要有两种形式:基于用户和基于物品的推荐算法.</p>\n<p>ALS(alternate least square)是交替最小二乘法的简称,也是MLlib的基础推荐算法.</p>\n<p><strong>一. 协同过滤</strong></p>\n<p>协同过滤算法是一种基于群体用户或物品的典型推荐算法,主要有两种:</p>\n<blockquote>\n<ul>\n<li>通过考察具有相同爱好的用户对相同物品的评分标准进行计算</li>\n<li>考察具有相同特质的物品从而推荐给选择了某件物品的用户</li>\n</ul>\n</blockquote>\n<p>不足:</p>\n<blockquote>\n<ul>\n<li>基于用户: 针对热点物品的处理不够准确,一些常用的物品其推荐结果往往排在首位,但是这样没有实际意义.其次,数据量大,计算费事</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>基于物品: 存在推荐同类物品的问题</li>\n</ul>\n</blockquote>\n<p><strong>二. 相似度度量</strong></p>\n<ul>\n<li><p>基于欧几里德距离的相似度计算</p>\n<p>欧式距离表示空间中两个点的真实距离,<img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D272/sign=824f524b36292df593c3ab128e305ce2/9e3df8dcd100baa1dbb0d0df4b10b912c8fc2e31.jpg\" alt=\"img\">,在相似度计算中,不同的物品或用户可将其定义成不同的坐标点,特定目标定位成坐标原点.因为欧式距离越大,相近度越小,因此一般以<code>1/(ρ+1)</code>作为相似度近似值</p>\n</li>\n<li><p>基于余弦角度的相似度</p>\n<p>余弦相似度通过计算两个向量的夹角余弦值来评估他们的相似度</p>\n<p><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=ff93f325064f78f0940692a118586130/e850352ac65c1038573da3b3b7119313b07e897b.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p>计算公式:<img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D187/sign=50b538a78244ebf869716037eef8d736/0df431adcbef760970e3983b2bdda3cc7dd99ead.jpg\" alt=\"img\"></p>\n<p>余弦值大小在[-1,1],值大小与夹角成正比</p>\n<ul>\n<li>欧式距离相似度与余弦相似度比较</li>\n</ul>\n<p>欧式相似度以目标绝对距离作为衡量标准,余弦相似度以目标差异大小作为衡量标准.余弦相似度更多的目标的方向趋势上区分,而随特定坐标数字不敏感.</p>\n<ul>\n<li><p>余弦相似度实战</p>\n<p>步骤:</p>\n<p>a. 输入数据</p>\n<p>b.建立相似度算法公式</p>\n<p>c.计算不同用户之间的相似度</p>\n</li>\n</ul>\n"},{"title":"MySQL查漏补缺（三）","date":"2018-04-07T16:05:51.000Z","_content":"* 视图：虚拟表，从数据库中的一个或多个表中导出来的表，还可以在已定义视图的基础上定义。\n* 视图中看到的数据只是存放在基本表中的数据，若基本表数据发生变化，则这种变化可以自动反映到视图中。\n*  创建视图：\n```SQL\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n\t\tVIEW view_name [(column_list)]\n    \tAS SELECT_statement\n    \t[WITH [CASCADED | LOCAL] CHECK OPTION]```\n<!-- more-->\nREPLACE表示替换已有视图，WITH [CASCADED | LOCAL] CHECK OPTION表示视图在更新时保证在视图的权限范围之内。CASCADE（级联的）为默认值，表示视图更新时要满足所有相关视图和表的条件;LOCAL表示更新时满足该视图本身定义的条件即可。\n视图选择的算法有三种，UNDEFINED表示MySQL将自动选择算法;MERGE表示将使用的视图语句与视图定义合并起来，使得视图定义的某一部分取代语句对应的部分;TEMPTABLE表示将视图结果存入临时表，然后用临时表执行语句。\n* 默认情况下，将在当前数据库创建新视图。要在给定数据库创建视图，创建时应将名称指定为：db_name.view_name\n* 查看视图：`DESCRIBE 视图名`，`SHOW TABLE STATUS LIKE '视图名'`，`SHOW CREATE VIEW 视图名`\n* `SELECT * FROM information_schema.views`,MySQL中，information_schema数据库中的views表中存储了所有视图的定义，可以查看视图的详细信息。\n* 修改视图：\n> ```SQL\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n\t\tVIEW view_name [(column_list)]\n    \tAS SELECT_statement\n    \t[WITH [CASCADED | LOCAL] CHECK OPTION]```\n> ```SQL\nALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n\t\tVIEW view_name [(column_list)]\n    \tAS SELECT_statement\n    \t[WITH [CASCADED | LOCAL] CHECK OPTION]```\n* 更新视图：`UPDATE 视图名 SET col_name = val `,`DELETE FROM 视图名 WHERE condition_expr`\n* 当视图中包含如下内容时，视图的更新不能被执行：\n> 1. 视图中不包含基表中被定义为非空的列\n> 2. 在定义视图的SELECT语句后的字段列表中使用了数学表达式\n> 3. 在定义视图的SELECT语句后的字段列表中使用了聚合函数\n> 4. 在定义视图的SELECT语句中使用了DISTINCT，UNION，TOP，GROUP BY或HAVING子句\n* 删除视图：\n```SQL\nDROP VIEW [IF EXISTS]\n\tview_name [,view_name] ...\n    [RESTRICT | CASCADE]```\n* 触发器是个特殊的存储过程，不需要CALL语句来调用，只要当一个预定义的事件发生时，就会被自动调用，可以查询其他表。\n* 创建触发器：\n```SQL\nCREATE TRIGGER trigger_name trigger_time trigger_event\nON tb1_name FOR EACH ROW trigger_stmt\n```\ntrigger_time标识触发时机，可指定为before或after;trigger_event标识触发事件，包括INSERT，UPDATE，DELETE;tb1_name指明在哪张表上建立触发器;trigger_stmt是触发器程序体。可以为单条语句，也可以使用BEGIN和END作为开始和结束执行多条语句。\n* 实例：\n\n```SQL\nmysql> CREATE TRIGGER ins_sum BEFORE INSERT ON account\n    -> for each row SET @SUM=@SUM+NEW.amount;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> set @SUM=0\n    -> ;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> INSERT INTO account values(1,1.00),(2,2.00);\nQuery OK, 2 rows affected (0.00 sec)\nRecords: 2  Duplicates: 0  Warnings: 0\n\nmysql> select @SUM;\n+------+\n| @SUM |\n+------+\n| 3.00 |\n+------+\n1 row in set (0.00 sec)\n```\n使用OLD和NEW关键字，能够访问受触发程序影响的行中的列（OLD和NEW不区分大小写），可以使用OLD.col_name来引用更新前的某一行的列，也能使用NEW.col_name来引用更新后的行中的列。\n* 查看触发器：`SHOW TRIGGERSV`，`SELECT * FROM INFORMATION_SCHEMA.TRIGGERS WHERE condition`\n* 删除触发器：`DROP TRIGGER [schema_name.]trigger_name`\n* 对于相同的表，相同的事件只能创建一个触发器\n* 用CREATE USER创建新用户：\n\n    ```SQL\n    CREATE USER user_sprcification\n        [, user_specification] ...\n\n    user_specification:\n        user@host\n        [\n            IDENTIFIED BY [PASSWORD] 'password'\n          |\tIDENTIFIED WITH auth_plugin [AS 'auth_string']\n        ]\n    ```\n这样创建的账户没有任何权限，如果添加的账户已经存在则会返回一个错误。[PASSWORD]表示使用哈希值设置密码。host表示允许登陆的用户主机名称，默认为%，即对所有主机开放访问权限。如果用户不需要密码登陆，则可以省略`IDENTIFIED  BY`语句。IDENTIFIED WITH为用户指定一个身份验证插件，与IDENTIFIED BY 互斥。\n* GRANT创建用户同时授权：\n\t```SQL\n    GRANT privileges ON db.table\n    TO user@host [IDENTIFIED BY 'password'] [, user [IDENTIFIED BY 'password']]\n    [WITH GRANT OPTION];\n    ```\n* 直接操作MySQL用户表创建用户：\n\t```SQL\n    INSERT INTO mysql.user(Host,User,Password,[privilegelist])\n    VALUES ('host','username',PASSWORD('password'),privilegevaluelist)```\n* 删除用户：`DROP USER user` ，DROP USER不能自动关闭任何打开的用户对话，如果用户有打开的回话，此时取消用户，命令不会生效，直到对话关闭后生效。\n* 删除用户2： `DELETE FROM MySQL user WHERE host='hostname' and user = 'username'`\n","source":"_posts/MySQL查漏补缺（三）.md","raw":"---\ntitle: MySQL查漏补缺（三）\ndate: 2018-04-08 00:05:51\ntags: [数据库, MySQL]\n---\n* 视图：虚拟表，从数据库中的一个或多个表中导出来的表，还可以在已定义视图的基础上定义。\n* 视图中看到的数据只是存放在基本表中的数据，若基本表数据发生变化，则这种变化可以自动反映到视图中。\n*  创建视图：\n```SQL\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n\t\tVIEW view_name [(column_list)]\n    \tAS SELECT_statement\n    \t[WITH [CASCADED | LOCAL] CHECK OPTION]```\n<!-- more-->\nREPLACE表示替换已有视图，WITH [CASCADED | LOCAL] CHECK OPTION表示视图在更新时保证在视图的权限范围之内。CASCADE（级联的）为默认值，表示视图更新时要满足所有相关视图和表的条件;LOCAL表示更新时满足该视图本身定义的条件即可。\n视图选择的算法有三种，UNDEFINED表示MySQL将自动选择算法;MERGE表示将使用的视图语句与视图定义合并起来，使得视图定义的某一部分取代语句对应的部分;TEMPTABLE表示将视图结果存入临时表，然后用临时表执行语句。\n* 默认情况下，将在当前数据库创建新视图。要在给定数据库创建视图，创建时应将名称指定为：db_name.view_name\n* 查看视图：`DESCRIBE 视图名`，`SHOW TABLE STATUS LIKE '视图名'`，`SHOW CREATE VIEW 视图名`\n* `SELECT * FROM information_schema.views`,MySQL中，information_schema数据库中的views表中存储了所有视图的定义，可以查看视图的详细信息。\n* 修改视图：\n> ```SQL\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n\t\tVIEW view_name [(column_list)]\n    \tAS SELECT_statement\n    \t[WITH [CASCADED | LOCAL] CHECK OPTION]```\n> ```SQL\nALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n\t\tVIEW view_name [(column_list)]\n    \tAS SELECT_statement\n    \t[WITH [CASCADED | LOCAL] CHECK OPTION]```\n* 更新视图：`UPDATE 视图名 SET col_name = val `,`DELETE FROM 视图名 WHERE condition_expr`\n* 当视图中包含如下内容时，视图的更新不能被执行：\n> 1. 视图中不包含基表中被定义为非空的列\n> 2. 在定义视图的SELECT语句后的字段列表中使用了数学表达式\n> 3. 在定义视图的SELECT语句后的字段列表中使用了聚合函数\n> 4. 在定义视图的SELECT语句中使用了DISTINCT，UNION，TOP，GROUP BY或HAVING子句\n* 删除视图：\n```SQL\nDROP VIEW [IF EXISTS]\n\tview_name [,view_name] ...\n    [RESTRICT | CASCADE]```\n* 触发器是个特殊的存储过程，不需要CALL语句来调用，只要当一个预定义的事件发生时，就会被自动调用，可以查询其他表。\n* 创建触发器：\n```SQL\nCREATE TRIGGER trigger_name trigger_time trigger_event\nON tb1_name FOR EACH ROW trigger_stmt\n```\ntrigger_time标识触发时机，可指定为before或after;trigger_event标识触发事件，包括INSERT，UPDATE，DELETE;tb1_name指明在哪张表上建立触发器;trigger_stmt是触发器程序体。可以为单条语句，也可以使用BEGIN和END作为开始和结束执行多条语句。\n* 实例：\n\n```SQL\nmysql> CREATE TRIGGER ins_sum BEFORE INSERT ON account\n    -> for each row SET @SUM=@SUM+NEW.amount;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> set @SUM=0\n    -> ;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> INSERT INTO account values(1,1.00),(2,2.00);\nQuery OK, 2 rows affected (0.00 sec)\nRecords: 2  Duplicates: 0  Warnings: 0\n\nmysql> select @SUM;\n+------+\n| @SUM |\n+------+\n| 3.00 |\n+------+\n1 row in set (0.00 sec)\n```\n使用OLD和NEW关键字，能够访问受触发程序影响的行中的列（OLD和NEW不区分大小写），可以使用OLD.col_name来引用更新前的某一行的列，也能使用NEW.col_name来引用更新后的行中的列。\n* 查看触发器：`SHOW TRIGGERSV`，`SELECT * FROM INFORMATION_SCHEMA.TRIGGERS WHERE condition`\n* 删除触发器：`DROP TRIGGER [schema_name.]trigger_name`\n* 对于相同的表，相同的事件只能创建一个触发器\n* 用CREATE USER创建新用户：\n\n    ```SQL\n    CREATE USER user_sprcification\n        [, user_specification] ...\n\n    user_specification:\n        user@host\n        [\n            IDENTIFIED BY [PASSWORD] 'password'\n          |\tIDENTIFIED WITH auth_plugin [AS 'auth_string']\n        ]\n    ```\n这样创建的账户没有任何权限，如果添加的账户已经存在则会返回一个错误。[PASSWORD]表示使用哈希值设置密码。host表示允许登陆的用户主机名称，默认为%，即对所有主机开放访问权限。如果用户不需要密码登陆，则可以省略`IDENTIFIED  BY`语句。IDENTIFIED WITH为用户指定一个身份验证插件，与IDENTIFIED BY 互斥。\n* GRANT创建用户同时授权：\n\t```SQL\n    GRANT privileges ON db.table\n    TO user@host [IDENTIFIED BY 'password'] [, user [IDENTIFIED BY 'password']]\n    [WITH GRANT OPTION];\n    ```\n* 直接操作MySQL用户表创建用户：\n\t```SQL\n    INSERT INTO mysql.user(Host,User,Password,[privilegelist])\n    VALUES ('host','username',PASSWORD('password'),privilegevaluelist)```\n* 删除用户：`DROP USER user` ，DROP USER不能自动关闭任何打开的用户对话，如果用户有打开的回话，此时取消用户，命令不会生效，直到对话关闭后生效。\n* 删除用户2： `DELETE FROM MySQL user WHERE host='hostname' and user = 'username'`\n","slug":"MySQL查漏补缺（三）","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6m000ocf96r10sz6ze","content":"<ul>\n<li>视图：虚拟表，从数据库中的一个或多个表中导出来的表，还可以在已定义视图的基础上定义。</li>\n<li>视图中看到的数据只是存放在基本表中的数据，若基本表数据发生变化，则这种变化可以自动反映到视图中。</li>\n<li>创建视图：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> [<span class=\"keyword\">OR</span> <span class=\"keyword\">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class=\"keyword\">MERGE</span> | TEMPTABLE&#125;]</span><br><span class=\"line\">\t\t<span class=\"keyword\">VIEW</span> view_name [(column_list)]</span><br><span class=\"line\">    \t<span class=\"keyword\">AS</span> SELECT_statement</span><br><span class=\"line\">    \t[<span class=\"keyword\">WITH</span> [<span class=\"keyword\">CASCADED</span> | <span class=\"keyword\">LOCAL</span>] <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>REPLACE表示替换已有视图，WITH [CASCADED | LOCAL] CHECK OPTION表示视图在更新时保证在视图的权限范围之内。CASCADE（级联的）为默认值，表示视图更新时要满足所有相关视图和表的条件;LOCAL表示更新时满足该视图本身定义的条件即可。<br>视图选择的算法有三种，UNDEFINED表示MySQL将自动选择算法;MERGE表示将使用的视图语句与视图定义合并起来，使得视图定义的某一部分取代语句对应的部分;TEMPTABLE表示将视图结果存入临时表，然后用临时表执行语句。</p>\n<ul>\n<li>默认情况下，将在当前数据库创建新视图。要在给定数据库创建视图，创建时应将名称指定为：db_name.view_name</li>\n<li>查看视图：<code>DESCRIBE 视图名</code>，<code>SHOW TABLE STATUS LIKE &#39;视图名&#39;</code>，<code>SHOW CREATE VIEW 视图名</code></li>\n<li><code>SELECT * FROM information_schema.views</code>,MySQL中，information_schema数据库中的views表中存储了所有视图的定义，可以查看视图的详细信息。</li>\n<li>修改视图：<blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> [<span class=\"keyword\">OR</span> <span class=\"keyword\">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class=\"keyword\">MERGE</span> | TEMPTABLE&#125;]</span><br><span class=\"line\">\t\t<span class=\"keyword\">VIEW</span> view_name [(column_list)]</span><br><span class=\"line\">    \t<span class=\"keyword\">AS</span> SELECT_statement</span><br><span class=\"line\">    \t[<span class=\"keyword\">WITH</span> [<span class=\"keyword\">CASCADED</span> | <span class=\"keyword\">LOCAL</span>] <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> [ALGORITHM = &#123;UNDEFINED | <span class=\"keyword\">MERGE</span> | TEMPTABLE&#125;]</span><br><span class=\"line\">\t\t<span class=\"keyword\">VIEW</span> view_name [(column_list)]</span><br><span class=\"line\">    \t<span class=\"keyword\">AS</span> SELECT_statement</span><br><span class=\"line\">    \t[<span class=\"keyword\">WITH</span> [<span class=\"keyword\">CASCADED</span> | <span class=\"keyword\">LOCAL</span>] <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>更新视图：<code>UPDATE 视图名 SET col_name = val</code>,<code>DELETE FROM 视图名 WHERE condition_expr</code></li>\n<li>当视图中包含如下内容时，视图的更新不能被执行：<blockquote>\n<ol>\n<li>视图中不包含基表中被定义为非空的列</li>\n<li>在定义视图的SELECT语句后的字段列表中使用了数学表达式</li>\n<li>在定义视图的SELECT语句后的字段列表中使用了聚合函数</li>\n<li>在定义视图的SELECT语句中使用了DISTINCT，UNION，TOP，GROUP BY或HAVING子句</li>\n</ol>\n</blockquote>\n</li>\n<li><p>删除视图：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">VIEW</span> [<span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span>]</span><br><span class=\"line\">\tview_name [,view_name] ...</span><br><span class=\"line\">    [RESTRICT | <span class=\"keyword\">CASCADE</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>触发器是个特殊的存储过程，不需要CALL语句来调用，只要当一个预定义的事件发生时，就会被自动调用，可以查询其他表。</p>\n</li>\n<li>创建触发器：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name trigger_time trigger_event</span><br><span class=\"line\"><span class=\"keyword\">ON</span> tb1_name <span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"keyword\">ROW</span> trigger_stmt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>trigger_time标识触发时机，可指定为before或after;trigger_event标识触发事件，包括INSERT，UPDATE，DELETE;tb1_name指明在哪张表上建立触发器;trigger_stmt是触发器程序体。可以为单条语句，也可以使用BEGIN和END作为开始和结束执行多条语句。</p>\n<ul>\n<li>实例：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE TRIGGER ins_sum BEFORE INSERT ON account</span><br><span class=\"line\">    -&gt; for each row SET @SUM=@SUM+NEW.amount;</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; set @SUM=0</span><br><span class=\"line\">    -&gt; ;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; INSERT INTO account values(1,1.00),(2,2.00);</span><br><span class=\"line\">Query OK, 2 rows affected (0.00 sec)</span><br><span class=\"line\">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @SUM;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @SUM |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| 3.00 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>使用OLD和NEW关键字，能够访问受触发程序影响的行中的列（OLD和NEW不区分大小写），可以使用OLD.col_name来引用更新前的某一行的列，也能使用NEW.col_name来引用更新后的行中的列。</p>\n<ul>\n<li>查看触发器：<code>SHOW TRIGGERSV</code>，<code>SELECT * FROM INFORMATION_SCHEMA.TRIGGERS WHERE condition</code></li>\n<li>删除触发器：<code>DROP TRIGGER [schema_name.]trigger_name</code></li>\n<li>对于相同的表，相同的事件只能创建一个触发器</li>\n<li><p>用CREATE USER创建新用户：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> user_sprcification</span><br><span class=\"line\">    [, user_specification] ...</span><br><span class=\"line\"></span><br><span class=\"line\">user_specification:</span><br><span class=\"line\">    <span class=\"keyword\">user</span>@host</span><br><span class=\"line\">    [</span><br><span class=\"line\">        <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> [<span class=\"keyword\">PASSWORD</span>] <span class=\"string\">'password'</span></span><br><span class=\"line\">      |\t<span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">WITH</span> auth_plugin [<span class=\"keyword\">AS</span> <span class=\"string\">'auth_string'</span>]</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样创建的账户没有任何权限，如果添加的账户已经存在则会返回一个错误。[PASSWORD]表示使用哈希值设置密码。host表示允许登陆的用户主机名称，默认为%，即对所有主机开放访问权限。如果用户不需要密码登陆，则可以省略<code>IDENTIFIED  BY</code>语句。IDENTIFIED WITH为用户指定一个身份验证插件，与IDENTIFIED BY 互斥。</p>\n<ul>\n<li><p>GRANT创建用户同时授权：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">privileges</span> <span class=\"keyword\">ON</span> db.table</span><br><span class=\"line\"><span class=\"keyword\">TO</span> <span class=\"keyword\">user</span>@host [<span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'password'</span>] [, <span class=\"keyword\">user</span> [<span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'password'</span>]]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> <span class=\"keyword\">GRANT</span> <span class=\"keyword\">OPTION</span>];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接操作MySQL用户表创建用户：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> mysql.user(Host,<span class=\"keyword\">User</span>,<span class=\"keyword\">Password</span>,[privilegelist])</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"string\">'host'</span>,<span class=\"string\">'username'</span>,<span class=\"keyword\">PASSWORD</span>(<span class=\"string\">'password'</span>),privilegevaluelist)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除用户：<code>DROP USER user</code> ，DROP USER不能自动关闭任何打开的用户对话，如果用户有打开的回话，此时取消用户，命令不会生效，直到对话关闭后生效。</p>\n</li>\n<li>删除用户2： <code>DELETE FROM MySQL user WHERE host=&#39;hostname&#39; and user = &#39;username&#39;</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>视图：虚拟表，从数据库中的一个或多个表中导出来的表，还可以在已定义视图的基础上定义。</li>\n<li>视图中看到的数据只是存放在基本表中的数据，若基本表数据发生变化，则这种变化可以自动反映到视图中。</li>\n<li>创建视图：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> [<span class=\"keyword\">OR</span> <span class=\"keyword\">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class=\"keyword\">MERGE</span> | TEMPTABLE&#125;]</span><br><span class=\"line\">\t\t<span class=\"keyword\">VIEW</span> view_name [(column_list)]</span><br><span class=\"line\">    \t<span class=\"keyword\">AS</span> SELECT_statement</span><br><span class=\"line\">    \t[<span class=\"keyword\">WITH</span> [<span class=\"keyword\">CASCADED</span> | <span class=\"keyword\">LOCAL</span>] <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<p>REPLACE表示替换已有视图，WITH [CASCADED | LOCAL] CHECK OPTION表示视图在更新时保证在视图的权限范围之内。CASCADE（级联的）为默认值，表示视图更新时要满足所有相关视图和表的条件;LOCAL表示更新时满足该视图本身定义的条件即可。<br>视图选择的算法有三种，UNDEFINED表示MySQL将自动选择算法;MERGE表示将使用的视图语句与视图定义合并起来，使得视图定义的某一部分取代语句对应的部分;TEMPTABLE表示将视图结果存入临时表，然后用临时表执行语句。</p>\n<ul>\n<li>默认情况下，将在当前数据库创建新视图。要在给定数据库创建视图，创建时应将名称指定为：db_name.view_name</li>\n<li>查看视图：<code>DESCRIBE 视图名</code>，<code>SHOW TABLE STATUS LIKE &#39;视图名&#39;</code>，<code>SHOW CREATE VIEW 视图名</code></li>\n<li><code>SELECT * FROM information_schema.views</code>,MySQL中，information_schema数据库中的views表中存储了所有视图的定义，可以查看视图的详细信息。</li>\n<li>修改视图：<blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> [<span class=\"keyword\">OR</span> <span class=\"keyword\">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class=\"keyword\">MERGE</span> | TEMPTABLE&#125;]</span><br><span class=\"line\">\t\t<span class=\"keyword\">VIEW</span> view_name [(column_list)]</span><br><span class=\"line\">    \t<span class=\"keyword\">AS</span> SELECT_statement</span><br><span class=\"line\">    \t[<span class=\"keyword\">WITH</span> [<span class=\"keyword\">CASCADED</span> | <span class=\"keyword\">LOCAL</span>] <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> [ALGORITHM = &#123;UNDEFINED | <span class=\"keyword\">MERGE</span> | TEMPTABLE&#125;]</span><br><span class=\"line\">\t\t<span class=\"keyword\">VIEW</span> view_name [(column_list)]</span><br><span class=\"line\">    \t<span class=\"keyword\">AS</span> SELECT_statement</span><br><span class=\"line\">    \t[<span class=\"keyword\">WITH</span> [<span class=\"keyword\">CASCADED</span> | <span class=\"keyword\">LOCAL</span>] <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>更新视图：<code>UPDATE 视图名 SET col_name = val</code>,<code>DELETE FROM 视图名 WHERE condition_expr</code></li>\n<li>当视图中包含如下内容时，视图的更新不能被执行：<blockquote>\n<ol>\n<li>视图中不包含基表中被定义为非空的列</li>\n<li>在定义视图的SELECT语句后的字段列表中使用了数学表达式</li>\n<li>在定义视图的SELECT语句后的字段列表中使用了聚合函数</li>\n<li>在定义视图的SELECT语句中使用了DISTINCT，UNION，TOP，GROUP BY或HAVING子句</li>\n</ol>\n</blockquote>\n</li>\n<li><p>删除视图：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">VIEW</span> [<span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span>]</span><br><span class=\"line\">\tview_name [,view_name] ...</span><br><span class=\"line\">    [RESTRICT | <span class=\"keyword\">CASCADE</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>触发器是个特殊的存储过程，不需要CALL语句来调用，只要当一个预定义的事件发生时，就会被自动调用，可以查询其他表。</p>\n</li>\n<li>创建触发器：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name trigger_time trigger_event</span><br><span class=\"line\"><span class=\"keyword\">ON</span> tb1_name <span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"keyword\">ROW</span> trigger_stmt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>trigger_time标识触发时机，可指定为before或after;trigger_event标识触发事件，包括INSERT，UPDATE，DELETE;tb1_name指明在哪张表上建立触发器;trigger_stmt是触发器程序体。可以为单条语句，也可以使用BEGIN和END作为开始和结束执行多条语句。</p>\n<ul>\n<li>实例：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE TRIGGER ins_sum BEFORE INSERT ON account</span><br><span class=\"line\">    -&gt; for each row SET @SUM=@SUM+NEW.amount;</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; set @SUM=0</span><br><span class=\"line\">    -&gt; ;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; INSERT INTO account values(1,1.00),(2,2.00);</span><br><span class=\"line\">Query OK, 2 rows affected (0.00 sec)</span><br><span class=\"line\">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @SUM;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @SUM |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| 3.00 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>使用OLD和NEW关键字，能够访问受触发程序影响的行中的列（OLD和NEW不区分大小写），可以使用OLD.col_name来引用更新前的某一行的列，也能使用NEW.col_name来引用更新后的行中的列。</p>\n<ul>\n<li>查看触发器：<code>SHOW TRIGGERSV</code>，<code>SELECT * FROM INFORMATION_SCHEMA.TRIGGERS WHERE condition</code></li>\n<li>删除触发器：<code>DROP TRIGGER [schema_name.]trigger_name</code></li>\n<li>对于相同的表，相同的事件只能创建一个触发器</li>\n<li><p>用CREATE USER创建新用户：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> user_sprcification</span><br><span class=\"line\">    [, user_specification] ...</span><br><span class=\"line\"></span><br><span class=\"line\">user_specification:</span><br><span class=\"line\">    <span class=\"keyword\">user</span>@host</span><br><span class=\"line\">    [</span><br><span class=\"line\">        <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> [<span class=\"keyword\">PASSWORD</span>] <span class=\"string\">'password'</span></span><br><span class=\"line\">      |\t<span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">WITH</span> auth_plugin [<span class=\"keyword\">AS</span> <span class=\"string\">'auth_string'</span>]</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样创建的账户没有任何权限，如果添加的账户已经存在则会返回一个错误。[PASSWORD]表示使用哈希值设置密码。host表示允许登陆的用户主机名称，默认为%，即对所有主机开放访问权限。如果用户不需要密码登陆，则可以省略<code>IDENTIFIED  BY</code>语句。IDENTIFIED WITH为用户指定一个身份验证插件，与IDENTIFIED BY 互斥。</p>\n<ul>\n<li><p>GRANT创建用户同时授权：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">privileges</span> <span class=\"keyword\">ON</span> db.table</span><br><span class=\"line\"><span class=\"keyword\">TO</span> <span class=\"keyword\">user</span>@host [<span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'password'</span>] [, <span class=\"keyword\">user</span> [<span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'password'</span>]]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> <span class=\"keyword\">GRANT</span> <span class=\"keyword\">OPTION</span>];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接操作MySQL用户表创建用户：</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> mysql.user(Host,<span class=\"keyword\">User</span>,<span class=\"keyword\">Password</span>,[privilegelist])</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"string\">'host'</span>,<span class=\"string\">'username'</span>,<span class=\"keyword\">PASSWORD</span>(<span class=\"string\">'password'</span>),privilegevaluelist)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除用户：<code>DROP USER user</code> ，DROP USER不能自动关闭任何打开的用户对话，如果用户有打开的回话，此时取消用户，命令不会生效，直到对话关闭后生效。</p>\n</li>\n<li>删除用户2： <code>DELETE FROM MySQL user WHERE host=&#39;hostname&#39; and user = &#39;username&#39;</code></li>\n</ul>"},{"title":"MySQL查漏补缺（一）","date":"2018-04-03T06:36:40.000Z","_content":"本篇博客记录本人在复习MySQL基本操作过程中碰到的之前忽略或者忘记的知识点\n* 命令`HOW DATABASES`后出现的mysql数据库是必需的，它描述用户访问权限\n* 创建数据库是在系统磁盘上划分一块区域用于数据的存储和管理\n* `show engines`查看系统支持的引擎\n* InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键\n> 特点：\n> - InnoDB给MySQL提供了具有提交、回滚、和崩溃恢复能力的事务安全存储引擎\n> - 为处理巨大数据量的最大性能设计，CPU效率高\n> - 完全与MySQL服务器整合\n> - 支持外键完整约束\n>   <!-- more-->\n* MyISAM拥有较高的插入、查询速度，但不支持事务\n* MEMORY存储引擎将数据存储到内存中，为查询和引用其他表数据提供快速访问\n* 主键是表中*一列或者多列的组合*，主键约束要求主键数据唯一，并且不能为空，主键可以和外键结合起来定义不同数据表之间的关系，可以加快查询的速度\n* 主键类型：单字段主键、多字段联合主键\n* 创建多字段主键：`PRIMARY KET [VAR1,VAR2,...]`\n* 外键用来在两个表的数据之间建立链接，可以是一列或者多列，外键对应参照完整性\n* 一个表的外键可以为空，可以不是本表的主键，若不为空，则每个外键的值必须等于另一个表中主键的某个值\n* 定义外键后，不允许删除在另一个表中具有关联关系的行\n* 创建外键语法:`[CONSTRAINT <外键名>] FOREIGN KEY 字段名1 [，字段名2，...] REFRENCES <主表名> 主键列1[， 主键列2...]`\n* 一个表中不能有相同名称的外键\n* 一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分\n* 查看表的基本结构：\n> DESC:查看基本结构\n> SHOW CREATE TABLE:查看详细表结构，可以显示创建表的语句，加上‘\\G‘参数显示的结果更直观\n* 修改表名：`alter table 表名 rename to 新表名`\n* 修改字段数据类型：`alter table 表名 modify 字段名 数据类型`\n* 修改字段名：`alter table 表名 change 旧字段名 新字段名 新数据类型`\n* 添加字段：`alter table 表名 add 新字段名 数据类型 约束类型 [FIRST|AFTER 已存在字段名]` FIRST和AFTER为可选参数，将新字段置于首位或者添加到以存在字段名之后， 默认添加到最后列\n* 删除字段： `alter table 表名 drop 字段名 `\n* 修改表名的排列顺序：`alter table 表名 modify 字段名 数据类型 FIRST | AFTER 已存在字段`\n* 修改引擎： `alter table 表名 engin=引擎名`\n* 删除外键约束：`alter table 表名 drop foreign kei 外键名`\n* 数据表之间存在关联关系时，删除父表会报错\n* 并不是每个表都需要主键\n* 表示小数：浮点数：float double 定点数：decimal,都可以用（M，N）表示，M为精度，表示总共位数，N为标度，表示小数位数\n* decimal以串存放，其可能的最大取直与double一样\n* CHAR(M)定长字符串，检索到CHAR值时，尾部空格将删除\n* VARCHAR(M)长度可变字符串，M表示最大列长度，0-65535，实际占用空间为字符串实际长度加一，在值保存和检索时尾部的空格任保留\n* ENUM是字符串对象，值为表在创建时在列规定中枚举的一列直，语法`字段名 enum （'val1'，'val2',...'valn'）`\n* ENUM类型的字段在取值时只能在指定枚举列表中取且一次只能取一个，成员尾部空格将自动被删除，ENUM值在内部用整数表示，每个枚举值均有一个索引值，列表索引值从一开始编号，NULL的索引为NULL，字段值区分大小写\n![](/home/harold/Pictures/Selection_050.png)\n![](/home/harold/Pictures/Selection_051.png)\n\n* SET是一个字符串对象，可以有0-64个成员，SET类型的列可以从定义的列值中选择多个字符的联合，SET会删除重复的值\n* BIN()函数将数字转换为二进制\n* 二进制字符串类型：\n> - BIT:位字段\n> - BINARY(M):长度二进制字符串\n>  - VARBINARY(M): 变长\n>  - BLOB(M):小BLOB，BLOB是二进制大对象，存储可变数量的数据\n* TEXT和BLOB比较：\n\n<table>\n<tr><td>TEXT</td>\n<td>BLOB</td></tr>\n<tr><td>存储非二进制字符串(字符字符串)</td>\n<td>存储二进制字符串(字节字符串)</td></tr>\n<tr><td>有一个字符集,根据字符集对值比较和排序</td>\n<td>没有字符集，排序和比较基于列值字节的数值</td></tr>\n<tr><td>只能存纯文本文件</td>\n<td>主要存图片，音频等</td></tr>\n<table>\n* `=`操作符：\n 若有一个或两个参数为NULL，比较结果为NULL\n 若两个参数都是字符串，则按字符串进行比较\n 都为整数，按整数比较\n 若一个字符串一个整数比较，自动将字符串转换为整数\n\n* 安全等于运算符`<=>`,可用来判断null值\n* `LEAST（val1,val2,...valn）`运算符返回参数中的最小值，如果参数中有NULL，返回NULL\n* `GREATEST(val1,val2,...)`返回最大值，有NULL时，返回NULL\n* `exp REGEXP 匹配条件`，用来匹配字符串，匹配返回1,否则返回0，若expr或匹配条件中有一个NULL，结果为NULL，通配符比LIKE多，不区分大小写\n* 函数CEIL(x),CEILING(x),FLOOR(x)获取整数值，前两个向上取整，floor()向下取整\n* 函数RAND(x)返回0-1间的浮点数，x作为种子\n* ROUND(x)函数四舍五入,ROUND(x,y)返回最接近x的数，结果保留小数点后y位，若y为负值，则将小数点保留x只到小数点左边y位\n* TRUNCATE(x,y)返回被舍去小数点后y位的数字x，若y为0，则结果不带有小数部分，若y为负数，则截取(归零)x小数点做起y位开始后所有低位的值。\n* CHAR_LENGTH(str)返回字符串str所包含的字符个数，一个多字节字符算作一个单字符。\n* LENGTH(str）返回字符串的字节长度\n* CONCAT(s1,s2,...)连接字符串，如果有一个参数为NULL，则结果为NULL，若自变量中存在二进制字符串，则结果为一个二进制字符串\n* CONCAT(X,S1,S2,...)以x作为分隔符连接字符串\n* `INSERT(S1,X，LEN,s2)`替换字符串函数，从s1的x位置用s2取代len个字符，若x超过字符串长度，则返回原始字符串，有一个参数为NULL则返回NULL\n* 大小写转换LOWER(STR),LCASE(STR),UPPER(STR),UCASE(STR)\n* 获取指定长度字符串`LEFT(s,n)`,`RIGHT(s,n)`\n* `TRIM(s1 FROM s)`从s两端删除所有子字符s1\n* 匹配子串str1在str中开始位置的函数:`LOCATE(str1,str),POSITION(str1 IN str),INSTR(str,str1)`\n* `ELT(N,str1,str2,...)`返回指定位置N的字符串,若N小于1或大于参数的个数，则返回NULL\n* `IF(expr,v1,v2)`若expr为真，返回v1,否则返回v2\n* `IFNULL(v1,v2)`若v1不为NULL，则返回v1.否则返回v2\n* `CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2] [ELSE rn] END`如果expr的值等于某个vn，则返回对应rn\n* 查看系统信息`select version()` `select connection_ID()`\n* `SELECT USER(),CURRENT_USER(),SYSTEM_USER();`获取用户名函数\n* `LAST_INSERT_ID()`获取最后一格自动生成的ID值\n* `FORMAT(x,n)`将数字格式化，四舍五入保留小数点后n位。以字符串形式返回，若n=0,则返回函数不包含小数部分\n* `CONV(n,FROM_BASE,TO_BASE)`对N进制转换\n* ip地址与数字相互转换：`INET_ATON(expr)`返回一个代表地址数值的整数，`INET_NTOA(EXPR)`将数值转换为网络地址\n* 查询语句中AND和OR一起使用时，AND优先级高于OR\n* DISTINCT关键字去重\n* ORDER BY关键字默认按ASC(升序)方式排序，DESC只对其前面的列进行降序排序\n* [GROUP BY 字段] [HAVING <条件表达式>]分组查询\n* HAVING和WHERE比较：两个都是用来过滤数据的，HAVING在数据分组之后进行过滤来选择分组，WHERE在分组之前来选择记录。WHERE排除的记录不再包括在分组中。\n\n","source":"_posts/MySQL查漏补缺（一）.md","raw":"---\ntitle: MySQL查漏补缺（一）\ndate: 2018-04-03 14:36:40\ntags: [数据库, MySQL]\n---\n本篇博客记录本人在复习MySQL基本操作过程中碰到的之前忽略或者忘记的知识点\n* 命令`HOW DATABASES`后出现的mysql数据库是必需的，它描述用户访问权限\n* 创建数据库是在系统磁盘上划分一块区域用于数据的存储和管理\n* `show engines`查看系统支持的引擎\n* InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键\n> 特点：\n> - InnoDB给MySQL提供了具有提交、回滚、和崩溃恢复能力的事务安全存储引擎\n> - 为处理巨大数据量的最大性能设计，CPU效率高\n> - 完全与MySQL服务器整合\n> - 支持外键完整约束\n>   <!-- more-->\n* MyISAM拥有较高的插入、查询速度，但不支持事务\n* MEMORY存储引擎将数据存储到内存中，为查询和引用其他表数据提供快速访问\n* 主键是表中*一列或者多列的组合*，主键约束要求主键数据唯一，并且不能为空，主键可以和外键结合起来定义不同数据表之间的关系，可以加快查询的速度\n* 主键类型：单字段主键、多字段联合主键\n* 创建多字段主键：`PRIMARY KET [VAR1,VAR2,...]`\n* 外键用来在两个表的数据之间建立链接，可以是一列或者多列，外键对应参照完整性\n* 一个表的外键可以为空，可以不是本表的主键，若不为空，则每个外键的值必须等于另一个表中主键的某个值\n* 定义外键后，不允许删除在另一个表中具有关联关系的行\n* 创建外键语法:`[CONSTRAINT <外键名>] FOREIGN KEY 字段名1 [，字段名2，...] REFRENCES <主表名> 主键列1[， 主键列2...]`\n* 一个表中不能有相同名称的外键\n* 一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分\n* 查看表的基本结构：\n> DESC:查看基本结构\n> SHOW CREATE TABLE:查看详细表结构，可以显示创建表的语句，加上‘\\G‘参数显示的结果更直观\n* 修改表名：`alter table 表名 rename to 新表名`\n* 修改字段数据类型：`alter table 表名 modify 字段名 数据类型`\n* 修改字段名：`alter table 表名 change 旧字段名 新字段名 新数据类型`\n* 添加字段：`alter table 表名 add 新字段名 数据类型 约束类型 [FIRST|AFTER 已存在字段名]` FIRST和AFTER为可选参数，将新字段置于首位或者添加到以存在字段名之后， 默认添加到最后列\n* 删除字段： `alter table 表名 drop 字段名 `\n* 修改表名的排列顺序：`alter table 表名 modify 字段名 数据类型 FIRST | AFTER 已存在字段`\n* 修改引擎： `alter table 表名 engin=引擎名`\n* 删除外键约束：`alter table 表名 drop foreign kei 外键名`\n* 数据表之间存在关联关系时，删除父表会报错\n* 并不是每个表都需要主键\n* 表示小数：浮点数：float double 定点数：decimal,都可以用（M，N）表示，M为精度，表示总共位数，N为标度，表示小数位数\n* decimal以串存放，其可能的最大取直与double一样\n* CHAR(M)定长字符串，检索到CHAR值时，尾部空格将删除\n* VARCHAR(M)长度可变字符串，M表示最大列长度，0-65535，实际占用空间为字符串实际长度加一，在值保存和检索时尾部的空格任保留\n* ENUM是字符串对象，值为表在创建时在列规定中枚举的一列直，语法`字段名 enum （'val1'，'val2',...'valn'）`\n* ENUM类型的字段在取值时只能在指定枚举列表中取且一次只能取一个，成员尾部空格将自动被删除，ENUM值在内部用整数表示，每个枚举值均有一个索引值，列表索引值从一开始编号，NULL的索引为NULL，字段值区分大小写\n![](/home/harold/Pictures/Selection_050.png)\n![](/home/harold/Pictures/Selection_051.png)\n\n* SET是一个字符串对象，可以有0-64个成员，SET类型的列可以从定义的列值中选择多个字符的联合，SET会删除重复的值\n* BIN()函数将数字转换为二进制\n* 二进制字符串类型：\n> - BIT:位字段\n> - BINARY(M):长度二进制字符串\n>  - VARBINARY(M): 变长\n>  - BLOB(M):小BLOB，BLOB是二进制大对象，存储可变数量的数据\n* TEXT和BLOB比较：\n\n<table>\n<tr><td>TEXT</td>\n<td>BLOB</td></tr>\n<tr><td>存储非二进制字符串(字符字符串)</td>\n<td>存储二进制字符串(字节字符串)</td></tr>\n<tr><td>有一个字符集,根据字符集对值比较和排序</td>\n<td>没有字符集，排序和比较基于列值字节的数值</td></tr>\n<tr><td>只能存纯文本文件</td>\n<td>主要存图片，音频等</td></tr>\n<table>\n* `=`操作符：\n 若有一个或两个参数为NULL，比较结果为NULL\n 若两个参数都是字符串，则按字符串进行比较\n 都为整数，按整数比较\n 若一个字符串一个整数比较，自动将字符串转换为整数\n\n* 安全等于运算符`<=>`,可用来判断null值\n* `LEAST（val1,val2,...valn）`运算符返回参数中的最小值，如果参数中有NULL，返回NULL\n* `GREATEST(val1,val2,...)`返回最大值，有NULL时，返回NULL\n* `exp REGEXP 匹配条件`，用来匹配字符串，匹配返回1,否则返回0，若expr或匹配条件中有一个NULL，结果为NULL，通配符比LIKE多，不区分大小写\n* 函数CEIL(x),CEILING(x),FLOOR(x)获取整数值，前两个向上取整，floor()向下取整\n* 函数RAND(x)返回0-1间的浮点数，x作为种子\n* ROUND(x)函数四舍五入,ROUND(x,y)返回最接近x的数，结果保留小数点后y位，若y为负值，则将小数点保留x只到小数点左边y位\n* TRUNCATE(x,y)返回被舍去小数点后y位的数字x，若y为0，则结果不带有小数部分，若y为负数，则截取(归零)x小数点做起y位开始后所有低位的值。\n* CHAR_LENGTH(str)返回字符串str所包含的字符个数，一个多字节字符算作一个单字符。\n* LENGTH(str）返回字符串的字节长度\n* CONCAT(s1,s2,...)连接字符串，如果有一个参数为NULL，则结果为NULL，若自变量中存在二进制字符串，则结果为一个二进制字符串\n* CONCAT(X,S1,S2,...)以x作为分隔符连接字符串\n* `INSERT(S1,X，LEN,s2)`替换字符串函数，从s1的x位置用s2取代len个字符，若x超过字符串长度，则返回原始字符串，有一个参数为NULL则返回NULL\n* 大小写转换LOWER(STR),LCASE(STR),UPPER(STR),UCASE(STR)\n* 获取指定长度字符串`LEFT(s,n)`,`RIGHT(s,n)`\n* `TRIM(s1 FROM s)`从s两端删除所有子字符s1\n* 匹配子串str1在str中开始位置的函数:`LOCATE(str1,str),POSITION(str1 IN str),INSTR(str,str1)`\n* `ELT(N,str1,str2,...)`返回指定位置N的字符串,若N小于1或大于参数的个数，则返回NULL\n* `IF(expr,v1,v2)`若expr为真，返回v1,否则返回v2\n* `IFNULL(v1,v2)`若v1不为NULL，则返回v1.否则返回v2\n* `CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2] [ELSE rn] END`如果expr的值等于某个vn，则返回对应rn\n* 查看系统信息`select version()` `select connection_ID()`\n* `SELECT USER(),CURRENT_USER(),SYSTEM_USER();`获取用户名函数\n* `LAST_INSERT_ID()`获取最后一格自动生成的ID值\n* `FORMAT(x,n)`将数字格式化，四舍五入保留小数点后n位。以字符串形式返回，若n=0,则返回函数不包含小数部分\n* `CONV(n,FROM_BASE,TO_BASE)`对N进制转换\n* ip地址与数字相互转换：`INET_ATON(expr)`返回一个代表地址数值的整数，`INET_NTOA(EXPR)`将数值转换为网络地址\n* 查询语句中AND和OR一起使用时，AND优先级高于OR\n* DISTINCT关键字去重\n* ORDER BY关键字默认按ASC(升序)方式排序，DESC只对其前面的列进行降序排序\n* [GROUP BY 字段] [HAVING <条件表达式>]分组查询\n* HAVING和WHERE比较：两个都是用来过滤数据的，HAVING在数据分组之后进行过滤来选择分组，WHERE在分组之前来选择记录。WHERE排除的记录不再包括在分组中。\n\n","slug":"MySQL查漏补缺（一）","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6o000pcf96a08e6okm","content":"<p>本篇博客记录本人在复习MySQL基本操作过程中碰到的之前忽略或者忘记的知识点</p>\n<ul>\n<li>命令<code>HOW DATABASES</code>后出现的mysql数据库是必需的，它描述用户访问权限</li>\n<li>创建数据库是在系统磁盘上划分一块区域用于数据的存储和管理</li>\n<li><code>show engines</code>查看系统支持的引擎</li>\n<li>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键<blockquote>\n<p>特点：</p>\n<ul>\n<li>InnoDB给MySQL提供了具有提交、回滚、和崩溃恢复能力的事务安全存储引擎</li>\n<li>为处理巨大数据量的最大性能设计，CPU效率高</li>\n<li>完全与MySQL服务器整合</li>\n<li>支持外键完整约束<a id=\"more\"></a></li>\n</ul>\n</blockquote>\n</li>\n<li>MyISAM拥有较高的插入、查询速度，但不支持事务</li>\n<li>MEMORY存储引擎将数据存储到内存中，为查询和引用其他表数据提供快速访问</li>\n<li>主键是表中<em>一列或者多列的组合</em>，主键约束要求主键数据唯一，并且不能为空，主键可以和外键结合起来定义不同数据表之间的关系，可以加快查询的速度</li>\n<li>主键类型：单字段主键、多字段联合主键</li>\n<li>创建多字段主键：<code>PRIMARY KET [VAR1,VAR2,...]</code></li>\n<li>外键用来在两个表的数据之间建立链接，可以是一列或者多列，外键对应参照完整性</li>\n<li>一个表的外键可以为空，可以不是本表的主键，若不为空，则每个外键的值必须等于另一个表中主键的某个值</li>\n<li>定义外键后，不允许删除在另一个表中具有关联关系的行</li>\n<li>创建外键语法:<code>[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名1 [，字段名2，...] REFRENCES &lt;主表名&gt; 主键列1[， 主键列2...]</code></li>\n<li>一个表中不能有相同名称的外键</li>\n<li>一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分</li>\n<li>查看表的基本结构：<blockquote>\n<p>DESC:查看基本结构<br>SHOW CREATE TABLE:查看详细表结构，可以显示创建表的语句，加上‘\\G‘参数显示的结果更直观</p>\n</blockquote>\n</li>\n<li>修改表名：<code>alter table 表名 rename to 新表名</code></li>\n<li>修改字段数据类型：<code>alter table 表名 modify 字段名 数据类型</code></li>\n<li>修改字段名：<code>alter table 表名 change 旧字段名 新字段名 新数据类型</code></li>\n<li>添加字段：<code>alter table 表名 add 新字段名 数据类型 约束类型 [FIRST|AFTER 已存在字段名]</code> FIRST和AFTER为可选参数，将新字段置于首位或者添加到以存在字段名之后， 默认添加到最后列</li>\n<li>删除字段： <code>alter table 表名 drop 字段名</code></li>\n<li>修改表名的排列顺序：<code>alter table 表名 modify 字段名 数据类型 FIRST | AFTER 已存在字段</code></li>\n<li>修改引擎： <code>alter table 表名 engin=引擎名</code></li>\n<li>删除外键约束：<code>alter table 表名 drop foreign kei 外键名</code></li>\n<li>数据表之间存在关联关系时，删除父表会报错</li>\n<li>并不是每个表都需要主键</li>\n<li>表示小数：浮点数：float double 定点数：decimal,都可以用（M，N）表示，M为精度，表示总共位数，N为标度，表示小数位数</li>\n<li>decimal以串存放，其可能的最大取直与double一样</li>\n<li>CHAR(M)定长字符串，检索到CHAR值时，尾部空格将删除</li>\n<li>VARCHAR(M)长度可变字符串，M表示最大列长度，0-65535，实际占用空间为字符串实际长度加一，在值保存和检索时尾部的空格任保留</li>\n<li>ENUM是字符串对象，值为表在创建时在列规定中枚举的一列直，语法<code>字段名 enum （&#39;val1&#39;，&#39;val2&#39;,...&#39;valn&#39;）</code></li>\n<li><p>ENUM类型的字段在取值时只能在指定枚举列表中取且一次只能取一个，成员尾部空格将自动被删除，ENUM值在内部用整数表示，每个枚举值均有一个索引值，列表索引值从一开始编号，NULL的索引为NULL，字段值区分大小写<br><img src=\"/home/harold/Pictures/Selection_050.png\" alt=\"\"><br><img src=\"/home/harold/Pictures/Selection_051.png\" alt=\"\"></p>\n</li>\n<li><p>SET是一个字符串对象，可以有0-64个成员，SET类型的列可以从定义的列值中选择多个字符的联合，SET会删除重复的值</p>\n</li>\n<li>BIN()函数将数字转换为二进制</li>\n<li>二进制字符串类型：<blockquote>\n<ul>\n<li>BIT:位字段</li>\n<li>BINARY(M):长度二进制字符串<ul>\n<li>VARBINARY(M): 变长</li>\n<li>BLOB(M):小BLOB，BLOB是二进制大对象，存储可变数量的数据</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>TEXT和BLOB比较：</li>\n</ul>\n<p><table></table></p>\n<p><tr><td>TEXT</td></tr></p>\n<p><td>BLOB</td></p>\n<p><tr><td>存储非二进制字符串(字符字符串)</td></tr></p>\n<p><td>存储二进制字符串(字节字符串)</td></p>\n<p><tr><td>有一个字符集,根据字符集对值比较和排序</td></tr></p>\n<p><td>没有字符集，排序和比较基于列值字节的数值</td></p>\n<p><tr><td>只能存纯文本文件</td></tr></p>\n<p><td>主要存图片，音频等</td></p>\n<p><table></table></p>\n<ul>\n<li><p><code>=</code>操作符：<br>若有一个或两个参数为NULL，比较结果为NULL<br>若两个参数都是字符串，则按字符串进行比较<br>都为整数，按整数比较<br>若一个字符串一个整数比较，自动将字符串转换为整数</p>\n</li>\n<li><p>安全等于运算符<code>&lt;=&gt;</code>,可用来判断null值</p>\n</li>\n<li><code>LEAST（val1,val2,...valn）</code>运算符返回参数中的最小值，如果参数中有NULL，返回NULL</li>\n<li><code>GREATEST(val1,val2,...)</code>返回最大值，有NULL时，返回NULL</li>\n<li><code>exp REGEXP 匹配条件</code>，用来匹配字符串，匹配返回1,否则返回0，若expr或匹配条件中有一个NULL，结果为NULL，通配符比LIKE多，不区分大小写</li>\n<li>函数CEIL(x),CEILING(x),FLOOR(x)获取整数值，前两个向上取整，floor()向下取整</li>\n<li>函数RAND(x)返回0-1间的浮点数，x作为种子</li>\n<li>ROUND(x)函数四舍五入,ROUND(x,y)返回最接近x的数，结果保留小数点后y位，若y为负值，则将小数点保留x只到小数点左边y位</li>\n<li>TRUNCATE(x,y)返回被舍去小数点后y位的数字x，若y为0，则结果不带有小数部分，若y为负数，则截取(归零)x小数点做起y位开始后所有低位的值。</li>\n<li>CHAR_LENGTH(str)返回字符串str所包含的字符个数，一个多字节字符算作一个单字符。</li>\n<li>LENGTH(str）返回字符串的字节长度</li>\n<li>CONCAT(s1,s2,…)连接字符串，如果有一个参数为NULL，则结果为NULL，若自变量中存在二进制字符串，则结果为一个二进制字符串</li>\n<li>CONCAT(X,S1,S2,…)以x作为分隔符连接字符串</li>\n<li><code>INSERT(S1,X，LEN,s2)</code>替换字符串函数，从s1的x位置用s2取代len个字符，若x超过字符串长度，则返回原始字符串，有一个参数为NULL则返回NULL</li>\n<li>大小写转换LOWER(STR),LCASE(STR),UPPER(STR),UCASE(STR)</li>\n<li>获取指定长度字符串<code>LEFT(s,n)</code>,<code>RIGHT(s,n)</code></li>\n<li><code>TRIM(s1 FROM s)</code>从s两端删除所有子字符s1</li>\n<li>匹配子串str1在str中开始位置的函数:<code>LOCATE(str1,str),POSITION(str1 IN str),INSTR(str,str1)</code></li>\n<li><code>ELT(N,str1,str2,...)</code>返回指定位置N的字符串,若N小于1或大于参数的个数，则返回NULL</li>\n<li><code>IF(expr,v1,v2)</code>若expr为真，返回v1,否则返回v2</li>\n<li><code>IFNULL(v1,v2)</code>若v1不为NULL，则返回v1.否则返回v2</li>\n<li><code>CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2] [ELSE rn] END</code>如果expr的值等于某个vn，则返回对应rn</li>\n<li>查看系统信息<code>select version()</code> <code>select connection_ID()</code></li>\n<li><code>SELECT USER(),CURRENT_USER(),SYSTEM_USER();</code>获取用户名函数</li>\n<li><code>LAST_INSERT_ID()</code>获取最后一格自动生成的ID值</li>\n<li><code>FORMAT(x,n)</code>将数字格式化，四舍五入保留小数点后n位。以字符串形式返回，若n=0,则返回函数不包含小数部分</li>\n<li><code>CONV(n,FROM_BASE,TO_BASE)</code>对N进制转换</li>\n<li>ip地址与数字相互转换：<code>INET_ATON(expr)</code>返回一个代表地址数值的整数，<code>INET_NTOA(EXPR)</code>将数值转换为网络地址</li>\n<li>查询语句中AND和OR一起使用时，AND优先级高于OR</li>\n<li>DISTINCT关键字去重</li>\n<li>ORDER BY关键字默认按ASC(升序)方式排序，DESC只对其前面的列进行降序排序</li>\n<li>[GROUP BY 字段] [HAVING &lt;条件表达式&gt;]分组查询</li>\n<li>HAVING和WHERE比较：两个都是用来过滤数据的，HAVING在数据分组之后进行过滤来选择分组，WHERE在分组之前来选择记录。WHERE排除的记录不再包括在分组中。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本篇博客记录本人在复习MySQL基本操作过程中碰到的之前忽略或者忘记的知识点</p>\n<ul>\n<li>命令<code>HOW DATABASES</code>后出现的mysql数据库是必需的，它描述用户访问权限</li>\n<li>创建数据库是在系统磁盘上划分一块区域用于数据的存储和管理</li>\n<li><code>show engines</code>查看系统支持的引擎</li>\n<li>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键<blockquote>\n<p>特点：</p>\n<ul>\n<li>InnoDB给MySQL提供了具有提交、回滚、和崩溃恢复能力的事务安全存储引擎</li>\n<li>为处理巨大数据量的最大性能设计，CPU效率高</li>\n<li>完全与MySQL服务器整合</li>\n<li>支持外键完整约束","more":"</li>\n</ul>\n</blockquote>\n</li>\n<li>MyISAM拥有较高的插入、查询速度，但不支持事务</li>\n<li>MEMORY存储引擎将数据存储到内存中，为查询和引用其他表数据提供快速访问</li>\n<li>主键是表中<em>一列或者多列的组合</em>，主键约束要求主键数据唯一，并且不能为空，主键可以和外键结合起来定义不同数据表之间的关系，可以加快查询的速度</li>\n<li>主键类型：单字段主键、多字段联合主键</li>\n<li>创建多字段主键：<code>PRIMARY KET [VAR1,VAR2,...]</code></li>\n<li>外键用来在两个表的数据之间建立链接，可以是一列或者多列，外键对应参照完整性</li>\n<li>一个表的外键可以为空，可以不是本表的主键，若不为空，则每个外键的值必须等于另一个表中主键的某个值</li>\n<li>定义外键后，不允许删除在另一个表中具有关联关系的行</li>\n<li>创建外键语法:<code>[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名1 [，字段名2，...] REFRENCES &lt;主表名&gt; 主键列1[， 主键列2...]</code></li>\n<li>一个表中不能有相同名称的外键</li>\n<li>一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分</li>\n<li>查看表的基本结构：<blockquote>\n<p>DESC:查看基本结构<br>SHOW CREATE TABLE:查看详细表结构，可以显示创建表的语句，加上‘\\G‘参数显示的结果更直观</p>\n</blockquote>\n</li>\n<li>修改表名：<code>alter table 表名 rename to 新表名</code></li>\n<li>修改字段数据类型：<code>alter table 表名 modify 字段名 数据类型</code></li>\n<li>修改字段名：<code>alter table 表名 change 旧字段名 新字段名 新数据类型</code></li>\n<li>添加字段：<code>alter table 表名 add 新字段名 数据类型 约束类型 [FIRST|AFTER 已存在字段名]</code> FIRST和AFTER为可选参数，将新字段置于首位或者添加到以存在字段名之后， 默认添加到最后列</li>\n<li>删除字段： <code>alter table 表名 drop 字段名</code></li>\n<li>修改表名的排列顺序：<code>alter table 表名 modify 字段名 数据类型 FIRST | AFTER 已存在字段</code></li>\n<li>修改引擎： <code>alter table 表名 engin=引擎名</code></li>\n<li>删除外键约束：<code>alter table 表名 drop foreign kei 外键名</code></li>\n<li>数据表之间存在关联关系时，删除父表会报错</li>\n<li>并不是每个表都需要主键</li>\n<li>表示小数：浮点数：float double 定点数：decimal,都可以用（M，N）表示，M为精度，表示总共位数，N为标度，表示小数位数</li>\n<li>decimal以串存放，其可能的最大取直与double一样</li>\n<li>CHAR(M)定长字符串，检索到CHAR值时，尾部空格将删除</li>\n<li>VARCHAR(M)长度可变字符串，M表示最大列长度，0-65535，实际占用空间为字符串实际长度加一，在值保存和检索时尾部的空格任保留</li>\n<li>ENUM是字符串对象，值为表在创建时在列规定中枚举的一列直，语法<code>字段名 enum （&#39;val1&#39;，&#39;val2&#39;,...&#39;valn&#39;）</code></li>\n<li><p>ENUM类型的字段在取值时只能在指定枚举列表中取且一次只能取一个，成员尾部空格将自动被删除，ENUM值在内部用整数表示，每个枚举值均有一个索引值，列表索引值从一开始编号，NULL的索引为NULL，字段值区分大小写<br><img src=\"/home/harold/Pictures/Selection_050.png\" alt=\"\"><br><img src=\"/home/harold/Pictures/Selection_051.png\" alt=\"\"></p>\n</li>\n<li><p>SET是一个字符串对象，可以有0-64个成员，SET类型的列可以从定义的列值中选择多个字符的联合，SET会删除重复的值</p>\n</li>\n<li>BIN()函数将数字转换为二进制</li>\n<li>二进制字符串类型：<blockquote>\n<ul>\n<li>BIT:位字段</li>\n<li>BINARY(M):长度二进制字符串<ul>\n<li>VARBINARY(M): 变长</li>\n<li>BLOB(M):小BLOB，BLOB是二进制大对象，存储可变数量的数据</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>TEXT和BLOB比较：</li>\n</ul>\n<p><table></table></p>\n<p><tr><td>TEXT</td></tr></p>\n<p><td>BLOB</td></p>\n<p><tr><td>存储非二进制字符串(字符字符串)</td></tr></p>\n<p><td>存储二进制字符串(字节字符串)</td></p>\n<p><tr><td>有一个字符集,根据字符集对值比较和排序</td></tr></p>\n<p><td>没有字符集，排序和比较基于列值字节的数值</td></p>\n<p><tr><td>只能存纯文本文件</td></tr></p>\n<p><td>主要存图片，音频等</td></p>\n<p><table></table></p>\n<ul>\n<li><p><code>=</code>操作符：<br>若有一个或两个参数为NULL，比较结果为NULL<br>若两个参数都是字符串，则按字符串进行比较<br>都为整数，按整数比较<br>若一个字符串一个整数比较，自动将字符串转换为整数</p>\n</li>\n<li><p>安全等于运算符<code>&lt;=&gt;</code>,可用来判断null值</p>\n</li>\n<li><code>LEAST（val1,val2,...valn）</code>运算符返回参数中的最小值，如果参数中有NULL，返回NULL</li>\n<li><code>GREATEST(val1,val2,...)</code>返回最大值，有NULL时，返回NULL</li>\n<li><code>exp REGEXP 匹配条件</code>，用来匹配字符串，匹配返回1,否则返回0，若expr或匹配条件中有一个NULL，结果为NULL，通配符比LIKE多，不区分大小写</li>\n<li>函数CEIL(x),CEILING(x),FLOOR(x)获取整数值，前两个向上取整，floor()向下取整</li>\n<li>函数RAND(x)返回0-1间的浮点数，x作为种子</li>\n<li>ROUND(x)函数四舍五入,ROUND(x,y)返回最接近x的数，结果保留小数点后y位，若y为负值，则将小数点保留x只到小数点左边y位</li>\n<li>TRUNCATE(x,y)返回被舍去小数点后y位的数字x，若y为0，则结果不带有小数部分，若y为负数，则截取(归零)x小数点做起y位开始后所有低位的值。</li>\n<li>CHAR_LENGTH(str)返回字符串str所包含的字符个数，一个多字节字符算作一个单字符。</li>\n<li>LENGTH(str）返回字符串的字节长度</li>\n<li>CONCAT(s1,s2,…)连接字符串，如果有一个参数为NULL，则结果为NULL，若自变量中存在二进制字符串，则结果为一个二进制字符串</li>\n<li>CONCAT(X,S1,S2,…)以x作为分隔符连接字符串</li>\n<li><code>INSERT(S1,X，LEN,s2)</code>替换字符串函数，从s1的x位置用s2取代len个字符，若x超过字符串长度，则返回原始字符串，有一个参数为NULL则返回NULL</li>\n<li>大小写转换LOWER(STR),LCASE(STR),UPPER(STR),UCASE(STR)</li>\n<li>获取指定长度字符串<code>LEFT(s,n)</code>,<code>RIGHT(s,n)</code></li>\n<li><code>TRIM(s1 FROM s)</code>从s两端删除所有子字符s1</li>\n<li>匹配子串str1在str中开始位置的函数:<code>LOCATE(str1,str),POSITION(str1 IN str),INSTR(str,str1)</code></li>\n<li><code>ELT(N,str1,str2,...)</code>返回指定位置N的字符串,若N小于1或大于参数的个数，则返回NULL</li>\n<li><code>IF(expr,v1,v2)</code>若expr为真，返回v1,否则返回v2</li>\n<li><code>IFNULL(v1,v2)</code>若v1不为NULL，则返回v1.否则返回v2</li>\n<li><code>CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2] [ELSE rn] END</code>如果expr的值等于某个vn，则返回对应rn</li>\n<li>查看系统信息<code>select version()</code> <code>select connection_ID()</code></li>\n<li><code>SELECT USER(),CURRENT_USER(),SYSTEM_USER();</code>获取用户名函数</li>\n<li><code>LAST_INSERT_ID()</code>获取最后一格自动生成的ID值</li>\n<li><code>FORMAT(x,n)</code>将数字格式化，四舍五入保留小数点后n位。以字符串形式返回，若n=0,则返回函数不包含小数部分</li>\n<li><code>CONV(n,FROM_BASE,TO_BASE)</code>对N进制转换</li>\n<li>ip地址与数字相互转换：<code>INET_ATON(expr)</code>返回一个代表地址数值的整数，<code>INET_NTOA(EXPR)</code>将数值转换为网络地址</li>\n<li>查询语句中AND和OR一起使用时，AND优先级高于OR</li>\n<li>DISTINCT关键字去重</li>\n<li>ORDER BY关键字默认按ASC(升序)方式排序，DESC只对其前面的列进行降序排序</li>\n<li>[GROUP BY 字段] [HAVING &lt;条件表达式&gt;]分组查询</li>\n<li>HAVING和WHERE比较：两个都是用来过滤数据的，HAVING在数据分组之后进行过滤来选择分组，WHERE在分组之前来选择记录。WHERE排除的记录不再包括在分组中。</li>\n</ul>"},{"title":"MySQL查漏补缺（二）","date":"2018-04-04T14:55:35.000Z","_content":"\n* 在GROUP BY语句后使用WITH ROLLUP，在所有查询结果后会增加一条记录，计算查询出的所有记录的总和\n* 使用WITH ROLLUP时，不能同时使用ORDER BY子句排序，两者相互排斥\n* 使用LIMIT限制查询结果的数量，`LIMIT [位置偏移量（默认为0），] 行数`，偏移量表示从哪一行开始显示\n* COUNT(*)计算表中总的行数，不管某列是否有空值，COUNT（字段名）会忽略字段列中的空值\n* SUM（）函数计算时会忽略NULL的行\n* MAX()和MIN()都不仅可以查找数据类型，还可以用于字符类型\n* 连接查询条件：两个或多个列表存在相同意义的字段\n* 在一个连接查询中，如果涉及到的两个表都为一个表，称为自连接查询，自连接是特殊的内连接。两表相同时，用AS取别名防止二义性\n* <!-- more-->\n* 子查询：一个查询语句嵌套到一个查询语句的内部\n* SOME，ANY表示满足其中任一条件，允许创建一个表达式对子查询的返回列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件\n* ALL关键字需要同时满足所有的内层查询条件\n* EXISTS关键字后面跟任意子查询，子查询有返回行则返回TRUE，此时外层语句将进行查询，否则返回false，对称的操作时NOT EXISTS\n* 利用UNION关键字可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列和数据类型必须相同。UNION会删除重复的记录，所有返回的行都是唯一的，UNION ALL不删除重复行也不对结果自动排序。UNION ALL的效率高一点\n* LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回，REGEXP会返回\n* 更新表UPDATE table_name SET column_name = val WHERE condition如果忽略WHERE子句，MySQL将更新表中所有的行\n* TRUNCATE TABLE语句直接删除原来的表并新建一个表，比DELETE速度快\n* 索引用于快速查找出某个列中有一特定行的值，是对数据库表中一列或者多列的值进行排序的一种结构，可提高特定数据的查询速度\n* 索引是单独存储在磁盘上的数据结构，所有MySQL列类型都可以被索引\n* 索引优点：\n> 1. 通过创建唯一索引，可以保证数据库表中没一行数据的唯一性\n> 2. 可以大大加快数据的查询速度\n> 3. 在实现数据参考的完整性方面，可以加速表与表之间的连接\n> 4. 在使用分组和排序子句进行数据查询时，可以显式减少查询中分组和排序的时间\n* 索引缺点：\n> . 创建索引和维护索引需要耗费时间，并且随着数据量的增加所耗费的时间也会增加\n> . 索引需要占磁盘空间\n> . 对表中的数据进行增加、删除和修改的时候，索引也要动态维护，降低了维护速度\n\n索引分类：\n> * 普通索引：基本索引类型，允许在定义索引的列中插入重复值和空值\n> * 唯一索引：索引列必须是唯一的，允许有空值。主键索引是特殊唯一索引，不允许有空值\n> * 单列索引：一个索引只允许包含一列，一个表可以有多个单列索引\n> * 组合索引：在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。遵循最左前缀集合\n> * 全文索引：类型为FULLTEXT，在定义索引的列上支持全文查找，允许在这些索引列中插入重复值和空值MySQL中只有MyISAM存储引擎支持全文索引\n> * 空间索引：对空间数据类型字段建立的索引。\n创建表时创建索引：`CREATE TABLE table_name [col_name data_type] [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC | DESC]`,UNIQUE|FULLTEXT|SPATIAL 可选，分别表示唯一索引，全文索引和空间索引，INDEX与KEY为同义词，用来指定创建索引，index_name为索引名，可选，若不指定，则默认以col_name为索引值;length可选，表示索引的长度，只有字符串类型的字段才能指定索引长度。\n\n```SQL\nmysql> show create table book\\G\n*************************** 1. row ***************************\n       Table: book\nCreate Table: CREATE TABLE `book` (\n  `book_id` int(11) NOT NULL,\n  `book_name` varchar(255) NOT NULL,\n  `authors` varchar(255) NOT NULL,\n  `info` varchar(255) DEFAULT NULL,\n  `comment` varchar(255) DEFAULT NULL,\n  `year_publication` year(4) NOT NULL,\n  KEY `year_publication` (`year_publication`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n1 row in set (0.00 sec)\n```\n使用EXPLAIN语句查看索引是否正在使用。\n```SQL\nmysql> explain select * from book where year_publication=1990 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: book\n   partitions: NULL\n         type: ref\npossible_keys: year_publication\n          key: year_publication\n      key_len: 1\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index condition\n1 row in set, 1 warning (0.01 sec)\n\n```\n* `ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length]) [ASC|DESC]`在已存在的表上添加索引\n* `CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC|DESC]`在已存在的表上添加索引\n* `ALTER TABLE table_name DROP INDEX index_name`删除索引\n* 添加AUTO_INCREMENT约束字段的唯一索引不能被删除\n* DROP INDEX index_name ON table_name;\n* 存储过程是一条或多条SQL语句的集合，可视为批文件。\n* 存储程序可以分为存储过程和函数。创建存储过程，只能用输出变量返回值。`CREATE PROCEDURE`,创建函数`CREATE FUNCTION`，使用`CALL`语句调用存储过程。函数可以从语句外部调用，也能返回标量值。存储过程可以调用其他存储过程。\n* `CREATE PROCEDURE sp_name ([proc_parameter]) [characteristics ...] routine_body`,proc_parameter指定参数列表，列表形式：`[IN | OUT | INOUT] param_name type`,type参数类型可以时MySQL数据库中的任意类型。characteristic指定存储过程的特性，取值有：\n> LANGUAGE SQL:说明routine_body部分是由SQL语句组成的\n> [NOT] DETERMINISTIC：指明存储过程结果是否确定，即相同的输入是否能得到相同的输出\n> {CONSTRAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}，指明子程序使用SQL语句的限制\n> SQL SECURITY {DEFINER（定义者——默认） | INVOKER（拥有权限的调用者）}：指定谁有权执行\n> COMMENT'string':注释信息\n\nroutine_body是SQL代码内容，用BEGIN...END表示开始和结束\n\n```SQL\nmysql> DELIMITER //\nmysql> CREATE PROCEDURE CountProc (OUT param1 INT)\n    -> SELECT COUNT(*) INTO param1 FROM fruits;\n    -> END //\n```\n将计算结果放入参数param1,`DELIMITER //`语句设置结束符，避免与存储过程中的;相冲突\n* 创建存储函数`CREATE FUNCTION func_name ([func_parameter]) RETURNS type [characteristic...] routine_body`,RETURNS type表示函数返回数据的类型\n* ```sql\nmysql> CREATE FUNCTION NameByZip()\n    -> RETURNS CHAR(50)\n    -> RETURN (SELECT f_name FROM fruits WHERE s_price>5.0);\n    -> //\nQuery OK, 0 rows affected (0.01 sec)\n```\n如果存储函数中RETURN语句返回的类型不同于函数RETURNS子句中指定类型不同，返回值将被强制为恰当的类型。函数体必须包含一个RETURN value语句\n* 变量可以在子程序中声明使用，作用范围是BEGIN...END程序中\n* 定义变量：`DECLARE var_name[,var_name]... data_type [DEFAULT value]`\n* 改变变量值：`SET var_name = expr [,var_name = expr]...`\n* 通过`SELECT col_name[,...] INTO var_name[,...] table_expr`向变量赋值\n* 定义条件是事先定义程序执行过程中遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。\n* 定义条件：\n* ```SQL\n    CREATE condition_name CONDITION FOR [condition type]\n\n    [condition_type]:\n    SQLSTATE [VALUE] sqlstate_value | mysql_error_code```\n    condition type表示条件的类型，sqlstate_value 和 mysql_error_code都表示MySQL的错误\n* 定义处理程序：\n\n```SQL\nDECALRE handler_type HANDLER FOR condition_value[,...] sp_statement\nhandler_type:\nCONTINUE | EXIT | UNDO\n\ncondition_value:\n\tSQLSTATE [VALUE]  sqlstate_value\n    | condition_name\n    | SQLWARNING\n    | NOT FOUND\n    | SQLEXCEPTION\n    | mysql_error_code\n```\nhandler_type为错误处理方式，有三个取值，UNDO表示遇到错误后撤回之前的操作，MySQL不支持UNDO\n`e.g:DECLARE CONTINUE HANDLER FOR 1146 SET @info='NO_SUCH_TABLE'`;\n* @var_name表示用户变量，使用SET赋值，与连接有关，一个客户端定义的变量不能被其他客户端看到或使用，客户端退出时，其连接的用户变量将自动释放。\n* 光标：数据量大时，在存储过程和函数中逐条读取查询结果集中的记录。必须在声明处理程序之前声明光标，并且变量和条件还必须在声明光标或处理程序之前被声明。\n* `DECLARE cursor_name CURSOR FOR select_statement`声明标签\n* `OPEN cursor_name`:打开先前声明的光标\n* `FETCH cursore_name INTO var_name,...`使用光标，将光标存入var_name,var_name必须在声明光标前就定义好\n* `CLOSE cursor_name`:关闭光标\n* MySQL中光标只能在存储过程和函数中使用\n* 流程控制语句：根据条件控制语句的执行，IF，CASE，LOOP，LEAVE，ITERATE，REPEAT，WHILE语句等\n* IF语句：\n```SQL\n IF expr_condition THEN statement_list\n \t[ELSEIF expr_condition THEN statement_list]...\n \t[ELSE statement_list]\n END IF```\n* CASE语句：\n```SQL\nCASE case_expr\n\tWHEN when_value THEN statement_list\n    [WHEN when_value THEN statement_list] ...\n    [ELSE statement_list]\nEND CASE```\n* LOOP语句：\n```SQL\n[loop_label：] LOOP\n\tstatement_list\nEND LOOP [loop_label]\n```\n使用LEAVE语句退出LOOP\n* LEAVE语句用来退出任何被标注的控制流程构造，语法`LEAVE label`\n* ITERATE语句将执行顺序转到语句段开头处，语法`ITERATE label`\n* REPEAT语句创建一个带条件判断的循环过程：\n```SQL\n·[repeat_label:] REPEAT\n\tstatement_list\nUNTIL expr_condition\nEND REPEAT [repeat_label]\n```\n* WHILE语句：\n```SQL\n[while_label:] WHILE expr_condition DO\n\tstatement_list\nEND WHILE [while_label]\n```\n* 调用存储过程：`CALL sp_name(parameter[,...])`\n* `SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']`查看存储过程和函数的状态\n* `SHOW CREATE {PROCEDURE | FUNCTION} sp_name `查看存储过程和函数的定义\n* `SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME = 'sp_name'`,从information_schema.Routines表中查看procedure和函数信息。\n* 修改存储过程和函数`ALTER {PROCEDURE | FUNCTION} sp_name [characteristic...]`,characteristic表示存储函数的特性\n* `DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name`删除过程和函数\n* 存储程序和函数的比较：本质上都是存储程序，函数只能通过return语句返回单个值或者表对象，而存储过程不允许执行return，但是可以通过OUT返回多个值。函数限制比较多，不能用临时表，只能用表变量，还有一些函数不可用;存储过程限制较少。函数可以嵌入在SQL语句中使用，存储过程一般作为一个独立的部分来执行\n* 在存储过程中可以用CALL调用其他存储过程，但是不能用DROP语句删除其他存储过程\n* 传入中文参数时，要在定义存储过程的语句中加入`character set gbk`","source":"_posts/MySQL查漏补缺（二）.md","raw":"---\ntitle: MySQL查漏补缺（二）\ndate: 2018-04-04 22:55:35\ntags: [数据库, MySQL]\n---\n\n* 在GROUP BY语句后使用WITH ROLLUP，在所有查询结果后会增加一条记录，计算查询出的所有记录的总和\n* 使用WITH ROLLUP时，不能同时使用ORDER BY子句排序，两者相互排斥\n* 使用LIMIT限制查询结果的数量，`LIMIT [位置偏移量（默认为0），] 行数`，偏移量表示从哪一行开始显示\n* COUNT(*)计算表中总的行数，不管某列是否有空值，COUNT（字段名）会忽略字段列中的空值\n* SUM（）函数计算时会忽略NULL的行\n* MAX()和MIN()都不仅可以查找数据类型，还可以用于字符类型\n* 连接查询条件：两个或多个列表存在相同意义的字段\n* 在一个连接查询中，如果涉及到的两个表都为一个表，称为自连接查询，自连接是特殊的内连接。两表相同时，用AS取别名防止二义性\n* <!-- more-->\n* 子查询：一个查询语句嵌套到一个查询语句的内部\n* SOME，ANY表示满足其中任一条件，允许创建一个表达式对子查询的返回列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件\n* ALL关键字需要同时满足所有的内层查询条件\n* EXISTS关键字后面跟任意子查询，子查询有返回行则返回TRUE，此时外层语句将进行查询，否则返回false，对称的操作时NOT EXISTS\n* 利用UNION关键字可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列和数据类型必须相同。UNION会删除重复的记录，所有返回的行都是唯一的，UNION ALL不删除重复行也不对结果自动排序。UNION ALL的效率高一点\n* LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回，REGEXP会返回\n* 更新表UPDATE table_name SET column_name = val WHERE condition如果忽略WHERE子句，MySQL将更新表中所有的行\n* TRUNCATE TABLE语句直接删除原来的表并新建一个表，比DELETE速度快\n* 索引用于快速查找出某个列中有一特定行的值，是对数据库表中一列或者多列的值进行排序的一种结构，可提高特定数据的查询速度\n* 索引是单独存储在磁盘上的数据结构，所有MySQL列类型都可以被索引\n* 索引优点：\n> 1. 通过创建唯一索引，可以保证数据库表中没一行数据的唯一性\n> 2. 可以大大加快数据的查询速度\n> 3. 在实现数据参考的完整性方面，可以加速表与表之间的连接\n> 4. 在使用分组和排序子句进行数据查询时，可以显式减少查询中分组和排序的时间\n* 索引缺点：\n> . 创建索引和维护索引需要耗费时间，并且随着数据量的增加所耗费的时间也会增加\n> . 索引需要占磁盘空间\n> . 对表中的数据进行增加、删除和修改的时候，索引也要动态维护，降低了维护速度\n\n索引分类：\n> * 普通索引：基本索引类型，允许在定义索引的列中插入重复值和空值\n> * 唯一索引：索引列必须是唯一的，允许有空值。主键索引是特殊唯一索引，不允许有空值\n> * 单列索引：一个索引只允许包含一列，一个表可以有多个单列索引\n> * 组合索引：在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。遵循最左前缀集合\n> * 全文索引：类型为FULLTEXT，在定义索引的列上支持全文查找，允许在这些索引列中插入重复值和空值MySQL中只有MyISAM存储引擎支持全文索引\n> * 空间索引：对空间数据类型字段建立的索引。\n创建表时创建索引：`CREATE TABLE table_name [col_name data_type] [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC | DESC]`,UNIQUE|FULLTEXT|SPATIAL 可选，分别表示唯一索引，全文索引和空间索引，INDEX与KEY为同义词，用来指定创建索引，index_name为索引名，可选，若不指定，则默认以col_name为索引值;length可选，表示索引的长度，只有字符串类型的字段才能指定索引长度。\n\n```SQL\nmysql> show create table book\\G\n*************************** 1. row ***************************\n       Table: book\nCreate Table: CREATE TABLE `book` (\n  `book_id` int(11) NOT NULL,\n  `book_name` varchar(255) NOT NULL,\n  `authors` varchar(255) NOT NULL,\n  `info` varchar(255) DEFAULT NULL,\n  `comment` varchar(255) DEFAULT NULL,\n  `year_publication` year(4) NOT NULL,\n  KEY `year_publication` (`year_publication`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n1 row in set (0.00 sec)\n```\n使用EXPLAIN语句查看索引是否正在使用。\n```SQL\nmysql> explain select * from book where year_publication=1990 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: book\n   partitions: NULL\n         type: ref\npossible_keys: year_publication\n          key: year_publication\n      key_len: 1\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index condition\n1 row in set, 1 warning (0.01 sec)\n\n```\n* `ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length]) [ASC|DESC]`在已存在的表上添加索引\n* `CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC|DESC]`在已存在的表上添加索引\n* `ALTER TABLE table_name DROP INDEX index_name`删除索引\n* 添加AUTO_INCREMENT约束字段的唯一索引不能被删除\n* DROP INDEX index_name ON table_name;\n* 存储过程是一条或多条SQL语句的集合，可视为批文件。\n* 存储程序可以分为存储过程和函数。创建存储过程，只能用输出变量返回值。`CREATE PROCEDURE`,创建函数`CREATE FUNCTION`，使用`CALL`语句调用存储过程。函数可以从语句外部调用，也能返回标量值。存储过程可以调用其他存储过程。\n* `CREATE PROCEDURE sp_name ([proc_parameter]) [characteristics ...] routine_body`,proc_parameter指定参数列表，列表形式：`[IN | OUT | INOUT] param_name type`,type参数类型可以时MySQL数据库中的任意类型。characteristic指定存储过程的特性，取值有：\n> LANGUAGE SQL:说明routine_body部分是由SQL语句组成的\n> [NOT] DETERMINISTIC：指明存储过程结果是否确定，即相同的输入是否能得到相同的输出\n> {CONSTRAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}，指明子程序使用SQL语句的限制\n> SQL SECURITY {DEFINER（定义者——默认） | INVOKER（拥有权限的调用者）}：指定谁有权执行\n> COMMENT'string':注释信息\n\nroutine_body是SQL代码内容，用BEGIN...END表示开始和结束\n\n```SQL\nmysql> DELIMITER //\nmysql> CREATE PROCEDURE CountProc (OUT param1 INT)\n    -> SELECT COUNT(*) INTO param1 FROM fruits;\n    -> END //\n```\n将计算结果放入参数param1,`DELIMITER //`语句设置结束符，避免与存储过程中的;相冲突\n* 创建存储函数`CREATE FUNCTION func_name ([func_parameter]) RETURNS type [characteristic...] routine_body`,RETURNS type表示函数返回数据的类型\n* ```sql\nmysql> CREATE FUNCTION NameByZip()\n    -> RETURNS CHAR(50)\n    -> RETURN (SELECT f_name FROM fruits WHERE s_price>5.0);\n    -> //\nQuery OK, 0 rows affected (0.01 sec)\n```\n如果存储函数中RETURN语句返回的类型不同于函数RETURNS子句中指定类型不同，返回值将被强制为恰当的类型。函数体必须包含一个RETURN value语句\n* 变量可以在子程序中声明使用，作用范围是BEGIN...END程序中\n* 定义变量：`DECLARE var_name[,var_name]... data_type [DEFAULT value]`\n* 改变变量值：`SET var_name = expr [,var_name = expr]...`\n* 通过`SELECT col_name[,...] INTO var_name[,...] table_expr`向变量赋值\n* 定义条件是事先定义程序执行过程中遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。\n* 定义条件：\n* ```SQL\n    CREATE condition_name CONDITION FOR [condition type]\n\n    [condition_type]:\n    SQLSTATE [VALUE] sqlstate_value | mysql_error_code```\n    condition type表示条件的类型，sqlstate_value 和 mysql_error_code都表示MySQL的错误\n* 定义处理程序：\n\n```SQL\nDECALRE handler_type HANDLER FOR condition_value[,...] sp_statement\nhandler_type:\nCONTINUE | EXIT | UNDO\n\ncondition_value:\n\tSQLSTATE [VALUE]  sqlstate_value\n    | condition_name\n    | SQLWARNING\n    | NOT FOUND\n    | SQLEXCEPTION\n    | mysql_error_code\n```\nhandler_type为错误处理方式，有三个取值，UNDO表示遇到错误后撤回之前的操作，MySQL不支持UNDO\n`e.g:DECLARE CONTINUE HANDLER FOR 1146 SET @info='NO_SUCH_TABLE'`;\n* @var_name表示用户变量，使用SET赋值，与连接有关，一个客户端定义的变量不能被其他客户端看到或使用，客户端退出时，其连接的用户变量将自动释放。\n* 光标：数据量大时，在存储过程和函数中逐条读取查询结果集中的记录。必须在声明处理程序之前声明光标，并且变量和条件还必须在声明光标或处理程序之前被声明。\n* `DECLARE cursor_name CURSOR FOR select_statement`声明标签\n* `OPEN cursor_name`:打开先前声明的光标\n* `FETCH cursore_name INTO var_name,...`使用光标，将光标存入var_name,var_name必须在声明光标前就定义好\n* `CLOSE cursor_name`:关闭光标\n* MySQL中光标只能在存储过程和函数中使用\n* 流程控制语句：根据条件控制语句的执行，IF，CASE，LOOP，LEAVE，ITERATE，REPEAT，WHILE语句等\n* IF语句：\n```SQL\n IF expr_condition THEN statement_list\n \t[ELSEIF expr_condition THEN statement_list]...\n \t[ELSE statement_list]\n END IF```\n* CASE语句：\n```SQL\nCASE case_expr\n\tWHEN when_value THEN statement_list\n    [WHEN when_value THEN statement_list] ...\n    [ELSE statement_list]\nEND CASE```\n* LOOP语句：\n```SQL\n[loop_label：] LOOP\n\tstatement_list\nEND LOOP [loop_label]\n```\n使用LEAVE语句退出LOOP\n* LEAVE语句用来退出任何被标注的控制流程构造，语法`LEAVE label`\n* ITERATE语句将执行顺序转到语句段开头处，语法`ITERATE label`\n* REPEAT语句创建一个带条件判断的循环过程：\n```SQL\n·[repeat_label:] REPEAT\n\tstatement_list\nUNTIL expr_condition\nEND REPEAT [repeat_label]\n```\n* WHILE语句：\n```SQL\n[while_label:] WHILE expr_condition DO\n\tstatement_list\nEND WHILE [while_label]\n```\n* 调用存储过程：`CALL sp_name(parameter[,...])`\n* `SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']`查看存储过程和函数的状态\n* `SHOW CREATE {PROCEDURE | FUNCTION} sp_name `查看存储过程和函数的定义\n* `SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME = 'sp_name'`,从information_schema.Routines表中查看procedure和函数信息。\n* 修改存储过程和函数`ALTER {PROCEDURE | FUNCTION} sp_name [characteristic...]`,characteristic表示存储函数的特性\n* `DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name`删除过程和函数\n* 存储程序和函数的比较：本质上都是存储程序，函数只能通过return语句返回单个值或者表对象，而存储过程不允许执行return，但是可以通过OUT返回多个值。函数限制比较多，不能用临时表，只能用表变量，还有一些函数不可用;存储过程限制较少。函数可以嵌入在SQL语句中使用，存储过程一般作为一个独立的部分来执行\n* 在存储过程中可以用CALL调用其他存储过程，但是不能用DROP语句删除其他存储过程\n* 传入中文参数时，要在定义存储过程的语句中加入`character set gbk`","slug":"MySQL查漏补缺（二）","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6o000qcf962wgadp8s","content":"<ul>\n<li>在GROUP BY语句后使用WITH ROLLUP，在所有查询结果后会增加一条记录，计算查询出的所有记录的总和</li>\n<li>使用WITH ROLLUP时，不能同时使用ORDER BY子句排序，两者相互排斥</li>\n<li>使用LIMIT限制查询结果的数量，<code>LIMIT [位置偏移量（默认为0），] 行数</code>，偏移量表示从哪一行开始显示</li>\n<li>COUNT(*)计算表中总的行数，不管某列是否有空值，COUNT（字段名）会忽略字段列中的空值</li>\n<li>SUM（）函数计算时会忽略NULL的行</li>\n<li>MAX()和MIN()都不仅可以查找数据类型，还可以用于字符类型</li>\n<li>连接查询条件：两个或多个列表存在相同意义的字段</li>\n<li>在一个连接查询中，如果涉及到的两个表都为一个表，称为自连接查询，自连接是特殊的内连接。两表相同时，用AS取别名防止二义性</li>\n<li><a id=\"more\"></a></li>\n<li>子查询：一个查询语句嵌套到一个查询语句的内部</li>\n<li>SOME，ANY表示满足其中任一条件，允许创建一个表达式对子查询的返回列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件</li>\n<li>ALL关键字需要同时满足所有的内层查询条件</li>\n<li>EXISTS关键字后面跟任意子查询，子查询有返回行则返回TRUE，此时外层语句将进行查询，否则返回false，对称的操作时NOT EXISTS</li>\n<li>利用UNION关键字可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列和数据类型必须相同。UNION会删除重复的记录，所有返回的行都是唯一的，UNION ALL不删除重复行也不对结果自动排序。UNION ALL的效率高一点</li>\n<li>LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回，REGEXP会返回</li>\n<li>更新表UPDATE table_name SET column_name = val WHERE condition如果忽略WHERE子句，MySQL将更新表中所有的行</li>\n<li>TRUNCATE TABLE语句直接删除原来的表并新建一个表，比DELETE速度快</li>\n<li>索引用于快速查找出某个列中有一特定行的值，是对数据库表中一列或者多列的值进行排序的一种结构，可提高特定数据的查询速度</li>\n<li>索引是单独存储在磁盘上的数据结构，所有MySQL列类型都可以被索引</li>\n<li>索引优点：<blockquote>\n<ol>\n<li>通过创建唯一索引，可以保证数据库表中没一行数据的唯一性</li>\n<li>可以大大加快数据的查询速度</li>\n<li>在实现数据参考的完整性方面，可以加速表与表之间的连接</li>\n<li>在使用分组和排序子句进行数据查询时，可以显式减少查询中分组和排序的时间</li>\n</ol>\n</blockquote>\n</li>\n<li>索引缺点：<blockquote>\n<p>. 创建索引和维护索引需要耗费时间，并且随着数据量的增加所耗费的时间也会增加<br>. 索引需要占磁盘空间<br>. 对表中的数据进行增加、删除和修改的时候，索引也要动态维护，降低了维护速度</p>\n</blockquote>\n</li>\n</ul>\n<p>索引分类：</p>\n<blockquote>\n<ul>\n<li>普通索引：基本索引类型，允许在定义索引的列中插入重复值和空值</li>\n<li>唯一索引：索引列必须是唯一的，允许有空值。主键索引是特殊唯一索引，不允许有空值</li>\n<li>单列索引：一个索引只允许包含一列，一个表可以有多个单列索引</li>\n<li>组合索引：在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。遵循最左前缀集合</li>\n<li>全文索引：类型为FULLTEXT，在定义索引的列上支持全文查找，允许在这些索引列中插入重复值和空值MySQL中只有MyISAM存储引擎支持全文索引</li>\n<li>空间索引：对空间数据类型字段建立的索引。<br>创建表时创建索引：<code>CREATE TABLE table_name [col_name data_type] [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC | DESC]</code>,UNIQUE|FULLTEXT|SPATIAL 可选，分别表示唯一索引，全文索引和空间索引，INDEX与KEY为同义词，用来指定创建索引，index_name为索引名，可选，若不指定，则默认以col_name为索引值;length可选，表示索引的长度，只有字符串类型的字段才能指定索引长度。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show create table book\\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">       Table: book</span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">Table</span>: <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`book`</span> (</span><br><span class=\"line\">  <span class=\"string\">`book_id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`book_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`authors`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`info`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`comment`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`year_publication`</span> <span class=\"keyword\">year</span>(<span class=\"number\">4</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`year_publication`</span> (<span class=\"string\">`year_publication`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=latin1</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>使用EXPLAIN语句查看索引是否正在使用。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from book where year_publication=1990 \\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">           id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: book</span><br><span class=\"line\">   partitions: NULL</span><br><span class=\"line\">         type: ref</span><br><span class=\"line\">possible_keys: year_publication</span><br><span class=\"line\">          key: year_publication</span><br><span class=\"line\">      key_len: 1</span><br><span class=\"line\">          ref: const</span><br><span class=\"line\">         rows: 1</span><br><span class=\"line\">     filtered: 100.00</span><br><span class=\"line\">        Extra: Using index condition</span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span>, <span class=\"number\">1</span> <span class=\"keyword\">warning</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length]) [ASC|DESC]</code>在已存在的表上添加索引</li>\n<li><code>CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC|DESC]</code>在已存在的表上添加索引</li>\n<li><code>ALTER TABLE table_name DROP INDEX index_name</code>删除索引</li>\n<li>添加AUTO_INCREMENT约束字段的唯一索引不能被删除</li>\n<li>DROP INDEX index_name ON table_name;</li>\n<li>存储过程是一条或多条SQL语句的集合，可视为批文件。</li>\n<li>存储程序可以分为存储过程和函数。创建存储过程，只能用输出变量返回值。<code>CREATE PROCEDURE</code>,创建函数<code>CREATE FUNCTION</code>，使用<code>CALL</code>语句调用存储过程。函数可以从语句外部调用，也能返回标量值。存储过程可以调用其他存储过程。</li>\n<li><code>CREATE PROCEDURE sp_name ([proc_parameter]) [characteristics ...] routine_body</code>,proc_parameter指定参数列表，列表形式：<code>[IN | OUT | INOUT] param_name type</code>,type参数类型可以时MySQL数据库中的任意类型。characteristic指定存储过程的特性，取值有：<blockquote>\n<p>LANGUAGE SQL:说明routine_body部分是由SQL语句组成的<br>[NOT] DETERMINISTIC：指明存储过程结果是否确定，即相同的输入是否能得到相同的输出<br>{CONSTRAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}，指明子程序使用SQL语句的限制<br>SQL SECURITY {DEFINER（定义者——默认） | INVOKER（拥有权限的调用者）}：指定谁有权执行<br>COMMENT’string’:注释信息</p>\n</blockquote>\n</li>\n</ul>\n<p>routine_body是SQL代码内容，用BEGIN…END表示开始和结束</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; DELIMITER //</span><br><span class=\"line\">mysql&gt; CREATE PROCEDURE CountProc (OUT param1 INT)</span><br><span class=\"line\">    -&gt; SELECT COUNT(*) INTO param1 FROM fruits;</span><br><span class=\"line\">    -&gt; END //</span><br></pre></td></tr></table></figure>\n<p>将计算结果放入参数param1,<code>DELIMITER //</code>语句设置结束符，避免与存储过程中的;相冲突</p>\n<ul>\n<li>创建存储函数<code>CREATE FUNCTION func_name ([func_parameter]) RETURNS type [characteristic...] routine_body</code>,RETURNS type表示函数返回数据的类型</li>\n<li><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION NameByZip()</span><br><span class=\"line\">    -&gt; RETURNS CHAR(50)</span><br><span class=\"line\">    -&gt; RETURN (SELECT f_name FROM fruits WHERE s_price&gt;5.0);</span><br><span class=\"line\">    -&gt; //</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果存储函数中RETURN语句返回的类型不同于函数RETURNS子句中指定类型不同，返回值将被强制为恰当的类型。函数体必须包含一个RETURN value语句</p>\n<ul>\n<li>变量可以在子程序中声明使用，作用范围是BEGIN…END程序中</li>\n<li>定义变量：<code>DECLARE var_name[,var_name]... data_type [DEFAULT value]</code></li>\n<li>改变变量值：<code>SET var_name = expr [,var_name = expr]...</code></li>\n<li>通过<code>SELECT col_name[,...] INTO var_name[,...] table_expr</code>向变量赋值</li>\n<li>定义条件是事先定义程序执行过程中遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。</li>\n<li>定义条件：</li>\n<li><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> condition_name CONDITION <span class=\"keyword\">FOR</span> [condition <span class=\"keyword\">type</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">[condition_type]:</span><br><span class=\"line\"><span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>] sqlstate_value | mysql_error_code</span><br></pre></td></tr></table></figure>\n<p>  condition type表示条件的类型，sqlstate_value 和 mysql_error_code都表示MySQL的错误</p>\n</li>\n<li>定义处理程序：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECALRE handler_type <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> condition_value[,...] sp_statement</span><br><span class=\"line\">handler_type:</span><br><span class=\"line\">CONTINUE | <span class=\"keyword\">EXIT</span> | <span class=\"keyword\">UNDO</span></span><br><span class=\"line\"></span><br><span class=\"line\">condition_value:</span><br><span class=\"line\">\t<span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>]  sqlstate_value</span><br><span class=\"line\">    | condition_name</span><br><span class=\"line\">    | SQLWARNING</span><br><span class=\"line\">    | <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span></span><br><span class=\"line\">    | SQLEXCEPTION</span><br><span class=\"line\">    | mysql_error_code</span><br></pre></td></tr></table></figure>\n<p>handler_type为错误处理方式，有三个取值，UNDO表示遇到错误后撤回之前的操作，MySQL不支持UNDO<br><code>e.g:DECLARE CONTINUE HANDLER FOR 1146 SET @info=&#39;NO_SUCH_TABLE&#39;</code>;</p>\n<ul>\n<li>@var_name表示用户变量，使用SET赋值，与连接有关，一个客户端定义的变量不能被其他客户端看到或使用，客户端退出时，其连接的用户变量将自动释放。</li>\n<li>光标：数据量大时，在存储过程和函数中逐条读取查询结果集中的记录。必须在声明处理程序之前声明光标，并且变量和条件还必须在声明光标或处理程序之前被声明。</li>\n<li><code>DECLARE cursor_name CURSOR FOR select_statement</code>声明标签</li>\n<li><code>OPEN cursor_name</code>:打开先前声明的光标</li>\n<li><code>FETCH cursore_name INTO var_name,...</code>使用光标，将光标存入var_name,var_name必须在声明光标前就定义好</li>\n<li><code>CLOSE cursor_name</code>:关闭光标</li>\n<li>MySQL中光标只能在存储过程和函数中使用</li>\n<li>流程控制语句：根据条件控制语句的执行，IF，CASE，LOOP，LEAVE，ITERATE，REPEAT，WHILE语句等</li>\n<li><p>IF语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF expr_condition THEN statement_list</span><br><span class=\"line\">\t[ELSEIF expr_condition THEN statement_list]...</span><br><span class=\"line\">\t[ELSE statement_list]</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">IF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CASE语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CASE case_expr</span><br><span class=\"line\">\tWHEN when_value THEN statement_list</span><br><span class=\"line\">    [WHEN when_value THEN statement_list] ...</span><br><span class=\"line\">    [ELSE statement_list]</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">CASE</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>LOOP语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[loop_label：] LOOP</span><br><span class=\"line\">\tstatement_list</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">LOOP</span> [loop_label]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用LEAVE语句退出LOOP</p>\n<ul>\n<li>LEAVE语句用来退出任何被标注的控制流程构造，语法<code>LEAVE label</code></li>\n<li>ITERATE语句将执行顺序转到语句段开头处，语法<code>ITERATE label</code></li>\n<li><p>REPEAT语句创建一个带条件判断的循环过程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">·[repeat_label:] REPEAT</span><br><span class=\"line\">\tstatement_list</span><br><span class=\"line\">UNTIL expr_condition</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">REPEAT</span> [repeat_label]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>WHILE语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[while_label:] WHILE expr_condition <span class=\"keyword\">DO</span></span><br><span class=\"line\">\tstatement_list</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">WHILE</span> [while_label]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用存储过程：<code>CALL sp_name(parameter[,...])</code></p>\n</li>\n<li><code>SHOW {PROCEDURE | FUNCTION} STATUS [LIKE &#39;pattern&#39;]</code>查看存储过程和函数的状态</li>\n<li><code>SHOW CREATE {PROCEDURE | FUNCTION} sp_name</code>查看存储过程和函数的定义</li>\n<li><code>SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME = &#39;sp_name&#39;</code>,从information_schema.Routines表中查看procedure和函数信息。</li>\n<li>修改存储过程和函数<code>ALTER {PROCEDURE | FUNCTION} sp_name [characteristic...]</code>,characteristic表示存储函数的特性</li>\n<li><code>DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name</code>删除过程和函数</li>\n<li>存储程序和函数的比较：本质上都是存储程序，函数只能通过return语句返回单个值或者表对象，而存储过程不允许执行return，但是可以通过OUT返回多个值。函数限制比较多，不能用临时表，只能用表变量，还有一些函数不可用;存储过程限制较少。函数可以嵌入在SQL语句中使用，存储过程一般作为一个独立的部分来执行</li>\n<li>在存储过程中可以用CALL调用其他存储过程，但是不能用DROP语句删除其他存储过程</li>\n<li>传入中文参数时，要在定义存储过程的语句中加入<code>character set gbk</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>在GROUP BY语句后使用WITH ROLLUP，在所有查询结果后会增加一条记录，计算查询出的所有记录的总和</li>\n<li>使用WITH ROLLUP时，不能同时使用ORDER BY子句排序，两者相互排斥</li>\n<li>使用LIMIT限制查询结果的数量，<code>LIMIT [位置偏移量（默认为0），] 行数</code>，偏移量表示从哪一行开始显示</li>\n<li>COUNT(*)计算表中总的行数，不管某列是否有空值，COUNT（字段名）会忽略字段列中的空值</li>\n<li>SUM（）函数计算时会忽略NULL的行</li>\n<li>MAX()和MIN()都不仅可以查找数据类型，还可以用于字符类型</li>\n<li>连接查询条件：两个或多个列表存在相同意义的字段</li>\n<li>在一个连接查询中，如果涉及到的两个表都为一个表，称为自连接查询，自连接是特殊的内连接。两表相同时，用AS取别名防止二义性</li>\n<li>","more":"</li>\n<li>子查询：一个查询语句嵌套到一个查询语句的内部</li>\n<li>SOME，ANY表示满足其中任一条件，允许创建一个表达式对子查询的返回列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件</li>\n<li>ALL关键字需要同时满足所有的内层查询条件</li>\n<li>EXISTS关键字后面跟任意子查询，子查询有返回行则返回TRUE，此时外层语句将进行查询，否则返回false，对称的操作时NOT EXISTS</li>\n<li>利用UNION关键字可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列和数据类型必须相同。UNION会删除重复的记录，所有返回的行都是唯一的，UNION ALL不删除重复行也不对结果自动排序。UNION ALL的效率高一点</li>\n<li>LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回，REGEXP会返回</li>\n<li>更新表UPDATE table_name SET column_name = val WHERE condition如果忽略WHERE子句，MySQL将更新表中所有的行</li>\n<li>TRUNCATE TABLE语句直接删除原来的表并新建一个表，比DELETE速度快</li>\n<li>索引用于快速查找出某个列中有一特定行的值，是对数据库表中一列或者多列的值进行排序的一种结构，可提高特定数据的查询速度</li>\n<li>索引是单独存储在磁盘上的数据结构，所有MySQL列类型都可以被索引</li>\n<li>索引优点：<blockquote>\n<ol>\n<li>通过创建唯一索引，可以保证数据库表中没一行数据的唯一性</li>\n<li>可以大大加快数据的查询速度</li>\n<li>在实现数据参考的完整性方面，可以加速表与表之间的连接</li>\n<li>在使用分组和排序子句进行数据查询时，可以显式减少查询中分组和排序的时间</li>\n</ol>\n</blockquote>\n</li>\n<li>索引缺点：<blockquote>\n<p>. 创建索引和维护索引需要耗费时间，并且随着数据量的增加所耗费的时间也会增加<br>. 索引需要占磁盘空间<br>. 对表中的数据进行增加、删除和修改的时候，索引也要动态维护，降低了维护速度</p>\n</blockquote>\n</li>\n</ul>\n<p>索引分类：</p>\n<blockquote>\n<ul>\n<li>普通索引：基本索引类型，允许在定义索引的列中插入重复值和空值</li>\n<li>唯一索引：索引列必须是唯一的，允许有空值。主键索引是特殊唯一索引，不允许有空值</li>\n<li>单列索引：一个索引只允许包含一列，一个表可以有多个单列索引</li>\n<li>组合索引：在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。遵循最左前缀集合</li>\n<li>全文索引：类型为FULLTEXT，在定义索引的列上支持全文查找，允许在这些索引列中插入重复值和空值MySQL中只有MyISAM存储引擎支持全文索引</li>\n<li>空间索引：对空间数据类型字段建立的索引。<br>创建表时创建索引：<code>CREATE TABLE table_name [col_name data_type] [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC | DESC]</code>,UNIQUE|FULLTEXT|SPATIAL 可选，分别表示唯一索引，全文索引和空间索引，INDEX与KEY为同义词，用来指定创建索引，index_name为索引名，可选，若不指定，则默认以col_name为索引值;length可选，表示索引的长度，只有字符串类型的字段才能指定索引长度。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show create table book\\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">       Table: book</span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">Table</span>: <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`book`</span> (</span><br><span class=\"line\">  <span class=\"string\">`book_id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`book_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`authors`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`info`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`comment`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`year_publication`</span> <span class=\"keyword\">year</span>(<span class=\"number\">4</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`year_publication`</span> (<span class=\"string\">`year_publication`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=latin1</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>使用EXPLAIN语句查看索引是否正在使用。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from book where year_publication=1990 \\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">           id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: book</span><br><span class=\"line\">   partitions: NULL</span><br><span class=\"line\">         type: ref</span><br><span class=\"line\">possible_keys: year_publication</span><br><span class=\"line\">          key: year_publication</span><br><span class=\"line\">      key_len: 1</span><br><span class=\"line\">          ref: const</span><br><span class=\"line\">         rows: 1</span><br><span class=\"line\">     filtered: 100.00</span><br><span class=\"line\">        Extra: Using index condition</span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span>, <span class=\"number\">1</span> <span class=\"keyword\">warning</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length]) [ASC|DESC]</code>在已存在的表上添加索引</li>\n<li><code>CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC|DESC]</code>在已存在的表上添加索引</li>\n<li><code>ALTER TABLE table_name DROP INDEX index_name</code>删除索引</li>\n<li>添加AUTO_INCREMENT约束字段的唯一索引不能被删除</li>\n<li>DROP INDEX index_name ON table_name;</li>\n<li>存储过程是一条或多条SQL语句的集合，可视为批文件。</li>\n<li>存储程序可以分为存储过程和函数。创建存储过程，只能用输出变量返回值。<code>CREATE PROCEDURE</code>,创建函数<code>CREATE FUNCTION</code>，使用<code>CALL</code>语句调用存储过程。函数可以从语句外部调用，也能返回标量值。存储过程可以调用其他存储过程。</li>\n<li><code>CREATE PROCEDURE sp_name ([proc_parameter]) [characteristics ...] routine_body</code>,proc_parameter指定参数列表，列表形式：<code>[IN | OUT | INOUT] param_name type</code>,type参数类型可以时MySQL数据库中的任意类型。characteristic指定存储过程的特性，取值有：<blockquote>\n<p>LANGUAGE SQL:说明routine_body部分是由SQL语句组成的<br>[NOT] DETERMINISTIC：指明存储过程结果是否确定，即相同的输入是否能得到相同的输出<br>{CONSTRAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}，指明子程序使用SQL语句的限制<br>SQL SECURITY {DEFINER（定义者——默认） | INVOKER（拥有权限的调用者）}：指定谁有权执行<br>COMMENT’string’:注释信息</p>\n</blockquote>\n</li>\n</ul>\n<p>routine_body是SQL代码内容，用BEGIN…END表示开始和结束</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; DELIMITER //</span><br><span class=\"line\">mysql&gt; CREATE PROCEDURE CountProc (OUT param1 INT)</span><br><span class=\"line\">    -&gt; SELECT COUNT(*) INTO param1 FROM fruits;</span><br><span class=\"line\">    -&gt; END //</span><br></pre></td></tr></table></figure>\n<p>将计算结果放入参数param1,<code>DELIMITER //</code>语句设置结束符，避免与存储过程中的;相冲突</p>\n<ul>\n<li>创建存储函数<code>CREATE FUNCTION func_name ([func_parameter]) RETURNS type [characteristic...] routine_body</code>,RETURNS type表示函数返回数据的类型</li>\n<li><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION NameByZip()</span><br><span class=\"line\">    -&gt; RETURNS CHAR(50)</span><br><span class=\"line\">    -&gt; RETURN (SELECT f_name FROM fruits WHERE s_price&gt;5.0);</span><br><span class=\"line\">    -&gt; //</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果存储函数中RETURN语句返回的类型不同于函数RETURNS子句中指定类型不同，返回值将被强制为恰当的类型。函数体必须包含一个RETURN value语句</p>\n<ul>\n<li>变量可以在子程序中声明使用，作用范围是BEGIN…END程序中</li>\n<li>定义变量：<code>DECLARE var_name[,var_name]... data_type [DEFAULT value]</code></li>\n<li>改变变量值：<code>SET var_name = expr [,var_name = expr]...</code></li>\n<li>通过<code>SELECT col_name[,...] INTO var_name[,...] table_expr</code>向变量赋值</li>\n<li>定义条件是事先定义程序执行过程中遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。</li>\n<li>定义条件：</li>\n<li><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> condition_name CONDITION <span class=\"keyword\">FOR</span> [condition <span class=\"keyword\">type</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">[condition_type]:</span><br><span class=\"line\"><span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>] sqlstate_value | mysql_error_code</span><br></pre></td></tr></table></figure>\n<p>  condition type表示条件的类型，sqlstate_value 和 mysql_error_code都表示MySQL的错误</p>\n</li>\n<li>定义处理程序：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECALRE handler_type <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> condition_value[,...] sp_statement</span><br><span class=\"line\">handler_type:</span><br><span class=\"line\">CONTINUE | <span class=\"keyword\">EXIT</span> | <span class=\"keyword\">UNDO</span></span><br><span class=\"line\"></span><br><span class=\"line\">condition_value:</span><br><span class=\"line\">\t<span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>]  sqlstate_value</span><br><span class=\"line\">    | condition_name</span><br><span class=\"line\">    | SQLWARNING</span><br><span class=\"line\">    | <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span></span><br><span class=\"line\">    | SQLEXCEPTION</span><br><span class=\"line\">    | mysql_error_code</span><br></pre></td></tr></table></figure>\n<p>handler_type为错误处理方式，有三个取值，UNDO表示遇到错误后撤回之前的操作，MySQL不支持UNDO<br><code>e.g:DECLARE CONTINUE HANDLER FOR 1146 SET @info=&#39;NO_SUCH_TABLE&#39;</code>;</p>\n<ul>\n<li>@var_name表示用户变量，使用SET赋值，与连接有关，一个客户端定义的变量不能被其他客户端看到或使用，客户端退出时，其连接的用户变量将自动释放。</li>\n<li>光标：数据量大时，在存储过程和函数中逐条读取查询结果集中的记录。必须在声明处理程序之前声明光标，并且变量和条件还必须在声明光标或处理程序之前被声明。</li>\n<li><code>DECLARE cursor_name CURSOR FOR select_statement</code>声明标签</li>\n<li><code>OPEN cursor_name</code>:打开先前声明的光标</li>\n<li><code>FETCH cursore_name INTO var_name,...</code>使用光标，将光标存入var_name,var_name必须在声明光标前就定义好</li>\n<li><code>CLOSE cursor_name</code>:关闭光标</li>\n<li>MySQL中光标只能在存储过程和函数中使用</li>\n<li>流程控制语句：根据条件控制语句的执行，IF，CASE，LOOP，LEAVE，ITERATE，REPEAT，WHILE语句等</li>\n<li><p>IF语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF expr_condition THEN statement_list</span><br><span class=\"line\">\t[ELSEIF expr_condition THEN statement_list]...</span><br><span class=\"line\">\t[ELSE statement_list]</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">IF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CASE语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CASE case_expr</span><br><span class=\"line\">\tWHEN when_value THEN statement_list</span><br><span class=\"line\">    [WHEN when_value THEN statement_list] ...</span><br><span class=\"line\">    [ELSE statement_list]</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">CASE</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>LOOP语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[loop_label：] LOOP</span><br><span class=\"line\">\tstatement_list</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">LOOP</span> [loop_label]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用LEAVE语句退出LOOP</p>\n<ul>\n<li>LEAVE语句用来退出任何被标注的控制流程构造，语法<code>LEAVE label</code></li>\n<li>ITERATE语句将执行顺序转到语句段开头处，语法<code>ITERATE label</code></li>\n<li><p>REPEAT语句创建一个带条件判断的循环过程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">·[repeat_label:] REPEAT</span><br><span class=\"line\">\tstatement_list</span><br><span class=\"line\">UNTIL expr_condition</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">REPEAT</span> [repeat_label]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>WHILE语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[while_label:] WHILE expr_condition <span class=\"keyword\">DO</span></span><br><span class=\"line\">\tstatement_list</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">WHILE</span> [while_label]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用存储过程：<code>CALL sp_name(parameter[,...])</code></p>\n</li>\n<li><code>SHOW {PROCEDURE | FUNCTION} STATUS [LIKE &#39;pattern&#39;]</code>查看存储过程和函数的状态</li>\n<li><code>SHOW CREATE {PROCEDURE | FUNCTION} sp_name</code>查看存储过程和函数的定义</li>\n<li><code>SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME = &#39;sp_name&#39;</code>,从information_schema.Routines表中查看procedure和函数信息。</li>\n<li>修改存储过程和函数<code>ALTER {PROCEDURE | FUNCTION} sp_name [characteristic...]</code>,characteristic表示存储函数的特性</li>\n<li><code>DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name</code>删除过程和函数</li>\n<li>存储程序和函数的比较：本质上都是存储程序，函数只能通过return语句返回单个值或者表对象，而存储过程不允许执行return，但是可以通过OUT返回多个值。函数限制比较多，不能用临时表，只能用表变量，还有一些函数不可用;存储过程限制较少。函数可以嵌入在SQL语句中使用，存储过程一般作为一个独立的部分来执行</li>\n<li>在存储过程中可以用CALL调用其他存储过程，但是不能用DROP语句删除其他存储过程</li>\n<li>传入中文参数时，要在定义存储过程的语句中加入<code>character set gbk</code></li>\n</ul>"},{"title":"MLlib----基本概念","date":"2018-05-06T04:34:23.000Z","_content":"\n**一、MLlib基本数据类型：**\n\n**多种数据类型**\n\nLocal vector：本地向量集，主要向Spark提供一组可以进行操作的数据集合\n\nLabeled point： 向量标签， 能够让用户分类不同的数据集合\n\nLocal matrix： 本地矩阵， 将数据集合以矩阵形式存储在本地计算机中\n\nDistributed matrix： 分布式矩阵，将数据集合以矩阵形式存储在分布式计算机中\n<!-- more-->\n\n**本地向量集**\n\nLocal vector 主要分为两类，以数据集（4,5,2,9）为例介绍两种分类：\n\n- 稀疏型数据集：(4,  Array(0,1,2,3), Array(4,5,2,9))\n- 密集型数据集：(4,5,2,9)\n\n```scala\nobject testVector {\n  def main(args: Array[String]): Unit = {\n    val vd : Vector = Vectors.dense(2,0,6)\n    println(vd(2))\n      //Vectors.sparse(数据大小, 数据下标（严格递增，不需要公差为1,可大于数据大小）, 数据)\n    val vs: Vector = Vectors.sparse(4, Array(0,1,2,3), Array(9,5,2,7))\n    println(vs(2))//这里面的参数必须小于总的数据大小\n  }\n}\noutput :\n6.0\n2.0\n```\n\n目前MLib只支持整数与浮点数计算，字符类型会转换成整数\n\n**向量标签**\n\n向量标签用于对MLlib中机器学习算法的不同值做标记，LabeledPoint是建立向量标签的静态类，Feature现实打印标记点所代表的数据内容，Label显示标记数\n\n```scala\nimport org.apache.spark.mllib.linalg.{Vector, Vectors}\nimport org.apache.spark.mllib.regression.LabeledPoint\n\nobject testLablePoint {\n  def main(args: Array[String]): Unit = {\n    val vd: Vector = Vectors.dense(2,0,6)\n    val pos = LabeledPoint(1,vd)\n    println(pos.features)//打印标记点内容数据\n    println(pos.label)\n    val vs: Vector = Vectors.sparse(4, Array(0,1,2,3), Array(9,5,2,7))\n    val neg = LabeledPoint(2, vs)\n    println(neg.features)\n    println(neg.label)\n  }\n}\noutput：\n[2.0,0.0,6.0]\n1.0\n(4,[0,1,2,3],[9.0,5.0,2.0,7.0])\n2.0\n```\n\n可以调用MLUtils.loadLibSVMFile对写到文件中的数据进行读取，数据格式为：\n\n`label index1：value1 index2：value2 ...`\n\n```scala\nimport org.apache.spark.mllib.util.MLUtils\nimport org.apache.spark._\n\nobject testLabeledPoint2 {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testLabeledPoint2\")\n    val sc = new SparkContext(conf)\n    val mu = MLUtils.loadLibSVMFile(sc, \"/media/harold/SpareDisk/SParkMLibDemo/src/labeleddata.txt\")\n    mu.foreach(println)\n  }\n}\n\ninput:\n1 0:2 1:3 2:3\n2 0:5 1:8 2:9\n1 0:7 1:6 2:7\n1 0:3 1:2 2:1\n```\n\nloadLibSVMFile方法将数据分解为一个稀疏向量 \n\n**本地矩阵**\n\n```scala\nobject testMatrix {\n  def main(args: Array[String]): Unit = {\n    val mx = Matrices.dense(2, 3, Array(1,2,3,4,5,6))//将数组转换为2行三列的矩阵\n    println(mx)\n  }\n}\noutput：\n1.0  3.0  5.0  \n2.0  4.0  6.0  \n```\n​\n\n**分布式矩阵**\n\n分布式矩阵进行数据存储的情况一般数据量都非常大，其处理速度和效率与存储格式相关，MLlib提供四种分布式矩阵存储形式：行矩阵，带有行索引的行矩阵，坐标矩阵、块矩阵。\n\n* 行矩阵\n\n> 以行作为基本方向，列的作用比较小,相当于一个巨大的特征向量的集合。\n\n```scala\nimport org.apache.spark.mllib.linalg.Vectors\nimport org.apache.spark.mllib.linalg.distributed.RowMatrix\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testRowMatrix {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testRowMatrix\")\n    val sc = new SparkContext(conf)\n    val rdd = sc.textFile(\"labeleddata.txt\")\n      .map(_.split(\" \")\n      .map(_.toDouble))\n      .map(line => Vectors.dense(line))\n    val rm = new RowMatrix(rdd)\n    println(rm.numRows())\n    println(rm.numCols())\n  }\n}\nfileinput：\n1 2 3\n4 5 6\noutput：\n2\n3\n```\n\n  * 带有行索引的矩阵\n\n  行矩阵是一个转换变化,不是最运行结果,内容无法直接显示,因此提供了带有行索引的矩阵\n\n  ```scala\n  import org.apache.spark.mllib.linalg.Vectors\n  import org.apache.spark.mllib.linalg.distributed.{IndexedRow, IndexedRowMatrix}\n  import org.apache.spark.{SparkConf, SparkContext}\n\n  object testIndexedRowMatrix {\n    def main(args: Array[String]): Unit = {\n      val conf = new SparkConf()\n        .setMaster(\"local\")\n        .setAppName(\"testIndexedRowMatrix\")\n      val sc = new SparkContext(conf)\n      val rdd = sc.textFile(\"labeleddata.txt\")\n        .map(_.split(\" \")\n          .map(_.toDouble))\n        .map(line => Vectors.dense(line))\n        .map((vd) => new IndexedRow(vd.size,vd))\n      val irm = new IndexedRowMatrix(rdd)\n      println(irm.getClass)\n      irm.rows.foreach(println)\n    }\n  }\n  input:\n  1 2 3\n  4 5 6\n  output:\n  class org.apache.spark.mllib.linalg.distributed.IndexedRowMatrix\n  IndexedRow(3,[1.0,2.0,3.0])\n  IndexedRow(3,[4.0,5.0,6.0])\n  ```\n\n  * 坐标矩阵\n\n    一种带有坐标标记的矩阵,每一个具体数据都有一组坐标进行标示(x: Long,  y:  Long, value: Double).x,y分别是行和列,一般用于数据比较多且较为分散的情形\n\n    ```scala\n    import org.apache.spark.mllib.linalg.distributed.{CoordinateMatrix, MatrixEntry}\n    import org.apache.spark.{SparkConf, SparkContext}\n\n    object testCoordinateRowMatrix {\n      def main(args: Array[String]): Unit = {\n        val conf = new SparkConf()\n          .setMaster(\"local\")\n          .setAppName(\"testCoordinateRowMatrix\")\n        val sc = new SparkContext(conf)\n        val rdd = sc.textFile(\"labeleddata.txt\")\n          .map(_.split(\" \")\n            .map(_.toDouble))\n          .map(vue => (vue(0).toLong, vue(1).toLong, vue(2)))\n          .map(vue2 => new MatrixEntry(vue2 _1, vue2 _2, vue2 _3))\n        val crm = new CoordinateMatrix(rdd)\n        crm.entries.foreach(println)\n      }\n    }\n    output:\n    MatrixEntry(1,2,3.0)\n    MatrixEntry(4,5,6.0)\n    ```\n\n    三个矩阵级别依次增加,高级可向低级转换.\n\n\n\n**二 MLlib数理统计基本概念**\n\n在MLlib中,统计量计算主要用Statistic类库,主要包括:\n\n* colStats:  以列为基础计算统计量的基本数据\n* chiSqTest: 对数据集内数据计算皮尔逊距离\n* corr: 计算两个数据集的相关系数\n\n```scala\nimport org.apache.spark.mllib.linalg.Vectors\nimport org.apache.spark.mllib.stat.Statistics\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testSummary {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testIndexedRowMatrix\")\n    val sc = new SparkContext(conf)\n    val rdd = sc.textFile(\"a.txt\")\n      .map(_.split(\" \")\n        .map(_.toDouble))\n      .map(line => Vectors.dense(line))\n    val summary = Statistics.colStats(rdd)\n    println(summary.max)\n    println(summary.min)\n    println(summary.count)//行内数据个数\n    println(summary.mean)//均值\n    println(summary.numNonzeros)//非零数字个数\n    println(summary.variance)//标准差\n    println(summary.normL1)//欧式距离,表达数据集内数据长度\n    println(summary.normL2)//曼哈顿距离,表达两点在标准坐标系上的绝对轴距总和\n  }\n}\ninput:\n0\n1\n2\n3\n45\n6\n2\n1\n3\n56\n32\n65\noutput:\n[65.0]\n[0.0]\n12\n[18.0]\n[11.0]\n[598.7272727272727]\n[216.0]\n[102.34256201600583]\n```\n\n* 两组数据相关系数计算\n\n  相关系数用来反映变量之间相关关系密切程度,MLlib中默认相关系数求法是皮尔逊相关系数法.\n\n  两个变量之间的皮尔逊相关系数定义为两个变量之间的[协方差](https://baike.baidu.com/item/%E5%8D%8F%E6%96%B9%E5%B7%AE)和[标准差](https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%B7%AE)的商：\n\n  ![img](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D289/sign=90b7ce2ea064034f0bcdc50e96c27980/060828381f30e92463d59cc247086e061c95f7d4.jpg)\n\n​       可以看作是两组数据的向量夹角的余弦,描述两组数据的分开程度.\n\n```scala\nimport org.apache.spark.mllib.stat.Statistics\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testCorrect {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testCorrect\")\n    val sc = new SparkContext(conf)\n    val rddX = sc.textFile(\"x.txt\")\n      .flatMap(_.split(\" \")\n        .map(_.toDouble))\n    val rddY = sc.textFile(\"y.txt\")\n      .flatMap(_.split(\" \")\n        .map(_.toDouble))\n    val correlation: Double = Statistics.corr(rddX,rddY)\n    println(correlation)\n  }\n}\ninput://两个文件分别输入\nxtxt:1 2 3 4 5\nytxt:2 4 6 8 10\noutout:\n0.9999999999999998\n```\n\n使用val correlation: Double = Statistics.corr(rddX,rddY,'spearman'),可以计算斯皮尔曼相关系数\n\n* 分层抽样\n\n分层抽样:一种数据提取算法,先将总体的单位按照特征分为若干级次总体,然后再从每一曾进行单纯随机抽样,组成一个样本.\n\neg:数据内容如下:\n\n> aa\n>\n> bb\n>\n> aaa\n>\n> bbb\n>\n> ccc\n\n将每个字符串中含有三个字符的标记为1,两个字符的标记为2,再根据其数目进行分组.\n\n```scala\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testStratifiedSampling2 {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testStratifiedSampling2\")\n    val sc = new SparkContext(conf)\n    val data = sc.textFile(\"a.txt\").map(row => {\n      if (row.length == 3)\n        (row, 1)\n      else\n        (row, 2)\n    }\n    ).map(each => (each _2, each _1))\n    val fractions : Map[Int, Double] = (List((1,0.3),(2,0.7))).toMap//设定抽样格式,fractions表示在层1抽0.2，在层2中抽0.8\n    //withReplacement false表示不重复抽样\n    val approxSample = data.sampleByKey(withReplacement = false, fractions, 0)\n    approxSample.foreach(println)\n  }\n}\n```\n\n* 假设检验\n\n  MLlib规定常使用的数据集一般为向量和矩阵.\n\n  ```scala\n  import org.apache.spark.mllib.linalg.{Matrices, Vectors}\n  import org.apache.spark.mllib.stat.Statistics\n\n  object testChiSq {\n    def main(args: Array[String]): Unit = {\n      val vd = Vectors.dense(1,2,3,4,5,6)\n      val vdResult = Statistics.chiSqTest(vd)\n      println(vdResult)\n      println(\"------------------\")\n      val mtx = Matrices.dense(3,2, Array(1,3,5,2,4,6))\n      val mtxResult = Statistics.chiSqTest(mtx)\n      println(mtxResult)\n    }\n  }\n  output:\n  Chi squared test summary:\n  method: pearson//卡方检验使用方法\n  degrees of freedom = 5 //自由度\n  statistic = 5.000000000000001 //统计量\n  pValue = 0.4158801869955079 //p值\n  No presumption against null hypothesis: observed follows the same distribution as expected..\n  ------------------\n  Chi squared test summary:\n  method: pearson\n  degrees of freedom = 2 \n  statistic = 0.14141414141414144 \n  pValue = 0.931734784568187 \n  No presumption against null hypothesis: the occurrence of the outcomes is statistically independent..\n  ```\n","source":"_posts/MLlib-基本概念.md","raw":"---\ntitle: MLlib----基本概念\ndate: 2018-05-06 12:34:23\ntags: [MLlib,  机器学习,  大数据]\n---\n\n**一、MLlib基本数据类型：**\n\n**多种数据类型**\n\nLocal vector：本地向量集，主要向Spark提供一组可以进行操作的数据集合\n\nLabeled point： 向量标签， 能够让用户分类不同的数据集合\n\nLocal matrix： 本地矩阵， 将数据集合以矩阵形式存储在本地计算机中\n\nDistributed matrix： 分布式矩阵，将数据集合以矩阵形式存储在分布式计算机中\n<!-- more-->\n\n**本地向量集**\n\nLocal vector 主要分为两类，以数据集（4,5,2,9）为例介绍两种分类：\n\n- 稀疏型数据集：(4,  Array(0,1,2,3), Array(4,5,2,9))\n- 密集型数据集：(4,5,2,9)\n\n```scala\nobject testVector {\n  def main(args: Array[String]): Unit = {\n    val vd : Vector = Vectors.dense(2,0,6)\n    println(vd(2))\n      //Vectors.sparse(数据大小, 数据下标（严格递增，不需要公差为1,可大于数据大小）, 数据)\n    val vs: Vector = Vectors.sparse(4, Array(0,1,2,3), Array(9,5,2,7))\n    println(vs(2))//这里面的参数必须小于总的数据大小\n  }\n}\noutput :\n6.0\n2.0\n```\n\n目前MLib只支持整数与浮点数计算，字符类型会转换成整数\n\n**向量标签**\n\n向量标签用于对MLlib中机器学习算法的不同值做标记，LabeledPoint是建立向量标签的静态类，Feature现实打印标记点所代表的数据内容，Label显示标记数\n\n```scala\nimport org.apache.spark.mllib.linalg.{Vector, Vectors}\nimport org.apache.spark.mllib.regression.LabeledPoint\n\nobject testLablePoint {\n  def main(args: Array[String]): Unit = {\n    val vd: Vector = Vectors.dense(2,0,6)\n    val pos = LabeledPoint(1,vd)\n    println(pos.features)//打印标记点内容数据\n    println(pos.label)\n    val vs: Vector = Vectors.sparse(4, Array(0,1,2,3), Array(9,5,2,7))\n    val neg = LabeledPoint(2, vs)\n    println(neg.features)\n    println(neg.label)\n  }\n}\noutput：\n[2.0,0.0,6.0]\n1.0\n(4,[0,1,2,3],[9.0,5.0,2.0,7.0])\n2.0\n```\n\n可以调用MLUtils.loadLibSVMFile对写到文件中的数据进行读取，数据格式为：\n\n`label index1：value1 index2：value2 ...`\n\n```scala\nimport org.apache.spark.mllib.util.MLUtils\nimport org.apache.spark._\n\nobject testLabeledPoint2 {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testLabeledPoint2\")\n    val sc = new SparkContext(conf)\n    val mu = MLUtils.loadLibSVMFile(sc, \"/media/harold/SpareDisk/SParkMLibDemo/src/labeleddata.txt\")\n    mu.foreach(println)\n  }\n}\n\ninput:\n1 0:2 1:3 2:3\n2 0:5 1:8 2:9\n1 0:7 1:6 2:7\n1 0:3 1:2 2:1\n```\n\nloadLibSVMFile方法将数据分解为一个稀疏向量 \n\n**本地矩阵**\n\n```scala\nobject testMatrix {\n  def main(args: Array[String]): Unit = {\n    val mx = Matrices.dense(2, 3, Array(1,2,3,4,5,6))//将数组转换为2行三列的矩阵\n    println(mx)\n  }\n}\noutput：\n1.0  3.0  5.0  \n2.0  4.0  6.0  \n```\n​\n\n**分布式矩阵**\n\n分布式矩阵进行数据存储的情况一般数据量都非常大，其处理速度和效率与存储格式相关，MLlib提供四种分布式矩阵存储形式：行矩阵，带有行索引的行矩阵，坐标矩阵、块矩阵。\n\n* 行矩阵\n\n> 以行作为基本方向，列的作用比较小,相当于一个巨大的特征向量的集合。\n\n```scala\nimport org.apache.spark.mllib.linalg.Vectors\nimport org.apache.spark.mllib.linalg.distributed.RowMatrix\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testRowMatrix {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testRowMatrix\")\n    val sc = new SparkContext(conf)\n    val rdd = sc.textFile(\"labeleddata.txt\")\n      .map(_.split(\" \")\n      .map(_.toDouble))\n      .map(line => Vectors.dense(line))\n    val rm = new RowMatrix(rdd)\n    println(rm.numRows())\n    println(rm.numCols())\n  }\n}\nfileinput：\n1 2 3\n4 5 6\noutput：\n2\n3\n```\n\n  * 带有行索引的矩阵\n\n  行矩阵是一个转换变化,不是最运行结果,内容无法直接显示,因此提供了带有行索引的矩阵\n\n  ```scala\n  import org.apache.spark.mllib.linalg.Vectors\n  import org.apache.spark.mllib.linalg.distributed.{IndexedRow, IndexedRowMatrix}\n  import org.apache.spark.{SparkConf, SparkContext}\n\n  object testIndexedRowMatrix {\n    def main(args: Array[String]): Unit = {\n      val conf = new SparkConf()\n        .setMaster(\"local\")\n        .setAppName(\"testIndexedRowMatrix\")\n      val sc = new SparkContext(conf)\n      val rdd = sc.textFile(\"labeleddata.txt\")\n        .map(_.split(\" \")\n          .map(_.toDouble))\n        .map(line => Vectors.dense(line))\n        .map((vd) => new IndexedRow(vd.size,vd))\n      val irm = new IndexedRowMatrix(rdd)\n      println(irm.getClass)\n      irm.rows.foreach(println)\n    }\n  }\n  input:\n  1 2 3\n  4 5 6\n  output:\n  class org.apache.spark.mllib.linalg.distributed.IndexedRowMatrix\n  IndexedRow(3,[1.0,2.0,3.0])\n  IndexedRow(3,[4.0,5.0,6.0])\n  ```\n\n  * 坐标矩阵\n\n    一种带有坐标标记的矩阵,每一个具体数据都有一组坐标进行标示(x: Long,  y:  Long, value: Double).x,y分别是行和列,一般用于数据比较多且较为分散的情形\n\n    ```scala\n    import org.apache.spark.mllib.linalg.distributed.{CoordinateMatrix, MatrixEntry}\n    import org.apache.spark.{SparkConf, SparkContext}\n\n    object testCoordinateRowMatrix {\n      def main(args: Array[String]): Unit = {\n        val conf = new SparkConf()\n          .setMaster(\"local\")\n          .setAppName(\"testCoordinateRowMatrix\")\n        val sc = new SparkContext(conf)\n        val rdd = sc.textFile(\"labeleddata.txt\")\n          .map(_.split(\" \")\n            .map(_.toDouble))\n          .map(vue => (vue(0).toLong, vue(1).toLong, vue(2)))\n          .map(vue2 => new MatrixEntry(vue2 _1, vue2 _2, vue2 _3))\n        val crm = new CoordinateMatrix(rdd)\n        crm.entries.foreach(println)\n      }\n    }\n    output:\n    MatrixEntry(1,2,3.0)\n    MatrixEntry(4,5,6.0)\n    ```\n\n    三个矩阵级别依次增加,高级可向低级转换.\n\n\n\n**二 MLlib数理统计基本概念**\n\n在MLlib中,统计量计算主要用Statistic类库,主要包括:\n\n* colStats:  以列为基础计算统计量的基本数据\n* chiSqTest: 对数据集内数据计算皮尔逊距离\n* corr: 计算两个数据集的相关系数\n\n```scala\nimport org.apache.spark.mllib.linalg.Vectors\nimport org.apache.spark.mllib.stat.Statistics\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testSummary {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testIndexedRowMatrix\")\n    val sc = new SparkContext(conf)\n    val rdd = sc.textFile(\"a.txt\")\n      .map(_.split(\" \")\n        .map(_.toDouble))\n      .map(line => Vectors.dense(line))\n    val summary = Statistics.colStats(rdd)\n    println(summary.max)\n    println(summary.min)\n    println(summary.count)//行内数据个数\n    println(summary.mean)//均值\n    println(summary.numNonzeros)//非零数字个数\n    println(summary.variance)//标准差\n    println(summary.normL1)//欧式距离,表达数据集内数据长度\n    println(summary.normL2)//曼哈顿距离,表达两点在标准坐标系上的绝对轴距总和\n  }\n}\ninput:\n0\n1\n2\n3\n45\n6\n2\n1\n3\n56\n32\n65\noutput:\n[65.0]\n[0.0]\n12\n[18.0]\n[11.0]\n[598.7272727272727]\n[216.0]\n[102.34256201600583]\n```\n\n* 两组数据相关系数计算\n\n  相关系数用来反映变量之间相关关系密切程度,MLlib中默认相关系数求法是皮尔逊相关系数法.\n\n  两个变量之间的皮尔逊相关系数定义为两个变量之间的[协方差](https://baike.baidu.com/item/%E5%8D%8F%E6%96%B9%E5%B7%AE)和[标准差](https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%B7%AE)的商：\n\n  ![img](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D289/sign=90b7ce2ea064034f0bcdc50e96c27980/060828381f30e92463d59cc247086e061c95f7d4.jpg)\n\n​       可以看作是两组数据的向量夹角的余弦,描述两组数据的分开程度.\n\n```scala\nimport org.apache.spark.mllib.stat.Statistics\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testCorrect {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testCorrect\")\n    val sc = new SparkContext(conf)\n    val rddX = sc.textFile(\"x.txt\")\n      .flatMap(_.split(\" \")\n        .map(_.toDouble))\n    val rddY = sc.textFile(\"y.txt\")\n      .flatMap(_.split(\" \")\n        .map(_.toDouble))\n    val correlation: Double = Statistics.corr(rddX,rddY)\n    println(correlation)\n  }\n}\ninput://两个文件分别输入\nxtxt:1 2 3 4 5\nytxt:2 4 6 8 10\noutout:\n0.9999999999999998\n```\n\n使用val correlation: Double = Statistics.corr(rddX,rddY,'spearman'),可以计算斯皮尔曼相关系数\n\n* 分层抽样\n\n分层抽样:一种数据提取算法,先将总体的单位按照特征分为若干级次总体,然后再从每一曾进行单纯随机抽样,组成一个样本.\n\neg:数据内容如下:\n\n> aa\n>\n> bb\n>\n> aaa\n>\n> bbb\n>\n> ccc\n\n将每个字符串中含有三个字符的标记为1,两个字符的标记为2,再根据其数目进行分组.\n\n```scala\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject testStratifiedSampling2 {\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"testStratifiedSampling2\")\n    val sc = new SparkContext(conf)\n    val data = sc.textFile(\"a.txt\").map(row => {\n      if (row.length == 3)\n        (row, 1)\n      else\n        (row, 2)\n    }\n    ).map(each => (each _2, each _1))\n    val fractions : Map[Int, Double] = (List((1,0.3),(2,0.7))).toMap//设定抽样格式,fractions表示在层1抽0.2，在层2中抽0.8\n    //withReplacement false表示不重复抽样\n    val approxSample = data.sampleByKey(withReplacement = false, fractions, 0)\n    approxSample.foreach(println)\n  }\n}\n```\n\n* 假设检验\n\n  MLlib规定常使用的数据集一般为向量和矩阵.\n\n  ```scala\n  import org.apache.spark.mllib.linalg.{Matrices, Vectors}\n  import org.apache.spark.mllib.stat.Statistics\n\n  object testChiSq {\n    def main(args: Array[String]): Unit = {\n      val vd = Vectors.dense(1,2,3,4,5,6)\n      val vdResult = Statistics.chiSqTest(vd)\n      println(vdResult)\n      println(\"------------------\")\n      val mtx = Matrices.dense(3,2, Array(1,3,5,2,4,6))\n      val mtxResult = Statistics.chiSqTest(mtx)\n      println(mtxResult)\n    }\n  }\n  output:\n  Chi squared test summary:\n  method: pearson//卡方检验使用方法\n  degrees of freedom = 5 //自由度\n  statistic = 5.000000000000001 //统计量\n  pValue = 0.4158801869955079 //p值\n  No presumption against null hypothesis: observed follows the same distribution as expected..\n  ------------------\n  Chi squared test summary:\n  method: pearson\n  degrees of freedom = 2 \n  statistic = 0.14141414141414144 \n  pValue = 0.931734784568187 \n  No presumption against null hypothesis: the occurrence of the outcomes is statistically independent..\n  ```\n","slug":"MLlib-基本概念","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6p000scf96v30uniqk","content":"<p><strong>一、MLlib基本数据类型：</strong></p>\n<p><strong>多种数据类型</strong></p>\n<p>Local vector：本地向量集，主要向Spark提供一组可以进行操作的数据集合</p>\n<p>Labeled point： 向量标签， 能够让用户分类不同的数据集合</p>\n<p>Local matrix： 本地矩阵， 将数据集合以矩阵形式存储在本地计算机中</p>\n<p>Distributed matrix： 分布式矩阵，将数据集合以矩阵形式存储在分布式计算机中<br><a id=\"more\"></a></p>\n<p><strong>本地向量集</strong></p>\n<p>Local vector 主要分为两类，以数据集（4,5,2,9）为例介绍两种分类：</p>\n<ul>\n<li>稀疏型数据集：(4,  Array(0,1,2,3), Array(4,5,2,9))</li>\n<li>密集型数据集：(4,5,2,9)</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testVector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vd : <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.dense(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">    println(vd(<span class=\"number\">2</span>))</span><br><span class=\"line\">      <span class=\"comment\">//Vectors.sparse(数据大小, 数据下标（严格递增，不需要公差为1,可大于数据大小）, 数据)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> vs: <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.sparse(<span class=\"number\">4</span>, <span class=\"type\">Array</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>), <span class=\"type\">Array</span>(<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>))</span><br><span class=\"line\">    println(vs(<span class=\"number\">2</span>))<span class=\"comment\">//这里面的参数必须小于总的数据大小</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output :</span><br><span class=\"line\"><span class=\"number\">6.0</span></span><br><span class=\"line\"><span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n<p>目前MLib只支持整数与浮点数计算，字符类型会转换成整数</p>\n<p><strong>向量标签</strong></p>\n<p>向量标签用于对MLlib中机器学习算法的不同值做标记，LabeledPoint是建立向量标签的静态类，Feature现实打印标记点所代表的数据内容，Label显示标记数</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.&#123;<span class=\"type\">Vector</span>, <span class=\"type\">Vectors</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.regression.<span class=\"type\">LabeledPoint</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testLablePoint</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vd: <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.dense(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pos = <span class=\"type\">LabeledPoint</span>(<span class=\"number\">1</span>,vd)</span><br><span class=\"line\">    println(pos.features)<span class=\"comment\">//打印标记点内容数据</span></span><br><span class=\"line\">    println(pos.label)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vs: <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.sparse(<span class=\"number\">4</span>, <span class=\"type\">Array</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>), <span class=\"type\">Array</span>(<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> neg = <span class=\"type\">LabeledPoint</span>(<span class=\"number\">2</span>, vs)</span><br><span class=\"line\">    println(neg.features)</span><br><span class=\"line\">    println(neg.label)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output：</span><br><span class=\"line\">[<span class=\"number\">2.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">6.0</span>]</span><br><span class=\"line\"><span class=\"number\">1.0</span></span><br><span class=\"line\">(<span class=\"number\">4</span>,[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">9.0</span>,<span class=\"number\">5.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">7.0</span>])</span><br><span class=\"line\"><span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n<p>可以调用MLUtils.loadLibSVMFile对写到文件中的数据进行读取，数据格式为：</p>\n<p><code>label index1：value1 index2：value2 ...</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.util.<span class=\"type\">MLUtils</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testLabeledPoint2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testLabeledPoint2\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mu = <span class=\"type\">MLUtils</span>.loadLibSVMFile(sc, <span class=\"string\">\"/media/harold/SpareDisk/SParkMLibDemo/src/labeleddata.txt\"</span>)</span><br><span class=\"line\">    mu.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">input:</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span>:<span class=\"number\">2</span> <span class=\"number\">1</span>:<span class=\"number\">3</span> <span class=\"number\">2</span>:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">0</span>:<span class=\"number\">5</span> <span class=\"number\">1</span>:<span class=\"number\">8</span> <span class=\"number\">2</span>:<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span>:<span class=\"number\">7</span> <span class=\"number\">1</span>:<span class=\"number\">6</span> <span class=\"number\">2</span>:<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span>:<span class=\"number\">3</span> <span class=\"number\">1</span>:<span class=\"number\">2</span> <span class=\"number\">2</span>:<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>loadLibSVMFile方法将数据分解为一个稀疏向量 </p>\n<p><strong>本地矩阵</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mx = <span class=\"type\">Matrices</span>.dense(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>))<span class=\"comment\">//将数组转换为2行三列的矩阵</span></span><br><span class=\"line\">    println(mx)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output：</span><br><span class=\"line\"><span class=\"number\">1.0</span>  <span class=\"number\">3.0</span>  <span class=\"number\">5.0</span>  </span><br><span class=\"line\"><span class=\"number\">2.0</span>  <span class=\"number\">4.0</span>  <span class=\"number\">6.0</span></span><br></pre></td></tr></table></figure>\n<p>​</p>\n<p><strong>分布式矩阵</strong></p>\n<p>分布式矩阵进行数据存储的情况一般数据量都非常大，其处理速度和效率与存储格式相关，MLlib提供四种分布式矩阵存储形式：行矩阵，带有行索引的行矩阵，坐标矩阵、块矩阵。</p>\n<ul>\n<li>行矩阵</li>\n</ul>\n<blockquote>\n<p>以行作为基本方向，列的作用比较小,相当于一个巨大的特征向量的集合。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.<span class=\"type\">Vectors</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.distributed.<span class=\"type\">RowMatrix</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testRowMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"labeleddata.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">      .map(_.toDouble))</span><br><span class=\"line\">      .map(line =&gt; <span class=\"type\">Vectors</span>.dense(line))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rm = <span class=\"keyword\">new</span> <span class=\"type\">RowMatrix</span>(rdd)</span><br><span class=\"line\">    println(rm.numRows())</span><br><span class=\"line\">    println(rm.numCols())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fileinput：</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\">output：</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>带有行索引的矩阵</p>\n<p>行矩阵是一个转换变化,不是最运行结果,内容无法直接显示,因此提供了带有行索引的矩阵</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.<span class=\"type\">Vectors</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.distributed.&#123;<span class=\"type\">IndexedRow</span>, <span class=\"type\">IndexedRowMatrix</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testIndexedRowMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testIndexedRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"labeleddata.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">      .map(line =&gt; <span class=\"type\">Vectors</span>.dense(line))</span><br><span class=\"line\">      .map((vd) =&gt; <span class=\"keyword\">new</span> <span class=\"type\">IndexedRow</span>(vd.size,vd))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> irm = <span class=\"keyword\">new</span> <span class=\"type\">IndexedRowMatrix</span>(rdd)</span><br><span class=\"line\">    println(irm.getClass)</span><br><span class=\"line\">    irm.rows.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input:</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">spark</span>.<span class=\"title\">mllib</span>.<span class=\"title\">linalg</span>.<span class=\"title\">distributed</span>.<span class=\"title\">IndexedRowMatrix</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">IndexedRow</span>(<span class=\"params\">3,[1.0,2.0,3.0]</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">IndexedRow</span>(<span class=\"params\">3,[4.0,5.0,6.0]</span>)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>坐标矩阵</p>\n<p>一种带有坐标标记的矩阵,每一个具体数据都有一组坐标进行标示(x: Long,  y:  Long, value: Double).x,y分别是行和列,一般用于数据比较多且较为分散的情形</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.distributed.&#123;<span class=\"type\">CoordinateMatrix</span>, <span class=\"type\">MatrixEntry</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testCoordinateRowMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testCoordinateRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"labeleddata.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">      .map(vue =&gt; (vue(<span class=\"number\">0</span>).toLong, vue(<span class=\"number\">1</span>).toLong, vue(<span class=\"number\">2</span>)))</span><br><span class=\"line\">      .map(vue2 =&gt; <span class=\"keyword\">new</span> <span class=\"type\">MatrixEntry</span>(vue2 _1, vue2 _2, vue2 _3))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> crm = <span class=\"keyword\">new</span> <span class=\"type\">CoordinateMatrix</span>(rdd)</span><br><span class=\"line\">    crm.entries.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"type\">MatrixEntry</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.0</span>)</span><br><span class=\"line\"><span class=\"type\">MatrixEntry</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6.0</span>)</span><br></pre></td></tr></table></figure>\n<p>三个矩阵级别依次增加,高级可向低级转换.</p>\n</li>\n</ul>\n<p><strong>二 MLlib数理统计基本概念</strong></p>\n<p>在MLlib中,统计量计算主要用Statistic类库,主要包括:</p>\n<ul>\n<li>colStats:  以列为基础计算统计量的基本数据</li>\n<li>chiSqTest: 对数据集内数据计算皮尔逊距离</li>\n<li>corr: 计算两个数据集的相关系数</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.<span class=\"type\">Vectors</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.stat.<span class=\"type\">Statistics</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testSummary</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testIndexedRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"a.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">      .map(line =&gt; <span class=\"type\">Vectors</span>.dense(line))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> summary = <span class=\"type\">Statistics</span>.colStats(rdd)</span><br><span class=\"line\">    println(summary.max)</span><br><span class=\"line\">    println(summary.min)</span><br><span class=\"line\">    println(summary.count)<span class=\"comment\">//行内数据个数</span></span><br><span class=\"line\">    println(summary.mean)<span class=\"comment\">//均值</span></span><br><span class=\"line\">    println(summary.numNonzeros)<span class=\"comment\">//非零数字个数</span></span><br><span class=\"line\">    println(summary.variance)<span class=\"comment\">//标准差</span></span><br><span class=\"line\">    println(summary.normL1)<span class=\"comment\">//欧式距离,表达数据集内数据长度</span></span><br><span class=\"line\">    println(summary.normL2)<span class=\"comment\">//曼哈顿距离,表达两点在标准坐标系上的绝对轴距总和</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input:</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">45</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">56</span></span><br><span class=\"line\"><span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">65</span></span><br><span class=\"line\">output:</span><br><span class=\"line\">[<span class=\"number\">65.0</span>]</span><br><span class=\"line\">[<span class=\"number\">0.0</span>]</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\">[<span class=\"number\">18.0</span>]</span><br><span class=\"line\">[<span class=\"number\">11.0</span>]</span><br><span class=\"line\">[<span class=\"number\">598.7272727272727</span>]</span><br><span class=\"line\">[<span class=\"number\">216.0</span>]</span><br><span class=\"line\">[<span class=\"number\">102.34256201600583</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>两组数据相关系数计算</p>\n<p>相关系数用来反映变量之间相关关系密切程度,MLlib中默认相关系数求法是皮尔逊相关系数法.</p>\n<p>两个变量之间的皮尔逊相关系数定义为两个变量之间的<a href=\"https://baike.baidu.com/item/%E5%8D%8F%E6%96%B9%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">协方差</a>和<a href=\"https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">标准差</a>的商：</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D289/sign=90b7ce2ea064034f0bcdc50e96c27980/060828381f30e92463d59cc247086e061c95f7d4.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p>​       可以看作是两组数据的向量夹角的余弦,描述两组数据的分开程度.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.stat.<span class=\"type\">Statistics</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testCorrect</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testCorrect\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rddX = sc.textFile(<span class=\"string\">\"x.txt\"</span>)</span><br><span class=\"line\">      .flatMap(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rddY = sc.textFile(<span class=\"string\">\"y.txt\"</span>)</span><br><span class=\"line\">      .flatMap(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> correlation: <span class=\"type\">Double</span> = <span class=\"type\">Statistics</span>.corr(rddX,rddY)</span><br><span class=\"line\">    println(correlation)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input:<span class=\"comment\">//两个文件分别输入</span></span><br><span class=\"line\">xtxt:<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\">ytxt:<span class=\"number\">2</span> <span class=\"number\">4</span> <span class=\"number\">6</span> <span class=\"number\">8</span> <span class=\"number\">10</span></span><br><span class=\"line\">outout:</span><br><span class=\"line\"><span class=\"number\">0.9999999999999998</span></span><br></pre></td></tr></table></figure>\n<p>使用val correlation: Double = Statistics.corr(rddX,rddY,’spearman’),可以计算斯皮尔曼相关系数</p>\n<ul>\n<li>分层抽样</li>\n</ul>\n<p>分层抽样:一种数据提取算法,先将总体的单位按照特征分为若干级次总体,然后再从每一曾进行单纯随机抽样,组成一个样本.</p>\n<p>eg:数据内容如下:</p>\n<blockquote>\n<p>aa</p>\n<p>bb</p>\n<p>aaa</p>\n<p>bbb</p>\n<p>ccc</p>\n</blockquote>\n<p>将每个字符串中含有三个字符的标记为1,两个字符的标记为2,再根据其数目进行分组.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testStratifiedSampling2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testStratifiedSampling2\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> data = sc.textFile(<span class=\"string\">\"a.txt\"</span>).map(row =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (row.length == <span class=\"number\">3</span>)</span><br><span class=\"line\">        (row, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        (row, <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ).map(each =&gt; (each _2, each _1))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> fractions : <span class=\"type\">Map</span>[<span class=\"type\">Int</span>, <span class=\"type\">Double</span>] = (<span class=\"type\">List</span>((<span class=\"number\">1</span>,<span class=\"number\">0.3</span>),(<span class=\"number\">2</span>,<span class=\"number\">0.7</span>))).toMap<span class=\"comment\">//设定抽样格式,fractions表示在层1抽0.2，在层2中抽0.8</span></span><br><span class=\"line\">    <span class=\"comment\">//withReplacement false表示不重复抽样</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> approxSample = data.sampleByKey(withReplacement = <span class=\"literal\">false</span>, fractions, <span class=\"number\">0</span>)</span><br><span class=\"line\">    approxSample.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>假设检验</p>\n<p>MLlib规定常使用的数据集一般为向量和矩阵.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.&#123;<span class=\"type\">Matrices</span>, <span class=\"type\">Vectors</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.stat.<span class=\"type\">Statistics</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testChiSq</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vd = <span class=\"type\">Vectors</span>.dense(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vdResult = <span class=\"type\">Statistics</span>.chiSqTest(vd)</span><br><span class=\"line\">    println(vdResult)</span><br><span class=\"line\">    println(<span class=\"string\">\"------------------\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mtx = <span class=\"type\">Matrices</span>.dense(<span class=\"number\">3</span>,<span class=\"number\">2</span>, <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mtxResult = <span class=\"type\">Statistics</span>.chiSqTest(mtx)</span><br><span class=\"line\">    println(mtxResult)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"type\">Chi</span> squared test summary:</span><br><span class=\"line\">method: pearson<span class=\"comment\">//卡方检验使用方法</span></span><br><span class=\"line\">degrees of freedom = <span class=\"number\">5</span> <span class=\"comment\">//自由度</span></span><br><span class=\"line\">statistic = <span class=\"number\">5.000000000000001</span> <span class=\"comment\">//统计量</span></span><br><span class=\"line\">pValue = <span class=\"number\">0.4158801869955079</span> <span class=\"comment\">//p值</span></span><br><span class=\"line\"><span class=\"type\">No</span> presumption against <span class=\"literal\">null</span> hypothesis: observed follows the same distribution as expected..</span><br><span class=\"line\">------------------</span><br><span class=\"line\"><span class=\"type\">Chi</span> squared test summary:</span><br><span class=\"line\">method: pearson</span><br><span class=\"line\">degrees of freedom = <span class=\"number\">2</span> </span><br><span class=\"line\">statistic = <span class=\"number\">0.14141414141414144</span> </span><br><span class=\"line\">pValue = <span class=\"number\">0.931734784568187</span> </span><br><span class=\"line\"><span class=\"type\">No</span> presumption against <span class=\"literal\">null</span> hypothesis: the occurrence of the outcomes is statistically independent..</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>一、MLlib基本数据类型：</strong></p>\n<p><strong>多种数据类型</strong></p>\n<p>Local vector：本地向量集，主要向Spark提供一组可以进行操作的数据集合</p>\n<p>Labeled point： 向量标签， 能够让用户分类不同的数据集合</p>\n<p>Local matrix： 本地矩阵， 将数据集合以矩阵形式存储在本地计算机中</p>\n<p>Distributed matrix： 分布式矩阵，将数据集合以矩阵形式存储在分布式计算机中<br>","more":"</p>\n<p><strong>本地向量集</strong></p>\n<p>Local vector 主要分为两类，以数据集（4,5,2,9）为例介绍两种分类：</p>\n<ul>\n<li>稀疏型数据集：(4,  Array(0,1,2,3), Array(4,5,2,9))</li>\n<li>密集型数据集：(4,5,2,9)</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testVector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vd : <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.dense(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">    println(vd(<span class=\"number\">2</span>))</span><br><span class=\"line\">      <span class=\"comment\">//Vectors.sparse(数据大小, 数据下标（严格递增，不需要公差为1,可大于数据大小）, 数据)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> vs: <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.sparse(<span class=\"number\">4</span>, <span class=\"type\">Array</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>), <span class=\"type\">Array</span>(<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>))</span><br><span class=\"line\">    println(vs(<span class=\"number\">2</span>))<span class=\"comment\">//这里面的参数必须小于总的数据大小</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output :</span><br><span class=\"line\"><span class=\"number\">6.0</span></span><br><span class=\"line\"><span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n<p>目前MLib只支持整数与浮点数计算，字符类型会转换成整数</p>\n<p><strong>向量标签</strong></p>\n<p>向量标签用于对MLlib中机器学习算法的不同值做标记，LabeledPoint是建立向量标签的静态类，Feature现实打印标记点所代表的数据内容，Label显示标记数</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.&#123;<span class=\"type\">Vector</span>, <span class=\"type\">Vectors</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.regression.<span class=\"type\">LabeledPoint</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testLablePoint</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vd: <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.dense(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pos = <span class=\"type\">LabeledPoint</span>(<span class=\"number\">1</span>,vd)</span><br><span class=\"line\">    println(pos.features)<span class=\"comment\">//打印标记点内容数据</span></span><br><span class=\"line\">    println(pos.label)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vs: <span class=\"type\">Vector</span> = <span class=\"type\">Vectors</span>.sparse(<span class=\"number\">4</span>, <span class=\"type\">Array</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>), <span class=\"type\">Array</span>(<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> neg = <span class=\"type\">LabeledPoint</span>(<span class=\"number\">2</span>, vs)</span><br><span class=\"line\">    println(neg.features)</span><br><span class=\"line\">    println(neg.label)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output：</span><br><span class=\"line\">[<span class=\"number\">2.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">6.0</span>]</span><br><span class=\"line\"><span class=\"number\">1.0</span></span><br><span class=\"line\">(<span class=\"number\">4</span>,[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">9.0</span>,<span class=\"number\">5.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">7.0</span>])</span><br><span class=\"line\"><span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n<p>可以调用MLUtils.loadLibSVMFile对写到文件中的数据进行读取，数据格式为：</p>\n<p><code>label index1：value1 index2：value2 ...</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.util.<span class=\"type\">MLUtils</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testLabeledPoint2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testLabeledPoint2\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mu = <span class=\"type\">MLUtils</span>.loadLibSVMFile(sc, <span class=\"string\">\"/media/harold/SpareDisk/SParkMLibDemo/src/labeleddata.txt\"</span>)</span><br><span class=\"line\">    mu.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">input:</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span>:<span class=\"number\">2</span> <span class=\"number\">1</span>:<span class=\"number\">3</span> <span class=\"number\">2</span>:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">0</span>:<span class=\"number\">5</span> <span class=\"number\">1</span>:<span class=\"number\">8</span> <span class=\"number\">2</span>:<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span>:<span class=\"number\">7</span> <span class=\"number\">1</span>:<span class=\"number\">6</span> <span class=\"number\">2</span>:<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span>:<span class=\"number\">3</span> <span class=\"number\">1</span>:<span class=\"number\">2</span> <span class=\"number\">2</span>:<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>loadLibSVMFile方法将数据分解为一个稀疏向量 </p>\n<p><strong>本地矩阵</strong></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mx = <span class=\"type\">Matrices</span>.dense(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>))<span class=\"comment\">//将数组转换为2行三列的矩阵</span></span><br><span class=\"line\">    println(mx)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output：</span><br><span class=\"line\"><span class=\"number\">1.0</span>  <span class=\"number\">3.0</span>  <span class=\"number\">5.0</span>  </span><br><span class=\"line\"><span class=\"number\">2.0</span>  <span class=\"number\">4.0</span>  <span class=\"number\">6.0</span></span><br></pre></td></tr></table></figure>\n<p>​</p>\n<p><strong>分布式矩阵</strong></p>\n<p>分布式矩阵进行数据存储的情况一般数据量都非常大，其处理速度和效率与存储格式相关，MLlib提供四种分布式矩阵存储形式：行矩阵，带有行索引的行矩阵，坐标矩阵、块矩阵。</p>\n<ul>\n<li>行矩阵</li>\n</ul>\n<blockquote>\n<p>以行作为基本方向，列的作用比较小,相当于一个巨大的特征向量的集合。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.<span class=\"type\">Vectors</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.distributed.<span class=\"type\">RowMatrix</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testRowMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"labeleddata.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">      .map(_.toDouble))</span><br><span class=\"line\">      .map(line =&gt; <span class=\"type\">Vectors</span>.dense(line))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rm = <span class=\"keyword\">new</span> <span class=\"type\">RowMatrix</span>(rdd)</span><br><span class=\"line\">    println(rm.numRows())</span><br><span class=\"line\">    println(rm.numCols())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fileinput：</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\">output：</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>带有行索引的矩阵</p>\n<p>行矩阵是一个转换变化,不是最运行结果,内容无法直接显示,因此提供了带有行索引的矩阵</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.<span class=\"type\">Vectors</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.distributed.&#123;<span class=\"type\">IndexedRow</span>, <span class=\"type\">IndexedRowMatrix</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testIndexedRowMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testIndexedRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"labeleddata.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">      .map(line =&gt; <span class=\"type\">Vectors</span>.dense(line))</span><br><span class=\"line\">      .map((vd) =&gt; <span class=\"keyword\">new</span> <span class=\"type\">IndexedRow</span>(vd.size,vd))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> irm = <span class=\"keyword\">new</span> <span class=\"type\">IndexedRowMatrix</span>(rdd)</span><br><span class=\"line\">    println(irm.getClass)</span><br><span class=\"line\">    irm.rows.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input:</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">spark</span>.<span class=\"title\">mllib</span>.<span class=\"title\">linalg</span>.<span class=\"title\">distributed</span>.<span class=\"title\">IndexedRowMatrix</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">IndexedRow</span>(<span class=\"params\">3,[1.0,2.0,3.0]</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">IndexedRow</span>(<span class=\"params\">3,[4.0,5.0,6.0]</span>)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>坐标矩阵</p>\n<p>一种带有坐标标记的矩阵,每一个具体数据都有一组坐标进行标示(x: Long,  y:  Long, value: Double).x,y分别是行和列,一般用于数据比较多且较为分散的情形</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.distributed.&#123;<span class=\"type\">CoordinateMatrix</span>, <span class=\"type\">MatrixEntry</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testCoordinateRowMatrix</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testCoordinateRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"labeleddata.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">      .map(vue =&gt; (vue(<span class=\"number\">0</span>).toLong, vue(<span class=\"number\">1</span>).toLong, vue(<span class=\"number\">2</span>)))</span><br><span class=\"line\">      .map(vue2 =&gt; <span class=\"keyword\">new</span> <span class=\"type\">MatrixEntry</span>(vue2 _1, vue2 _2, vue2 _3))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> crm = <span class=\"keyword\">new</span> <span class=\"type\">CoordinateMatrix</span>(rdd)</span><br><span class=\"line\">    crm.entries.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"type\">MatrixEntry</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.0</span>)</span><br><span class=\"line\"><span class=\"type\">MatrixEntry</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6.0</span>)</span><br></pre></td></tr></table></figure>\n<p>三个矩阵级别依次增加,高级可向低级转换.</p>\n</li>\n</ul>\n<p><strong>二 MLlib数理统计基本概念</strong></p>\n<p>在MLlib中,统计量计算主要用Statistic类库,主要包括:</p>\n<ul>\n<li>colStats:  以列为基础计算统计量的基本数据</li>\n<li>chiSqTest: 对数据集内数据计算皮尔逊距离</li>\n<li>corr: 计算两个数据集的相关系数</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.<span class=\"type\">Vectors</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.stat.<span class=\"type\">Statistics</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testSummary</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testIndexedRowMatrix\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.textFile(<span class=\"string\">\"a.txt\"</span>)</span><br><span class=\"line\">      .map(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">      .map(line =&gt; <span class=\"type\">Vectors</span>.dense(line))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> summary = <span class=\"type\">Statistics</span>.colStats(rdd)</span><br><span class=\"line\">    println(summary.max)</span><br><span class=\"line\">    println(summary.min)</span><br><span class=\"line\">    println(summary.count)<span class=\"comment\">//行内数据个数</span></span><br><span class=\"line\">    println(summary.mean)<span class=\"comment\">//均值</span></span><br><span class=\"line\">    println(summary.numNonzeros)<span class=\"comment\">//非零数字个数</span></span><br><span class=\"line\">    println(summary.variance)<span class=\"comment\">//标准差</span></span><br><span class=\"line\">    println(summary.normL1)<span class=\"comment\">//欧式距离,表达数据集内数据长度</span></span><br><span class=\"line\">    println(summary.normL2)<span class=\"comment\">//曼哈顿距离,表达两点在标准坐标系上的绝对轴距总和</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input:</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">45</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">56</span></span><br><span class=\"line\"><span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">65</span></span><br><span class=\"line\">output:</span><br><span class=\"line\">[<span class=\"number\">65.0</span>]</span><br><span class=\"line\">[<span class=\"number\">0.0</span>]</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\">[<span class=\"number\">18.0</span>]</span><br><span class=\"line\">[<span class=\"number\">11.0</span>]</span><br><span class=\"line\">[<span class=\"number\">598.7272727272727</span>]</span><br><span class=\"line\">[<span class=\"number\">216.0</span>]</span><br><span class=\"line\">[<span class=\"number\">102.34256201600583</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>两组数据相关系数计算</p>\n<p>相关系数用来反映变量之间相关关系密切程度,MLlib中默认相关系数求法是皮尔逊相关系数法.</p>\n<p>两个变量之间的皮尔逊相关系数定义为两个变量之间的<a href=\"https://baike.baidu.com/item/%E5%8D%8F%E6%96%B9%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">协方差</a>和<a href=\"https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">标准差</a>的商：</p>\n<p><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D289/sign=90b7ce2ea064034f0bcdc50e96c27980/060828381f30e92463d59cc247086e061c95f7d4.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p>​       可以看作是两组数据的向量夹角的余弦,描述两组数据的分开程度.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.stat.<span class=\"type\">Statistics</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testCorrect</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testCorrect\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rddX = sc.textFile(<span class=\"string\">\"x.txt\"</span>)</span><br><span class=\"line\">      .flatMap(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rddY = sc.textFile(<span class=\"string\">\"y.txt\"</span>)</span><br><span class=\"line\">      .flatMap(_.split(<span class=\"string\">\" \"</span>)</span><br><span class=\"line\">        .map(_.toDouble))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> correlation: <span class=\"type\">Double</span> = <span class=\"type\">Statistics</span>.corr(rddX,rddY)</span><br><span class=\"line\">    println(correlation)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input:<span class=\"comment\">//两个文件分别输入</span></span><br><span class=\"line\">xtxt:<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\">ytxt:<span class=\"number\">2</span> <span class=\"number\">4</span> <span class=\"number\">6</span> <span class=\"number\">8</span> <span class=\"number\">10</span></span><br><span class=\"line\">outout:</span><br><span class=\"line\"><span class=\"number\">0.9999999999999998</span></span><br></pre></td></tr></table></figure>\n<p>使用val correlation: Double = Statistics.corr(rddX,rddY,’spearman’),可以计算斯皮尔曼相关系数</p>\n<ul>\n<li>分层抽样</li>\n</ul>\n<p>分层抽样:一种数据提取算法,先将总体的单位按照特征分为若干级次总体,然后再从每一曾进行单纯随机抽样,组成一个样本.</p>\n<p>eg:数据内容如下:</p>\n<blockquote>\n<p>aa</p>\n<p>bb</p>\n<p>aaa</p>\n<p>bbb</p>\n<p>ccc</p>\n</blockquote>\n<p>将每个字符串中含有三个字符的标记为1,两个字符的标记为2,再根据其数目进行分组.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.&#123;<span class=\"type\">SparkConf</span>, <span class=\"type\">SparkContext</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testStratifiedSampling2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"testStratifiedSampling2\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> data = sc.textFile(<span class=\"string\">\"a.txt\"</span>).map(row =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (row.length == <span class=\"number\">3</span>)</span><br><span class=\"line\">        (row, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        (row, <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ).map(each =&gt; (each _2, each _1))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> fractions : <span class=\"type\">Map</span>[<span class=\"type\">Int</span>, <span class=\"type\">Double</span>] = (<span class=\"type\">List</span>((<span class=\"number\">1</span>,<span class=\"number\">0.3</span>),(<span class=\"number\">2</span>,<span class=\"number\">0.7</span>))).toMap<span class=\"comment\">//设定抽样格式,fractions表示在层1抽0.2，在层2中抽0.8</span></span><br><span class=\"line\">    <span class=\"comment\">//withReplacement false表示不重复抽样</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> approxSample = data.sampleByKey(withReplacement = <span class=\"literal\">false</span>, fractions, <span class=\"number\">0</span>)</span><br><span class=\"line\">    approxSample.foreach(println)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>假设检验</p>\n<p>MLlib规定常使用的数据集一般为向量和矩阵.</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.linalg.&#123;<span class=\"type\">Matrices</span>, <span class=\"type\">Vectors</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.mllib.stat.<span class=\"type\">Statistics</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">testChiSq</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vd = <span class=\"type\">Vectors</span>.dense(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> vdResult = <span class=\"type\">Statistics</span>.chiSqTest(vd)</span><br><span class=\"line\">    println(vdResult)</span><br><span class=\"line\">    println(<span class=\"string\">\"------------------\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mtx = <span class=\"type\">Matrices</span>.dense(<span class=\"number\">3</span>,<span class=\"number\">2</span>, <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mtxResult = <span class=\"type\">Statistics</span>.chiSqTest(mtx)</span><br><span class=\"line\">    println(mtxResult)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"type\">Chi</span> squared test summary:</span><br><span class=\"line\">method: pearson<span class=\"comment\">//卡方检验使用方法</span></span><br><span class=\"line\">degrees of freedom = <span class=\"number\">5</span> <span class=\"comment\">//自由度</span></span><br><span class=\"line\">statistic = <span class=\"number\">5.000000000000001</span> <span class=\"comment\">//统计量</span></span><br><span class=\"line\">pValue = <span class=\"number\">0.4158801869955079</span> <span class=\"comment\">//p值</span></span><br><span class=\"line\"><span class=\"type\">No</span> presumption against <span class=\"literal\">null</span> hypothesis: observed follows the same distribution as expected..</span><br><span class=\"line\">------------------</span><br><span class=\"line\"><span class=\"type\">Chi</span> squared test summary:</span><br><span class=\"line\">method: pearson</span><br><span class=\"line\">degrees of freedom = <span class=\"number\">2</span> </span><br><span class=\"line\">statistic = <span class=\"number\">0.14141414141414144</span> </span><br><span class=\"line\">pValue = <span class=\"number\">0.931734784568187</span> </span><br><span class=\"line\"><span class=\"type\">No</span> presumption against <span class=\"literal\">null</span> hypothesis: the occurrence of the outcomes is statistically independent..</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"Scala快速学习","date":"2018-04-25T08:36:47.000Z","_content":"* 变量声明：\n  var：可变变量\n  val：不可变变量（推荐使用）\n\n<!-- more-->\n\n```scala\nscala> val x = 3\nx: Int = 3\n\nscala> x = 4\n<console>:12: error: reassignment to val\n       x = 4\n         ^\n```\n\n```scala\nscala> var b = 45\nb: Int = 45\n\nscala> b = 12\nb: Int = 12\n```\n* scala值类型（没有包装类型）：\nByte\nChar\nShort\nInt\nLong\nFloat\nDouble\n\n* 条件表达式\nscala中所有类的基类是`Any`类型\nUnit类型相当于java中的void类型，用`()`表示\n\n```scala\nscala> val x = 4\nx: Int = 4\n\nscala> val y = if(x > 1) 1 else \"error\"\ny: Any = 1\n\nscala> print(y)\n1\nscala> val z = if(x < 1) 1 else \"error\"\nz: Any = error\n\nscala> print(z)\nerror\nscala> val w = if (x < 1) 1\nw: AnyVal = ()\n\nscala> print(w)\n()\nscala> val b = if (x > 1) 1 else if (x < 1) -1 else 0\nb: Int = 1\n\nscala> val c = if (x < 1) 1 else ()\nc: AnyVal = ()\n```\n\n* for循环\n\n  a to b:返回[a,b]的闭区间\n\n  a until b:返回[a,b),不包含b\n\n  ```scala\n  scala> 1 to 10\n  res4: scala.collection.immutable.Range.Inclusive = Range 1 to 10\n\n  scala> 1 until 10\n  res5: scala.collection.immutable.Range = Range 1 until 10\n  ```\n\n  ​\n\n  ```scala\n  scala> for (i <- 1 to 10){\n       | print(i)\n       | }\n  12345678910\n  scala> for (i <- 1 until 10){\n       | print(i)\n       | }\n  123456789\n  scala> for (i <- arr) {\n       | print(i)\n       | }\n  javascalapythonc#\n\n  ```\n\n  *嵌套循环*：用`;`隔开\n\n  ```scala\n  scala> for (i <- 1 to 3; j <- 1 to 3) if(i != j) println(i*10 + j+\"\")\n  12\n  13\n  21\n  23\n  31\n  32\n  ```\n\n  也可以用：\n\n  ```scala\n  for() {\n      for(){\n          ...\n      }\n  }\n  ```\n\n  yield:将每次迭代生成的值封装到集合中\n\n  ```scala\n   val res = for(i <- 1 until 10) yield i \n  res: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)\n  scala> print(res)\n  Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)\n  ```\n\n  ​\n\n* 方法和函数的申明以及转换\n\n  scala中的各种操作符（+ - * /等）都是作为方法存在的，从源码中可以看出来，以int为例：\n\n  ```scala\n  final abstract class Int() extends scala.AnyVal {\n    def toByte : scala.Byte\n    def toShort : scala.Short\n    def toChar : scala.Char\n    def toInt : scala.Int\n    def toLong : scala.Long\n    def toFloat : scala.Float\n    def toDouble : scala.Double\n    def unary_~ : scala.Int\n    def unary_+ : scala.Int\n    def unary_- : scala.Int\n    def +(x : scala.Predef.String) : scala.Predef.String\n    def <<(x : scala.Int) : scala.Int\n    def <<(x : scala.Long) : scala.Int\n    def >>>(x : scala.Int) : scala.Int\n    def >>>(x : scala.Long) : scala.Int\n    def >>(x : scala.Int) : scala.Int\n    def >>(x : scala.Long) : scala.Int\n    def ==(x : scala.Byte) : scala.Boolean\n    def ==(x : scala.Short) : scala.Boolean\n    def ==(x : scala.Char) : scala.Boolean...\n  ```\n\n  测试：\n\n  ```scala\n  scala> 1+2\n  res0: Int = 3\n\n  scala> 1.+(2)\n  res1: Int = 3\n  ```\n\n  方法的声明：def 方法名 （参数1：参数类型 ...)：  返回类型  = 方法体 \n\n  ```scala\n  scala> def m1(x:Int, y:Int): Int = x + y\n  m1: (x: Int, y: Int)Int\n  scala> m1(3,4)\n  res3: Int = 7\n  ```\n\n  scala中的方法和函数不是一个东西，定义的方式都不一样。\n\n  函数定义方式：\n\n  ```scala\n  scala> var f1 = (x :Int, y:Int) => x + y\n  f1: (Int, Int) => Int = $$Lambda$1074/1012975233@1b3a9ef4\n  ```\n\n  函数调用方式：\n\n  ```scala\n  scala> f1(1,2)\n  res4: Int = 3\n  ```\n\n  函数一般可以作为方法的参数被传入：\n\n  ```scala\n  scala> def m2(f: (Int, Int) => Int) = f(3,4)\n  m2: (f: (Int, Int) => Int)Int\n\n  scala> val f1 = (x:Int, y:Int) => x+y\n  f1: (Int, Int) => Int = $$Lambda$1082/1413679210@5740ad76\n\n  scala> m2(f1)\n  res5: Int = 7\n  ```\n\n  方法转为函数：空格+下划线\n\n  ```scala\n  scala> def m1(x: Int, y: Int):Int = x + y\n  m1: (x: Int, y: Int)Int\n\n  scala> val f1 = m1 _\n  f1: (Int, Int) => Int = $$Lambda$1087/504561103@1d0fc0bc\n\n  scala> m2(f1)\n  res6: Int = 7\n\n  scala> m2(m1)//内部以隐式方法将方法转为函数\n  res7: Int = 7\n  ```\n\n* 数组\n\n  *定长数组*：不需要引入第三方的定长数组包\n\n  ```scala\n  scala> val arr1 = new Array[Int](8)\n  arr1: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0)\n\n  scala> val arr1 = new Array[String](8)//静态数组，需要new，不指明成员\n  arr1: Array[String] = Array(null, null, null, null, null, null, null, null)\n\n  scala> print(arr1)//输出数组引用\n  [Ljava.lang.String;@13835bdc\n  scala> println(arr1.toBuffer)//转换为数组缓存输出\n  ArrayBuffer(null, null, null, null, null, null, null, null)\n   \n  scala> val arr2 = Array(\"java\", \"scala\", \"python\")//普通类，不需要new，写new会报错\n  arr2: Array[String] = Array(java, scala, python)\n   \n  scala> print(arr2(0))\n  java\n  ```\n\n  *变长数组*：需要引入包 \n\n  ```scala\n  scala> val arr3 = ArrayBuffer[Int]()//不导入包会报错\n  <console>:11: error: not found: value ArrayBuffer\n         val arr3 = ArrayBuffer[Int]()\n                    ^\n  scala> import scala.collection.mutable.Array//此处导入变长数组的包\n  scala> val arr3 = ArrayBuffer[Int]()\n  arr3: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()\n  //向变长数组中添加元素，用+=\n  scala> arr3 += 1\n  res11: arr3.type = ArrayBuffer(1)\n\n  scala> arr3 += (2,3,4)\n  res12: arr3.type = ArrayBuffer(1, 2, 3, 4)\n  //向变长数组添加数组，用++=\n  scala> arr3 ++= Array(5,6)\n  res13: arr3.type = ArrayBuffer(1, 2, 3, 4, 5, 6)\n\n  scala> arr3 ++= ArrayBuffer(7,8)\n  res14: arr3.type = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8)\n  //向变长数组中从某个位置起添加数据，用insert方法\n  scala> arr3.insert(0,-1,0)//从第0个位置起添加-1,0,其他元素依次向后\n\n  scala> arr3\n  res16: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(-1, 0, 1, 2, 3, 4, 5, 6, 7, 8)\n  scala> arr3.remove(0,2)//从变长数组中的某个位置起删除几个数据\n\n  scala> arr3\n  res18: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8)\n  //注意：定长数组没有+= ++= insort remove等方法\n  ```\n\n  数组的遍历和常用操作：\n\n  ```scala\n  scala> val arr = Array(1,2,3,4,5,6,7,8,9)\n  arr: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n  scala> for(i <- arr) println(i)\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n  scala> for(i <- 0 until arr.length) println(arr(i))\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n  scala> for(i <- (0 until arr.length).reverse) println(arr(i))\n  9\n  8\n  7\n  6\n  5\n  4\n  3\n  2\n  1\n\n  //数组的常用操作：\n  scala> arr.sum\n  res22: Int = 45\n\n  scala> arr.max\n  res23: Int = 9\n\n  scala> arr.sorted\n  res24: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)\n  ```\n\n* 映射\n\n  类似于Java中的Map类，存储键值对，默认值是不可改变的，想要改变需要导入mutable包\n\n  定义方式：\n\n  ```scala\n  scala> val map1 = Map(\"scala\" -> 1, \"java\" -> 2, \"python\" -> 3)\n  map1: scala.collection.immutable.Map[String,Int] = Map(scala -> 1, java -> 2, python -> 3)\n  //通过元组定义\n  scala> val map2 = Map((\"scala\",1),(\"java\",2))\n  map2: scala.collection.immutable.Map[String,Int] = Map(scala -> 1, java -> 2)\n  ```\n\n  获取和修改Map值：\n\n  ```scala\n  scala> map1(\"scala\")//获取值\n  res28: Int = 1\n\n  scala> map1(\"scala\") = 6//默认不可变，修改会报错，需要导包\n  <console>:14: error: value update is not a member of scala.collection.immutable.Map[String,Int]\n         map1(\"scala\") = 6\n         ^\n  scala> import scala.collection.mutable._\n  import scala.collection.mutable._\n\n  scala> val map1 = Map(\"scala\" -> 1, \"java\" -> 2, \"python\" -> 3)\n  map1: scala.collection.mutable.Map[String,Int] = Map(scala -> 1, java -> 2, python -> 3)\n\n  scala> map1(\"scala\") = 6\n  //当查询一个不存在的键的时候会报错\n  scala> map1(\"c#\")\n  java.util.NoSuchElementException: key not found: c#\n    at scala.collection.MapLike.default(MapLike.scala:232)\n    at scala.collection.MapLike.default$(MapLike.scala:231)\n    at scala.collection.AbstractMap.default(Map.scala:59)\n    at scala.collection.mutable.HashMap.apply(HashMap.scala:65)\n    ... 28 elided\n  //不存在时指定默认值\n  scala> map1.getOrElse(\"c#\", -1)\n  res32: Int = -1\n  ```\n\n* 元组\n\n  由小括号括起来的多个值，可以是多个类型，下标从1开始\n\n  ```scala\n  //声明元组\n  scala> val t = (\"scala\", 100L, 3.14, (\"apark\",1))\n  t: (String, Long, Double, (String, Int)) = (scala,100,3.14,(apark,1))\n  //获取元素\n  scala> t._1\n  res33: String = scala\n\n  scala> t._4\n  res34: (String, Int) = (apark,1)\n\n  scala> t._4._2\n  res35: Int = 1\n\n  //另一种取值方式：\n  scala> val t, (a,b,c,d) = (\"scala\", 100L, 3.14, (\"apark\",1))\n  t: (String, Long, Double, (String, Int)) = (scala,100,3.14,(apark,1))\n  a: String = scala\n  b: Long = 100\n  c: Double = 3.14\n  d: (String, Int) = (apark,1)\n\n  scala> a\n  res36: String = scala\n  ```\n\n  元组操作：\n\n  ```scala\n  scala> val arr = Array((\"a\",1),(\"b\",2),(\"c\",3))\n  arr: Array[(String, Int)] = Array((a,1), (b,2), (c,3))\n  //数组转换为不可变的Map\n  scala> arr.toMap\n  res37: scala.collection.immutable.Map[String,Int] = Map(a -> 1, b -> 2, c -> 3)\n\n  //拉链操作：将两个数组组成一一对应组成键值对\n  scala> val arr1 = Array(\"a\",\"b\",\"c\")\n  arr1: Array[String] = Array(a, b, c)\n\n  scala> val arr2 = Array(1,2,3)\n  arr2: Array[Int] = Array(1, 2, 3)\n\n  scala> arr1 zip arr2\n  res38: Array[(String, Int)] = Array((a,1), (b,2), (c,3))\n  //位置靠前的为键\n  scala> arr2 zip arr1\n  res39: Array[(Int, String)] = Array((1,a), (2,b), (3,c))\n\n  scala> arr2.zip(arr1)\n  res40: Array[(Int, String)] = Array((1,a), (2,b), (3,c))\n  //当两个数组长度不一样时，也能zip，此时会截取掉长出来的那一部分\n  scala> val arr3 = Array(1,2,3,4,5,6)\n  arr3: Array[Int] = Array(1, 2, 3, 4, 5, 6)\n\n  scala> arr1.zip(arr3)\n  res41: Array[(String, Int)] = Array((a,1), (b,2), (c,3))\n\n  scala> arr3.zip(arr1)\n  res42: Array[(Int, String)] = Array((1,a), (2,b), (3,c))\n\n  scala> arr1.zip(arr1)\n  res43: Array[(String, String)] = Array((a,a), (b,b), (c,c))\n  ```\n\n* 集合\n\n  scala中的集合有三大类，分别是Seq(序列)，Set(集)，Map(映射)\n\n  1.Seq\n\n  分为可变和不可变的Seq，\n\n  不可变Seq：\n\n  ```scala\n  scala> val list = List(1,2,3)\n  list: List[Int] = List(1, 2, 3)\n  //默认不可变，需要添加新的元素只能通过：：或+：创建新的List\n  scala> val list2 = 0 :: list\n  list2: List[Int] = List(0, 1, 2, 3)\n\n  scala> val list3 = list.::(0)\n  list3: List[Int] = List(0, 1, 2, 3)\n\n  scala> val list4 = 0 +: list\n  list4: List[Int] = List(0, 1, 2, 3)\n\n  scala> val list5 = List(5,6,7)\n  list5: List[Int] = List(5, 6, 7)\n  //两个List中的元素合并到一起，用++\n  scala> val list6 = list ++ list5\n  list6: List[Int] = List(1, 2, 3, 5, 6, 7)\n  //List中元素可以重复\n  scala> val list7 = list ++ list\n  list7: List[Int] = List(1, 2, 3, 1, 2, 3)\n  //想要改变合并后List中的元素的位置，改变++左右顺序即可\n  scala> val list8 = list5 ++ list\n  list8: List[Int] = List(5, 6, 7, 1, 2, 3)\n\n  ```\n\n  可变Seq：\n\n  ```scala\n  scala> val list1 = ListBuffer(1,2,3)//创建\n  list1: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3)\n\n  scala> list1 += 4//追加元素，用+=\n  res44: list1.type = ListBuffer(1, 2, 3, 4)\n\n  scala> list1.append(5)//也可以用append()\n\n  scala> list1\n  res46: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 5)\n  //两个List合并并赋值给list1：+++\n  scala> list1 ++= list2\n  res48: list1.type = ListBuffer(1, 2, 3, 4, 5, 6, 7, 8)\n\n  scala> val list1 = ListBuffer(3)\n  list1: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3)\n\n  scala> val list2 = ListBuffer(4,5,6)\n  list2: scala.collection.mutable.ListBuffer[Int] = ListBuffer(4, 5, 6)\n\n  scala> list1 ++ list2\n  res50: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3, 4, 5, 6)\n  //仅进行++操作并不会影响list1和2的元素，会创建一个新的ListBuffer\n  scala> list1\n  res51: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3)\n  //可变类型调用不可变方法不会改变原来的值，会创建一个新的值\n  scala> list1 :+ 4\n  res52: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3, 4)\n  ```\n\n  2.Set，此处只展示可变的Set\n\n  ```scala\n  scala> val set1 = new HashSet[Int]()//此处[Int]为泛型\n  set1: scala.collection.mutable.HashSet[Int] = Set()\n  //set中追加元素，用+=或add方法\n  scala> set1 += 1\n  res54: set1.type = Set(1)\n\n  scala> set1 += 2\n  res55: set1.type = Set(1, 2)\n\n  scala> set1.add(3)\n  res56: Boolean = true\n\n  scala> set1\n  res57: scala.collection.mutable.HashSet[Int] = Set(1, 2, 3)\n  //set与另一个set合并，用++=\n  scala> set1 ++= Set(4,5,6)\n  res58: set1.type = Set(1, 5, 2, 6, 3, 4)\n\n  scala> set1 ++= Set(5,6,7)\n  res59: set1.type = Set(1, 5, 2, 6, 3, 7, 4)\n  //删除元素：-=、remove()方法\n  scala> set1 -= 1\n  res60: set1.type = Set(5, 2, 6, 3, 7, 4)\n\n  scala> set1.remove(2)\n  res61: Boolean = true\n\n  scala> set1\n  res62: scala.collection.mutable.HashSet[Int] = Set(5, 6, 3, 7, 4)\n  ```\n\n  3.Map\n\n  仅分析可变类型\n\n  ```scala\n  scala> val map = new HashMap[String, Int]()//定义一个map\n  map: scala.collection.mutable.HashMap[String,Int] = Map()\n\n  scala> map(\"scala\") = 1\n\n  scala> map\n  res64: scala.collection.mutable.HashMap[String,Int] = Map(scala -> 1)\n  //添加元素 += put \n  scala> map += ((\"java\",2))\n  res65: map.type = Map(scala -> 1, java -> 2)\n\n  scala> map += ((\"python\",3),(\"c#\",4))\n  res66: map.type = Map(scala -> 1, java -> 2, c# -> 4, python -> 3)\n\n  scala> map.put(\"c++\",5)\n  res67: Option[Int] = None\n\n  scala> map\n  res68: scala.collection.mutable.HashMap[String,Int] = Map(scala -> 1, c++ -> 5, java -> 2, c# -> 4, python -> 3)\n  //删除元素 -= remove方法\n  scala> map -= \"java\"\n  res70: map.type = Map(scala -> 1, c++ -> 5, c# -> 4, python -> 3)\n\n  scala> map.remove(\"c++\")\n  res71: Option[Int] = Some(5)\n\n  scala> map\n  res72: scala.collection.mutable.HashMap[String,Int] = Map(scala -> 1, c# -> 4, python -> 3)\n  ```\n\n  ​\n","source":"_posts/Scala快速学习.md","raw":"---\ntitle: Scala快速学习\ndate: 2018-04-25 16:36:47\ntags: scala\n---\n* 变量声明：\n  var：可变变量\n  val：不可变变量（推荐使用）\n\n<!-- more-->\n\n```scala\nscala> val x = 3\nx: Int = 3\n\nscala> x = 4\n<console>:12: error: reassignment to val\n       x = 4\n         ^\n```\n\n```scala\nscala> var b = 45\nb: Int = 45\n\nscala> b = 12\nb: Int = 12\n```\n* scala值类型（没有包装类型）：\nByte\nChar\nShort\nInt\nLong\nFloat\nDouble\n\n* 条件表达式\nscala中所有类的基类是`Any`类型\nUnit类型相当于java中的void类型，用`()`表示\n\n```scala\nscala> val x = 4\nx: Int = 4\n\nscala> val y = if(x > 1) 1 else \"error\"\ny: Any = 1\n\nscala> print(y)\n1\nscala> val z = if(x < 1) 1 else \"error\"\nz: Any = error\n\nscala> print(z)\nerror\nscala> val w = if (x < 1) 1\nw: AnyVal = ()\n\nscala> print(w)\n()\nscala> val b = if (x > 1) 1 else if (x < 1) -1 else 0\nb: Int = 1\n\nscala> val c = if (x < 1) 1 else ()\nc: AnyVal = ()\n```\n\n* for循环\n\n  a to b:返回[a,b]的闭区间\n\n  a until b:返回[a,b),不包含b\n\n  ```scala\n  scala> 1 to 10\n  res4: scala.collection.immutable.Range.Inclusive = Range 1 to 10\n\n  scala> 1 until 10\n  res5: scala.collection.immutable.Range = Range 1 until 10\n  ```\n\n  ​\n\n  ```scala\n  scala> for (i <- 1 to 10){\n       | print(i)\n       | }\n  12345678910\n  scala> for (i <- 1 until 10){\n       | print(i)\n       | }\n  123456789\n  scala> for (i <- arr) {\n       | print(i)\n       | }\n  javascalapythonc#\n\n  ```\n\n  *嵌套循环*：用`;`隔开\n\n  ```scala\n  scala> for (i <- 1 to 3; j <- 1 to 3) if(i != j) println(i*10 + j+\"\")\n  12\n  13\n  21\n  23\n  31\n  32\n  ```\n\n  也可以用：\n\n  ```scala\n  for() {\n      for(){\n          ...\n      }\n  }\n  ```\n\n  yield:将每次迭代生成的值封装到集合中\n\n  ```scala\n   val res = for(i <- 1 until 10) yield i \n  res: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)\n  scala> print(res)\n  Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)\n  ```\n\n  ​\n\n* 方法和函数的申明以及转换\n\n  scala中的各种操作符（+ - * /等）都是作为方法存在的，从源码中可以看出来，以int为例：\n\n  ```scala\n  final abstract class Int() extends scala.AnyVal {\n    def toByte : scala.Byte\n    def toShort : scala.Short\n    def toChar : scala.Char\n    def toInt : scala.Int\n    def toLong : scala.Long\n    def toFloat : scala.Float\n    def toDouble : scala.Double\n    def unary_~ : scala.Int\n    def unary_+ : scala.Int\n    def unary_- : scala.Int\n    def +(x : scala.Predef.String) : scala.Predef.String\n    def <<(x : scala.Int) : scala.Int\n    def <<(x : scala.Long) : scala.Int\n    def >>>(x : scala.Int) : scala.Int\n    def >>>(x : scala.Long) : scala.Int\n    def >>(x : scala.Int) : scala.Int\n    def >>(x : scala.Long) : scala.Int\n    def ==(x : scala.Byte) : scala.Boolean\n    def ==(x : scala.Short) : scala.Boolean\n    def ==(x : scala.Char) : scala.Boolean...\n  ```\n\n  测试：\n\n  ```scala\n  scala> 1+2\n  res0: Int = 3\n\n  scala> 1.+(2)\n  res1: Int = 3\n  ```\n\n  方法的声明：def 方法名 （参数1：参数类型 ...)：  返回类型  = 方法体 \n\n  ```scala\n  scala> def m1(x:Int, y:Int): Int = x + y\n  m1: (x: Int, y: Int)Int\n  scala> m1(3,4)\n  res3: Int = 7\n  ```\n\n  scala中的方法和函数不是一个东西，定义的方式都不一样。\n\n  函数定义方式：\n\n  ```scala\n  scala> var f1 = (x :Int, y:Int) => x + y\n  f1: (Int, Int) => Int = $$Lambda$1074/1012975233@1b3a9ef4\n  ```\n\n  函数调用方式：\n\n  ```scala\n  scala> f1(1,2)\n  res4: Int = 3\n  ```\n\n  函数一般可以作为方法的参数被传入：\n\n  ```scala\n  scala> def m2(f: (Int, Int) => Int) = f(3,4)\n  m2: (f: (Int, Int) => Int)Int\n\n  scala> val f1 = (x:Int, y:Int) => x+y\n  f1: (Int, Int) => Int = $$Lambda$1082/1413679210@5740ad76\n\n  scala> m2(f1)\n  res5: Int = 7\n  ```\n\n  方法转为函数：空格+下划线\n\n  ```scala\n  scala> def m1(x: Int, y: Int):Int = x + y\n  m1: (x: Int, y: Int)Int\n\n  scala> val f1 = m1 _\n  f1: (Int, Int) => Int = $$Lambda$1087/504561103@1d0fc0bc\n\n  scala> m2(f1)\n  res6: Int = 7\n\n  scala> m2(m1)//内部以隐式方法将方法转为函数\n  res7: Int = 7\n  ```\n\n* 数组\n\n  *定长数组*：不需要引入第三方的定长数组包\n\n  ```scala\n  scala> val arr1 = new Array[Int](8)\n  arr1: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0)\n\n  scala> val arr1 = new Array[String](8)//静态数组，需要new，不指明成员\n  arr1: Array[String] = Array(null, null, null, null, null, null, null, null)\n\n  scala> print(arr1)//输出数组引用\n  [Ljava.lang.String;@13835bdc\n  scala> println(arr1.toBuffer)//转换为数组缓存输出\n  ArrayBuffer(null, null, null, null, null, null, null, null)\n   \n  scala> val arr2 = Array(\"java\", \"scala\", \"python\")//普通类，不需要new，写new会报错\n  arr2: Array[String] = Array(java, scala, python)\n   \n  scala> print(arr2(0))\n  java\n  ```\n\n  *变长数组*：需要引入包 \n\n  ```scala\n  scala> val arr3 = ArrayBuffer[Int]()//不导入包会报错\n  <console>:11: error: not found: value ArrayBuffer\n         val arr3 = ArrayBuffer[Int]()\n                    ^\n  scala> import scala.collection.mutable.Array//此处导入变长数组的包\n  scala> val arr3 = ArrayBuffer[Int]()\n  arr3: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()\n  //向变长数组中添加元素，用+=\n  scala> arr3 += 1\n  res11: arr3.type = ArrayBuffer(1)\n\n  scala> arr3 += (2,3,4)\n  res12: arr3.type = ArrayBuffer(1, 2, 3, 4)\n  //向变长数组添加数组，用++=\n  scala> arr3 ++= Array(5,6)\n  res13: arr3.type = ArrayBuffer(1, 2, 3, 4, 5, 6)\n\n  scala> arr3 ++= ArrayBuffer(7,8)\n  res14: arr3.type = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8)\n  //向变长数组中从某个位置起添加数据，用insert方法\n  scala> arr3.insert(0,-1,0)//从第0个位置起添加-1,0,其他元素依次向后\n\n  scala> arr3\n  res16: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(-1, 0, 1, 2, 3, 4, 5, 6, 7, 8)\n  scala> arr3.remove(0,2)//从变长数组中的某个位置起删除几个数据\n\n  scala> arr3\n  res18: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8)\n  //注意：定长数组没有+= ++= insort remove等方法\n  ```\n\n  数组的遍历和常用操作：\n\n  ```scala\n  scala> val arr = Array(1,2,3,4,5,6,7,8,9)\n  arr: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n  scala> for(i <- arr) println(i)\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n  scala> for(i <- 0 until arr.length) println(arr(i))\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n  scala> for(i <- (0 until arr.length).reverse) println(arr(i))\n  9\n  8\n  7\n  6\n  5\n  4\n  3\n  2\n  1\n\n  //数组的常用操作：\n  scala> arr.sum\n  res22: Int = 45\n\n  scala> arr.max\n  res23: Int = 9\n\n  scala> arr.sorted\n  res24: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)\n  ```\n\n* 映射\n\n  类似于Java中的Map类，存储键值对，默认值是不可改变的，想要改变需要导入mutable包\n\n  定义方式：\n\n  ```scala\n  scala> val map1 = Map(\"scala\" -> 1, \"java\" -> 2, \"python\" -> 3)\n  map1: scala.collection.immutable.Map[String,Int] = Map(scala -> 1, java -> 2, python -> 3)\n  //通过元组定义\n  scala> val map2 = Map((\"scala\",1),(\"java\",2))\n  map2: scala.collection.immutable.Map[String,Int] = Map(scala -> 1, java -> 2)\n  ```\n\n  获取和修改Map值：\n\n  ```scala\n  scala> map1(\"scala\")//获取值\n  res28: Int = 1\n\n  scala> map1(\"scala\") = 6//默认不可变，修改会报错，需要导包\n  <console>:14: error: value update is not a member of scala.collection.immutable.Map[String,Int]\n         map1(\"scala\") = 6\n         ^\n  scala> import scala.collection.mutable._\n  import scala.collection.mutable._\n\n  scala> val map1 = Map(\"scala\" -> 1, \"java\" -> 2, \"python\" -> 3)\n  map1: scala.collection.mutable.Map[String,Int] = Map(scala -> 1, java -> 2, python -> 3)\n\n  scala> map1(\"scala\") = 6\n  //当查询一个不存在的键的时候会报错\n  scala> map1(\"c#\")\n  java.util.NoSuchElementException: key not found: c#\n    at scala.collection.MapLike.default(MapLike.scala:232)\n    at scala.collection.MapLike.default$(MapLike.scala:231)\n    at scala.collection.AbstractMap.default(Map.scala:59)\n    at scala.collection.mutable.HashMap.apply(HashMap.scala:65)\n    ... 28 elided\n  //不存在时指定默认值\n  scala> map1.getOrElse(\"c#\", -1)\n  res32: Int = -1\n  ```\n\n* 元组\n\n  由小括号括起来的多个值，可以是多个类型，下标从1开始\n\n  ```scala\n  //声明元组\n  scala> val t = (\"scala\", 100L, 3.14, (\"apark\",1))\n  t: (String, Long, Double, (String, Int)) = (scala,100,3.14,(apark,1))\n  //获取元素\n  scala> t._1\n  res33: String = scala\n\n  scala> t._4\n  res34: (String, Int) = (apark,1)\n\n  scala> t._4._2\n  res35: Int = 1\n\n  //另一种取值方式：\n  scala> val t, (a,b,c,d) = (\"scala\", 100L, 3.14, (\"apark\",1))\n  t: (String, Long, Double, (String, Int)) = (scala,100,3.14,(apark,1))\n  a: String = scala\n  b: Long = 100\n  c: Double = 3.14\n  d: (String, Int) = (apark,1)\n\n  scala> a\n  res36: String = scala\n  ```\n\n  元组操作：\n\n  ```scala\n  scala> val arr = Array((\"a\",1),(\"b\",2),(\"c\",3))\n  arr: Array[(String, Int)] = Array((a,1), (b,2), (c,3))\n  //数组转换为不可变的Map\n  scala> arr.toMap\n  res37: scala.collection.immutable.Map[String,Int] = Map(a -> 1, b -> 2, c -> 3)\n\n  //拉链操作：将两个数组组成一一对应组成键值对\n  scala> val arr1 = Array(\"a\",\"b\",\"c\")\n  arr1: Array[String] = Array(a, b, c)\n\n  scala> val arr2 = Array(1,2,3)\n  arr2: Array[Int] = Array(1, 2, 3)\n\n  scala> arr1 zip arr2\n  res38: Array[(String, Int)] = Array((a,1), (b,2), (c,3))\n  //位置靠前的为键\n  scala> arr2 zip arr1\n  res39: Array[(Int, String)] = Array((1,a), (2,b), (3,c))\n\n  scala> arr2.zip(arr1)\n  res40: Array[(Int, String)] = Array((1,a), (2,b), (3,c))\n  //当两个数组长度不一样时，也能zip，此时会截取掉长出来的那一部分\n  scala> val arr3 = Array(1,2,3,4,5,6)\n  arr3: Array[Int] = Array(1, 2, 3, 4, 5, 6)\n\n  scala> arr1.zip(arr3)\n  res41: Array[(String, Int)] = Array((a,1), (b,2), (c,3))\n\n  scala> arr3.zip(arr1)\n  res42: Array[(Int, String)] = Array((1,a), (2,b), (3,c))\n\n  scala> arr1.zip(arr1)\n  res43: Array[(String, String)] = Array((a,a), (b,b), (c,c))\n  ```\n\n* 集合\n\n  scala中的集合有三大类，分别是Seq(序列)，Set(集)，Map(映射)\n\n  1.Seq\n\n  分为可变和不可变的Seq，\n\n  不可变Seq：\n\n  ```scala\n  scala> val list = List(1,2,3)\n  list: List[Int] = List(1, 2, 3)\n  //默认不可变，需要添加新的元素只能通过：：或+：创建新的List\n  scala> val list2 = 0 :: list\n  list2: List[Int] = List(0, 1, 2, 3)\n\n  scala> val list3 = list.::(0)\n  list3: List[Int] = List(0, 1, 2, 3)\n\n  scala> val list4 = 0 +: list\n  list4: List[Int] = List(0, 1, 2, 3)\n\n  scala> val list5 = List(5,6,7)\n  list5: List[Int] = List(5, 6, 7)\n  //两个List中的元素合并到一起，用++\n  scala> val list6 = list ++ list5\n  list6: List[Int] = List(1, 2, 3, 5, 6, 7)\n  //List中元素可以重复\n  scala> val list7 = list ++ list\n  list7: List[Int] = List(1, 2, 3, 1, 2, 3)\n  //想要改变合并后List中的元素的位置，改变++左右顺序即可\n  scala> val list8 = list5 ++ list\n  list8: List[Int] = List(5, 6, 7, 1, 2, 3)\n\n  ```\n\n  可变Seq：\n\n  ```scala\n  scala> val list1 = ListBuffer(1,2,3)//创建\n  list1: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3)\n\n  scala> list1 += 4//追加元素，用+=\n  res44: list1.type = ListBuffer(1, 2, 3, 4)\n\n  scala> list1.append(5)//也可以用append()\n\n  scala> list1\n  res46: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 5)\n  //两个List合并并赋值给list1：+++\n  scala> list1 ++= list2\n  res48: list1.type = ListBuffer(1, 2, 3, 4, 5, 6, 7, 8)\n\n  scala> val list1 = ListBuffer(3)\n  list1: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3)\n\n  scala> val list2 = ListBuffer(4,5,6)\n  list2: scala.collection.mutable.ListBuffer[Int] = ListBuffer(4, 5, 6)\n\n  scala> list1 ++ list2\n  res50: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3, 4, 5, 6)\n  //仅进行++操作并不会影响list1和2的元素，会创建一个新的ListBuffer\n  scala> list1\n  res51: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3)\n  //可变类型调用不可变方法不会改变原来的值，会创建一个新的值\n  scala> list1 :+ 4\n  res52: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3, 4)\n  ```\n\n  2.Set，此处只展示可变的Set\n\n  ```scala\n  scala> val set1 = new HashSet[Int]()//此处[Int]为泛型\n  set1: scala.collection.mutable.HashSet[Int] = Set()\n  //set中追加元素，用+=或add方法\n  scala> set1 += 1\n  res54: set1.type = Set(1)\n\n  scala> set1 += 2\n  res55: set1.type = Set(1, 2)\n\n  scala> set1.add(3)\n  res56: Boolean = true\n\n  scala> set1\n  res57: scala.collection.mutable.HashSet[Int] = Set(1, 2, 3)\n  //set与另一个set合并，用++=\n  scala> set1 ++= Set(4,5,6)\n  res58: set1.type = Set(1, 5, 2, 6, 3, 4)\n\n  scala> set1 ++= Set(5,6,7)\n  res59: set1.type = Set(1, 5, 2, 6, 3, 7, 4)\n  //删除元素：-=、remove()方法\n  scala> set1 -= 1\n  res60: set1.type = Set(5, 2, 6, 3, 7, 4)\n\n  scala> set1.remove(2)\n  res61: Boolean = true\n\n  scala> set1\n  res62: scala.collection.mutable.HashSet[Int] = Set(5, 6, 3, 7, 4)\n  ```\n\n  3.Map\n\n  仅分析可变类型\n\n  ```scala\n  scala> val map = new HashMap[String, Int]()//定义一个map\n  map: scala.collection.mutable.HashMap[String,Int] = Map()\n\n  scala> map(\"scala\") = 1\n\n  scala> map\n  res64: scala.collection.mutable.HashMap[String,Int] = Map(scala -> 1)\n  //添加元素 += put \n  scala> map += ((\"java\",2))\n  res65: map.type = Map(scala -> 1, java -> 2)\n\n  scala> map += ((\"python\",3),(\"c#\",4))\n  res66: map.type = Map(scala -> 1, java -> 2, c# -> 4, python -> 3)\n\n  scala> map.put(\"c++\",5)\n  res67: Option[Int] = None\n\n  scala> map\n  res68: scala.collection.mutable.HashMap[String,Int] = Map(scala -> 1, c++ -> 5, java -> 2, c# -> 4, python -> 3)\n  //删除元素 -= remove方法\n  scala> map -= \"java\"\n  res70: map.type = Map(scala -> 1, c++ -> 5, c# -> 4, python -> 3)\n\n  scala> map.remove(\"c++\")\n  res71: Option[Int] = Some(5)\n\n  scala> map\n  res72: scala.collection.mutable.HashMap[String,Int] = Map(scala -> 1, c# -> 4, python -> 3)\n  ```\n\n  ​\n","slug":"Scala快速学习","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6q000tcf96jv6auoqc","content":"<ul>\n<li>变量声明：<br>var：可变变量<br>val：不可变变量（推荐使用）</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> x = <span class=\"number\">3</span></span><br><span class=\"line\">x: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; x = <span class=\"number\">4</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">12</span>: error: reassignment to <span class=\"keyword\">val</span></span><br><span class=\"line\">       x = <span class=\"number\">4</span></span><br><span class=\"line\">         ^</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">var</span> b = <span class=\"number\">45</span></span><br><span class=\"line\">b: <span class=\"type\">Int</span> = <span class=\"number\">45</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; b = <span class=\"number\">12</span></span><br><span class=\"line\">b: <span class=\"type\">Int</span> = <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>scala值类型（没有包装类型）：<br>Byte<br>Char<br>Short<br>Int<br>Long<br>Float<br>Double</p>\n</li>\n<li><p>条件表达式<br>scala中所有类的基类是<code>Any</code>类型<br>Unit类型相当于java中的void类型，用<code>()</code>表示</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> x = <span class=\"number\">4</span></span><br><span class=\"line\">x: <span class=\"type\">Int</span> = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> y = <span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"string\">\"error\"</span></span><br><span class=\"line\">y: <span class=\"type\">Any</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(y)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> z = <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"string\">\"error\"</span></span><br><span class=\"line\">z: <span class=\"type\">Any</span> = error</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(z)</span><br><span class=\"line\">error</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> w = <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1</span>) <span class=\"number\">1</span></span><br><span class=\"line\">w: <span class=\"type\">AnyVal</span> = ()</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(w)</span><br><span class=\"line\">()</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> b = <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1</span>) <span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">b: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> c = <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> ()</span><br><span class=\"line\">c: <span class=\"type\">AnyVal</span> = ()</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>for循环</p>\n<p>a to b:返回[a,b]的闭区间</p>\n<p>a until b:返回[a,b),不包含b</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"number\">1</span> to <span class=\"number\">10</span></span><br><span class=\"line\">res4: scala.collection.immutable.<span class=\"type\">Range</span>.<span class=\"type\">Inclusive</span> = <span class=\"type\">Range</span> <span class=\"number\">1</span> to <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"number\">1</span> until <span class=\"number\">10</span></span><br><span class=\"line\">res5: scala.collection.immutable.<span class=\"type\">Range</span> = <span class=\"type\">Range</span> <span class=\"number\">1</span> until <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>​</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">     | print(i)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\"><span class=\"number\">12345678910</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> until <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">     | print(i)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\"><span class=\"number\">123456789</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- arr) &#123;</span><br><span class=\"line\">     | print(i)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\">javascalapythonc#</span><br></pre></td></tr></table></figure>\n<p><em>嵌套循环</em>：用<code>;</code>隔开</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span>; j &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span>) <span class=\"keyword\">if</span>(i != j) println(i*<span class=\"number\">10</span> + j+<span class=\"string\">\"\"</span>)</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br><span class=\"line\"><span class=\"number\">23</span></span><br><span class=\"line\"><span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">32</span></span><br></pre></td></tr></table></figure>\n<p>也可以用：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>()&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>yield:将每次迭代生成的值封装到集合中</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">val</span> res = <span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">1</span> until <span class=\"number\">10</span>) <span class=\"keyword\">yield</span> i </span><br><span class=\"line\">res: scala.collection.immutable.<span class=\"type\">IndexedSeq</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Vector</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">scala&gt; print(res)</span><br><span class=\"line\"><span class=\"type\">Vector</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>方法和函数的申明以及转换</p>\n<p>scala中的各种操作符（+ - * /等）都是作为方法存在的，从源码中可以看出来，以int为例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Int</span>(<span class=\"params\"></span>) <span class=\"keyword\">extends</span> <span class=\"title\">scala</span>.<span class=\"title\">AnyVal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toByte</span> </span>: scala.<span class=\"type\">Byte</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toShort</span> </span>: scala.<span class=\"type\">Short</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toChar</span> </span>: scala.<span class=\"type\">Char</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toInt</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toLong</span> </span>: scala.<span class=\"type\">Long</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toFloat</span> </span>: scala.<span class=\"type\">Float</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toDouble</span> </span>: scala.<span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unary_~</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unary_+</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unary_-</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">+</span></span>(x : scala.<span class=\"type\">Predef</span>.<span class=\"type\">String</span>) : scala.<span class=\"type\">Predef</span>.<span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&lt;&lt;</span></span>(x : scala.<span class=\"type\">Int</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&lt;&lt;</span></span>(x : scala.<span class=\"type\">Long</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;&gt;</span></span>(x : scala.<span class=\"type\">Int</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;&gt;</span></span>(x : scala.<span class=\"type\">Long</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;</span></span>(x : scala.<span class=\"type\">Int</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;</span></span>(x : scala.<span class=\"type\">Long</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">==</span></span>(x : scala.<span class=\"type\">Byte</span>) : scala.<span class=\"type\">Boolean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">==</span></span>(x : scala.<span class=\"type\">Short</span>) : scala.<span class=\"type\">Boolean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">==</span></span>(x : scala.<span class=\"type\">Char</span>) : scala.<span class=\"type\">Boolean</span>...</span><br></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"number\">1</span>+<span class=\"number\">2</span></span><br><span class=\"line\">res0: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"number\">1.</span>+(<span class=\"number\">2</span>)</span><br><span class=\"line\">res1: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>方法的声明：def 方法名 （参数1：参数类型 …)：  返回类型  = 方法体 </p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>): <span class=\"type\">Int</span> = x + y</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\">scala&gt; m1(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">res3: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>scala中的方法和函数不是一个东西，定义的方式都不一样。</p>\n<p>函数定义方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">var</span> f1 = (x :<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>) =&gt; x + y</span><br><span class=\"line\">f1: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1074</span>/<span class=\"number\">1012975233</span>@<span class=\"number\">1</span>b3a9ef4</span><br></pre></td></tr></table></figure>\n<p>函数调用方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; f1(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">res4: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>函数一般可以作为方法的参数被传入：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m2</span></span>(f: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span>) = f(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">m2: (f: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> f1 = (x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>) =&gt; x+y</span><br><span class=\"line\">f1: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1082</span>/<span class=\"number\">1413679210</span>@<span class=\"number\">5740</span>ad76</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(f1)</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>方法转为函数：空格+下划线</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>):<span class=\"type\">Int</span> = x + y</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> f1 = m1 _</span><br><span class=\"line\">f1: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1087</span>/<span class=\"number\">504561103</span>@<span class=\"number\">1</span>d0fc0bc</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(f1)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(m1)<span class=\"comment\">//内部以隐式方法将方法转为函数</span></span><br><span class=\"line\">res7: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组</p>\n<p><em>定长数组</em>：不需要引入第三方的定长数组包</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr1 = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](<span class=\"number\">8</span>)</span><br><span class=\"line\">arr1: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr1 = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">String</span>](<span class=\"number\">8</span>)<span class=\"comment\">//静态数组，需要new，不指明成员</span></span><br><span class=\"line\">arr1: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(arr1)<span class=\"comment\">//输出数组引用</span></span><br><span class=\"line\">[<span class=\"type\">Ljava</span>.lang.<span class=\"type\">String</span>;@<span class=\"number\">13835</span>bdc</span><br><span class=\"line\">scala&gt; println(arr1.toBuffer)<span class=\"comment\">//转换为数组缓存输出</span></span><br><span class=\"line\"><span class=\"type\">ArrayBuffer</span>(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr2 = <span class=\"type\">Array</span>(<span class=\"string\">\"java\"</span>, <span class=\"string\">\"scala\"</span>, <span class=\"string\">\"python\"</span>)<span class=\"comment\">//普通类，不需要new，写new会报错</span></span><br><span class=\"line\">arr2: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(java, scala, python)</span><br><span class=\"line\"> </span><br><span class=\"line\">scala&gt; print(arr2(<span class=\"number\">0</span>))</span><br><span class=\"line\">java</span><br></pre></td></tr></table></figure>\n<p><em>变长数组</em>：需要引入包 </p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr3 = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()<span class=\"comment\">//不导入包会报错</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">11</span>: error: not found: value <span class=\"type\">ArrayBuffer</span></span><br><span class=\"line\">       <span class=\"keyword\">val</span> arr3 = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">                  ^</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Array</span><span class=\"comment\">//此处导入变长数组的包</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr3 = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">arr3: scala.collection.mutable.<span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ArrayBuffer</span>()</span><br><span class=\"line\"><span class=\"comment\">//向变长数组中添加元素，用+=</span></span><br><span class=\"line\">scala&gt; arr3 += <span class=\"number\">1</span></span><br><span class=\"line\">res11: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3 += (<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">res12: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">//向变长数组添加数组，用++=</span></span><br><span class=\"line\">scala&gt; arr3 ++= <span class=\"type\">Array</span>(<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">res13: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3 ++= <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">7</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">res14: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"comment\">//向变长数组中从某个位置起添加数据，用insert方法</span></span><br><span class=\"line\">scala&gt; arr3.insert(<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>)<span class=\"comment\">//从第0个位置起添加-1,0,其他元素依次向后</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3</span><br><span class=\"line\">res16: scala.collection.mutable.<span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">scala&gt; arr3.remove(<span class=\"number\">0</span>,<span class=\"number\">2</span>)<span class=\"comment\">//从变长数组中的某个位置起删除几个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3</span><br><span class=\"line\">res18: scala.collection.mutable.<span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"comment\">//注意：定长数组没有+= ++= insort remove等方法</span></span><br></pre></td></tr></table></figure>\n<p>数组的遍历和常用操作：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span>(i &lt;- arr) println(i)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until arr.length) println(arr(i))</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span>(i &lt;- (<span class=\"number\">0</span> until arr.length).reverse) println(arr(i))</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组的常用操作：</span></span><br><span class=\"line\">scala&gt; arr.sum</span><br><span class=\"line\">res22: <span class=\"type\">Int</span> = <span class=\"number\">45</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.max</span><br><span class=\"line\">res23: <span class=\"type\">Int</span> = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.sorted</span><br><span class=\"line\">res24: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>映射</p>\n<p>类似于Java中的Map类，存储键值对，默认值是不可改变的，想要改变需要导入mutable包</p>\n<p>定义方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map1 = <span class=\"type\">Map</span>(<span class=\"string\">\"scala\"</span> -&gt; <span class=\"number\">1</span>, <span class=\"string\">\"java\"</span> -&gt; <span class=\"number\">2</span>, <span class=\"string\">\"python\"</span> -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">map1: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//通过元组定义</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map2 = <span class=\"type\">Map</span>((<span class=\"string\">\"scala\"</span>,<span class=\"number\">1</span>),(<span class=\"string\">\"java\"</span>,<span class=\"number\">2</span>))</span><br><span class=\"line\">map2: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>获取和修改Map值：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; map1(<span class=\"string\">\"scala\"</span>)<span class=\"comment\">//获取值</span></span><br><span class=\"line\">res28: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map1(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">6</span><span class=\"comment\">//默认不可变，修改会报错，需要导包</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">14</span>: error: value update is not a member of scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>]</span><br><span class=\"line\">       map1(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">6</span></span><br><span class=\"line\">       ^</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map1 = <span class=\"type\">Map</span>(<span class=\"string\">\"scala\"</span> -&gt; <span class=\"number\">1</span>, <span class=\"string\">\"java\"</span> -&gt; <span class=\"number\">2</span>, <span class=\"string\">\"python\"</span> -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">map1: scala.collection.mutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map1(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"comment\">//当查询一个不存在的键的时候会报错</span></span><br><span class=\"line\">scala&gt; map1(<span class=\"string\">\"c#\"</span>)</span><br><span class=\"line\">java.util.<span class=\"type\">NoSuchElementException</span>: key not found: c#</span><br><span class=\"line\">  at scala.collection.<span class=\"type\">MapLike</span>.<span class=\"keyword\">default</span>(<span class=\"type\">MapLike</span>.scala:<span class=\"number\">232</span>)</span><br><span class=\"line\">  at scala.collection.<span class=\"type\">MapLike</span>.<span class=\"keyword\">default</span>$(<span class=\"type\">MapLike</span>.scala:<span class=\"number\">231</span>)</span><br><span class=\"line\">  at scala.collection.<span class=\"type\">AbstractMap</span>.<span class=\"keyword\">default</span>(<span class=\"type\">Map</span>.scala:<span class=\"number\">59</span>)</span><br><span class=\"line\">  at scala.collection.mutable.<span class=\"type\">HashMap</span>.apply(<span class=\"type\">HashMap</span>.scala:<span class=\"number\">65</span>)</span><br><span class=\"line\">  ... <span class=\"number\">28</span> elided</span><br><span class=\"line\"><span class=\"comment\">//不存在时指定默认值</span></span><br><span class=\"line\">scala&gt; map1.getOrElse(<span class=\"string\">\"c#\"</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">res32: <span class=\"type\">Int</span> = <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>元组</p>\n<p>由小括号括起来的多个值，可以是多个类型，下标从1开始</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明元组</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> t = (<span class=\"string\">\"scala\"</span>, <span class=\"number\">100</span>L, <span class=\"number\">3.14</span>, (<span class=\"string\">\"apark\"</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">t: (<span class=\"type\">String</span>, <span class=\"type\">Long</span>, <span class=\"type\">Double</span>, (<span class=\"type\">String</span>, <span class=\"type\">Int</span>)) = (scala,<span class=\"number\">100</span>,<span class=\"number\">3.14</span>,(apark,<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">//获取元素</span></span><br><span class=\"line\">scala&gt; t._1</span><br><span class=\"line\">res33: <span class=\"type\">String</span> = scala</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; t._4</span><br><span class=\"line\">res34: (<span class=\"type\">String</span>, <span class=\"type\">Int</span>) = (apark,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; t._4._2</span><br><span class=\"line\">res35: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另一种取值方式：</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> t, (a,b,c,d) = (<span class=\"string\">\"scala\"</span>, <span class=\"number\">100</span>L, <span class=\"number\">3.14</span>, (<span class=\"string\">\"apark\"</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">t: (<span class=\"type\">String</span>, <span class=\"type\">Long</span>, <span class=\"type\">Double</span>, (<span class=\"type\">String</span>, <span class=\"type\">Int</span>)) = (scala,<span class=\"number\">100</span>,<span class=\"number\">3.14</span>,(apark,<span class=\"number\">1</span>))</span><br><span class=\"line\">a: <span class=\"type\">String</span> = scala</span><br><span class=\"line\">b: <span class=\"type\">Long</span> = <span class=\"number\">100</span></span><br><span class=\"line\">c: <span class=\"type\">Double</span> = <span class=\"number\">3.14</span></span><br><span class=\"line\">d: (<span class=\"type\">String</span>, <span class=\"type\">Int</span>) = (apark,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; a</span><br><span class=\"line\">res36: <span class=\"type\">String</span> = scala</span><br></pre></td></tr></table></figure>\n<p>元组操作：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>((<span class=\"string\">\"a\"</span>,<span class=\"number\">1</span>),(<span class=\"string\">\"b\"</span>,<span class=\"number\">2</span>),(<span class=\"string\">\"c\"</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((a,<span class=\"number\">1</span>), (b,<span class=\"number\">2</span>), (c,<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"comment\">//数组转换为不可变的Map</span></span><br><span class=\"line\">scala&gt; arr.toMap</span><br><span class=\"line\">res37: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(a -&gt; <span class=\"number\">1</span>, b -&gt; <span class=\"number\">2</span>, c -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//拉链操作：将两个数组组成一一对应组成键值对</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr1 = <span class=\"type\">Array</span>(<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">arr1: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(a, b, c)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr2 = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">arr2: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr1 zip arr2</span><br><span class=\"line\">res38: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((a,<span class=\"number\">1</span>), (b,<span class=\"number\">2</span>), (c,<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"comment\">//位置靠前的为键</span></span><br><span class=\"line\">scala&gt; arr2 zip arr1</span><br><span class=\"line\">res39: <span class=\"type\">Array</span>[(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((<span class=\"number\">1</span>,a), (<span class=\"number\">2</span>,b), (<span class=\"number\">3</span>,c))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr2.zip(arr1)</span><br><span class=\"line\">res40: <span class=\"type\">Array</span>[(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((<span class=\"number\">1</span>,a), (<span class=\"number\">2</span>,b), (<span class=\"number\">3</span>,c))</span><br><span class=\"line\"><span class=\"comment\">//当两个数组长度不一样时，也能zip，此时会截取掉长出来的那一部分</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr3 = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">arr3: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr1.zip(arr3)</span><br><span class=\"line\">res41: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((a,<span class=\"number\">1</span>), (b,<span class=\"number\">2</span>), (c,<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3.zip(arr1)</span><br><span class=\"line\">res42: <span class=\"type\">Array</span>[(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((<span class=\"number\">1</span>,a), (<span class=\"number\">2</span>,b), (<span class=\"number\">3</span>,c))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr1.zip(arr1)</span><br><span class=\"line\">res43: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((a,a), (b,b), (c,c))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>集合</p>\n<p>scala中的集合有三大类，分别是Seq(序列)，Set(集)，Map(映射)</p>\n<p>1.Seq</p>\n<p>分为可变和不可变的Seq，</p>\n<p>不可变Seq：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list = <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//默认不可变，需要添加新的元素只能通过：：或+：创建新的List</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list2 = <span class=\"number\">0</span> :: list</span><br><span class=\"line\">list2: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list3 = list.::(<span class=\"number\">0</span>)</span><br><span class=\"line\">list3: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list4 = <span class=\"number\">0</span> +: list</span><br><span class=\"line\">list4: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list5 = <span class=\"type\">List</span>(<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>)</span><br><span class=\"line\">list5: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">//两个List中的元素合并到一起，用++</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list6 = list ++ list5</span><br><span class=\"line\">list6: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">//List中元素可以重复</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list7 = list ++ list</span><br><span class=\"line\">list7: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//想要改变合并后List中的元素的位置，改变++左右顺序即可</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list8 = list5 ++ list</span><br><span class=\"line\">list8: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>可变Seq：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list1 = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)<span class=\"comment\">//创建</span></span><br><span class=\"line\">list1: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1 += <span class=\"number\">4</span><span class=\"comment\">//追加元素，用+=</span></span><br><span class=\"line\">res44: list1.<span class=\"keyword\">type</span> = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1.append(<span class=\"number\">5</span>)<span class=\"comment\">//也可以用append()</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1</span><br><span class=\"line\">res46: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//两个List合并并赋值给list1：+++</span></span><br><span class=\"line\">scala&gt; list1 ++= list2</span><br><span class=\"line\">res48: list1.<span class=\"keyword\">type</span> = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list1 = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">list1: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list2 = <span class=\"type\">ListBuffer</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">list2: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1 ++ list2</span><br><span class=\"line\">res50: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"comment\">//仅进行++操作并不会影响list1和2的元素，会创建一个新的ListBuffer</span></span><br><span class=\"line\">scala&gt; list1</span><br><span class=\"line\">res51: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//可变类型调用不可变方法不会改变原来的值，会创建一个新的值</span></span><br><span class=\"line\">scala&gt; list1 :+ <span class=\"number\">4</span></span><br><span class=\"line\">res52: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>2.Set，此处只展示可变的Set</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> set1 = <span class=\"keyword\">new</span> <span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>]()<span class=\"comment\">//此处[Int]为泛型</span></span><br><span class=\"line\">set1: scala.collection.mutable.<span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Set</span>()</span><br><span class=\"line\"><span class=\"comment\">//set中追加元素，用+=或add方法</span></span><br><span class=\"line\">scala&gt; set1 += <span class=\"number\">1</span></span><br><span class=\"line\">res54: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1 += <span class=\"number\">2</span></span><br><span class=\"line\">res55: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1.add(<span class=\"number\">3</span>)</span><br><span class=\"line\">res56: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1</span><br><span class=\"line\">res57: scala.collection.mutable.<span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//set与另一个set合并，用++=</span></span><br><span class=\"line\">scala&gt; set1 ++= <span class=\"type\">Set</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">res58: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1 ++= <span class=\"type\">Set</span>(<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>)</span><br><span class=\"line\">res59: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">//删除元素：-=、remove()方法</span></span><br><span class=\"line\">scala&gt; set1 -= <span class=\"number\">1</span></span><br><span class=\"line\">res60: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1.remove(<span class=\"number\">2</span>)</span><br><span class=\"line\">res61: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1</span><br><span class=\"line\">res62: scala.collection.mutable.<span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Set</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>3.Map</p>\n<p>仅分析可变类型</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map = <span class=\"keyword\">new</span> <span class=\"type\">HashMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]()<span class=\"comment\">//定义一个map</span></span><br><span class=\"line\">map: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map</span><br><span class=\"line\">res64: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//添加元素 += put </span></span><br><span class=\"line\">scala&gt; map += ((<span class=\"string\">\"java\"</span>,<span class=\"number\">2</span>))</span><br><span class=\"line\">res65: map.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map += ((<span class=\"string\">\"python\"</span>,<span class=\"number\">3</span>),(<span class=\"string\">\"c#\"</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\">res66: map.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map.put(<span class=\"string\">\"c++\"</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">res67: <span class=\"type\">Option</span>[<span class=\"type\">Int</span>] = <span class=\"type\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map</span><br><span class=\"line\">res68: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, c++ -&gt; <span class=\"number\">5</span>, java -&gt; <span class=\"number\">2</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//删除元素 -= remove方法</span></span><br><span class=\"line\">scala&gt; map -= <span class=\"string\">\"java\"</span></span><br><span class=\"line\">res70: map.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, c++ -&gt; <span class=\"number\">5</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map.remove(<span class=\"string\">\"c++\"</span>)</span><br><span class=\"line\">res71: <span class=\"type\">Option</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Some</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map</span><br><span class=\"line\">res72: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>变量声明：<br>var：可变变量<br>val：不可变变量（推荐使用）</li>\n</ul>","more":"<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> x = <span class=\"number\">3</span></span><br><span class=\"line\">x: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; x = <span class=\"number\">4</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">12</span>: error: reassignment to <span class=\"keyword\">val</span></span><br><span class=\"line\">       x = <span class=\"number\">4</span></span><br><span class=\"line\">         ^</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">var</span> b = <span class=\"number\">45</span></span><br><span class=\"line\">b: <span class=\"type\">Int</span> = <span class=\"number\">45</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; b = <span class=\"number\">12</span></span><br><span class=\"line\">b: <span class=\"type\">Int</span> = <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>scala值类型（没有包装类型）：<br>Byte<br>Char<br>Short<br>Int<br>Long<br>Float<br>Double</p>\n</li>\n<li><p>条件表达式<br>scala中所有类的基类是<code>Any</code>类型<br>Unit类型相当于java中的void类型，用<code>()</code>表示</p>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> x = <span class=\"number\">4</span></span><br><span class=\"line\">x: <span class=\"type\">Int</span> = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> y = <span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"string\">\"error\"</span></span><br><span class=\"line\">y: <span class=\"type\">Any</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(y)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> z = <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"string\">\"error\"</span></span><br><span class=\"line\">z: <span class=\"type\">Any</span> = error</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(z)</span><br><span class=\"line\">error</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> w = <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1</span>) <span class=\"number\">1</span></span><br><span class=\"line\">w: <span class=\"type\">AnyVal</span> = ()</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(w)</span><br><span class=\"line\">()</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> b = <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1</span>) <span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">b: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> c = <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1</span>) <span class=\"number\">1</span> <span class=\"keyword\">else</span> ()</span><br><span class=\"line\">c: <span class=\"type\">AnyVal</span> = ()</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>for循环</p>\n<p>a to b:返回[a,b]的闭区间</p>\n<p>a until b:返回[a,b),不包含b</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"number\">1</span> to <span class=\"number\">10</span></span><br><span class=\"line\">res4: scala.collection.immutable.<span class=\"type\">Range</span>.<span class=\"type\">Inclusive</span> = <span class=\"type\">Range</span> <span class=\"number\">1</span> to <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"number\">1</span> until <span class=\"number\">10</span></span><br><span class=\"line\">res5: scala.collection.immutable.<span class=\"type\">Range</span> = <span class=\"type\">Range</span> <span class=\"number\">1</span> until <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>​</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">     | print(i)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\"><span class=\"number\">12345678910</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> until <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">     | print(i)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\"><span class=\"number\">123456789</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- arr) &#123;</span><br><span class=\"line\">     | print(i)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\">javascalapythonc#</span><br></pre></td></tr></table></figure>\n<p><em>嵌套循环</em>：用<code>;</code>隔开</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">for</span> (i &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span>; j &lt;- <span class=\"number\">1</span> to <span class=\"number\">3</span>) <span class=\"keyword\">if</span>(i != j) println(i*<span class=\"number\">10</span> + j+<span class=\"string\">\"\"</span>)</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br><span class=\"line\"><span class=\"number\">23</span></span><br><span class=\"line\"><span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">32</span></span><br></pre></td></tr></table></figure>\n<p>也可以用：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>()&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>yield:将每次迭代生成的值封装到集合中</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">val</span> res = <span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">1</span> until <span class=\"number\">10</span>) <span class=\"keyword\">yield</span> i </span><br><span class=\"line\">res: scala.collection.immutable.<span class=\"type\">IndexedSeq</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Vector</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">scala&gt; print(res)</span><br><span class=\"line\"><span class=\"type\">Vector</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>方法和函数的申明以及转换</p>\n<p>scala中的各种操作符（+ - * /等）都是作为方法存在的，从源码中可以看出来，以int为例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Int</span>(<span class=\"params\"></span>) <span class=\"keyword\">extends</span> <span class=\"title\">scala</span>.<span class=\"title\">AnyVal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toByte</span> </span>: scala.<span class=\"type\">Byte</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toShort</span> </span>: scala.<span class=\"type\">Short</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toChar</span> </span>: scala.<span class=\"type\">Char</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toInt</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toLong</span> </span>: scala.<span class=\"type\">Long</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toFloat</span> </span>: scala.<span class=\"type\">Float</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toDouble</span> </span>: scala.<span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unary_~</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unary_+</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unary_-</span> </span>: scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">+</span></span>(x : scala.<span class=\"type\">Predef</span>.<span class=\"type\">String</span>) : scala.<span class=\"type\">Predef</span>.<span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&lt;&lt;</span></span>(x : scala.<span class=\"type\">Int</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&lt;&lt;</span></span>(x : scala.<span class=\"type\">Long</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;&gt;</span></span>(x : scala.<span class=\"type\">Int</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;&gt;</span></span>(x : scala.<span class=\"type\">Long</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;</span></span>(x : scala.<span class=\"type\">Int</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">&gt;&gt;</span></span>(x : scala.<span class=\"type\">Long</span>) : scala.<span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">==</span></span>(x : scala.<span class=\"type\">Byte</span>) : scala.<span class=\"type\">Boolean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">==</span></span>(x : scala.<span class=\"type\">Short</span>) : scala.<span class=\"type\">Boolean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">==</span></span>(x : scala.<span class=\"type\">Char</span>) : scala.<span class=\"type\">Boolean</span>...</span><br></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"number\">1</span>+<span class=\"number\">2</span></span><br><span class=\"line\">res0: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"number\">1.</span>+(<span class=\"number\">2</span>)</span><br><span class=\"line\">res1: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>方法的声明：def 方法名 （参数1：参数类型 …)：  返回类型  = 方法体 </p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>): <span class=\"type\">Int</span> = x + y</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\">scala&gt; m1(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">res3: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>scala中的方法和函数不是一个东西，定义的方式都不一样。</p>\n<p>函数定义方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">var</span> f1 = (x :<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>) =&gt; x + y</span><br><span class=\"line\">f1: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1074</span>/<span class=\"number\">1012975233</span>@<span class=\"number\">1</span>b3a9ef4</span><br></pre></td></tr></table></figure>\n<p>函数调用方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; f1(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">res4: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>函数一般可以作为方法的参数被传入：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m2</span></span>(f: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span>) = f(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">m2: (f: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> f1 = (x:<span class=\"type\">Int</span>, y:<span class=\"type\">Int</span>) =&gt; x+y</span><br><span class=\"line\">f1: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1082</span>/<span class=\"number\">1413679210</span>@<span class=\"number\">5740</span>ad76</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(f1)</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>方法转为函数：空格+下划线</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>):<span class=\"type\">Int</span> = x + y</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> f1 = m1 _</span><br><span class=\"line\">f1: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1087</span>/<span class=\"number\">504561103</span>@<span class=\"number\">1</span>d0fc0bc</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(f1)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(m1)<span class=\"comment\">//内部以隐式方法将方法转为函数</span></span><br><span class=\"line\">res7: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组</p>\n<p><em>定长数组</em>：不需要引入第三方的定长数组包</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr1 = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">Int</span>](<span class=\"number\">8</span>)</span><br><span class=\"line\">arr1: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr1 = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>[<span class=\"type\">String</span>](<span class=\"number\">8</span>)<span class=\"comment\">//静态数组，需要new，不指明成员</span></span><br><span class=\"line\">arr1: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; print(arr1)<span class=\"comment\">//输出数组引用</span></span><br><span class=\"line\">[<span class=\"type\">Ljava</span>.lang.<span class=\"type\">String</span>;@<span class=\"number\">13835</span>bdc</span><br><span class=\"line\">scala&gt; println(arr1.toBuffer)<span class=\"comment\">//转换为数组缓存输出</span></span><br><span class=\"line\"><span class=\"type\">ArrayBuffer</span>(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr2 = <span class=\"type\">Array</span>(<span class=\"string\">\"java\"</span>, <span class=\"string\">\"scala\"</span>, <span class=\"string\">\"python\"</span>)<span class=\"comment\">//普通类，不需要new，写new会报错</span></span><br><span class=\"line\">arr2: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(java, scala, python)</span><br><span class=\"line\"> </span><br><span class=\"line\">scala&gt; print(arr2(<span class=\"number\">0</span>))</span><br><span class=\"line\">java</span><br></pre></td></tr></table></figure>\n<p><em>变长数组</em>：需要引入包 </p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr3 = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()<span class=\"comment\">//不导入包会报错</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">11</span>: error: not found: value <span class=\"type\">ArrayBuffer</span></span><br><span class=\"line\">       <span class=\"keyword\">val</span> arr3 = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">                  ^</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Array</span><span class=\"comment\">//此处导入变长数组的包</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr3 = <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">arr3: scala.collection.mutable.<span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ArrayBuffer</span>()</span><br><span class=\"line\"><span class=\"comment\">//向变长数组中添加元素，用+=</span></span><br><span class=\"line\">scala&gt; arr3 += <span class=\"number\">1</span></span><br><span class=\"line\">res11: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3 += (<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">res12: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">//向变长数组添加数组，用++=</span></span><br><span class=\"line\">scala&gt; arr3 ++= <span class=\"type\">Array</span>(<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">res13: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3 ++= <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">7</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">res14: arr3.<span class=\"keyword\">type</span> = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"comment\">//向变长数组中从某个位置起添加数据，用insert方法</span></span><br><span class=\"line\">scala&gt; arr3.insert(<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>)<span class=\"comment\">//从第0个位置起添加-1,0,其他元素依次向后</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3</span><br><span class=\"line\">res16: scala.collection.mutable.<span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">scala&gt; arr3.remove(<span class=\"number\">0</span>,<span class=\"number\">2</span>)<span class=\"comment\">//从变长数组中的某个位置起删除几个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3</span><br><span class=\"line\">res18: scala.collection.mutable.<span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"comment\">//注意：定长数组没有+= ++= insort remove等方法</span></span><br></pre></td></tr></table></figure>\n<p>数组的遍历和常用操作：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span>(i &lt;- arr) println(i)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">0</span> until arr.length) println(arr(i))</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">for</span>(i &lt;- (<span class=\"number\">0</span> until arr.length).reverse) println(arr(i))</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组的常用操作：</span></span><br><span class=\"line\">scala&gt; arr.sum</span><br><span class=\"line\">res22: <span class=\"type\">Int</span> = <span class=\"number\">45</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.max</span><br><span class=\"line\">res23: <span class=\"type\">Int</span> = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.sorted</span><br><span class=\"line\">res24: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>映射</p>\n<p>类似于Java中的Map类，存储键值对，默认值是不可改变的，想要改变需要导入mutable包</p>\n<p>定义方式：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map1 = <span class=\"type\">Map</span>(<span class=\"string\">\"scala\"</span> -&gt; <span class=\"number\">1</span>, <span class=\"string\">\"java\"</span> -&gt; <span class=\"number\">2</span>, <span class=\"string\">\"python\"</span> -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">map1: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//通过元组定义</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map2 = <span class=\"type\">Map</span>((<span class=\"string\">\"scala\"</span>,<span class=\"number\">1</span>),(<span class=\"string\">\"java\"</span>,<span class=\"number\">2</span>))</span><br><span class=\"line\">map2: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>获取和修改Map值：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; map1(<span class=\"string\">\"scala\"</span>)<span class=\"comment\">//获取值</span></span><br><span class=\"line\">res28: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map1(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">6</span><span class=\"comment\">//默认不可变，修改会报错，需要导包</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">14</span>: error: value update is not a member of scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>]</span><br><span class=\"line\">       map1(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">6</span></span><br><span class=\"line\">       ^</span><br><span class=\"line\">scala&gt; <span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable._</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map1 = <span class=\"type\">Map</span>(<span class=\"string\">\"scala\"</span> -&gt; <span class=\"number\">1</span>, <span class=\"string\">\"java\"</span> -&gt; <span class=\"number\">2</span>, <span class=\"string\">\"python\"</span> -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">map1: scala.collection.mutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map1(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"comment\">//当查询一个不存在的键的时候会报错</span></span><br><span class=\"line\">scala&gt; map1(<span class=\"string\">\"c#\"</span>)</span><br><span class=\"line\">java.util.<span class=\"type\">NoSuchElementException</span>: key not found: c#</span><br><span class=\"line\">  at scala.collection.<span class=\"type\">MapLike</span>.<span class=\"keyword\">default</span>(<span class=\"type\">MapLike</span>.scala:<span class=\"number\">232</span>)</span><br><span class=\"line\">  at scala.collection.<span class=\"type\">MapLike</span>.<span class=\"keyword\">default</span>$(<span class=\"type\">MapLike</span>.scala:<span class=\"number\">231</span>)</span><br><span class=\"line\">  at scala.collection.<span class=\"type\">AbstractMap</span>.<span class=\"keyword\">default</span>(<span class=\"type\">Map</span>.scala:<span class=\"number\">59</span>)</span><br><span class=\"line\">  at scala.collection.mutable.<span class=\"type\">HashMap</span>.apply(<span class=\"type\">HashMap</span>.scala:<span class=\"number\">65</span>)</span><br><span class=\"line\">  ... <span class=\"number\">28</span> elided</span><br><span class=\"line\"><span class=\"comment\">//不存在时指定默认值</span></span><br><span class=\"line\">scala&gt; map1.getOrElse(<span class=\"string\">\"c#\"</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">res32: <span class=\"type\">Int</span> = <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>元组</p>\n<p>由小括号括起来的多个值，可以是多个类型，下标从1开始</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明元组</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> t = (<span class=\"string\">\"scala\"</span>, <span class=\"number\">100</span>L, <span class=\"number\">3.14</span>, (<span class=\"string\">\"apark\"</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">t: (<span class=\"type\">String</span>, <span class=\"type\">Long</span>, <span class=\"type\">Double</span>, (<span class=\"type\">String</span>, <span class=\"type\">Int</span>)) = (scala,<span class=\"number\">100</span>,<span class=\"number\">3.14</span>,(apark,<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">//获取元素</span></span><br><span class=\"line\">scala&gt; t._1</span><br><span class=\"line\">res33: <span class=\"type\">String</span> = scala</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; t._4</span><br><span class=\"line\">res34: (<span class=\"type\">String</span>, <span class=\"type\">Int</span>) = (apark,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; t._4._2</span><br><span class=\"line\">res35: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另一种取值方式：</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> t, (a,b,c,d) = (<span class=\"string\">\"scala\"</span>, <span class=\"number\">100</span>L, <span class=\"number\">3.14</span>, (<span class=\"string\">\"apark\"</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">t: (<span class=\"type\">String</span>, <span class=\"type\">Long</span>, <span class=\"type\">Double</span>, (<span class=\"type\">String</span>, <span class=\"type\">Int</span>)) = (scala,<span class=\"number\">100</span>,<span class=\"number\">3.14</span>,(apark,<span class=\"number\">1</span>))</span><br><span class=\"line\">a: <span class=\"type\">String</span> = scala</span><br><span class=\"line\">b: <span class=\"type\">Long</span> = <span class=\"number\">100</span></span><br><span class=\"line\">c: <span class=\"type\">Double</span> = <span class=\"number\">3.14</span></span><br><span class=\"line\">d: (<span class=\"type\">String</span>, <span class=\"type\">Int</span>) = (apark,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; a</span><br><span class=\"line\">res36: <span class=\"type\">String</span> = scala</span><br></pre></td></tr></table></figure>\n<p>元组操作：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>((<span class=\"string\">\"a\"</span>,<span class=\"number\">1</span>),(<span class=\"string\">\"b\"</span>,<span class=\"number\">2</span>),(<span class=\"string\">\"c\"</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((a,<span class=\"number\">1</span>), (b,<span class=\"number\">2</span>), (c,<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"comment\">//数组转换为不可变的Map</span></span><br><span class=\"line\">scala&gt; arr.toMap</span><br><span class=\"line\">res37: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(a -&gt; <span class=\"number\">1</span>, b -&gt; <span class=\"number\">2</span>, c -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//拉链操作：将两个数组组成一一对应组成键值对</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr1 = <span class=\"type\">Array</span>(<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">arr1: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(a, b, c)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr2 = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">arr2: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr1 zip arr2</span><br><span class=\"line\">res38: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((a,<span class=\"number\">1</span>), (b,<span class=\"number\">2</span>), (c,<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"comment\">//位置靠前的为键</span></span><br><span class=\"line\">scala&gt; arr2 zip arr1</span><br><span class=\"line\">res39: <span class=\"type\">Array</span>[(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((<span class=\"number\">1</span>,a), (<span class=\"number\">2</span>,b), (<span class=\"number\">3</span>,c))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr2.zip(arr1)</span><br><span class=\"line\">res40: <span class=\"type\">Array</span>[(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((<span class=\"number\">1</span>,a), (<span class=\"number\">2</span>,b), (<span class=\"number\">3</span>,c))</span><br><span class=\"line\"><span class=\"comment\">//当两个数组长度不一样时，也能zip，此时会截取掉长出来的那一部分</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr3 = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">arr3: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr1.zip(arr3)</span><br><span class=\"line\">res41: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((a,<span class=\"number\">1</span>), (b,<span class=\"number\">2</span>), (c,<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr3.zip(arr1)</span><br><span class=\"line\">res42: <span class=\"type\">Array</span>[(<span class=\"type\">Int</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((<span class=\"number\">1</span>,a), (<span class=\"number\">2</span>,b), (<span class=\"number\">3</span>,c))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr1.zip(arr1)</span><br><span class=\"line\">res43: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">String</span>)] = <span class=\"type\">Array</span>((a,a), (b,b), (c,c))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>集合</p>\n<p>scala中的集合有三大类，分别是Seq(序列)，Set(集)，Map(映射)</p>\n<p>1.Seq</p>\n<p>分为可变和不可变的Seq，</p>\n<p>不可变Seq：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list = <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//默认不可变，需要添加新的元素只能通过：：或+：创建新的List</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list2 = <span class=\"number\">0</span> :: list</span><br><span class=\"line\">list2: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list3 = list.::(<span class=\"number\">0</span>)</span><br><span class=\"line\">list3: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list4 = <span class=\"number\">0</span> +: list</span><br><span class=\"line\">list4: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list5 = <span class=\"type\">List</span>(<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>)</span><br><span class=\"line\">list5: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">//两个List中的元素合并到一起，用++</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list6 = list ++ list5</span><br><span class=\"line\">list6: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">//List中元素可以重复</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list7 = list ++ list</span><br><span class=\"line\">list7: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//想要改变合并后List中的元素的位置，改变++左右顺序即可</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list8 = list5 ++ list</span><br><span class=\"line\">list8: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>可变Seq：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list1 = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)<span class=\"comment\">//创建</span></span><br><span class=\"line\">list1: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1 += <span class=\"number\">4</span><span class=\"comment\">//追加元素，用+=</span></span><br><span class=\"line\">res44: list1.<span class=\"keyword\">type</span> = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1.append(<span class=\"number\">5</span>)<span class=\"comment\">//也可以用append()</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1</span><br><span class=\"line\">res46: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//两个List合并并赋值给list1：+++</span></span><br><span class=\"line\">scala&gt; list1 ++= list2</span><br><span class=\"line\">res48: list1.<span class=\"keyword\">type</span> = <span class=\"type\">ListBuffer</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list1 = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">list1: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list2 = <span class=\"type\">ListBuffer</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">list2: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list1 ++ list2</span><br><span class=\"line\">res50: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"comment\">//仅进行++操作并不会影响list1和2的元素，会创建一个新的ListBuffer</span></span><br><span class=\"line\">scala&gt; list1</span><br><span class=\"line\">res51: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//可变类型调用不可变方法不会改变原来的值，会创建一个新的值</span></span><br><span class=\"line\">scala&gt; list1 :+ <span class=\"number\">4</span></span><br><span class=\"line\">res52: scala.collection.mutable.<span class=\"type\">ListBuffer</span>[<span class=\"type\">Int</span>] = <span class=\"type\">ListBuffer</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>2.Set，此处只展示可变的Set</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> set1 = <span class=\"keyword\">new</span> <span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>]()<span class=\"comment\">//此处[Int]为泛型</span></span><br><span class=\"line\">set1: scala.collection.mutable.<span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Set</span>()</span><br><span class=\"line\"><span class=\"comment\">//set中追加元素，用+=或add方法</span></span><br><span class=\"line\">scala&gt; set1 += <span class=\"number\">1</span></span><br><span class=\"line\">res54: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1 += <span class=\"number\">2</span></span><br><span class=\"line\">res55: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1.add(<span class=\"number\">3</span>)</span><br><span class=\"line\">res56: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1</span><br><span class=\"line\">res57: scala.collection.mutable.<span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//set与另一个set合并，用++=</span></span><br><span class=\"line\">scala&gt; set1 ++= <span class=\"type\">Set</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">res58: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1 ++= <span class=\"type\">Set</span>(<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>)</span><br><span class=\"line\">res59: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">//删除元素：-=、remove()方法</span></span><br><span class=\"line\">scala&gt; set1 -= <span class=\"number\">1</span></span><br><span class=\"line\">res60: set1.<span class=\"keyword\">type</span> = <span class=\"type\">Set</span>(<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1.remove(<span class=\"number\">2</span>)</span><br><span class=\"line\">res61: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; set1</span><br><span class=\"line\">res62: scala.collection.mutable.<span class=\"type\">HashSet</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Set</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>3.Map</p>\n<p>仅分析可变类型</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> map = <span class=\"keyword\">new</span> <span class=\"type\">HashMap</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]()<span class=\"comment\">//定义一个map</span></span><br><span class=\"line\">map: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map(<span class=\"string\">\"scala\"</span>) = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map</span><br><span class=\"line\">res64: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//添加元素 += put </span></span><br><span class=\"line\">scala&gt; map += ((<span class=\"string\">\"java\"</span>,<span class=\"number\">2</span>))</span><br><span class=\"line\">res65: map.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map += ((<span class=\"string\">\"python\"</span>,<span class=\"number\">3</span>),(<span class=\"string\">\"c#\"</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\">res66: map.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, java -&gt; <span class=\"number\">2</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map.put(<span class=\"string\">\"c++\"</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">res67: <span class=\"type\">Option</span>[<span class=\"type\">Int</span>] = <span class=\"type\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map</span><br><span class=\"line\">res68: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, c++ -&gt; <span class=\"number\">5</span>, java -&gt; <span class=\"number\">2</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">//删除元素 -= remove方法</span></span><br><span class=\"line\">scala&gt; map -= <span class=\"string\">\"java\"</span></span><br><span class=\"line\">res70: map.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, c++ -&gt; <span class=\"number\">5</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map.remove(<span class=\"string\">\"c++\"</span>)</span><br><span class=\"line\">res71: <span class=\"type\">Option</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Some</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; map</span><br><span class=\"line\">res72: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(scala -&gt; <span class=\"number\">1</span>, c# -&gt; <span class=\"number\">4</span>, python -&gt; <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>"},{"title":"lightGbm简要原理","date":"2018-06-06T17:47:18.000Z","_content":"\n本文转自:https://blog.csdn.net/niaolianjiulin/article/details/76584785\n\n和https://www.cnblogs.com/wanglei5205/p/8722237.html\n\n# 1. lightGBM简介\n\nxgboost的出现，让数据民工们告别了传统的机器学习算法们：RF、GBM、SVM、LASSO……..。现在微软推出了一个新的boosting框架，想要挑战xgboost的江湖地位。\n\n顾名思义，lightGBM包含两个关键点：light即轻量级，GBM 梯度提升机。\n\nLightGBM 是一个梯度 boosting 框架，使用基于学习算法的决策树。它可以说是分布式的，高效的，有以下优势：\n <!-- more-->\n- 更快的训练效率\n- 低内存使用\n- 更高的准确率\n- 支持并行化学习\n- 可处理大规模数据\n\n与常用的机器学习算法进行比较：速度飞起\n\n![这里写图片描述](https://img-blog.csdn.net/20170802163943148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmlhb2xpYW5qaXVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# 2. xgboost缺点\n\nXGB的介绍见[此篇博文](http://blog.csdn.net/niaolianjiulin/article/details/76574216)\n\n其缺点，或者说不足之处：\n\n- 每轮迭代时，都需要遍历整个训练数据多次。如果把整个训练数据装进内存则会限制训练数据的大小；如果不装进内存，反复地读写训练数据又会消耗非常大的时间。\n- 预排序方法（pre-sorted）：首先，空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。其次时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。\n- 对cache优化不友好。在预排序后，特征对梯度的访问是一种随机访问，并且不同的特征访问的顺序不一样，无法对cache进行优化。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的cache miss。\n\n# 3. lightGBM特点\n\n以上与其说是xgboost的不足，倒不如说是lightGBM作者们构建新算法时着重瞄准的点。解决了什么问题，那么原来模型没解决就成了原模型的缺点。\n\n概括来说，lightGBM主要有以下特点：\n\n- **基于Histogram的决策树算法**\n- **带深度限制的Leaf-wise的叶子生长策略**\n- 直方图做差加速\n- 直接支持类别特征(Categorical Feature)\n- Cache命中率优化\n- 基于直方图的稀疏特征优化\n- 多线程优化\n\n前2个特点使我们尤为关注的。\n\n**Histogram算法**\n\n直方图算法的基本思想：先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。遍历数据时，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。\n\n**带深度限制的Leaf-wise的叶子生长策略**\n\nLevel-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。\n\nLeaf-wise则是一种更为高效的策略：每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。\n\nLeaf-wise的缺点：可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度限制，在保证高效率的同时防止过拟合。\n\n# 4. lightGBM调参\n\n（1）num_leaves\n\nLightGBM使用的是leaf-wise的算法，因此在调节树的复杂程度时，使用的是num_leaves而不是max_depth。\n\n大致换算关系：num_leaves = 2^(max_depth)\n\n（2）样本分布非平衡数据集：可以param[‘is_unbalance’]=’true’\n\n（3）Bagging参数：bagging_fraction+bagging_freq（必须同时设置）、feature_fraction\n\n（4）min_data_in_leaf、min_sum_hessian_in_leaf\n\n```python\n// 01. train set and test set\ntrain_data = lgb.Dataset(dtrain[predictors],label=dtrain[target],feature_name=list(dtrain[predictors].columns), categorical_feature=dummies)\n\ntest_data = lgb.Dataset(dtest[predictors],label=dtest[target],feature_name=list(dtest[predictors].columns), categorical_feature=dummies)\n\n// 02. parameters\nparam = {\n    'max_depth':6,\n    'num_leaves':64,\n    'learning_rate':0.03,\n    'scale_pos_weight':1,\n    'num_threads':40,\n    'objective':'binary',\n    'bagging_fraction':0.7,\n    'bagging_freq':1,\n    'min_sum_hessian_in_leaf':100\n}\n\nparam['is_unbalance']='true'\nparam['metric'] = 'auc'\n\n// 03. cv and train\nbst=lgb.cv(param,train_data, num_boost_round=1000, nfold=3, early_stopping_rounds=30)\n\nestimators = lgb.train(param,train_data,num_boost_round=len(bst['auc-mean']))\n\n// 04. test predict\nypred = estimators.predict(dtest[predictors])12345678910111213141516171819202122232425262728\n```\n\n**# lightgbm关键参数**\n\n[![image](https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133821380-233032611.png)](https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133820459-1387924067.png)\n\n**# lightgbm调参方法cv**\n\n[代码github地址](https://github.com/wanglei5205/Machine_learning/blob/master/Boosting--LightGBM/lgb-python/2.lightgbm%E8%B0%83%E5%8F%82%E6%A1%88%E4%BE%8B.py)\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```python\n  1 # -*- coding: utf-8 -*-\n  2 \"\"\"\n  3 # 作者：wanglei5205\n  4 # 邮箱：wanglei5205@126.com\n  5 # 博客：http://cnblogs.com/wanglei5205\n  6 # github：http://github.com/wanglei5205\n  7 \"\"\"\n  8 ### 导入模块\n  9 import numpy as np\n 10 import pandas as pd\n 11 import lightgbm as lgb\n 12 from sklearn import metrics\n 13 \n 14 ### 载入数据\n 15 print('载入数据')\n 16 dataset1 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data1.csv')\n 17 dataset2 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data2.csv')\n 18 dataset3 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data3.csv')\n 19 dataset4 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data4.csv')\n 20 dataset5 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data5.csv')\n 21 \n 22 print('数据去重')\n 23 dataset1.drop_duplicates(inplace=True)\n 24 dataset2.drop_duplicates(inplace=True)\n 25 dataset3.drop_duplicates(inplace=True)\n 26 dataset4.drop_duplicates(inplace=True)\n 27 dataset5.drop_duplicates(inplace=True)\n 28 \n 29 print('数据合并')\n 30 trains = pd.concat([dataset1,dataset2],axis=0)\n 31 trains = pd.concat([trains,dataset3],axis=0)\n 32 trains = pd.concat([trains,dataset4],axis=0)\n 33 \n 34 online_test = dataset5\n 35 \n 36 ### 数据拆分(训练集+验证集+测试集)\n 37 print('数据拆分')\n 38 from sklearn.model_selection import train_test_split\n 39 train_xy,offline_test = train_test_split(trains,test_size = 0.2,random_state=21)\n 40 train,val = train_test_split(train_xy,test_size = 0.2,random_state=21)\n 41 \n 42 # 训练集\n 43 y_train = train.is_trade                                               # 训练集标签\n 44 X_train = train.drop(['instance_id','is_trade'],axis=1)                # 训练集特征矩阵\n 45 \n 46 # 验证集\n 47 y_val = val.is_trade                                                   # 验证集标签\n 48 X_val = val.drop(['instance_id','is_trade'],axis=1)                    # 验证集特征矩阵\n 49 \n 50 # 测试集\n 51 offline_test_X = offline_test.drop(['instance_id','is_trade'],axis=1)  # 线下测试特征矩阵\n 52 online_test_X  = online_test.drop(['instance_id'],axis=1)              # 线上测试特征矩阵\n 53 \n 54 ### 数据转换\n 55 print('数据转换')\n 56 lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=False)\n 57 lgb_eval = lgb.Dataset(X_val, y_val, reference=lgb_train,free_raw_data=False)\n 58 \n 59 ### 设置初始参数--不含交叉验证参数\n 60 print('设置参数')\n 61 params = {\n 62           'boosting_type': 'gbdt',\n 63           'objective': 'binary',\n 64           'metric': 'binary_logloss',\n 65           }\n 66 \n 67 ### 交叉验证(调参)\n 68 print('交叉验证')\n 69 min_merror = float('Inf')\n 70 best_params = {}\n 71 \n 72 # 准确率\n 73 print(\"调参1：提高准确率\")\n 74 for num_leaves in range(20,200,5):\n 75     for max_depth in range(3,8,1):\n 76         params['num_leaves'] = num_leaves\n 77         params['max_depth'] = max_depth\n 78 \n 79         cv_results = lgb.cv(\n 80                             params,\n 81                             lgb_train,\n 82                             seed=2018,\n 83                             nfold=3,\n 84                             metrics=['binary_error'],\n 85                             early_stopping_rounds=10,\n 86                             verbose_eval=True\n 87                             )\n 88 \n 89         mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n 90         boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n 91 \n 92         if mean_merror < min_merror:\n 93             min_merror = mean_merror\n 94             best_params['num_leaves'] = num_leaves\n 95             best_params['max_depth'] = max_depth\n 96 \n 97 params['num_leaves'] = best_params['num_leaves']\n 98 params['max_depth'] = best_params['max_depth']\n 99 \n100 # 过拟合\n101 print(\"调参2：降低过拟合\")\n102 for max_bin in range(1,255,5):\n103     for min_data_in_leaf in range(10,200,5):\n104             params['max_bin'] = max_bin\n105             params['min_data_in_leaf'] = min_data_in_leaf\n106 \n107             cv_results = lgb.cv(\n108                                 params,\n109                                 lgb_train,\n110                                 seed=42,\n111                                 nfold=3,\n112                                 metrics=['binary_error'],\n113                                 early_stopping_rounds=3,\n114                                 verbose_eval=True\n115                                 )\n116 \n117             mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n118             boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n119 \n120             if mean_merror < min_merror:\n121                 min_merror = mean_merror\n122                 best_params['max_bin']= max_bin\n123                 best_params['min_data_in_leaf'] = min_data_in_leaf\n124 \n125 params['min_data_in_leaf'] = best_params['min_data_in_leaf']\n126 params['max_bin'] = best_params['max_bin']\n127 \n128 print(\"调参3：降低过拟合\")\n129 for feature_fraction in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n130     for bagging_fraction in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n131         for bagging_freq in range(0,50,5):\n132             params['feature_fraction'] = feature_fraction\n133             params['bagging_fraction'] = bagging_fraction\n134             params['bagging_freq'] = bagging_freq\n135 \n136             cv_results = lgb.cv(\n137                                 params,\n138                                 lgb_train,\n139                                 seed=42,\n140                                 nfold=3,\n141                                 metrics=['binary_error'],\n142                                 early_stopping_rounds=3,\n143                                 verbose_eval=True\n144                                 )\n145 \n146             mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n147             boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n148 \n149             if mean_merror < min_merror:\n150                 min_merror = mean_merror\n151                 best_params['feature_fraction'] = feature_fraction\n152                 best_params['bagging_fraction'] = bagging_fraction\n153                 best_params['bagging_freq'] = bagging_freq\n154 \n155 params['feature_fraction'] = best_params['feature_fraction']\n156 params['bagging_fraction'] = best_params['bagging_fraction']\n157 params['bagging_freq'] = best_params['bagging_freq']\n158 \n159 print(\"调参4：降低过拟合\")\n160 for lambda_l1 in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n161     for lambda_l2 in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n162         for min_split_gain in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n163             params['lambda_l1'] = lambda_l1\n164             params['lambda_l2'] = lambda_l2\n165             params['min_split_gain'] = min_split_gain\n166 \n167             cv_results = lgb.cv(\n168                                 params,\n169                                 lgb_train,\n170                                 seed=42,\n171                                 nfold=3,\n172                                 metrics=['binary_error'],\n173                                 early_stopping_rounds=3,\n174                                 verbose_eval=True\n175                                 )\n176 \n177             mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n178             boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n179 \n180             if mean_merror < min_merror:\n181                 min_merror = mean_merror\n182                 best_params['lambda_l1'] = lambda_l1\n183                 best_params['lambda_l2'] = lambda_l2\n184                 best_params['min_split_gain'] = min_split_gain\n185 \n186 params['lambda_l1'] = best_params['lambda_l1']\n187 params['lambda_l2'] = best_params['lambda_l2']\n188 params['min_split_gain'] = best_params['min_split_gain']\n189 \n190 \n191 print(best_params)\n192 \n193 ### 训练\n194 params['learning_rate']=0.01\n195 lgb.train(\n196           params,                     # 参数字典\n197           lgb_train,                  # 训练集\n198           valid_sets=lgb_eval,        # 验证集\n199           num_boost_round=2000,       # 迭代次数\n200           early_stopping_rounds=50    # 早停次数\n201           )\n202 \n203 ### 线下预测\n204 print (\"线下预测\")\n205 preds_offline = lgb.predict(offline_test_X, num_iteration=lgb.best_iteration) # 输出概率\n206 offline=offline_test[['instance_id','is_trade']]\n207 offline['preds']=preds_offline\n208 offline.is_trade = offline['is_trade'].astype(np.float64)\n209 print('log_loss', metrics.log_loss(offline.is_trade, offline.preds))\n210 \n211 ### 线上预测\n212 print(\"线上预测\")\n213 preds_online =  lgb.predict(online_test_X, num_iteration=lgb.best_iteration)  # 输出概率\n214 online=online_test[['instance_id']]\n215 online['preds']=preds_online\n216 online.rename(columns={'preds':'predicted_score'},inplace=True)           # 更改列名\n217 online.to_csv(\"./data/20180405.txt\",index=None,sep=' ')                   # 保存结果\n218 \n219 ### 保存模型\n220 from sklearn.externals import joblib\n221 joblib.dump(lgb,'lgb.pkl')\n222 \n223 ### 特征选择\n224 df = pd.DataFrame(X_train.columns.tolist(), columns=['feature'])\n225 df['importance']=list(lgb.feature_importance())                           # 特征分数\n226 df = df.sort_values(by='importance',ascending=False)                      # 特征排序\n227 df.to_csv(\"./data/feature_score_20180331.csv\",index=None,encoding='gbk')  # 保存分数\n```\n","source":"_posts/lightGbm简要原理.md","raw":"---\ntitle: lightGbm简要原理\ndate: 2018-06-07 01:47:18\ntags: 机器学习 \n---\n\n本文转自:https://blog.csdn.net/niaolianjiulin/article/details/76584785\n\n和https://www.cnblogs.com/wanglei5205/p/8722237.html\n\n# 1. lightGBM简介\n\nxgboost的出现，让数据民工们告别了传统的机器学习算法们：RF、GBM、SVM、LASSO……..。现在微软推出了一个新的boosting框架，想要挑战xgboost的江湖地位。\n\n顾名思义，lightGBM包含两个关键点：light即轻量级，GBM 梯度提升机。\n\nLightGBM 是一个梯度 boosting 框架，使用基于学习算法的决策树。它可以说是分布式的，高效的，有以下优势：\n <!-- more-->\n- 更快的训练效率\n- 低内存使用\n- 更高的准确率\n- 支持并行化学习\n- 可处理大规模数据\n\n与常用的机器学习算法进行比较：速度飞起\n\n![这里写图片描述](https://img-blog.csdn.net/20170802163943148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmlhb2xpYW5qaXVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# 2. xgboost缺点\n\nXGB的介绍见[此篇博文](http://blog.csdn.net/niaolianjiulin/article/details/76574216)\n\n其缺点，或者说不足之处：\n\n- 每轮迭代时，都需要遍历整个训练数据多次。如果把整个训练数据装进内存则会限制训练数据的大小；如果不装进内存，反复地读写训练数据又会消耗非常大的时间。\n- 预排序方法（pre-sorted）：首先，空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。其次时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。\n- 对cache优化不友好。在预排序后，特征对梯度的访问是一种随机访问，并且不同的特征访问的顺序不一样，无法对cache进行优化。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的cache miss。\n\n# 3. lightGBM特点\n\n以上与其说是xgboost的不足，倒不如说是lightGBM作者们构建新算法时着重瞄准的点。解决了什么问题，那么原来模型没解决就成了原模型的缺点。\n\n概括来说，lightGBM主要有以下特点：\n\n- **基于Histogram的决策树算法**\n- **带深度限制的Leaf-wise的叶子生长策略**\n- 直方图做差加速\n- 直接支持类别特征(Categorical Feature)\n- Cache命中率优化\n- 基于直方图的稀疏特征优化\n- 多线程优化\n\n前2个特点使我们尤为关注的。\n\n**Histogram算法**\n\n直方图算法的基本思想：先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。遍历数据时，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。\n\n**带深度限制的Leaf-wise的叶子生长策略**\n\nLevel-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。\n\nLeaf-wise则是一种更为高效的策略：每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。\n\nLeaf-wise的缺点：可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度限制，在保证高效率的同时防止过拟合。\n\n# 4. lightGBM调参\n\n（1）num_leaves\n\nLightGBM使用的是leaf-wise的算法，因此在调节树的复杂程度时，使用的是num_leaves而不是max_depth。\n\n大致换算关系：num_leaves = 2^(max_depth)\n\n（2）样本分布非平衡数据集：可以param[‘is_unbalance’]=’true’\n\n（3）Bagging参数：bagging_fraction+bagging_freq（必须同时设置）、feature_fraction\n\n（4）min_data_in_leaf、min_sum_hessian_in_leaf\n\n```python\n// 01. train set and test set\ntrain_data = lgb.Dataset(dtrain[predictors],label=dtrain[target],feature_name=list(dtrain[predictors].columns), categorical_feature=dummies)\n\ntest_data = lgb.Dataset(dtest[predictors],label=dtest[target],feature_name=list(dtest[predictors].columns), categorical_feature=dummies)\n\n// 02. parameters\nparam = {\n    'max_depth':6,\n    'num_leaves':64,\n    'learning_rate':0.03,\n    'scale_pos_weight':1,\n    'num_threads':40,\n    'objective':'binary',\n    'bagging_fraction':0.7,\n    'bagging_freq':1,\n    'min_sum_hessian_in_leaf':100\n}\n\nparam['is_unbalance']='true'\nparam['metric'] = 'auc'\n\n// 03. cv and train\nbst=lgb.cv(param,train_data, num_boost_round=1000, nfold=3, early_stopping_rounds=30)\n\nestimators = lgb.train(param,train_data,num_boost_round=len(bst['auc-mean']))\n\n// 04. test predict\nypred = estimators.predict(dtest[predictors])12345678910111213141516171819202122232425262728\n```\n\n**# lightgbm关键参数**\n\n[![image](https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133821380-233032611.png)](https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133820459-1387924067.png)\n\n**# lightgbm调参方法cv**\n\n[代码github地址](https://github.com/wanglei5205/Machine_learning/blob/master/Boosting--LightGBM/lgb-python/2.lightgbm%E8%B0%83%E5%8F%82%E6%A1%88%E4%BE%8B.py)\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```python\n  1 # -*- coding: utf-8 -*-\n  2 \"\"\"\n  3 # 作者：wanglei5205\n  4 # 邮箱：wanglei5205@126.com\n  5 # 博客：http://cnblogs.com/wanglei5205\n  6 # github：http://github.com/wanglei5205\n  7 \"\"\"\n  8 ### 导入模块\n  9 import numpy as np\n 10 import pandas as pd\n 11 import lightgbm as lgb\n 12 from sklearn import metrics\n 13 \n 14 ### 载入数据\n 15 print('载入数据')\n 16 dataset1 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data1.csv')\n 17 dataset2 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data2.csv')\n 18 dataset3 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data3.csv')\n 19 dataset4 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data4.csv')\n 20 dataset5 = pd.read_csv('G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data5.csv')\n 21 \n 22 print('数据去重')\n 23 dataset1.drop_duplicates(inplace=True)\n 24 dataset2.drop_duplicates(inplace=True)\n 25 dataset3.drop_duplicates(inplace=True)\n 26 dataset4.drop_duplicates(inplace=True)\n 27 dataset5.drop_duplicates(inplace=True)\n 28 \n 29 print('数据合并')\n 30 trains = pd.concat([dataset1,dataset2],axis=0)\n 31 trains = pd.concat([trains,dataset3],axis=0)\n 32 trains = pd.concat([trains,dataset4],axis=0)\n 33 \n 34 online_test = dataset5\n 35 \n 36 ### 数据拆分(训练集+验证集+测试集)\n 37 print('数据拆分')\n 38 from sklearn.model_selection import train_test_split\n 39 train_xy,offline_test = train_test_split(trains,test_size = 0.2,random_state=21)\n 40 train,val = train_test_split(train_xy,test_size = 0.2,random_state=21)\n 41 \n 42 # 训练集\n 43 y_train = train.is_trade                                               # 训练集标签\n 44 X_train = train.drop(['instance_id','is_trade'],axis=1)                # 训练集特征矩阵\n 45 \n 46 # 验证集\n 47 y_val = val.is_trade                                                   # 验证集标签\n 48 X_val = val.drop(['instance_id','is_trade'],axis=1)                    # 验证集特征矩阵\n 49 \n 50 # 测试集\n 51 offline_test_X = offline_test.drop(['instance_id','is_trade'],axis=1)  # 线下测试特征矩阵\n 52 online_test_X  = online_test.drop(['instance_id'],axis=1)              # 线上测试特征矩阵\n 53 \n 54 ### 数据转换\n 55 print('数据转换')\n 56 lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=False)\n 57 lgb_eval = lgb.Dataset(X_val, y_val, reference=lgb_train,free_raw_data=False)\n 58 \n 59 ### 设置初始参数--不含交叉验证参数\n 60 print('设置参数')\n 61 params = {\n 62           'boosting_type': 'gbdt',\n 63           'objective': 'binary',\n 64           'metric': 'binary_logloss',\n 65           }\n 66 \n 67 ### 交叉验证(调参)\n 68 print('交叉验证')\n 69 min_merror = float('Inf')\n 70 best_params = {}\n 71 \n 72 # 准确率\n 73 print(\"调参1：提高准确率\")\n 74 for num_leaves in range(20,200,5):\n 75     for max_depth in range(3,8,1):\n 76         params['num_leaves'] = num_leaves\n 77         params['max_depth'] = max_depth\n 78 \n 79         cv_results = lgb.cv(\n 80                             params,\n 81                             lgb_train,\n 82                             seed=2018,\n 83                             nfold=3,\n 84                             metrics=['binary_error'],\n 85                             early_stopping_rounds=10,\n 86                             verbose_eval=True\n 87                             )\n 88 \n 89         mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n 90         boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n 91 \n 92         if mean_merror < min_merror:\n 93             min_merror = mean_merror\n 94             best_params['num_leaves'] = num_leaves\n 95             best_params['max_depth'] = max_depth\n 96 \n 97 params['num_leaves'] = best_params['num_leaves']\n 98 params['max_depth'] = best_params['max_depth']\n 99 \n100 # 过拟合\n101 print(\"调参2：降低过拟合\")\n102 for max_bin in range(1,255,5):\n103     for min_data_in_leaf in range(10,200,5):\n104             params['max_bin'] = max_bin\n105             params['min_data_in_leaf'] = min_data_in_leaf\n106 \n107             cv_results = lgb.cv(\n108                                 params,\n109                                 lgb_train,\n110                                 seed=42,\n111                                 nfold=3,\n112                                 metrics=['binary_error'],\n113                                 early_stopping_rounds=3,\n114                                 verbose_eval=True\n115                                 )\n116 \n117             mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n118             boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n119 \n120             if mean_merror < min_merror:\n121                 min_merror = mean_merror\n122                 best_params['max_bin']= max_bin\n123                 best_params['min_data_in_leaf'] = min_data_in_leaf\n124 \n125 params['min_data_in_leaf'] = best_params['min_data_in_leaf']\n126 params['max_bin'] = best_params['max_bin']\n127 \n128 print(\"调参3：降低过拟合\")\n129 for feature_fraction in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n130     for bagging_fraction in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n131         for bagging_freq in range(0,50,5):\n132             params['feature_fraction'] = feature_fraction\n133             params['bagging_fraction'] = bagging_fraction\n134             params['bagging_freq'] = bagging_freq\n135 \n136             cv_results = lgb.cv(\n137                                 params,\n138                                 lgb_train,\n139                                 seed=42,\n140                                 nfold=3,\n141                                 metrics=['binary_error'],\n142                                 early_stopping_rounds=3,\n143                                 verbose_eval=True\n144                                 )\n145 \n146             mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n147             boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n148 \n149             if mean_merror < min_merror:\n150                 min_merror = mean_merror\n151                 best_params['feature_fraction'] = feature_fraction\n152                 best_params['bagging_fraction'] = bagging_fraction\n153                 best_params['bagging_freq'] = bagging_freq\n154 \n155 params['feature_fraction'] = best_params['feature_fraction']\n156 params['bagging_fraction'] = best_params['bagging_fraction']\n157 params['bagging_freq'] = best_params['bagging_freq']\n158 \n159 print(\"调参4：降低过拟合\")\n160 for lambda_l1 in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n161     for lambda_l2 in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n162         for min_split_gain in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:\n163             params['lambda_l1'] = lambda_l1\n164             params['lambda_l2'] = lambda_l2\n165             params['min_split_gain'] = min_split_gain\n166 \n167             cv_results = lgb.cv(\n168                                 params,\n169                                 lgb_train,\n170                                 seed=42,\n171                                 nfold=3,\n172                                 metrics=['binary_error'],\n173                                 early_stopping_rounds=3,\n174                                 verbose_eval=True\n175                                 )\n176 \n177             mean_merror = pd.Series(cv_results['binary_error-mean']).min()\n178             boost_rounds = pd.Series(cv_results['binary_error-mean']).argmin()\n179 \n180             if mean_merror < min_merror:\n181                 min_merror = mean_merror\n182                 best_params['lambda_l1'] = lambda_l1\n183                 best_params['lambda_l2'] = lambda_l2\n184                 best_params['min_split_gain'] = min_split_gain\n185 \n186 params['lambda_l1'] = best_params['lambda_l1']\n187 params['lambda_l2'] = best_params['lambda_l2']\n188 params['min_split_gain'] = best_params['min_split_gain']\n189 \n190 \n191 print(best_params)\n192 \n193 ### 训练\n194 params['learning_rate']=0.01\n195 lgb.train(\n196           params,                     # 参数字典\n197           lgb_train,                  # 训练集\n198           valid_sets=lgb_eval,        # 验证集\n199           num_boost_round=2000,       # 迭代次数\n200           early_stopping_rounds=50    # 早停次数\n201           )\n202 \n203 ### 线下预测\n204 print (\"线下预测\")\n205 preds_offline = lgb.predict(offline_test_X, num_iteration=lgb.best_iteration) # 输出概率\n206 offline=offline_test[['instance_id','is_trade']]\n207 offline['preds']=preds_offline\n208 offline.is_trade = offline['is_trade'].astype(np.float64)\n209 print('log_loss', metrics.log_loss(offline.is_trade, offline.preds))\n210 \n211 ### 线上预测\n212 print(\"线上预测\")\n213 preds_online =  lgb.predict(online_test_X, num_iteration=lgb.best_iteration)  # 输出概率\n214 online=online_test[['instance_id']]\n215 online['preds']=preds_online\n216 online.rename(columns={'preds':'predicted_score'},inplace=True)           # 更改列名\n217 online.to_csv(\"./data/20180405.txt\",index=None,sep=' ')                   # 保存结果\n218 \n219 ### 保存模型\n220 from sklearn.externals import joblib\n221 joblib.dump(lgb,'lgb.pkl')\n222 \n223 ### 特征选择\n224 df = pd.DataFrame(X_train.columns.tolist(), columns=['feature'])\n225 df['importance']=list(lgb.feature_importance())                           # 特征分数\n226 df = df.sort_values(by='importance',ascending=False)                      # 特征排序\n227 df.to_csv(\"./data/feature_score_20180331.csv\",index=None,encoding='gbk')  # 保存分数\n```\n","slug":"lightGbm简要原理","published":1,"updated":"2018-06-07T14:06:34.267Z","_id":"cji4l7i6r000vcf96j63n8iie","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文转自:<a href=\"https://blog.csdn.net/niaolianjiulin/article/details/76584785\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/niaolianjiulin/article/details/76584785</a></p>\n<p>和<a href=\"https://www.cnblogs.com/wanglei5205/p/8722237.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wanglei5205/p/8722237.html</a></p>\n<h1 id=\"1-lightGBM简介\"><a href=\"#1-lightGBM简介\" class=\"headerlink\" title=\"1. lightGBM简介\"></a>1. lightGBM简介</h1><p>xgboost的出现，让数据民工们告别了传统的机器学习算法们：RF、GBM、SVM、LASSO……..。现在微软推出了一个新的boosting框架，想要挑战xgboost的江湖地位。</p>\n<p>顾名思义，lightGBM包含两个关键点：light即轻量级，GBM 梯度提升机。</p>\n<p>LightGBM 是一个梯度 boosting 框架，使用基于学习算法的决策树。它可以说是分布式的，高效的，有以下优势：<br> <a id=\"more\"></a></p>\n<ul>\n<li>更快的训练效率</li>\n<li>低内存使用</li>\n<li>更高的准确率</li>\n<li>支持并行化学习</li>\n<li>可处理大规模数据</li>\n</ul>\n<p>与常用的机器学习算法进行比较：速度飞起</p>\n<p><img src=\"https://img-blog.csdn.net/20170802163943148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmlhb2xpYW5qaXVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h1 id=\"2-xgboost缺点\"><a href=\"#2-xgboost缺点\" class=\"headerlink\" title=\"2. xgboost缺点\"></a>2. xgboost缺点</h1><p>XGB的介绍见<a href=\"http://blog.csdn.net/niaolianjiulin/article/details/76574216\" target=\"_blank\" rel=\"noopener\">此篇博文</a></p>\n<p>其缺点，或者说不足之处：</p>\n<ul>\n<li>每轮迭代时，都需要遍历整个训练数据多次。如果把整个训练数据装进内存则会限制训练数据的大小；如果不装进内存，反复地读写训练数据又会消耗非常大的时间。</li>\n<li>预排序方法（pre-sorted）：首先，空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。其次时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。</li>\n<li>对cache优化不友好。在预排序后，特征对梯度的访问是一种随机访问，并且不同的特征访问的顺序不一样，无法对cache进行优化。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的cache miss。</li>\n</ul>\n<h1 id=\"3-lightGBM特点\"><a href=\"#3-lightGBM特点\" class=\"headerlink\" title=\"3. lightGBM特点\"></a>3. lightGBM特点</h1><p>以上与其说是xgboost的不足，倒不如说是lightGBM作者们构建新算法时着重瞄准的点。解决了什么问题，那么原来模型没解决就成了原模型的缺点。</p>\n<p>概括来说，lightGBM主要有以下特点：</p>\n<ul>\n<li><strong>基于Histogram的决策树算法</strong></li>\n<li><strong>带深度限制的Leaf-wise的叶子生长策略</strong></li>\n<li>直方图做差加速</li>\n<li>直接支持类别特征(Categorical Feature)</li>\n<li>Cache命中率优化</li>\n<li>基于直方图的稀疏特征优化</li>\n<li>多线程优化</li>\n</ul>\n<p>前2个特点使我们尤为关注的。</p>\n<p><strong>Histogram算法</strong></p>\n<p>直方图算法的基本思想：先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。遍历数据时，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p>\n<p><strong>带深度限制的Leaf-wise的叶子生长策略</strong></p>\n<p>Level-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。</p>\n<p>Leaf-wise则是一种更为高效的策略：每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。</p>\n<p>Leaf-wise的缺点：可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度限制，在保证高效率的同时防止过拟合。</p>\n<h1 id=\"4-lightGBM调参\"><a href=\"#4-lightGBM调参\" class=\"headerlink\" title=\"4. lightGBM调参\"></a>4. lightGBM调参</h1><p>（1）num_leaves</p>\n<p>LightGBM使用的是leaf-wise的算法，因此在调节树的复杂程度时，使用的是num_leaves而不是max_depth。</p>\n<p>大致换算关系：num_leaves = 2^(max_depth)</p>\n<p>（2）样本分布非平衡数据集：可以param[‘is_unbalance’]=’true’</p>\n<p>（3）Bagging参数：bagging_fraction+bagging_freq（必须同时设置）、feature_fraction</p>\n<p>（4）min_data_in_leaf、min_sum_hessian_in_leaf</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// <span class=\"number\">01.</span> train set <span class=\"keyword\">and</span> test set</span><br><span class=\"line\">train_data = lgb.Dataset(dtrain[predictors],label=dtrain[target],feature_name=list(dtrain[predictors].columns), categorical_feature=dummies)</span><br><span class=\"line\"></span><br><span class=\"line\">test_data = lgb.Dataset(dtest[predictors],label=dtest[target],feature_name=list(dtest[predictors].columns), categorical_feature=dummies)</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"number\">02.</span> parameters</span><br><span class=\"line\">param = &#123;</span><br><span class=\"line\">    <span class=\"string\">'max_depth'</span>:<span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"string\">'num_leaves'</span>:<span class=\"number\">64</span>,</span><br><span class=\"line\">    <span class=\"string\">'learning_rate'</span>:<span class=\"number\">0.03</span>,</span><br><span class=\"line\">    <span class=\"string\">'scale_pos_weight'</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'num_threads'</span>:<span class=\"number\">40</span>,</span><br><span class=\"line\">    <span class=\"string\">'objective'</span>:<span class=\"string\">'binary'</span>,</span><br><span class=\"line\">    <span class=\"string\">'bagging_fraction'</span>:<span class=\"number\">0.7</span>,</span><br><span class=\"line\">    <span class=\"string\">'bagging_freq'</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'min_sum_hessian_in_leaf'</span>:<span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">param[<span class=\"string\">'is_unbalance'</span>]=<span class=\"string\">'true'</span></span><br><span class=\"line\">param[<span class=\"string\">'metric'</span>] = <span class=\"string\">'auc'</span></span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"number\">03.</span> cv <span class=\"keyword\">and</span> train</span><br><span class=\"line\">bst=lgb.cv(param,train_data, num_boost_round=<span class=\"number\">1000</span>, nfold=<span class=\"number\">3</span>, early_stopping_rounds=<span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">estimators = lgb.train(param,train_data,num_boost_round=len(bst[<span class=\"string\">'auc-mean'</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"number\">04.</span> test predict</span><br><span class=\"line\">ypred = estimators.predict(dtest[predictors])<span class=\"number\">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>\n<p><strong># lightgbm关键参数</strong></p>\n<p><a href=\"https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133820459-1387924067.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133821380-233032611.png\" alt=\"image\"></a></p>\n<p><strong># lightgbm调参方法cv</strong></p>\n<p><a href=\"https://github.com/wanglei5205/Machine_learning/blob/master/Boosting--LightGBM/lgb-python/2.lightgbm%E8%B0%83%E5%8F%82%E6%A1%88%E4%BE%8B.py\" target=\"_blank\" rel=\"noopener\">代码github地址</a></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span> <span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">  <span class=\"number\">2</span> <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">  3 # 作者：wanglei5205</span></span><br><span class=\"line\"><span class=\"string\">  4 # 邮箱：wanglei5205@126.com</span></span><br><span class=\"line\"><span class=\"string\">  5 # 博客：http://cnblogs.com/wanglei5205</span></span><br><span class=\"line\"><span class=\"string\">  6 # github：http://github.com/wanglei5205</span></span><br><span class=\"line\"><span class=\"string\">  7 \"\"\"</span></span><br><span class=\"line\">  <span class=\"number\">8</span> <span class=\"comment\">### 导入模块</span></span><br><span class=\"line\">  <span class=\"number\">9</span> <span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"> <span class=\"number\">10</span> <span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"> <span class=\"number\">11</span> <span class=\"keyword\">import</span> lightgbm <span class=\"keyword\">as</span> lgb</span><br><span class=\"line\"> <span class=\"number\">12</span> <span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"> <span class=\"number\">13</span> </span><br><span class=\"line\"> <span class=\"number\">14</span> <span class=\"comment\">### 载入数据</span></span><br><span class=\"line\"> <span class=\"number\">15</span> print(<span class=\"string\">'载入数据'</span>)</span><br><span class=\"line\"> <span class=\"number\">16</span> dataset1 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data1.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">17</span> dataset2 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data2.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">18</span> dataset3 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data3.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">19</span> dataset4 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data4.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">20</span> dataset5 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data5.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">21</span> </span><br><span class=\"line\"> <span class=\"number\">22</span> print(<span class=\"string\">'数据去重'</span>)</span><br><span class=\"line\"> <span class=\"number\">23</span> dataset1.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">24</span> dataset2.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">25</span> dataset3.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">26</span> dataset4.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">27</span> dataset5.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">28</span> </span><br><span class=\"line\"> <span class=\"number\">29</span> print(<span class=\"string\">'数据合并'</span>)</span><br><span class=\"line\"> <span class=\"number\">30</span> trains = pd.concat([dataset1,dataset2],axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"> <span class=\"number\">31</span> trains = pd.concat([trains,dataset3],axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"> <span class=\"number\">32</span> trains = pd.concat([trains,dataset4],axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"> <span class=\"number\">33</span> </span><br><span class=\"line\"> <span class=\"number\">34</span> online_test = dataset5</span><br><span class=\"line\"> <span class=\"number\">35</span> </span><br><span class=\"line\"> <span class=\"number\">36</span> <span class=\"comment\">### 数据拆分(训练集+验证集+测试集)</span></span><br><span class=\"line\"> <span class=\"number\">37</span> print(<span class=\"string\">'数据拆分'</span>)</span><br><span class=\"line\"> <span class=\"number\">38</span> <span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"> <span class=\"number\">39</span> train_xy,offline_test = train_test_split(trains,test_size = <span class=\"number\">0.2</span>,random_state=<span class=\"number\">21</span>)</span><br><span class=\"line\"> <span class=\"number\">40</span> train,val = train_test_split(train_xy,test_size = <span class=\"number\">0.2</span>,random_state=<span class=\"number\">21</span>)</span><br><span class=\"line\"> <span class=\"number\">41</span> </span><br><span class=\"line\"> <span class=\"number\">42</span> <span class=\"comment\"># 训练集</span></span><br><span class=\"line\"> <span class=\"number\">43</span> y_train = train.is_trade                                               <span class=\"comment\"># 训练集标签</span></span><br><span class=\"line\"> <span class=\"number\">44</span> X_train = train.drop([<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>],axis=<span class=\"number\">1</span>)                <span class=\"comment\"># 训练集特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">45</span> </span><br><span class=\"line\"> <span class=\"number\">46</span> <span class=\"comment\"># 验证集</span></span><br><span class=\"line\"> <span class=\"number\">47</span> y_val = val.is_trade                                                   <span class=\"comment\"># 验证集标签</span></span><br><span class=\"line\"> <span class=\"number\">48</span> X_val = val.drop([<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>],axis=<span class=\"number\">1</span>)                    <span class=\"comment\"># 验证集特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">49</span> </span><br><span class=\"line\"> <span class=\"number\">50</span> <span class=\"comment\"># 测试集</span></span><br><span class=\"line\"> <span class=\"number\">51</span> offline_test_X = offline_test.drop([<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>],axis=<span class=\"number\">1</span>)  <span class=\"comment\"># 线下测试特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">52</span> online_test_X  = online_test.drop([<span class=\"string\">'instance_id'</span>],axis=<span class=\"number\">1</span>)              <span class=\"comment\"># 线上测试特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">53</span> </span><br><span class=\"line\"> <span class=\"number\">54</span> <span class=\"comment\">### 数据转换</span></span><br><span class=\"line\"> <span class=\"number\">55</span> print(<span class=\"string\">'数据转换'</span>)</span><br><span class=\"line\"> <span class=\"number\">56</span> lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=<span class=\"keyword\">False</span>)</span><br><span class=\"line\"> <span class=\"number\">57</span> lgb_eval = lgb.Dataset(X_val, y_val, reference=lgb_train,free_raw_data=<span class=\"keyword\">False</span>)</span><br><span class=\"line\"> <span class=\"number\">58</span> </span><br><span class=\"line\"> <span class=\"number\">59</span> <span class=\"comment\">### 设置初始参数--不含交叉验证参数</span></span><br><span class=\"line\"> <span class=\"number\">60</span> print(<span class=\"string\">'设置参数'</span>)</span><br><span class=\"line\"> <span class=\"number\">61</span> params = &#123;</span><br><span class=\"line\"> <span class=\"number\">62</span>           <span class=\"string\">'boosting_type'</span>: <span class=\"string\">'gbdt'</span>,</span><br><span class=\"line\"> <span class=\"number\">63</span>           <span class=\"string\">'objective'</span>: <span class=\"string\">'binary'</span>,</span><br><span class=\"line\"> <span class=\"number\">64</span>           <span class=\"string\">'metric'</span>: <span class=\"string\">'binary_logloss'</span>,</span><br><span class=\"line\"> <span class=\"number\">65</span>           &#125;</span><br><span class=\"line\"> <span class=\"number\">66</span> </span><br><span class=\"line\"> <span class=\"number\">67</span> <span class=\"comment\">### 交叉验证(调参)</span></span><br><span class=\"line\"> <span class=\"number\">68</span> print(<span class=\"string\">'交叉验证'</span>)</span><br><span class=\"line\"> <span class=\"number\">69</span> min_merror = float(<span class=\"string\">'Inf'</span>)</span><br><span class=\"line\"> <span class=\"number\">70</span> best_params = &#123;&#125;</span><br><span class=\"line\"> <span class=\"number\">71</span> </span><br><span class=\"line\"> <span class=\"number\">72</span> <span class=\"comment\"># 准确率</span></span><br><span class=\"line\"> <span class=\"number\">73</span> print(<span class=\"string\">\"调参1：提高准确率\"</span>)</span><br><span class=\"line\"> <span class=\"number\">74</span> <span class=\"keyword\">for</span> num_leaves <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>,<span class=\"number\">200</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"> <span class=\"number\">75</span>     <span class=\"keyword\">for</span> max_depth <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\"> <span class=\"number\">76</span>         params[<span class=\"string\">'num_leaves'</span>] = num_leaves</span><br><span class=\"line\"> <span class=\"number\">77</span>         params[<span class=\"string\">'max_depth'</span>] = max_depth</span><br><span class=\"line\"> <span class=\"number\">78</span> </span><br><span class=\"line\"> <span class=\"number\">79</span>         cv_results = lgb.cv(</span><br><span class=\"line\"> <span class=\"number\">80</span>                             params,</span><br><span class=\"line\"> <span class=\"number\">81</span>                             lgb_train,</span><br><span class=\"line\"> <span class=\"number\">82</span>                             seed=<span class=\"number\">2018</span>,</span><br><span class=\"line\"> <span class=\"number\">83</span>                             nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"> <span class=\"number\">84</span>                             metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"> <span class=\"number\">85</span>                             early_stopping_rounds=<span class=\"number\">10</span>,</span><br><span class=\"line\"> <span class=\"number\">86</span>                             verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"> <span class=\"number\">87</span>                             )</span><br><span class=\"line\"> <span class=\"number\">88</span> </span><br><span class=\"line\"> <span class=\"number\">89</span>         mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"> <span class=\"number\">90</span>         boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"> <span class=\"number\">91</span> </span><br><span class=\"line\"> <span class=\"number\">92</span>         <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"> <span class=\"number\">93</span>             min_merror = mean_merror</span><br><span class=\"line\"> <span class=\"number\">94</span>             best_params[<span class=\"string\">'num_leaves'</span>] = num_leaves</span><br><span class=\"line\"> <span class=\"number\">95</span>             best_params[<span class=\"string\">'max_depth'</span>] = max_depth</span><br><span class=\"line\"> <span class=\"number\">96</span> </span><br><span class=\"line\"> <span class=\"number\">97</span> params[<span class=\"string\">'num_leaves'</span>] = best_params[<span class=\"string\">'num_leaves'</span>]</span><br><span class=\"line\"> <span class=\"number\">98</span> params[<span class=\"string\">'max_depth'</span>] = best_params[<span class=\"string\">'max_depth'</span>]</span><br><span class=\"line\"> <span class=\"number\">99</span> </span><br><span class=\"line\"><span class=\"number\">100</span> <span class=\"comment\"># 过拟合</span></span><br><span class=\"line\"><span class=\"number\">101</span> print(<span class=\"string\">\"调参2：降低过拟合\"</span>)</span><br><span class=\"line\"><span class=\"number\">102</span> <span class=\"keyword\">for</span> max_bin <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">255</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"number\">103</span>     <span class=\"keyword\">for</span> min_data_in_leaf <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>,<span class=\"number\">200</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"number\">104</span>             params[<span class=\"string\">'max_bin'</span>] = max_bin</span><br><span class=\"line\"><span class=\"number\">105</span>             params[<span class=\"string\">'min_data_in_leaf'</span>] = min_data_in_leaf</span><br><span class=\"line\"><span class=\"number\">106</span> </span><br><span class=\"line\"><span class=\"number\">107</span>             cv_results = lgb.cv(</span><br><span class=\"line\"><span class=\"number\">108</span>                                 params,</span><br><span class=\"line\"><span class=\"number\">109</span>                                 lgb_train,</span><br><span class=\"line\"><span class=\"number\">110</span>                                 seed=<span class=\"number\">42</span>,</span><br><span class=\"line\"><span class=\"number\">111</span>                                 nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">112</span>                                 metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"><span class=\"number\">113</span>                                 early_stopping_rounds=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">114</span>                                 verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">115</span>                                 )</span><br><span class=\"line\"><span class=\"number\">116</span> </span><br><span class=\"line\"><span class=\"number\">117</span>             mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"><span class=\"number\">118</span>             boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"><span class=\"number\">119</span> </span><br><span class=\"line\"><span class=\"number\">120</span>             <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"><span class=\"number\">121</span>                 min_merror = mean_merror</span><br><span class=\"line\"><span class=\"number\">122</span>                 best_params[<span class=\"string\">'max_bin'</span>]= max_bin</span><br><span class=\"line\"><span class=\"number\">123</span>                 best_params[<span class=\"string\">'min_data_in_leaf'</span>] = min_data_in_leaf</span><br><span class=\"line\"><span class=\"number\">124</span> </span><br><span class=\"line\"><span class=\"number\">125</span> params[<span class=\"string\">'min_data_in_leaf'</span>] = best_params[<span class=\"string\">'min_data_in_leaf'</span>]</span><br><span class=\"line\"><span class=\"number\">126</span> params[<span class=\"string\">'max_bin'</span>] = best_params[<span class=\"string\">'max_bin'</span>]</span><br><span class=\"line\"><span class=\"number\">127</span> </span><br><span class=\"line\"><span class=\"number\">128</span> print(<span class=\"string\">\"调参3：降低过拟合\"</span>)</span><br><span class=\"line\"><span class=\"number\">129</span> <span class=\"keyword\">for</span> feature_fraction <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">130</span>     <span class=\"keyword\">for</span> bagging_fraction <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">131</span>         <span class=\"keyword\">for</span> bagging_freq <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,<span class=\"number\">50</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"number\">132</span>             params[<span class=\"string\">'feature_fraction'</span>] = feature_fraction</span><br><span class=\"line\"><span class=\"number\">133</span>             params[<span class=\"string\">'bagging_fraction'</span>] = bagging_fraction</span><br><span class=\"line\"><span class=\"number\">134</span>             params[<span class=\"string\">'bagging_freq'</span>] = bagging_freq</span><br><span class=\"line\"><span class=\"number\">135</span> </span><br><span class=\"line\"><span class=\"number\">136</span>             cv_results = lgb.cv(</span><br><span class=\"line\"><span class=\"number\">137</span>                                 params,</span><br><span class=\"line\"><span class=\"number\">138</span>                                 lgb_train,</span><br><span class=\"line\"><span class=\"number\">139</span>                                 seed=<span class=\"number\">42</span>,</span><br><span class=\"line\"><span class=\"number\">140</span>                                 nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">141</span>                                 metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"><span class=\"number\">142</span>                                 early_stopping_rounds=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">143</span>                                 verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">144</span>                                 )</span><br><span class=\"line\"><span class=\"number\">145</span> </span><br><span class=\"line\"><span class=\"number\">146</span>             mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"><span class=\"number\">147</span>             boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"><span class=\"number\">148</span> </span><br><span class=\"line\"><span class=\"number\">149</span>             <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"><span class=\"number\">150</span>                 min_merror = mean_merror</span><br><span class=\"line\"><span class=\"number\">151</span>                 best_params[<span class=\"string\">'feature_fraction'</span>] = feature_fraction</span><br><span class=\"line\"><span class=\"number\">152</span>                 best_params[<span class=\"string\">'bagging_fraction'</span>] = bagging_fraction</span><br><span class=\"line\"><span class=\"number\">153</span>                 best_params[<span class=\"string\">'bagging_freq'</span>] = bagging_freq</span><br><span class=\"line\"><span class=\"number\">154</span> </span><br><span class=\"line\"><span class=\"number\">155</span> params[<span class=\"string\">'feature_fraction'</span>] = best_params[<span class=\"string\">'feature_fraction'</span>]</span><br><span class=\"line\"><span class=\"number\">156</span> params[<span class=\"string\">'bagging_fraction'</span>] = best_params[<span class=\"string\">'bagging_fraction'</span>]</span><br><span class=\"line\"><span class=\"number\">157</span> params[<span class=\"string\">'bagging_freq'</span>] = best_params[<span class=\"string\">'bagging_freq'</span>]</span><br><span class=\"line\"><span class=\"number\">158</span> </span><br><span class=\"line\"><span class=\"number\">159</span> print(<span class=\"string\">\"调参4：降低过拟合\"</span>)</span><br><span class=\"line\"><span class=\"number\">160</span> <span class=\"keyword\">for</span> lambda_l1 <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">161</span>     <span class=\"keyword\">for</span> lambda_l2 <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">162</span>         <span class=\"keyword\">for</span> min_split_gain <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">163</span>             params[<span class=\"string\">'lambda_l1'</span>] = lambda_l1</span><br><span class=\"line\"><span class=\"number\">164</span>             params[<span class=\"string\">'lambda_l2'</span>] = lambda_l2</span><br><span class=\"line\"><span class=\"number\">165</span>             params[<span class=\"string\">'min_split_gain'</span>] = min_split_gain</span><br><span class=\"line\"><span class=\"number\">166</span> </span><br><span class=\"line\"><span class=\"number\">167</span>             cv_results = lgb.cv(</span><br><span class=\"line\"><span class=\"number\">168</span>                                 params,</span><br><span class=\"line\"><span class=\"number\">169</span>                                 lgb_train,</span><br><span class=\"line\"><span class=\"number\">170</span>                                 seed=<span class=\"number\">42</span>,</span><br><span class=\"line\"><span class=\"number\">171</span>                                 nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">172</span>                                 metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"><span class=\"number\">173</span>                                 early_stopping_rounds=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">174</span>                                 verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">175</span>                                 )</span><br><span class=\"line\"><span class=\"number\">176</span> </span><br><span class=\"line\"><span class=\"number\">177</span>             mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"><span class=\"number\">178</span>             boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"><span class=\"number\">179</span> </span><br><span class=\"line\"><span class=\"number\">180</span>             <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"><span class=\"number\">181</span>                 min_merror = mean_merror</span><br><span class=\"line\"><span class=\"number\">182</span>                 best_params[<span class=\"string\">'lambda_l1'</span>] = lambda_l1</span><br><span class=\"line\"><span class=\"number\">183</span>                 best_params[<span class=\"string\">'lambda_l2'</span>] = lambda_l2</span><br><span class=\"line\"><span class=\"number\">184</span>                 best_params[<span class=\"string\">'min_split_gain'</span>] = min_split_gain</span><br><span class=\"line\"><span class=\"number\">185</span> </span><br><span class=\"line\"><span class=\"number\">186</span> params[<span class=\"string\">'lambda_l1'</span>] = best_params[<span class=\"string\">'lambda_l1'</span>]</span><br><span class=\"line\"><span class=\"number\">187</span> params[<span class=\"string\">'lambda_l2'</span>] = best_params[<span class=\"string\">'lambda_l2'</span>]</span><br><span class=\"line\"><span class=\"number\">188</span> params[<span class=\"string\">'min_split_gain'</span>] = best_params[<span class=\"string\">'min_split_gain'</span>]</span><br><span class=\"line\"><span class=\"number\">189</span> </span><br><span class=\"line\"><span class=\"number\">190</span> </span><br><span class=\"line\"><span class=\"number\">191</span> print(best_params)</span><br><span class=\"line\"><span class=\"number\">192</span> </span><br><span class=\"line\"><span class=\"number\">193</span> <span class=\"comment\">### 训练</span></span><br><span class=\"line\"><span class=\"number\">194</span> params[<span class=\"string\">'learning_rate'</span>]=<span class=\"number\">0.01</span></span><br><span class=\"line\"><span class=\"number\">195</span> lgb.train(</span><br><span class=\"line\"><span class=\"number\">196</span>           params,                     <span class=\"comment\"># 参数字典</span></span><br><span class=\"line\"><span class=\"number\">197</span>           lgb_train,                  <span class=\"comment\"># 训练集</span></span><br><span class=\"line\"><span class=\"number\">198</span>           valid_sets=lgb_eval,        <span class=\"comment\"># 验证集</span></span><br><span class=\"line\"><span class=\"number\">199</span>           num_boost_round=<span class=\"number\">2000</span>,       <span class=\"comment\"># 迭代次数</span></span><br><span class=\"line\"><span class=\"number\">200</span>           early_stopping_rounds=<span class=\"number\">50</span>    <span class=\"comment\"># 早停次数</span></span><br><span class=\"line\"><span class=\"number\">201</span>           )</span><br><span class=\"line\"><span class=\"number\">202</span> </span><br><span class=\"line\"><span class=\"number\">203</span> <span class=\"comment\">### 线下预测</span></span><br><span class=\"line\"><span class=\"number\">204</span> <span class=\"keyword\">print</span> (<span class=\"string\">\"线下预测\"</span>)</span><br><span class=\"line\"><span class=\"number\">205</span> preds_offline = lgb.predict(offline_test_X, num_iteration=lgb.best_iteration) <span class=\"comment\"># 输出概率</span></span><br><span class=\"line\"><span class=\"number\">206</span> offline=offline_test[[<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>]]</span><br><span class=\"line\"><span class=\"number\">207</span> offline[<span class=\"string\">'preds'</span>]=preds_offline</span><br><span class=\"line\"><span class=\"number\">208</span> offline.is_trade = offline[<span class=\"string\">'is_trade'</span>].astype(np.float64)</span><br><span class=\"line\"><span class=\"number\">209</span> print(<span class=\"string\">'log_loss'</span>, metrics.log_loss(offline.is_trade, offline.preds))</span><br><span class=\"line\"><span class=\"number\">210</span> </span><br><span class=\"line\"><span class=\"number\">211</span> <span class=\"comment\">### 线上预测</span></span><br><span class=\"line\"><span class=\"number\">212</span> print(<span class=\"string\">\"线上预测\"</span>)</span><br><span class=\"line\"><span class=\"number\">213</span> preds_online =  lgb.predict(online_test_X, num_iteration=lgb.best_iteration)  <span class=\"comment\"># 输出概率</span></span><br><span class=\"line\"><span class=\"number\">214</span> online=online_test[[<span class=\"string\">'instance_id'</span>]]</span><br><span class=\"line\"><span class=\"number\">215</span> online[<span class=\"string\">'preds'</span>]=preds_online</span><br><span class=\"line\"><span class=\"number\">216</span> online.rename(columns=&#123;<span class=\"string\">'preds'</span>:<span class=\"string\">'predicted_score'</span>&#125;,inplace=<span class=\"keyword\">True</span>)           <span class=\"comment\"># 更改列名</span></span><br><span class=\"line\"><span class=\"number\">217</span> online.to_csv(<span class=\"string\">\"./data/20180405.txt\"</span>,index=<span class=\"keyword\">None</span>,sep=<span class=\"string\">' '</span>)                   <span class=\"comment\"># 保存结果</span></span><br><span class=\"line\"><span class=\"number\">218</span> </span><br><span class=\"line\"><span class=\"number\">219</span> <span class=\"comment\">### 保存模型</span></span><br><span class=\"line\"><span class=\"number\">220</span> <span class=\"keyword\">from</span> sklearn.externals <span class=\"keyword\">import</span> joblib</span><br><span class=\"line\"><span class=\"number\">221</span> joblib.dump(lgb,<span class=\"string\">'lgb.pkl'</span>)</span><br><span class=\"line\"><span class=\"number\">222</span> </span><br><span class=\"line\"><span class=\"number\">223</span> <span class=\"comment\">### 特征选择</span></span><br><span class=\"line\"><span class=\"number\">224</span> df = pd.DataFrame(X_train.columns.tolist(), columns=[<span class=\"string\">'feature'</span>])</span><br><span class=\"line\"><span class=\"number\">225</span> df[<span class=\"string\">'importance'</span>]=list(lgb.feature_importance())                           <span class=\"comment\"># 特征分数</span></span><br><span class=\"line\"><span class=\"number\">226</span> df = df.sort_values(by=<span class=\"string\">'importance'</span>,ascending=<span class=\"keyword\">False</span>)                      <span class=\"comment\"># 特征排序</span></span><br><span class=\"line\"><span class=\"number\">227</span> df.to_csv(<span class=\"string\">\"./data/feature_score_20180331.csv\"</span>,index=<span class=\"keyword\">None</span>,encoding=<span class=\"string\">'gbk'</span>)  <span class=\"comment\"># 保存分数</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本文转自:<a href=\"https://blog.csdn.net/niaolianjiulin/article/details/76584785\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/niaolianjiulin/article/details/76584785</a></p>\n<p>和<a href=\"https://www.cnblogs.com/wanglei5205/p/8722237.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wanglei5205/p/8722237.html</a></p>\n<h1 id=\"1-lightGBM简介\"><a href=\"#1-lightGBM简介\" class=\"headerlink\" title=\"1. lightGBM简介\"></a>1. lightGBM简介</h1><p>xgboost的出现，让数据民工们告别了传统的机器学习算法们：RF、GBM、SVM、LASSO……..。现在微软推出了一个新的boosting框架，想要挑战xgboost的江湖地位。</p>\n<p>顾名思义，lightGBM包含两个关键点：light即轻量级，GBM 梯度提升机。</p>\n<p>LightGBM 是一个梯度 boosting 框架，使用基于学习算法的决策树。它可以说是分布式的，高效的，有以下优势：<br>","more":"</p>\n<ul>\n<li>更快的训练效率</li>\n<li>低内存使用</li>\n<li>更高的准确率</li>\n<li>支持并行化学习</li>\n<li>可处理大规模数据</li>\n</ul>\n<p>与常用的机器学习算法进行比较：速度飞起</p>\n<p><img src=\"https://img-blog.csdn.net/20170802163943148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmlhb2xpYW5qaXVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h1 id=\"2-xgboost缺点\"><a href=\"#2-xgboost缺点\" class=\"headerlink\" title=\"2. xgboost缺点\"></a>2. xgboost缺点</h1><p>XGB的介绍见<a href=\"http://blog.csdn.net/niaolianjiulin/article/details/76574216\" target=\"_blank\" rel=\"noopener\">此篇博文</a></p>\n<p>其缺点，或者说不足之处：</p>\n<ul>\n<li>每轮迭代时，都需要遍历整个训练数据多次。如果把整个训练数据装进内存则会限制训练数据的大小；如果不装进内存，反复地读写训练数据又会消耗非常大的时间。</li>\n<li>预排序方法（pre-sorted）：首先，空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。其次时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。</li>\n<li>对cache优化不友好。在预排序后，特征对梯度的访问是一种随机访问，并且不同的特征访问的顺序不一样，无法对cache进行优化。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的cache miss。</li>\n</ul>\n<h1 id=\"3-lightGBM特点\"><a href=\"#3-lightGBM特点\" class=\"headerlink\" title=\"3. lightGBM特点\"></a>3. lightGBM特点</h1><p>以上与其说是xgboost的不足，倒不如说是lightGBM作者们构建新算法时着重瞄准的点。解决了什么问题，那么原来模型没解决就成了原模型的缺点。</p>\n<p>概括来说，lightGBM主要有以下特点：</p>\n<ul>\n<li><strong>基于Histogram的决策树算法</strong></li>\n<li><strong>带深度限制的Leaf-wise的叶子生长策略</strong></li>\n<li>直方图做差加速</li>\n<li>直接支持类别特征(Categorical Feature)</li>\n<li>Cache命中率优化</li>\n<li>基于直方图的稀疏特征优化</li>\n<li>多线程优化</li>\n</ul>\n<p>前2个特点使我们尤为关注的。</p>\n<p><strong>Histogram算法</strong></p>\n<p>直方图算法的基本思想：先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。遍历数据时，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p>\n<p><strong>带深度限制的Leaf-wise的叶子生长策略</strong></p>\n<p>Level-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。</p>\n<p>Leaf-wise则是一种更为高效的策略：每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。</p>\n<p>Leaf-wise的缺点：可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度限制，在保证高效率的同时防止过拟合。</p>\n<h1 id=\"4-lightGBM调参\"><a href=\"#4-lightGBM调参\" class=\"headerlink\" title=\"4. lightGBM调参\"></a>4. lightGBM调参</h1><p>（1）num_leaves</p>\n<p>LightGBM使用的是leaf-wise的算法，因此在调节树的复杂程度时，使用的是num_leaves而不是max_depth。</p>\n<p>大致换算关系：num_leaves = 2^(max_depth)</p>\n<p>（2）样本分布非平衡数据集：可以param[‘is_unbalance’]=’true’</p>\n<p>（3）Bagging参数：bagging_fraction+bagging_freq（必须同时设置）、feature_fraction</p>\n<p>（4）min_data_in_leaf、min_sum_hessian_in_leaf</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// <span class=\"number\">01.</span> train set <span class=\"keyword\">and</span> test set</span><br><span class=\"line\">train_data = lgb.Dataset(dtrain[predictors],label=dtrain[target],feature_name=list(dtrain[predictors].columns), categorical_feature=dummies)</span><br><span class=\"line\"></span><br><span class=\"line\">test_data = lgb.Dataset(dtest[predictors],label=dtest[target],feature_name=list(dtest[predictors].columns), categorical_feature=dummies)</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"number\">02.</span> parameters</span><br><span class=\"line\">param = &#123;</span><br><span class=\"line\">    <span class=\"string\">'max_depth'</span>:<span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"string\">'num_leaves'</span>:<span class=\"number\">64</span>,</span><br><span class=\"line\">    <span class=\"string\">'learning_rate'</span>:<span class=\"number\">0.03</span>,</span><br><span class=\"line\">    <span class=\"string\">'scale_pos_weight'</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'num_threads'</span>:<span class=\"number\">40</span>,</span><br><span class=\"line\">    <span class=\"string\">'objective'</span>:<span class=\"string\">'binary'</span>,</span><br><span class=\"line\">    <span class=\"string\">'bagging_fraction'</span>:<span class=\"number\">0.7</span>,</span><br><span class=\"line\">    <span class=\"string\">'bagging_freq'</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'min_sum_hessian_in_leaf'</span>:<span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">param[<span class=\"string\">'is_unbalance'</span>]=<span class=\"string\">'true'</span></span><br><span class=\"line\">param[<span class=\"string\">'metric'</span>] = <span class=\"string\">'auc'</span></span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"number\">03.</span> cv <span class=\"keyword\">and</span> train</span><br><span class=\"line\">bst=lgb.cv(param,train_data, num_boost_round=<span class=\"number\">1000</span>, nfold=<span class=\"number\">3</span>, early_stopping_rounds=<span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">estimators = lgb.train(param,train_data,num_boost_round=len(bst[<span class=\"string\">'auc-mean'</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"number\">04.</span> test predict</span><br><span class=\"line\">ypred = estimators.predict(dtest[predictors])<span class=\"number\">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>\n<p><strong># lightgbm关键参数</strong></p>\n<p><a href=\"https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133820459-1387924067.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://images2018.cnblogs.com/blog/1307402/201804/1307402-20180405133821380-233032611.png\" alt=\"image\"></a></p>\n<p><strong># lightgbm调参方法cv</strong></p>\n<p><a href=\"https://github.com/wanglei5205/Machine_learning/blob/master/Boosting--LightGBM/lgb-python/2.lightgbm%E8%B0%83%E5%8F%82%E6%A1%88%E4%BE%8B.py\" target=\"_blank\" rel=\"noopener\">代码github地址</a></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span> <span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">  <span class=\"number\">2</span> <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">  3 # 作者：wanglei5205</span></span><br><span class=\"line\"><span class=\"string\">  4 # 邮箱：wanglei5205@126.com</span></span><br><span class=\"line\"><span class=\"string\">  5 # 博客：http://cnblogs.com/wanglei5205</span></span><br><span class=\"line\"><span class=\"string\">  6 # github：http://github.com/wanglei5205</span></span><br><span class=\"line\"><span class=\"string\">  7 \"\"\"</span></span><br><span class=\"line\">  <span class=\"number\">8</span> <span class=\"comment\">### 导入模块</span></span><br><span class=\"line\">  <span class=\"number\">9</span> <span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"> <span class=\"number\">10</span> <span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"> <span class=\"number\">11</span> <span class=\"keyword\">import</span> lightgbm <span class=\"keyword\">as</span> lgb</span><br><span class=\"line\"> <span class=\"number\">12</span> <span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> metrics</span><br><span class=\"line\"> <span class=\"number\">13</span> </span><br><span class=\"line\"> <span class=\"number\">14</span> <span class=\"comment\">### 载入数据</span></span><br><span class=\"line\"> <span class=\"number\">15</span> print(<span class=\"string\">'载入数据'</span>)</span><br><span class=\"line\"> <span class=\"number\">16</span> dataset1 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data1.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">17</span> dataset2 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data2.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">18</span> dataset3 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data3.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">19</span> dataset4 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data4.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">20</span> dataset5 = pd.read_csv(<span class=\"string\">'G:/ML/ML_match/IJCAI/data3.22/3.22ICJAI/data/7_train_data5.csv'</span>)</span><br><span class=\"line\"> <span class=\"number\">21</span> </span><br><span class=\"line\"> <span class=\"number\">22</span> print(<span class=\"string\">'数据去重'</span>)</span><br><span class=\"line\"> <span class=\"number\">23</span> dataset1.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">24</span> dataset2.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">25</span> dataset3.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">26</span> dataset4.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">27</span> dataset5.drop_duplicates(inplace=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"> <span class=\"number\">28</span> </span><br><span class=\"line\"> <span class=\"number\">29</span> print(<span class=\"string\">'数据合并'</span>)</span><br><span class=\"line\"> <span class=\"number\">30</span> trains = pd.concat([dataset1,dataset2],axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"> <span class=\"number\">31</span> trains = pd.concat([trains,dataset3],axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"> <span class=\"number\">32</span> trains = pd.concat([trains,dataset4],axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"> <span class=\"number\">33</span> </span><br><span class=\"line\"> <span class=\"number\">34</span> online_test = dataset5</span><br><span class=\"line\"> <span class=\"number\">35</span> </span><br><span class=\"line\"> <span class=\"number\">36</span> <span class=\"comment\">### 数据拆分(训练集+验证集+测试集)</span></span><br><span class=\"line\"> <span class=\"number\">37</span> print(<span class=\"string\">'数据拆分'</span>)</span><br><span class=\"line\"> <span class=\"number\">38</span> <span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"> <span class=\"number\">39</span> train_xy,offline_test = train_test_split(trains,test_size = <span class=\"number\">0.2</span>,random_state=<span class=\"number\">21</span>)</span><br><span class=\"line\"> <span class=\"number\">40</span> train,val = train_test_split(train_xy,test_size = <span class=\"number\">0.2</span>,random_state=<span class=\"number\">21</span>)</span><br><span class=\"line\"> <span class=\"number\">41</span> </span><br><span class=\"line\"> <span class=\"number\">42</span> <span class=\"comment\"># 训练集</span></span><br><span class=\"line\"> <span class=\"number\">43</span> y_train = train.is_trade                                               <span class=\"comment\"># 训练集标签</span></span><br><span class=\"line\"> <span class=\"number\">44</span> X_train = train.drop([<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>],axis=<span class=\"number\">1</span>)                <span class=\"comment\"># 训练集特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">45</span> </span><br><span class=\"line\"> <span class=\"number\">46</span> <span class=\"comment\"># 验证集</span></span><br><span class=\"line\"> <span class=\"number\">47</span> y_val = val.is_trade                                                   <span class=\"comment\"># 验证集标签</span></span><br><span class=\"line\"> <span class=\"number\">48</span> X_val = val.drop([<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>],axis=<span class=\"number\">1</span>)                    <span class=\"comment\"># 验证集特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">49</span> </span><br><span class=\"line\"> <span class=\"number\">50</span> <span class=\"comment\"># 测试集</span></span><br><span class=\"line\"> <span class=\"number\">51</span> offline_test_X = offline_test.drop([<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>],axis=<span class=\"number\">1</span>)  <span class=\"comment\"># 线下测试特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">52</span> online_test_X  = online_test.drop([<span class=\"string\">'instance_id'</span>],axis=<span class=\"number\">1</span>)              <span class=\"comment\"># 线上测试特征矩阵</span></span><br><span class=\"line\"> <span class=\"number\">53</span> </span><br><span class=\"line\"> <span class=\"number\">54</span> <span class=\"comment\">### 数据转换</span></span><br><span class=\"line\"> <span class=\"number\">55</span> print(<span class=\"string\">'数据转换'</span>)</span><br><span class=\"line\"> <span class=\"number\">56</span> lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=<span class=\"keyword\">False</span>)</span><br><span class=\"line\"> <span class=\"number\">57</span> lgb_eval = lgb.Dataset(X_val, y_val, reference=lgb_train,free_raw_data=<span class=\"keyword\">False</span>)</span><br><span class=\"line\"> <span class=\"number\">58</span> </span><br><span class=\"line\"> <span class=\"number\">59</span> <span class=\"comment\">### 设置初始参数--不含交叉验证参数</span></span><br><span class=\"line\"> <span class=\"number\">60</span> print(<span class=\"string\">'设置参数'</span>)</span><br><span class=\"line\"> <span class=\"number\">61</span> params = &#123;</span><br><span class=\"line\"> <span class=\"number\">62</span>           <span class=\"string\">'boosting_type'</span>: <span class=\"string\">'gbdt'</span>,</span><br><span class=\"line\"> <span class=\"number\">63</span>           <span class=\"string\">'objective'</span>: <span class=\"string\">'binary'</span>,</span><br><span class=\"line\"> <span class=\"number\">64</span>           <span class=\"string\">'metric'</span>: <span class=\"string\">'binary_logloss'</span>,</span><br><span class=\"line\"> <span class=\"number\">65</span>           &#125;</span><br><span class=\"line\"> <span class=\"number\">66</span> </span><br><span class=\"line\"> <span class=\"number\">67</span> <span class=\"comment\">### 交叉验证(调参)</span></span><br><span class=\"line\"> <span class=\"number\">68</span> print(<span class=\"string\">'交叉验证'</span>)</span><br><span class=\"line\"> <span class=\"number\">69</span> min_merror = float(<span class=\"string\">'Inf'</span>)</span><br><span class=\"line\"> <span class=\"number\">70</span> best_params = &#123;&#125;</span><br><span class=\"line\"> <span class=\"number\">71</span> </span><br><span class=\"line\"> <span class=\"number\">72</span> <span class=\"comment\"># 准确率</span></span><br><span class=\"line\"> <span class=\"number\">73</span> print(<span class=\"string\">\"调参1：提高准确率\"</span>)</span><br><span class=\"line\"> <span class=\"number\">74</span> <span class=\"keyword\">for</span> num_leaves <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>,<span class=\"number\">200</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"> <span class=\"number\">75</span>     <span class=\"keyword\">for</span> max_depth <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\"> <span class=\"number\">76</span>         params[<span class=\"string\">'num_leaves'</span>] = num_leaves</span><br><span class=\"line\"> <span class=\"number\">77</span>         params[<span class=\"string\">'max_depth'</span>] = max_depth</span><br><span class=\"line\"> <span class=\"number\">78</span> </span><br><span class=\"line\"> <span class=\"number\">79</span>         cv_results = lgb.cv(</span><br><span class=\"line\"> <span class=\"number\">80</span>                             params,</span><br><span class=\"line\"> <span class=\"number\">81</span>                             lgb_train,</span><br><span class=\"line\"> <span class=\"number\">82</span>                             seed=<span class=\"number\">2018</span>,</span><br><span class=\"line\"> <span class=\"number\">83</span>                             nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"> <span class=\"number\">84</span>                             metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"> <span class=\"number\">85</span>                             early_stopping_rounds=<span class=\"number\">10</span>,</span><br><span class=\"line\"> <span class=\"number\">86</span>                             verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"> <span class=\"number\">87</span>                             )</span><br><span class=\"line\"> <span class=\"number\">88</span> </span><br><span class=\"line\"> <span class=\"number\">89</span>         mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"> <span class=\"number\">90</span>         boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"> <span class=\"number\">91</span> </span><br><span class=\"line\"> <span class=\"number\">92</span>         <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"> <span class=\"number\">93</span>             min_merror = mean_merror</span><br><span class=\"line\"> <span class=\"number\">94</span>             best_params[<span class=\"string\">'num_leaves'</span>] = num_leaves</span><br><span class=\"line\"> <span class=\"number\">95</span>             best_params[<span class=\"string\">'max_depth'</span>] = max_depth</span><br><span class=\"line\"> <span class=\"number\">96</span> </span><br><span class=\"line\"> <span class=\"number\">97</span> params[<span class=\"string\">'num_leaves'</span>] = best_params[<span class=\"string\">'num_leaves'</span>]</span><br><span class=\"line\"> <span class=\"number\">98</span> params[<span class=\"string\">'max_depth'</span>] = best_params[<span class=\"string\">'max_depth'</span>]</span><br><span class=\"line\"> <span class=\"number\">99</span> </span><br><span class=\"line\"><span class=\"number\">100</span> <span class=\"comment\"># 过拟合</span></span><br><span class=\"line\"><span class=\"number\">101</span> print(<span class=\"string\">\"调参2：降低过拟合\"</span>)</span><br><span class=\"line\"><span class=\"number\">102</span> <span class=\"keyword\">for</span> max_bin <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">255</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"number\">103</span>     <span class=\"keyword\">for</span> min_data_in_leaf <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>,<span class=\"number\">200</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"number\">104</span>             params[<span class=\"string\">'max_bin'</span>] = max_bin</span><br><span class=\"line\"><span class=\"number\">105</span>             params[<span class=\"string\">'min_data_in_leaf'</span>] = min_data_in_leaf</span><br><span class=\"line\"><span class=\"number\">106</span> </span><br><span class=\"line\"><span class=\"number\">107</span>             cv_results = lgb.cv(</span><br><span class=\"line\"><span class=\"number\">108</span>                                 params,</span><br><span class=\"line\"><span class=\"number\">109</span>                                 lgb_train,</span><br><span class=\"line\"><span class=\"number\">110</span>                                 seed=<span class=\"number\">42</span>,</span><br><span class=\"line\"><span class=\"number\">111</span>                                 nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">112</span>                                 metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"><span class=\"number\">113</span>                                 early_stopping_rounds=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">114</span>                                 verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">115</span>                                 )</span><br><span class=\"line\"><span class=\"number\">116</span> </span><br><span class=\"line\"><span class=\"number\">117</span>             mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"><span class=\"number\">118</span>             boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"><span class=\"number\">119</span> </span><br><span class=\"line\"><span class=\"number\">120</span>             <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"><span class=\"number\">121</span>                 min_merror = mean_merror</span><br><span class=\"line\"><span class=\"number\">122</span>                 best_params[<span class=\"string\">'max_bin'</span>]= max_bin</span><br><span class=\"line\"><span class=\"number\">123</span>                 best_params[<span class=\"string\">'min_data_in_leaf'</span>] = min_data_in_leaf</span><br><span class=\"line\"><span class=\"number\">124</span> </span><br><span class=\"line\"><span class=\"number\">125</span> params[<span class=\"string\">'min_data_in_leaf'</span>] = best_params[<span class=\"string\">'min_data_in_leaf'</span>]</span><br><span class=\"line\"><span class=\"number\">126</span> params[<span class=\"string\">'max_bin'</span>] = best_params[<span class=\"string\">'max_bin'</span>]</span><br><span class=\"line\"><span class=\"number\">127</span> </span><br><span class=\"line\"><span class=\"number\">128</span> print(<span class=\"string\">\"调参3：降低过拟合\"</span>)</span><br><span class=\"line\"><span class=\"number\">129</span> <span class=\"keyword\">for</span> feature_fraction <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">130</span>     <span class=\"keyword\">for</span> bagging_fraction <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">131</span>         <span class=\"keyword\">for</span> bagging_freq <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,<span class=\"number\">50</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"number\">132</span>             params[<span class=\"string\">'feature_fraction'</span>] = feature_fraction</span><br><span class=\"line\"><span class=\"number\">133</span>             params[<span class=\"string\">'bagging_fraction'</span>] = bagging_fraction</span><br><span class=\"line\"><span class=\"number\">134</span>             params[<span class=\"string\">'bagging_freq'</span>] = bagging_freq</span><br><span class=\"line\"><span class=\"number\">135</span> </span><br><span class=\"line\"><span class=\"number\">136</span>             cv_results = lgb.cv(</span><br><span class=\"line\"><span class=\"number\">137</span>                                 params,</span><br><span class=\"line\"><span class=\"number\">138</span>                                 lgb_train,</span><br><span class=\"line\"><span class=\"number\">139</span>                                 seed=<span class=\"number\">42</span>,</span><br><span class=\"line\"><span class=\"number\">140</span>                                 nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">141</span>                                 metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"><span class=\"number\">142</span>                                 early_stopping_rounds=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">143</span>                                 verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">144</span>                                 )</span><br><span class=\"line\"><span class=\"number\">145</span> </span><br><span class=\"line\"><span class=\"number\">146</span>             mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"><span class=\"number\">147</span>             boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"><span class=\"number\">148</span> </span><br><span class=\"line\"><span class=\"number\">149</span>             <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"><span class=\"number\">150</span>                 min_merror = mean_merror</span><br><span class=\"line\"><span class=\"number\">151</span>                 best_params[<span class=\"string\">'feature_fraction'</span>] = feature_fraction</span><br><span class=\"line\"><span class=\"number\">152</span>                 best_params[<span class=\"string\">'bagging_fraction'</span>] = bagging_fraction</span><br><span class=\"line\"><span class=\"number\">153</span>                 best_params[<span class=\"string\">'bagging_freq'</span>] = bagging_freq</span><br><span class=\"line\"><span class=\"number\">154</span> </span><br><span class=\"line\"><span class=\"number\">155</span> params[<span class=\"string\">'feature_fraction'</span>] = best_params[<span class=\"string\">'feature_fraction'</span>]</span><br><span class=\"line\"><span class=\"number\">156</span> params[<span class=\"string\">'bagging_fraction'</span>] = best_params[<span class=\"string\">'bagging_fraction'</span>]</span><br><span class=\"line\"><span class=\"number\">157</span> params[<span class=\"string\">'bagging_freq'</span>] = best_params[<span class=\"string\">'bagging_freq'</span>]</span><br><span class=\"line\"><span class=\"number\">158</span> </span><br><span class=\"line\"><span class=\"number\">159</span> print(<span class=\"string\">\"调参4：降低过拟合\"</span>)</span><br><span class=\"line\"><span class=\"number\">160</span> <span class=\"keyword\">for</span> lambda_l1 <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">161</span>     <span class=\"keyword\">for</span> lambda_l2 <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">162</span>         <span class=\"keyword\">for</span> min_split_gain <span class=\"keyword\">in</span> [<span class=\"number\">0.0</span>,<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.7</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.0</span>]:</span><br><span class=\"line\"><span class=\"number\">163</span>             params[<span class=\"string\">'lambda_l1'</span>] = lambda_l1</span><br><span class=\"line\"><span class=\"number\">164</span>             params[<span class=\"string\">'lambda_l2'</span>] = lambda_l2</span><br><span class=\"line\"><span class=\"number\">165</span>             params[<span class=\"string\">'min_split_gain'</span>] = min_split_gain</span><br><span class=\"line\"><span class=\"number\">166</span> </span><br><span class=\"line\"><span class=\"number\">167</span>             cv_results = lgb.cv(</span><br><span class=\"line\"><span class=\"number\">168</span>                                 params,</span><br><span class=\"line\"><span class=\"number\">169</span>                                 lgb_train,</span><br><span class=\"line\"><span class=\"number\">170</span>                                 seed=<span class=\"number\">42</span>,</span><br><span class=\"line\"><span class=\"number\">171</span>                                 nfold=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">172</span>                                 metrics=[<span class=\"string\">'binary_error'</span>],</span><br><span class=\"line\"><span class=\"number\">173</span>                                 early_stopping_rounds=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"number\">174</span>                                 verbose_eval=<span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">175</span>                                 )</span><br><span class=\"line\"><span class=\"number\">176</span> </span><br><span class=\"line\"><span class=\"number\">177</span>             mean_merror = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).min()</span><br><span class=\"line\"><span class=\"number\">178</span>             boost_rounds = pd.Series(cv_results[<span class=\"string\">'binary_error-mean'</span>]).argmin()</span><br><span class=\"line\"><span class=\"number\">179</span> </span><br><span class=\"line\"><span class=\"number\">180</span>             <span class=\"keyword\">if</span> mean_merror &lt; min_merror:</span><br><span class=\"line\"><span class=\"number\">181</span>                 min_merror = mean_merror</span><br><span class=\"line\"><span class=\"number\">182</span>                 best_params[<span class=\"string\">'lambda_l1'</span>] = lambda_l1</span><br><span class=\"line\"><span class=\"number\">183</span>                 best_params[<span class=\"string\">'lambda_l2'</span>] = lambda_l2</span><br><span class=\"line\"><span class=\"number\">184</span>                 best_params[<span class=\"string\">'min_split_gain'</span>] = min_split_gain</span><br><span class=\"line\"><span class=\"number\">185</span> </span><br><span class=\"line\"><span class=\"number\">186</span> params[<span class=\"string\">'lambda_l1'</span>] = best_params[<span class=\"string\">'lambda_l1'</span>]</span><br><span class=\"line\"><span class=\"number\">187</span> params[<span class=\"string\">'lambda_l2'</span>] = best_params[<span class=\"string\">'lambda_l2'</span>]</span><br><span class=\"line\"><span class=\"number\">188</span> params[<span class=\"string\">'min_split_gain'</span>] = best_params[<span class=\"string\">'min_split_gain'</span>]</span><br><span class=\"line\"><span class=\"number\">189</span> </span><br><span class=\"line\"><span class=\"number\">190</span> </span><br><span class=\"line\"><span class=\"number\">191</span> print(best_params)</span><br><span class=\"line\"><span class=\"number\">192</span> </span><br><span class=\"line\"><span class=\"number\">193</span> <span class=\"comment\">### 训练</span></span><br><span class=\"line\"><span class=\"number\">194</span> params[<span class=\"string\">'learning_rate'</span>]=<span class=\"number\">0.01</span></span><br><span class=\"line\"><span class=\"number\">195</span> lgb.train(</span><br><span class=\"line\"><span class=\"number\">196</span>           params,                     <span class=\"comment\"># 参数字典</span></span><br><span class=\"line\"><span class=\"number\">197</span>           lgb_train,                  <span class=\"comment\"># 训练集</span></span><br><span class=\"line\"><span class=\"number\">198</span>           valid_sets=lgb_eval,        <span class=\"comment\"># 验证集</span></span><br><span class=\"line\"><span class=\"number\">199</span>           num_boost_round=<span class=\"number\">2000</span>,       <span class=\"comment\"># 迭代次数</span></span><br><span class=\"line\"><span class=\"number\">200</span>           early_stopping_rounds=<span class=\"number\">50</span>    <span class=\"comment\"># 早停次数</span></span><br><span class=\"line\"><span class=\"number\">201</span>           )</span><br><span class=\"line\"><span class=\"number\">202</span> </span><br><span class=\"line\"><span class=\"number\">203</span> <span class=\"comment\">### 线下预测</span></span><br><span class=\"line\"><span class=\"number\">204</span> <span class=\"keyword\">print</span> (<span class=\"string\">\"线下预测\"</span>)</span><br><span class=\"line\"><span class=\"number\">205</span> preds_offline = lgb.predict(offline_test_X, num_iteration=lgb.best_iteration) <span class=\"comment\"># 输出概率</span></span><br><span class=\"line\"><span class=\"number\">206</span> offline=offline_test[[<span class=\"string\">'instance_id'</span>,<span class=\"string\">'is_trade'</span>]]</span><br><span class=\"line\"><span class=\"number\">207</span> offline[<span class=\"string\">'preds'</span>]=preds_offline</span><br><span class=\"line\"><span class=\"number\">208</span> offline.is_trade = offline[<span class=\"string\">'is_trade'</span>].astype(np.float64)</span><br><span class=\"line\"><span class=\"number\">209</span> print(<span class=\"string\">'log_loss'</span>, metrics.log_loss(offline.is_trade, offline.preds))</span><br><span class=\"line\"><span class=\"number\">210</span> </span><br><span class=\"line\"><span class=\"number\">211</span> <span class=\"comment\">### 线上预测</span></span><br><span class=\"line\"><span class=\"number\">212</span> print(<span class=\"string\">\"线上预测\"</span>)</span><br><span class=\"line\"><span class=\"number\">213</span> preds_online =  lgb.predict(online_test_X, num_iteration=lgb.best_iteration)  <span class=\"comment\"># 输出概率</span></span><br><span class=\"line\"><span class=\"number\">214</span> online=online_test[[<span class=\"string\">'instance_id'</span>]]</span><br><span class=\"line\"><span class=\"number\">215</span> online[<span class=\"string\">'preds'</span>]=preds_online</span><br><span class=\"line\"><span class=\"number\">216</span> online.rename(columns=&#123;<span class=\"string\">'preds'</span>:<span class=\"string\">'predicted_score'</span>&#125;,inplace=<span class=\"keyword\">True</span>)           <span class=\"comment\"># 更改列名</span></span><br><span class=\"line\"><span class=\"number\">217</span> online.to_csv(<span class=\"string\">\"./data/20180405.txt\"</span>,index=<span class=\"keyword\">None</span>,sep=<span class=\"string\">' '</span>)                   <span class=\"comment\"># 保存结果</span></span><br><span class=\"line\"><span class=\"number\">218</span> </span><br><span class=\"line\"><span class=\"number\">219</span> <span class=\"comment\">### 保存模型</span></span><br><span class=\"line\"><span class=\"number\">220</span> <span class=\"keyword\">from</span> sklearn.externals <span class=\"keyword\">import</span> joblib</span><br><span class=\"line\"><span class=\"number\">221</span> joblib.dump(lgb,<span class=\"string\">'lgb.pkl'</span>)</span><br><span class=\"line\"><span class=\"number\">222</span> </span><br><span class=\"line\"><span class=\"number\">223</span> <span class=\"comment\">### 特征选择</span></span><br><span class=\"line\"><span class=\"number\">224</span> df = pd.DataFrame(X_train.columns.tolist(), columns=[<span class=\"string\">'feature'</span>])</span><br><span class=\"line\"><span class=\"number\">225</span> df[<span class=\"string\">'importance'</span>]=list(lgb.feature_importance())                           <span class=\"comment\"># 特征分数</span></span><br><span class=\"line\"><span class=\"number\">226</span> df = df.sort_values(by=<span class=\"string\">'importance'</span>,ascending=<span class=\"keyword\">False</span>)                      <span class=\"comment\"># 特征排序</span></span><br><span class=\"line\"><span class=\"number\">227</span> df.to_csv(<span class=\"string\">\"./data/feature_score_20180331.csv\"</span>,index=<span class=\"keyword\">None</span>,encoding=<span class=\"string\">'gbk'</span>)  <span class=\"comment\"># 保存分数</span></span><br></pre></td></tr></table></figure>"},{"title":"scala——actor，Akka","date":"2018-04-29T11:27:31.000Z","_content":"\n* Actor\n\n  Actor是消息并发模型\n\n  Scala中的Actor能够实现并行编程的强大功能，是基于事件的并发机制\n\n  Scala是运用消息（message）的发送和接收来实现多线程\n\n  使用scala能更容易的实现多线程应用的开发\n<!-- more-->\n\n* Java并发编程和Scala Actor编程的区别\n\n  Scala的Actor类似于Java的多线程编程，但是Scala的Actor提供的模型与多线程有所不同\n\n  Scala的Actor尽可能的避免锁和共享状态，从而避免多线程并发时出现资源争用的情况，进而提高多线程编程的性能，此外，Scala Actor还可以避免死锁等一系列传统多线程问题。\n\n  Java中多数使用的是可变状态的对象资源，对这些资源进行共享来实现多线程编程的话，控制好资源竞争与防止对象状态被意外修改是非常重要的，而对象的不变性也是难以保证的。\n\n  在scala中，可以通过复制不可变状态的资源（即对象）的一个副本，再基于Actor的消息发送、接收机制进行并行编程\n\n* Actor方法执行顺序：\n\n  1. 调用start()方法启动Actor\n  2. 执行act()方法\n  3. 向Actor发送消息\n\n* 发送消息的方式：\n\n  1. ！ 发送异步消息，没有返回值\n  2. ！? 发送同步消息，等待返回值\n  3. ！！ 发送异步消息，返回值是Future[Any]\n","source":"_posts/scala——actor，Akka.md","raw":"---\ntitle: scala——actor，Akka\ndate: 2018-04-29 19:27:31\ntags: scala\n---\n\n* Actor\n\n  Actor是消息并发模型\n\n  Scala中的Actor能够实现并行编程的强大功能，是基于事件的并发机制\n\n  Scala是运用消息（message）的发送和接收来实现多线程\n\n  使用scala能更容易的实现多线程应用的开发\n<!-- more-->\n\n* Java并发编程和Scala Actor编程的区别\n\n  Scala的Actor类似于Java的多线程编程，但是Scala的Actor提供的模型与多线程有所不同\n\n  Scala的Actor尽可能的避免锁和共享状态，从而避免多线程并发时出现资源争用的情况，进而提高多线程编程的性能，此外，Scala Actor还可以避免死锁等一系列传统多线程问题。\n\n  Java中多数使用的是可变状态的对象资源，对这些资源进行共享来实现多线程编程的话，控制好资源竞争与防止对象状态被意外修改是非常重要的，而对象的不变性也是难以保证的。\n\n  在scala中，可以通过复制不可变状态的资源（即对象）的一个副本，再基于Actor的消息发送、接收机制进行并行编程\n\n* Actor方法执行顺序：\n\n  1. 调用start()方法启动Actor\n  2. 执行act()方法\n  3. 向Actor发送消息\n\n* 发送消息的方式：\n\n  1. ！ 发送异步消息，没有返回值\n  2. ！? 发送同步消息，等待返回值\n  3. ！！ 发送异步消息，返回值是Future[Any]\n","slug":"scala——actor，Akka","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6s000xcf96ea3vd6nk","content":"<ul>\n<li><p>Actor</p>\n<p>Actor是消息并发模型</p>\n<p>Scala中的Actor能够实现并行编程的强大功能，是基于事件的并发机制</p>\n<p>Scala是运用消息（message）的发送和接收来实现多线程</p>\n<p>使用scala能更容易的实现多线程应用的开发</p>\n<a id=\"more\"></a>\n</li>\n<li><p>Java并发编程和Scala Actor编程的区别</p>\n<p>Scala的Actor类似于Java的多线程编程，但是Scala的Actor提供的模型与多线程有所不同</p>\n<p>Scala的Actor尽可能的避免锁和共享状态，从而避免多线程并发时出现资源争用的情况，进而提高多线程编程的性能，此外，Scala Actor还可以避免死锁等一系列传统多线程问题。</p>\n<p>Java中多数使用的是可变状态的对象资源，对这些资源进行共享来实现多线程编程的话，控制好资源竞争与防止对象状态被意外修改是非常重要的，而对象的不变性也是难以保证的。</p>\n<p>在scala中，可以通过复制不可变状态的资源（即对象）的一个副本，再基于Actor的消息发送、接收机制进行并行编程</p>\n</li>\n<li><p>Actor方法执行顺序：</p>\n<ol>\n<li>调用start()方法启动Actor</li>\n<li>执行act()方法</li>\n<li>向Actor发送消息</li>\n</ol>\n</li>\n<li><p>发送消息的方式：</p>\n<ol>\n<li>！ 发送异步消息，没有返回值</li>\n<li>！? 发送同步消息，等待返回值</li>\n<li>！！ 发送异步消息，返回值是Future[Any]</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>Actor</p>\n<p>Actor是消息并发模型</p>\n<p>Scala中的Actor能够实现并行编程的强大功能，是基于事件的并发机制</p>\n<p>Scala是运用消息（message）的发送和接收来实现多线程</p>\n<p>使用scala能更容易的实现多线程应用的开发</p>","more":"</li>\n<li><p>Java并发编程和Scala Actor编程的区别</p>\n<p>Scala的Actor类似于Java的多线程编程，但是Scala的Actor提供的模型与多线程有所不同</p>\n<p>Scala的Actor尽可能的避免锁和共享状态，从而避免多线程并发时出现资源争用的情况，进而提高多线程编程的性能，此外，Scala Actor还可以避免死锁等一系列传统多线程问题。</p>\n<p>Java中多数使用的是可变状态的对象资源，对这些资源进行共享来实现多线程编程的话，控制好资源竞争与防止对象状态被意外修改是非常重要的，而对象的不变性也是难以保证的。</p>\n<p>在scala中，可以通过复制不可变状态的资源（即对象）的一个副本，再基于Actor的消息发送、接收机制进行并行编程</p>\n</li>\n<li><p>Actor方法执行顺序：</p>\n<ol>\n<li>调用start()方法启动Actor</li>\n<li>执行act()方法</li>\n<li>向Actor发送消息</li>\n</ol>\n</li>\n<li><p>发送消息的方式：</p>\n<ol>\n<li>！ 发送异步消息，没有返回值</li>\n<li>！? 发送同步消息，等待返回值</li>\n<li>！！ 发送异步消息，返回值是Future[Any]</li>\n</ol>\n</li>\n</ul>"},{"title":"scala面向对象和模式匹配","date":"2018-04-25T14:08:26.000Z","_content":"\n**1.创建类、属性**\n\n* scala声明类时不需要加public关键字，默认为public，一个类文件可以声明多个类，用object声明的与class同名的类为class的伴生类\n\n* 属性不需要创建getter和setter，val默认只有get方法，因为他不可变;var有get 和 set 方法\n\n* 用private修饰的属性，该属性属于私有变量，只有本类和伴生对象中才能访问\n\n* 用private[this] 修饰的属性属于对象私有变量，只有本类可访问，伴生对象也无法访问\n\n  <!-- more-->\n\n```scala\nclass Person {//声明类\n  val id: String = \"100\"\n  var name: String = _\n  private var age: Int = _\n  private[this] val gender = \"male\"\n}\n\nobject Person {//伴生类\n  def main(args: Array[String]): Unit = {\n    val p = new Person()\n    //    println(p.id = \"123\")//val不可修改\n    p.name = \"ningning\"\n    p.age = 26\n    println(p.name)\n    println(p.age)\n    println(p.gender)//无法访问\n  }\n}\n\nobject Test {\n  def main(args: Array[String]): Unit = {\n    val p = new Person()\n    println(p.age) // 无法访问\n    println(p.name)\n  }\n}\n```\n\n**2.构造器和辅助构造器**\n\n* 主构造器：在类名后给一个参数列表，相当于构造器\n* 主构造器中的属性变量如果没有val或var修饰，默认是val类型，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，这样在创建对象传参的时候可以不给该值传参\n* 辅助构造器：在class作用范围内定义：`def this(主构造器参数列表，其他参数列表)`，类似于java当中的不同的构造器拥有不同的参数列表，但是都要实现默认构造器\n* 在辅助构造器第一行必须调用主构造器\n* 返回方法：不用`retrun`,最后一句代码的值作为返回值\n\n```scala\n/***\n  * 主构造器参数列表放到类名后面，和类名放在一起\n  * @param name\n  * @param age\n  * @param faceValue\n  */\nclass StructDemo(val name: String, var age:Int, faceValue: Int = 90) { /\n  var gender: String = _//此处定义为var，方便在后面的构造器变值\n  // /faceValue没有val或var修饰，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，在创建对象的时候可以不指定faceValue的值\n  def getFaceValue() :Int = {\n//    faceValue = 100//此时值不可更改，默认是val类型\n    faceValue\n  }\n\n  def this(name: String, age:Int, faceValue: Int, gender:String){//辅助构造器\n        this(name, age, faceValue)//第一行必须调用主构造器\n        this.gender = gender\n  }\n}\n\n\n\nobject StructDemo {\n  def main(args: Array[String]): Unit = {\n//    val s = new StructDemo(\"ningning\", 23)\n     val s = new StructDemo(\"ningning\",26,98,\"女\")\n    s.age = 29\n    println(s.age)\n    println(s.name)\n    println(s.getFaceValue())\n    println(s.gender)\n  }\n}\n```\n\n\n\n**3.单例对象**\n\n* scala中没有static修饰符，没有静态方法或静态字段，但可以用object关键字加类名语法结构实现同样的功能\n\n  > 1.工具类，存放常量和个工具方法\n  >\n  > 2.实现单例模式\n\n```scala\nobject SingletonDemo {\n  def main(args: Array[String]): Unit = {\n    val factory = SessionFactory\n    println(factory.getSessions)\n    println(factory.getSessions.size)\n    println(factory.getSessions(0))\n    println(factory.removeSession)\n  }\n}\n\nobject SessionFactory {\n  /**\n    * 相当于java中的静态块\n    */\n  println(\"SessionFactory executed\")\n  var i = 5\n  private val session = new ArrayBuffer[Session]()\n  while (i > 0) {\n    session += new Session\n    i -= 1\n  }\n\n  def getSessions = session\n\n  def removeSession: Unit = {\n    val s = session(0)\n    session.remove(0)\n    println(\"session removed:\" + s)\n  }\n}\n\nclass Session {\n\n}\n```\n\n**4.伴生对象**\n\n* 名字与类名相同，且用object修饰的对象叫伴生对象\n* 类和其伴生对象可以相互访问私有的方法和属性\n* 和单例对象的关系：单例对象不一定是伴生对象，但是伴生对象一定是单例对象\n* 互相访问的作用：\n\n```scala\nclass Dog {\n  private var name = \"erha\"\n  def printName() : Unit = {\n    //访问伴生对象的私有属性\n    println(Dog.CONSTANT + name)\n  }\n}\n\n/*\n伴生对象\n */\nobject Dog {\n  private val CONSTANT = \"BARK! BARK!\"\n\n  def main(args: Array[String]): Unit = {\n    val p = new Dog\n    //访问类中的私有字段\n    println(p.name)\n    p.name = \"dahuang\"\n    p.printName()\n  }\n}\n```\n\n\n\n**5.apply和unapply方法**\n\n* 一般被声明在伴生对象中\n* apply方法一般称为注入方法，可以用来初始化对象\n* apply方法的参数列表不需要和构造器参数列表统一\n* unapply方法常称为提取方法，可以用来提取固定对象\n* unapply方法会返回一个序列（Option）,内部产生一个Some对象来存放一些值\n* apply和unapply方法会被隐式调用\n\n```scala\nclass applyDemo(val name: String, var age: Int, var faceValue: Int) {\n\n}\n\nobject applyDemo {\n  def apply(name: String, age: Int, gender: Int, faceValue: Int): applyDemo =\n    new applyDemo(name, age, faceValue)\n\n  def unapply(arg: applyDemo): Option[(String, Int, Int)] = {\n    if (arg == null) {\n      None\n    } else {\n      Some(arg.name, arg.age, arg.faceValue)\n    }\n  }\n}\n\n/**\n  * 调用方式\n  */\nobject Test2 {\n  def main(args: Array[String]): Unit = {\n    val res = applyDemo(\"ningning\", 23, 1, 86) //不用new，用apply方法创建了一个对象\n    res match {\n      //模式匹配，调用unapply方法\n      case applyDemo(\"ningning\", age, faceValue) => println(s\"age: $age\") //在字符串中输出值的方式\n      case _ => println(\"no match\")\n    }\n\n  }\n}\n```\n\n\n\n**6.private关键字**\n\n* 变量前加private，该变量为私有字段\n* 变量前加private[this]，表示*对象私有字段*，只能在本类访问，伴生对象也不能访问\n* 方法前加private，表示私有方法\n* 类名前加private[包名]，表示该类只有包访问权限\n* 构造器参数列表前加private是指伴生对象权限，只有伴生对象才能访问\n\n```scala\n//包访问权限\nprivate[ch02] class PrivateDemo private(val gender: Int, val faceValue: Int) {\n  //私有字段\n  private val name = \"jingjing\"\n  //对象私有字段\n  private[this] var age = 24;\n\n  //私有方法\n  private def sayHello(): Unit = {\n    println(name + \"say hello\")\n  }\n}\n\nobject PrivateDemo {\n  def main(args: Array[String]): Unit = {\n    val privateDemo = new PrivateDemo(1, 88)\n    privateDemo.sayHello()\n  }\n}\n\nobject Test3 {\n  def main(args: Array[String]): Unit = {\n    val privateDemo = new PrivateDemo(0, 90)\n    //    privateDemo.sayHello() 访问不到\n    print(privateDemo.faceValue) //编译不能通过\n  }\n}\n```\n\n\n\n**7.特质、重写、抽象类和重写**\n\n* 特质：类似java中的接口，用`trait 类名`声明\n* 抽象类： `abstract 类名`声明，抽象类没有实现的方法，继承它的类一定要实现。\n* 继承：extends关键字\n* 实现接口：with关键字，与java中的implements类似，实现特质中没有实现的方法可以不用override\n* 重现方法或字段：override\n\n```scala\nobject ClassDEmo {\n  def main(args: Array[String]): Unit = {\n    val human = new Human\n    println(human.name)\n    println(human.fight)\n    println(human.distance)\n  }\n}\n\ntrait Flyable {\n  //声明一个没有值的字段\n  val distance: Int = 1000\n\n  //声明一个没有实现的方法\n  def fight: String\n\n  //声明一个实现的方法\n  def fly: Unit = {\n    print(\"I can fly\")\n  }\n}\n\n/**\n  * 抽象类\n  */\nabstract class Animal {\n  //声明一个没有值的字段\n  val name: String\n\n  //声明一个没有实现的方法\n  def run(): String\n\n  //声明一个实现的方法\n  def climb: String = {\n    \"In can climb\"\n  }\n}\n\nclass Human extends Animal with Flyable {\n  override val name: String = \"zhangsan\"\n\n  //重写抽象类没有实现的方法\n  override def run(): String = \"I can run\"\n\n  override val distance: Int = 900\n\n  //实现特质中没有实现的方法\n  def fight: String = \"With rob\"\n\n  //实现特质中实现了的方法\n  override def fly: Unit = println(\"override fly\")\n}\n```\n\n\n\n**8.模式匹配**\n\n* 类似java中的switch...case,但是功能更强大\n* case_的作用队标java中的default\n*  \n\n```scala\n/**\n  * 匹配字符串\n  */\nobject MatchStr {\n  def main(args: Array[String]): Unit = {\n    val arr = Array(\"java\",\"scala\",\"python\",\"c++\")\n    val name = arr(Random.nextInt(arr.length))\n    println(name)\n    name match  {\n      case \"java\" => print(\"java\")\n      case \"scala\" => print(\"scala\")\n      case \"python\" => print(\"python\")\n      case \"c++\" => print(\"c++\")\n      case \"_\" => print(\"nothing match\")\n    }\n  }\n}\n```\n\n```scala\n/**\n  * 匹配类型\n  */\nobject MatchType {\n  def main(args: Array[String]): Unit = {\n    val arr = Array(\"abcds\", 100, 3.14, true)\n    val element = arr(Random.nextInt(arr.length))\n    print(element)\n    element match {\n      case str:String => println(s\"a matches String:$str\")\n      case int: Int=> println(s\"a matches String:$int\")\n      case bool:Boolean => println(s\"a matches String:$bool\")\n      case matchTest:MatchTest => println(s\"a matches MatchTest:$matchTest\")\n      case _: Any =>  println(\"not match\")\n    }\n  }\n}\n```\n\n```scala\n/**\n  * 样例类匹配\n  */\nobject CaseClassDemo {\n  def main(args: Array[String]): Unit = {\n    val arr = Array(CheckTimeOutTask, SubmiTask(\"1000\",\"task-01\"), HeartBeat(3000))\n\n    arr(Random.nextInt(arr.length))  match {\n      case CheckTimeOutTask => println(\"Check\")\n      case SubmiTask(port,taskName) => println(\"submit\")\n      case HeartBeat(time) => println(\"heart\")\n    }\n  }\n}\n\ncase class HeartBeat(time: Long)\ncase class SubmiTask(id:String, taskName: String)\ncase object CheckTimeOutTask\n```\n\n```scala\n\n/**\n* 偏函数模式匹配\n**/\nobject PartialFunctionDemo {\n  def m1: PartialFunction[String, Int] = {\n    //String是输入类型，Int是输出类型\n    case \"one\" => {\n      println(\"case 1\")\n      1\n    }\n    case \"two\" => {\n      println(\"case2\")\n      2\n    }\n  }\n\n  def m2(num: String): Int = num match {\n    case \"one\" => 1\n    case \"two\" => 2\n    case _ => 0\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(m1(\"one\"))\n    println(m2(\"three\"))\n  }\n}\n```\n\n","source":"_posts/scala面向对象和模式匹配.md","raw":"---\ntitle: scala面向对象和模式匹配\ndate: 2018-04-25 22:08:26\ntags: scala\n---\n\n**1.创建类、属性**\n\n* scala声明类时不需要加public关键字，默认为public，一个类文件可以声明多个类，用object声明的与class同名的类为class的伴生类\n\n* 属性不需要创建getter和setter，val默认只有get方法，因为他不可变;var有get 和 set 方法\n\n* 用private修饰的属性，该属性属于私有变量，只有本类和伴生对象中才能访问\n\n* 用private[this] 修饰的属性属于对象私有变量，只有本类可访问，伴生对象也无法访问\n\n  <!-- more-->\n\n```scala\nclass Person {//声明类\n  val id: String = \"100\"\n  var name: String = _\n  private var age: Int = _\n  private[this] val gender = \"male\"\n}\n\nobject Person {//伴生类\n  def main(args: Array[String]): Unit = {\n    val p = new Person()\n    //    println(p.id = \"123\")//val不可修改\n    p.name = \"ningning\"\n    p.age = 26\n    println(p.name)\n    println(p.age)\n    println(p.gender)//无法访问\n  }\n}\n\nobject Test {\n  def main(args: Array[String]): Unit = {\n    val p = new Person()\n    println(p.age) // 无法访问\n    println(p.name)\n  }\n}\n```\n\n**2.构造器和辅助构造器**\n\n* 主构造器：在类名后给一个参数列表，相当于构造器\n* 主构造器中的属性变量如果没有val或var修饰，默认是val类型，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，这样在创建对象传参的时候可以不给该值传参\n* 辅助构造器：在class作用范围内定义：`def this(主构造器参数列表，其他参数列表)`，类似于java当中的不同的构造器拥有不同的参数列表，但是都要实现默认构造器\n* 在辅助构造器第一行必须调用主构造器\n* 返回方法：不用`retrun`,最后一句代码的值作为返回值\n\n```scala\n/***\n  * 主构造器参数列表放到类名后面，和类名放在一起\n  * @param name\n  * @param age\n  * @param faceValue\n  */\nclass StructDemo(val name: String, var age:Int, faceValue: Int = 90) { /\n  var gender: String = _//此处定义为var，方便在后面的构造器变值\n  // /faceValue没有val或var修饰，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，在创建对象的时候可以不指定faceValue的值\n  def getFaceValue() :Int = {\n//    faceValue = 100//此时值不可更改，默认是val类型\n    faceValue\n  }\n\n  def this(name: String, age:Int, faceValue: Int, gender:String){//辅助构造器\n        this(name, age, faceValue)//第一行必须调用主构造器\n        this.gender = gender\n  }\n}\n\n\n\nobject StructDemo {\n  def main(args: Array[String]): Unit = {\n//    val s = new StructDemo(\"ningning\", 23)\n     val s = new StructDemo(\"ningning\",26,98,\"女\")\n    s.age = 29\n    println(s.age)\n    println(s.name)\n    println(s.getFaceValue())\n    println(s.gender)\n  }\n}\n```\n\n\n\n**3.单例对象**\n\n* scala中没有static修饰符，没有静态方法或静态字段，但可以用object关键字加类名语法结构实现同样的功能\n\n  > 1.工具类，存放常量和个工具方法\n  >\n  > 2.实现单例模式\n\n```scala\nobject SingletonDemo {\n  def main(args: Array[String]): Unit = {\n    val factory = SessionFactory\n    println(factory.getSessions)\n    println(factory.getSessions.size)\n    println(factory.getSessions(0))\n    println(factory.removeSession)\n  }\n}\n\nobject SessionFactory {\n  /**\n    * 相当于java中的静态块\n    */\n  println(\"SessionFactory executed\")\n  var i = 5\n  private val session = new ArrayBuffer[Session]()\n  while (i > 0) {\n    session += new Session\n    i -= 1\n  }\n\n  def getSessions = session\n\n  def removeSession: Unit = {\n    val s = session(0)\n    session.remove(0)\n    println(\"session removed:\" + s)\n  }\n}\n\nclass Session {\n\n}\n```\n\n**4.伴生对象**\n\n* 名字与类名相同，且用object修饰的对象叫伴生对象\n* 类和其伴生对象可以相互访问私有的方法和属性\n* 和单例对象的关系：单例对象不一定是伴生对象，但是伴生对象一定是单例对象\n* 互相访问的作用：\n\n```scala\nclass Dog {\n  private var name = \"erha\"\n  def printName() : Unit = {\n    //访问伴生对象的私有属性\n    println(Dog.CONSTANT + name)\n  }\n}\n\n/*\n伴生对象\n */\nobject Dog {\n  private val CONSTANT = \"BARK! BARK!\"\n\n  def main(args: Array[String]): Unit = {\n    val p = new Dog\n    //访问类中的私有字段\n    println(p.name)\n    p.name = \"dahuang\"\n    p.printName()\n  }\n}\n```\n\n\n\n**5.apply和unapply方法**\n\n* 一般被声明在伴生对象中\n* apply方法一般称为注入方法，可以用来初始化对象\n* apply方法的参数列表不需要和构造器参数列表统一\n* unapply方法常称为提取方法，可以用来提取固定对象\n* unapply方法会返回一个序列（Option）,内部产生一个Some对象来存放一些值\n* apply和unapply方法会被隐式调用\n\n```scala\nclass applyDemo(val name: String, var age: Int, var faceValue: Int) {\n\n}\n\nobject applyDemo {\n  def apply(name: String, age: Int, gender: Int, faceValue: Int): applyDemo =\n    new applyDemo(name, age, faceValue)\n\n  def unapply(arg: applyDemo): Option[(String, Int, Int)] = {\n    if (arg == null) {\n      None\n    } else {\n      Some(arg.name, arg.age, arg.faceValue)\n    }\n  }\n}\n\n/**\n  * 调用方式\n  */\nobject Test2 {\n  def main(args: Array[String]): Unit = {\n    val res = applyDemo(\"ningning\", 23, 1, 86) //不用new，用apply方法创建了一个对象\n    res match {\n      //模式匹配，调用unapply方法\n      case applyDemo(\"ningning\", age, faceValue) => println(s\"age: $age\") //在字符串中输出值的方式\n      case _ => println(\"no match\")\n    }\n\n  }\n}\n```\n\n\n\n**6.private关键字**\n\n* 变量前加private，该变量为私有字段\n* 变量前加private[this]，表示*对象私有字段*，只能在本类访问，伴生对象也不能访问\n* 方法前加private，表示私有方法\n* 类名前加private[包名]，表示该类只有包访问权限\n* 构造器参数列表前加private是指伴生对象权限，只有伴生对象才能访问\n\n```scala\n//包访问权限\nprivate[ch02] class PrivateDemo private(val gender: Int, val faceValue: Int) {\n  //私有字段\n  private val name = \"jingjing\"\n  //对象私有字段\n  private[this] var age = 24;\n\n  //私有方法\n  private def sayHello(): Unit = {\n    println(name + \"say hello\")\n  }\n}\n\nobject PrivateDemo {\n  def main(args: Array[String]): Unit = {\n    val privateDemo = new PrivateDemo(1, 88)\n    privateDemo.sayHello()\n  }\n}\n\nobject Test3 {\n  def main(args: Array[String]): Unit = {\n    val privateDemo = new PrivateDemo(0, 90)\n    //    privateDemo.sayHello() 访问不到\n    print(privateDemo.faceValue) //编译不能通过\n  }\n}\n```\n\n\n\n**7.特质、重写、抽象类和重写**\n\n* 特质：类似java中的接口，用`trait 类名`声明\n* 抽象类： `abstract 类名`声明，抽象类没有实现的方法，继承它的类一定要实现。\n* 继承：extends关键字\n* 实现接口：with关键字，与java中的implements类似，实现特质中没有实现的方法可以不用override\n* 重现方法或字段：override\n\n```scala\nobject ClassDEmo {\n  def main(args: Array[String]): Unit = {\n    val human = new Human\n    println(human.name)\n    println(human.fight)\n    println(human.distance)\n  }\n}\n\ntrait Flyable {\n  //声明一个没有值的字段\n  val distance: Int = 1000\n\n  //声明一个没有实现的方法\n  def fight: String\n\n  //声明一个实现的方法\n  def fly: Unit = {\n    print(\"I can fly\")\n  }\n}\n\n/**\n  * 抽象类\n  */\nabstract class Animal {\n  //声明一个没有值的字段\n  val name: String\n\n  //声明一个没有实现的方法\n  def run(): String\n\n  //声明一个实现的方法\n  def climb: String = {\n    \"In can climb\"\n  }\n}\n\nclass Human extends Animal with Flyable {\n  override val name: String = \"zhangsan\"\n\n  //重写抽象类没有实现的方法\n  override def run(): String = \"I can run\"\n\n  override val distance: Int = 900\n\n  //实现特质中没有实现的方法\n  def fight: String = \"With rob\"\n\n  //实现特质中实现了的方法\n  override def fly: Unit = println(\"override fly\")\n}\n```\n\n\n\n**8.模式匹配**\n\n* 类似java中的switch...case,但是功能更强大\n* case_的作用队标java中的default\n*  \n\n```scala\n/**\n  * 匹配字符串\n  */\nobject MatchStr {\n  def main(args: Array[String]): Unit = {\n    val arr = Array(\"java\",\"scala\",\"python\",\"c++\")\n    val name = arr(Random.nextInt(arr.length))\n    println(name)\n    name match  {\n      case \"java\" => print(\"java\")\n      case \"scala\" => print(\"scala\")\n      case \"python\" => print(\"python\")\n      case \"c++\" => print(\"c++\")\n      case \"_\" => print(\"nothing match\")\n    }\n  }\n}\n```\n\n```scala\n/**\n  * 匹配类型\n  */\nobject MatchType {\n  def main(args: Array[String]): Unit = {\n    val arr = Array(\"abcds\", 100, 3.14, true)\n    val element = arr(Random.nextInt(arr.length))\n    print(element)\n    element match {\n      case str:String => println(s\"a matches String:$str\")\n      case int: Int=> println(s\"a matches String:$int\")\n      case bool:Boolean => println(s\"a matches String:$bool\")\n      case matchTest:MatchTest => println(s\"a matches MatchTest:$matchTest\")\n      case _: Any =>  println(\"not match\")\n    }\n  }\n}\n```\n\n```scala\n/**\n  * 样例类匹配\n  */\nobject CaseClassDemo {\n  def main(args: Array[String]): Unit = {\n    val arr = Array(CheckTimeOutTask, SubmiTask(\"1000\",\"task-01\"), HeartBeat(3000))\n\n    arr(Random.nextInt(arr.length))  match {\n      case CheckTimeOutTask => println(\"Check\")\n      case SubmiTask(port,taskName) => println(\"submit\")\n      case HeartBeat(time) => println(\"heart\")\n    }\n  }\n}\n\ncase class HeartBeat(time: Long)\ncase class SubmiTask(id:String, taskName: String)\ncase object CheckTimeOutTask\n```\n\n```scala\n\n/**\n* 偏函数模式匹配\n**/\nobject PartialFunctionDemo {\n  def m1: PartialFunction[String, Int] = {\n    //String是输入类型，Int是输出类型\n    case \"one\" => {\n      println(\"case 1\")\n      1\n    }\n    case \"two\" => {\n      println(\"case2\")\n      2\n    }\n  }\n\n  def m2(num: String): Int = num match {\n    case \"one\" => 1\n    case \"two\" => 2\n    case _ => 0\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(m1(\"one\"))\n    println(m2(\"three\"))\n  }\n}\n```\n\n","slug":"scala面向对象和模式匹配","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6t0010cf96eaj78hef","content":"<p><strong>1.创建类、属性</strong></p>\n<ul>\n<li><p>scala声明类时不需要加public关键字，默认为public，一个类文件可以声明多个类，用object声明的与class同名的类为class的伴生类</p>\n</li>\n<li><p>属性不需要创建getter和setter，val默认只有get方法，因为他不可变;var有get 和 set 方法</p>\n</li>\n<li><p>用private修饰的属性，该属性属于私有变量，只有本类和伴生对象中才能访问</p>\n</li>\n<li><p>用private[this] 修饰的属性属于对象私有变量，只有本类可访问，伴生对象也无法访问</p>\n<a id=\"more\"></a>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;<span class=\"comment\">//声明类</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> id: <span class=\"type\">String</span> = <span class=\"string\">\"100\"</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = _</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span> = _</span><br><span class=\"line\">  <span class=\"keyword\">private</span>[<span class=\"keyword\">this</span>] <span class=\"keyword\">val</span> gender = <span class=\"string\">\"male\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Person</span> </span>&#123;<span class=\"comment\">//伴生类</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">    <span class=\"comment\">//    println(p.id = \"123\")//val不可修改</span></span><br><span class=\"line\">    p.name = <span class=\"string\">\"ningning\"</span></span><br><span class=\"line\">    p.age = <span class=\"number\">26</span></span><br><span class=\"line\">    println(p.name)</span><br><span class=\"line\">    println(p.age)</span><br><span class=\"line\">    println(p.gender)<span class=\"comment\">//无法访问</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">    println(p.age) <span class=\"comment\">// 无法访问</span></span><br><span class=\"line\">    println(p.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.构造器和辅助构造器</strong></p>\n<ul>\n<li>主构造器：在类名后给一个参数列表，相当于构造器</li>\n<li>主构造器中的属性变量如果没有val或var修饰，默认是val类型，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，这样在创建对象传参的时候可以不给该值传参</li>\n<li>辅助构造器：在class作用范围内定义：<code>def this(主构造器参数列表，其他参数列表)</code>，类似于java当中的不同的构造器拥有不同的参数列表，但是都要实现默认构造器</li>\n<li>在辅助构造器第一行必须调用主构造器</li>\n<li>返回方法：不用<code>retrun</code>,最后一句代码的值作为返回值</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">  * 主构造器参数列表放到类名后面，和类名放在一起</span></span><br><span class=\"line\"><span class=\"comment\">  * @param name</span></span><br><span class=\"line\"><span class=\"comment\">  * @param age</span></span><br><span class=\"line\"><span class=\"comment\">  * @param faceValue</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StructDemo</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, var age:<span class=\"type\">Int</span>, faceValue: <span class=\"type\">Int</span> = 90</span>) </span>&#123; /</span><br><span class=\"line\">  <span class=\"keyword\">var</span> gender: <span class=\"type\">String</span> = _<span class=\"comment\">//此处定义为var，方便在后面的构造器变值</span></span><br><span class=\"line\">  <span class=\"comment\">// /faceValue没有val或var修饰，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，在创建对象的时候可以不指定faceValue的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFaceValue</span></span>() :<span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//    faceValue = 100//此时值不可更改，默认是val类型</span></span><br><span class=\"line\">    faceValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(name: <span class=\"type\">String</span>, age:<span class=\"type\">Int</span>, faceValue: <span class=\"type\">Int</span>, gender:<span class=\"type\">String</span>)&#123;<span class=\"comment\">//辅助构造器</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>(name, age, faceValue)<span class=\"comment\">//第一行必须调用主构造器</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.gender = gender</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">StructDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//    val s = new StructDemo(\"ningning\", 23)</span></span><br><span class=\"line\">     <span class=\"keyword\">val</span> s = <span class=\"keyword\">new</span> <span class=\"type\">StructDemo</span>(<span class=\"string\">\"ningning\"</span>,<span class=\"number\">26</span>,<span class=\"number\">98</span>,<span class=\"string\">\"女\"</span>)</span><br><span class=\"line\">    s.age = <span class=\"number\">29</span></span><br><span class=\"line\">    println(s.age)</span><br><span class=\"line\">    println(s.name)</span><br><span class=\"line\">    println(s.getFaceValue())</span><br><span class=\"line\">    println(s.gender)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3.单例对象</strong></p>\n<ul>\n<li><p>scala中没有static修饰符，没有静态方法或静态字段，但可以用object关键字加类名语法结构实现同样的功能</p>\n<blockquote>\n<p>1.工具类，存放常量和个工具方法</p>\n<p>2.实现单例模式</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SingletonDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> factory = <span class=\"type\">SessionFactory</span></span><br><span class=\"line\">    println(factory.getSessions)</span><br><span class=\"line\">    println(factory.getSessions.size)</span><br><span class=\"line\">    println(factory.getSessions(<span class=\"number\">0</span>))</span><br><span class=\"line\">    println(factory.removeSession)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SessionFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 相当于java中的静态块</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">  println(<span class=\"string\">\"SessionFactory executed\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> session = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Session</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    session += <span class=\"keyword\">new</span> <span class=\"type\">Session</span></span><br><span class=\"line\">    i -= <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSessions</span> </span>= session</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeSession</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> s = session(<span class=\"number\">0</span>)</span><br><span class=\"line\">    session.remove(<span class=\"number\">0</span>)</span><br><span class=\"line\">    println(<span class=\"string\">\"session removed:\"</span> + s)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Session</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>4.伴生对象</strong></p>\n<ul>\n<li>名字与类名相同，且用object修饰的对象叫伴生对象</li>\n<li>类和其伴生对象可以相互访问私有的方法和属性</li>\n<li>和单例对象的关系：单例对象不一定是伴生对象，但是伴生对象一定是单例对象</li>\n<li>互相访问的作用：</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> name = <span class=\"string\">\"erha\"</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printName</span></span>() : <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//访问伴生对象的私有属性</span></span><br><span class=\"line\">    println(<span class=\"type\">Dog</span>.<span class=\"type\">CONSTANT</span> + name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">伴生对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> <span class=\"type\">CONSTANT</span> = <span class=\"string\">\"BARK! BARK!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p = <span class=\"keyword\">new</span> <span class=\"type\">Dog</span></span><br><span class=\"line\">    <span class=\"comment\">//访问类中的私有字段</span></span><br><span class=\"line\">    println(p.name)</span><br><span class=\"line\">    p.name = <span class=\"string\">\"dahuang\"</span></span><br><span class=\"line\">    p.printName()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>5.apply和unapply方法</strong></p>\n<ul>\n<li>一般被声明在伴生对象中</li>\n<li>apply方法一般称为注入方法，可以用来初始化对象</li>\n<li>apply方法的参数列表不需要和构造器参数列表统一</li>\n<li>unapply方法常称为提取方法，可以用来提取固定对象</li>\n<li>unapply方法会返回一个序列（Option）,内部产生一个Some对象来存放一些值</li>\n<li>apply和unapply方法会被隐式调用</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">applyDemo</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, var age: <span class=\"type\">Int</span>, var faceValue: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">applyDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(name: <span class=\"type\">String</span>, age: <span class=\"type\">Int</span>, gender: <span class=\"type\">Int</span>, faceValue: <span class=\"type\">Int</span>): applyDemo =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> applyDemo(name, age, faceValue)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(arg: applyDemo): <span class=\"type\">Option</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)] = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"type\">None</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Some</span>(arg.name, arg.age, arg.faceValue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 调用方式</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = applyDemo(<span class=\"string\">\"ningning\"</span>, <span class=\"number\">23</span>, <span class=\"number\">1</span>, <span class=\"number\">86</span>) <span class=\"comment\">//不用new，用apply方法创建了一个对象</span></span><br><span class=\"line\">    res <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//模式匹配，调用unapply方法</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> applyDemo(<span class=\"string\">\"ningning\"</span>, age, faceValue) =&gt; println(<span class=\"string\">s\"age: <span class=\"subst\">$age</span>\"</span>) <span class=\"comment\">//在字符串中输出值的方式</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> _ =&gt; println(<span class=\"string\">\"no match\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>6.private关键字</strong></p>\n<ul>\n<li>变量前加private，该变量为私有字段</li>\n<li>变量前加private[this]，表示<em>对象私有字段</em>，只能在本类访问，伴生对象也不能访问</li>\n<li>方法前加private，表示私有方法</li>\n<li>类名前加private[包名]，表示该类只有包访问权限</li>\n<li>构造器参数列表前加private是指伴生对象权限，只有伴生对象才能访问</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包访问权限</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>[ch02] <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrivateDemo</span> <span class=\"title\">private</span>(<span class=\"params\">val gender: <span class=\"type\">Int</span>, val faceValue: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//私有字段</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> name = <span class=\"string\">\"jingjing\"</span></span><br><span class=\"line\">  <span class=\"comment\">//对象私有字段</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>[<span class=\"keyword\">this</span>] <span class=\"keyword\">var</span> age = <span class=\"number\">24</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//私有方法</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sayHello</span></span>(): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(name + <span class=\"string\">\"say hello\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">PrivateDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> privateDemo = <span class=\"keyword\">new</span> <span class=\"type\">PrivateDemo</span>(<span class=\"number\">1</span>, <span class=\"number\">88</span>)</span><br><span class=\"line\">    privateDemo.sayHello()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> privateDemo = <span class=\"keyword\">new</span> <span class=\"type\">PrivateDemo</span>(<span class=\"number\">0</span>, <span class=\"number\">90</span>)</span><br><span class=\"line\">    <span class=\"comment\">//    privateDemo.sayHello() 访问不到</span></span><br><span class=\"line\">    print(privateDemo.faceValue) <span class=\"comment\">//编译不能通过</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>7.特质、重写、抽象类和重写</strong></p>\n<ul>\n<li>特质：类似java中的接口，用<code>trait 类名</code>声明</li>\n<li>抽象类： <code>abstract 类名</code>声明，抽象类没有实现的方法，继承它的类一定要实现。</li>\n<li>继承：extends关键字</li>\n<li>实现接口：with关键字，与java中的implements类似，实现特质中没有实现的方法可以不用override</li>\n<li>重现方法或字段：override</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ClassDEmo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> human = <span class=\"keyword\">new</span> <span class=\"type\">Human</span></span><br><span class=\"line\">    println(human.name)</span><br><span class=\"line\">    println(human.fight)</span><br><span class=\"line\">    println(human.distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Flyable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有值的字段</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> distance: <span class=\"type\">Int</span> = <span class=\"number\">1000</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fight</span></span>: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fly</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    print(<span class=\"string\">\"I can fly\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 抽象类</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有值的字段</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> name: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span></span>(): <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climb</span></span>: <span class=\"type\">String</span> = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"In can climb\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"keyword\">with</span> <span class=\"title\">Flyable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> name: <span class=\"type\">String</span> = <span class=\"string\">\"zhangsan\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//重写抽象类没有实现的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span></span>(): <span class=\"type\">String</span> = <span class=\"string\">\"I can run\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> distance: <span class=\"type\">Int</span> = <span class=\"number\">900</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//实现特质中没有实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fight</span></span>: <span class=\"type\">String</span> = <span class=\"string\">\"With rob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//实现特质中实现了的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fly</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">\"override fly\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>8.模式匹配</strong></p>\n<ul>\n<li>类似java中的switch…case,但是功能更强大</li>\n<li>case_的作用队标java中的default</li>\n<li></li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 匹配字符串</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">MatchStr</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"string\">\"java\"</span>,<span class=\"string\">\"scala\"</span>,<span class=\"string\">\"python\"</span>,<span class=\"string\">\"c++\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = arr(<span class=\"type\">Random</span>.nextInt(arr.length))</span><br><span class=\"line\">    println(name)</span><br><span class=\"line\">    name <span class=\"keyword\">match</span>  &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"java\"</span> =&gt; print(<span class=\"string\">\"java\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"scala\"</span> =&gt; print(<span class=\"string\">\"scala\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"python\"</span> =&gt; print(<span class=\"string\">\"python\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"c++\"</span> =&gt; print(<span class=\"string\">\"c++\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"_\"</span> =&gt; print(<span class=\"string\">\"nothing match\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 匹配类型</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">MatchType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"string\">\"abcds\"</span>, <span class=\"number\">100</span>, <span class=\"number\">3.14</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> element = arr(<span class=\"type\">Random</span>.nextInt(arr.length))</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">    element <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> str:<span class=\"type\">String</span> =&gt; println(<span class=\"string\">s\"a matches String:<span class=\"subst\">$str</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> int: <span class=\"type\">Int</span>=&gt; println(<span class=\"string\">s\"a matches String:<span class=\"subst\">$int</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> bool:<span class=\"type\">Boolean</span> =&gt; println(<span class=\"string\">s\"a matches String:<span class=\"subst\">$bool</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> matchTest:<span class=\"type\">MatchTest</span> =&gt; println(<span class=\"string\">s\"a matches MatchTest:<span class=\"subst\">$matchTest</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> _: <span class=\"type\">Any</span> =&gt;  println(<span class=\"string\">\"not match\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 样例类匹配</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">CaseClassDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"type\">CheckTimeOutTask</span>, <span class=\"type\">SubmiTask</span>(<span class=\"string\">\"1000\"</span>,<span class=\"string\">\"task-01\"</span>), <span class=\"type\">HeartBeat</span>(<span class=\"number\">3000</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    arr(<span class=\"type\">Random</span>.nextInt(arr.length))  <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"type\">CheckTimeOutTask</span> =&gt; println(<span class=\"string\">\"Check\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"type\">SubmiTask</span>(port,taskName) =&gt; println(<span class=\"string\">\"submit\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"type\">HeartBeat</span>(time) =&gt; println(<span class=\"string\">\"heart\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeartBeat</span>(<span class=\"params\">time: <span class=\"type\">Long</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">class</span> <span class=\"title\">SubmiTask</span>(<span class=\"params\">id:<span class=\"type\">String</span>, taskName: <span class=\"type\">String</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">object</span> <span class=\"title\">CheckTimeOutTask</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 偏函数模式匹配</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">PartialFunctionDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>: <span class=\"type\">PartialFunction</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//String是输入类型，Int是输出类型</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"one\"</span> =&gt; &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"case 1\"</span>)</span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"two\"</span> =&gt; &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"case2\"</span>)</span><br><span class=\"line\">      <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m2</span></span>(num: <span class=\"type\">String</span>): <span class=\"type\">Int</span> = num <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"one\"</span> =&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"two\"</span> =&gt; <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(m1(<span class=\"string\">\"one\"</span>))</span><br><span class=\"line\">    println(m2(<span class=\"string\">\"three\"</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><strong>1.创建类、属性</strong></p>\n<ul>\n<li><p>scala声明类时不需要加public关键字，默认为public，一个类文件可以声明多个类，用object声明的与class同名的类为class的伴生类</p>\n</li>\n<li><p>属性不需要创建getter和setter，val默认只有get方法，因为他不可变;var有get 和 set 方法</p>\n</li>\n<li><p>用private修饰的属性，该属性属于私有变量，只有本类和伴生对象中才能访问</p>\n</li>\n<li><p>用private[this] 修饰的属性属于对象私有变量，只有本类可访问，伴生对象也无法访问</p>","more":"</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;<span class=\"comment\">//声明类</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> id: <span class=\"type\">String</span> = <span class=\"string\">\"100\"</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> = _</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span> = _</span><br><span class=\"line\">  <span class=\"keyword\">private</span>[<span class=\"keyword\">this</span>] <span class=\"keyword\">val</span> gender = <span class=\"string\">\"male\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Person</span> </span>&#123;<span class=\"comment\">//伴生类</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">    <span class=\"comment\">//    println(p.id = \"123\")//val不可修改</span></span><br><span class=\"line\">    p.name = <span class=\"string\">\"ningning\"</span></span><br><span class=\"line\">    p.age = <span class=\"number\">26</span></span><br><span class=\"line\">    println(p.name)</span><br><span class=\"line\">    println(p.age)</span><br><span class=\"line\">    println(p.gender)<span class=\"comment\">//无法访问</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">    println(p.age) <span class=\"comment\">// 无法访问</span></span><br><span class=\"line\">    println(p.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.构造器和辅助构造器</strong></p>\n<ul>\n<li>主构造器：在类名后给一个参数列表，相当于构造器</li>\n<li>主构造器中的属性变量如果没有val或var修饰，默认是val类型，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，这样在创建对象传参的时候可以不给该值传参</li>\n<li>辅助构造器：在class作用范围内定义：<code>def this(主构造器参数列表，其他参数列表)</code>，类似于java当中的不同的构造器拥有不同的参数列表，但是都要实现默认构造器</li>\n<li>在辅助构造器第一行必须调用主构造器</li>\n<li>返回方法：不用<code>retrun</code>,最后一句代码的值作为返回值</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">  * 主构造器参数列表放到类名后面，和类名放在一起</span></span><br><span class=\"line\"><span class=\"comment\">  * @param name</span></span><br><span class=\"line\"><span class=\"comment\">  * @param age</span></span><br><span class=\"line\"><span class=\"comment\">  * @param faceValue</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StructDemo</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, var age:<span class=\"type\">Int</span>, faceValue: <span class=\"type\">Int</span> = 90</span>) </span>&#123; /</span><br><span class=\"line\">  <span class=\"keyword\">var</span> gender: <span class=\"type\">String</span> = _<span class=\"comment\">//此处定义为var，方便在后面的构造器变值</span></span><br><span class=\"line\">  <span class=\"comment\">// /faceValue没有val或var修饰，只能在本类调用，创建出来的实例无法访问该属性,可以给定初始值，在创建对象的时候可以不指定faceValue的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFaceValue</span></span>() :<span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//    faceValue = 100//此时值不可更改，默认是val类型</span></span><br><span class=\"line\">    faceValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(name: <span class=\"type\">String</span>, age:<span class=\"type\">Int</span>, faceValue: <span class=\"type\">Int</span>, gender:<span class=\"type\">String</span>)&#123;<span class=\"comment\">//辅助构造器</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>(name, age, faceValue)<span class=\"comment\">//第一行必须调用主构造器</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.gender = gender</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">StructDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//    val s = new StructDemo(\"ningning\", 23)</span></span><br><span class=\"line\">     <span class=\"keyword\">val</span> s = <span class=\"keyword\">new</span> <span class=\"type\">StructDemo</span>(<span class=\"string\">\"ningning\"</span>,<span class=\"number\">26</span>,<span class=\"number\">98</span>,<span class=\"string\">\"女\"</span>)</span><br><span class=\"line\">    s.age = <span class=\"number\">29</span></span><br><span class=\"line\">    println(s.age)</span><br><span class=\"line\">    println(s.name)</span><br><span class=\"line\">    println(s.getFaceValue())</span><br><span class=\"line\">    println(s.gender)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3.单例对象</strong></p>\n<ul>\n<li><p>scala中没有static修饰符，没有静态方法或静态字段，但可以用object关键字加类名语法结构实现同样的功能</p>\n<blockquote>\n<p>1.工具类，存放常量和个工具方法</p>\n<p>2.实现单例模式</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SingletonDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> factory = <span class=\"type\">SessionFactory</span></span><br><span class=\"line\">    println(factory.getSessions)</span><br><span class=\"line\">    println(factory.getSessions.size)</span><br><span class=\"line\">    println(factory.getSessions(<span class=\"number\">0</span>))</span><br><span class=\"line\">    println(factory.removeSession)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SessionFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 相当于java中的静态块</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">  println(<span class=\"string\">\"SessionFactory executed\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> session = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>[<span class=\"type\">Session</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    session += <span class=\"keyword\">new</span> <span class=\"type\">Session</span></span><br><span class=\"line\">    i -= <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSessions</span> </span>= session</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeSession</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> s = session(<span class=\"number\">0</span>)</span><br><span class=\"line\">    session.remove(<span class=\"number\">0</span>)</span><br><span class=\"line\">    println(<span class=\"string\">\"session removed:\"</span> + s)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Session</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>4.伴生对象</strong></p>\n<ul>\n<li>名字与类名相同，且用object修饰的对象叫伴生对象</li>\n<li>类和其伴生对象可以相互访问私有的方法和属性</li>\n<li>和单例对象的关系：单例对象不一定是伴生对象，但是伴生对象一定是单例对象</li>\n<li>互相访问的作用：</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> name = <span class=\"string\">\"erha\"</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printName</span></span>() : <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//访问伴生对象的私有属性</span></span><br><span class=\"line\">    println(<span class=\"type\">Dog</span>.<span class=\"type\">CONSTANT</span> + name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">伴生对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> <span class=\"type\">CONSTANT</span> = <span class=\"string\">\"BARK! BARK!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> p = <span class=\"keyword\">new</span> <span class=\"type\">Dog</span></span><br><span class=\"line\">    <span class=\"comment\">//访问类中的私有字段</span></span><br><span class=\"line\">    println(p.name)</span><br><span class=\"line\">    p.name = <span class=\"string\">\"dahuang\"</span></span><br><span class=\"line\">    p.printName()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>5.apply和unapply方法</strong></p>\n<ul>\n<li>一般被声明在伴生对象中</li>\n<li>apply方法一般称为注入方法，可以用来初始化对象</li>\n<li>apply方法的参数列表不需要和构造器参数列表统一</li>\n<li>unapply方法常称为提取方法，可以用来提取固定对象</li>\n<li>unapply方法会返回一个序列（Option）,内部产生一个Some对象来存放一些值</li>\n<li>apply和unapply方法会被隐式调用</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">applyDemo</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, var age: <span class=\"type\">Int</span>, var faceValue: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">applyDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span></span>(name: <span class=\"type\">String</span>, age: <span class=\"type\">Int</span>, gender: <span class=\"type\">Int</span>, faceValue: <span class=\"type\">Int</span>): applyDemo =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> applyDemo(name, age, faceValue)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unapply</span></span>(arg: applyDemo): <span class=\"type\">Option</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)] = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"type\">None</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Some</span>(arg.name, arg.age, arg.faceValue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 调用方式</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = applyDemo(<span class=\"string\">\"ningning\"</span>, <span class=\"number\">23</span>, <span class=\"number\">1</span>, <span class=\"number\">86</span>) <span class=\"comment\">//不用new，用apply方法创建了一个对象</span></span><br><span class=\"line\">    res <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//模式匹配，调用unapply方法</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> applyDemo(<span class=\"string\">\"ningning\"</span>, age, faceValue) =&gt; println(<span class=\"string\">s\"age: <span class=\"subst\">$age</span>\"</span>) <span class=\"comment\">//在字符串中输出值的方式</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> _ =&gt; println(<span class=\"string\">\"no match\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>6.private关键字</strong></p>\n<ul>\n<li>变量前加private，该变量为私有字段</li>\n<li>变量前加private[this]，表示<em>对象私有字段</em>，只能在本类访问，伴生对象也不能访问</li>\n<li>方法前加private，表示私有方法</li>\n<li>类名前加private[包名]，表示该类只有包访问权限</li>\n<li>构造器参数列表前加private是指伴生对象权限，只有伴生对象才能访问</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包访问权限</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>[ch02] <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrivateDemo</span> <span class=\"title\">private</span>(<span class=\"params\">val gender: <span class=\"type\">Int</span>, val faceValue: <span class=\"type\">Int</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//私有字段</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> name = <span class=\"string\">\"jingjing\"</span></span><br><span class=\"line\">  <span class=\"comment\">//对象私有字段</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>[<span class=\"keyword\">this</span>] <span class=\"keyword\">var</span> age = <span class=\"number\">24</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//私有方法</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sayHello</span></span>(): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(name + <span class=\"string\">\"say hello\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">PrivateDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> privateDemo = <span class=\"keyword\">new</span> <span class=\"type\">PrivateDemo</span>(<span class=\"number\">1</span>, <span class=\"number\">88</span>)</span><br><span class=\"line\">    privateDemo.sayHello()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> privateDemo = <span class=\"keyword\">new</span> <span class=\"type\">PrivateDemo</span>(<span class=\"number\">0</span>, <span class=\"number\">90</span>)</span><br><span class=\"line\">    <span class=\"comment\">//    privateDemo.sayHello() 访问不到</span></span><br><span class=\"line\">    print(privateDemo.faceValue) <span class=\"comment\">//编译不能通过</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>7.特质、重写、抽象类和重写</strong></p>\n<ul>\n<li>特质：类似java中的接口，用<code>trait 类名</code>声明</li>\n<li>抽象类： <code>abstract 类名</code>声明，抽象类没有实现的方法，继承它的类一定要实现。</li>\n<li>继承：extends关键字</li>\n<li>实现接口：with关键字，与java中的implements类似，实现特质中没有实现的方法可以不用override</li>\n<li>重现方法或字段：override</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ClassDEmo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> human = <span class=\"keyword\">new</span> <span class=\"type\">Human</span></span><br><span class=\"line\">    println(human.name)</span><br><span class=\"line\">    println(human.fight)</span><br><span class=\"line\">    println(human.distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Flyable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有值的字段</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> distance: <span class=\"type\">Int</span> = <span class=\"number\">1000</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fight</span></span>: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fly</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    print(<span class=\"string\">\"I can fly\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 抽象类</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有值的字段</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> name: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个没有实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span></span>(): <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明一个实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climb</span></span>: <span class=\"type\">String</span> = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"In can climb\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"keyword\">with</span> <span class=\"title\">Flyable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> name: <span class=\"type\">String</span> = <span class=\"string\">\"zhangsan\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//重写抽象类没有实现的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span></span>(): <span class=\"type\">String</span> = <span class=\"string\">\"I can run\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> distance: <span class=\"type\">Int</span> = <span class=\"number\">900</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//实现特质中没有实现的方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fight</span></span>: <span class=\"type\">String</span> = <span class=\"string\">\"With rob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//实现特质中实现了的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fly</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">\"override fly\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>8.模式匹配</strong></p>\n<ul>\n<li>类似java中的switch…case,但是功能更强大</li>\n<li>case_的作用队标java中的default</li>\n<li></li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 匹配字符串</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">MatchStr</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"string\">\"java\"</span>,<span class=\"string\">\"scala\"</span>,<span class=\"string\">\"python\"</span>,<span class=\"string\">\"c++\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = arr(<span class=\"type\">Random</span>.nextInt(arr.length))</span><br><span class=\"line\">    println(name)</span><br><span class=\"line\">    name <span class=\"keyword\">match</span>  &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"java\"</span> =&gt; print(<span class=\"string\">\"java\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"scala\"</span> =&gt; print(<span class=\"string\">\"scala\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"python\"</span> =&gt; print(<span class=\"string\">\"python\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"c++\"</span> =&gt; print(<span class=\"string\">\"c++\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">\"_\"</span> =&gt; print(<span class=\"string\">\"nothing match\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 匹配类型</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">MatchType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"string\">\"abcds\"</span>, <span class=\"number\">100</span>, <span class=\"number\">3.14</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> element = arr(<span class=\"type\">Random</span>.nextInt(arr.length))</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">    element <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> str:<span class=\"type\">String</span> =&gt; println(<span class=\"string\">s\"a matches String:<span class=\"subst\">$str</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> int: <span class=\"type\">Int</span>=&gt; println(<span class=\"string\">s\"a matches String:<span class=\"subst\">$int</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> bool:<span class=\"type\">Boolean</span> =&gt; println(<span class=\"string\">s\"a matches String:<span class=\"subst\">$bool</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> matchTest:<span class=\"type\">MatchTest</span> =&gt; println(<span class=\"string\">s\"a matches MatchTest:<span class=\"subst\">$matchTest</span>\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> _: <span class=\"type\">Any</span> =&gt;  println(<span class=\"string\">\"not match\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 样例类匹配</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">CaseClassDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"type\">CheckTimeOutTask</span>, <span class=\"type\">SubmiTask</span>(<span class=\"string\">\"1000\"</span>,<span class=\"string\">\"task-01\"</span>), <span class=\"type\">HeartBeat</span>(<span class=\"number\">3000</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    arr(<span class=\"type\">Random</span>.nextInt(arr.length))  <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"type\">CheckTimeOutTask</span> =&gt; println(<span class=\"string\">\"Check\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"type\">SubmiTask</span>(port,taskName) =&gt; println(<span class=\"string\">\"submit\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"type\">HeartBeat</span>(time) =&gt; println(<span class=\"string\">\"heart\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeartBeat</span>(<span class=\"params\">time: <span class=\"type\">Long</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">class</span> <span class=\"title\">SubmiTask</span>(<span class=\"params\">id:<span class=\"type\">String</span>, taskName: <span class=\"type\">String</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">object</span> <span class=\"title\">CheckTimeOutTask</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 偏函数模式匹配</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">PartialFunctionDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>: <span class=\"type\">PartialFunction</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//String是输入类型，Int是输出类型</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"one\"</span> =&gt; &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"case 1\"</span>)</span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"two\"</span> =&gt; &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"case2\"</span>)</span><br><span class=\"line\">      <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m2</span></span>(num: <span class=\"type\">String</span>): <span class=\"type\">Int</span> = num <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"one\"</span> =&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"two\"</span> =&gt; <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(m1(<span class=\"string\">\"one\"</span>))</span><br><span class=\"line\">    println(m2(<span class=\"string\">\"three\"</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"《区块链原理、设计与应用》读书摘要","date":"2018-04-03T06:41:06.000Z","_content":"实验室项目需要了解区块链的有关原理和技术，将自己的读书摘要记录到此处\n一、技术核心概览\n---\n**定义与原理**\n中本聪：区块链是用于记录比特币交易账目历史的数据结构\nWikipedia：将区块链类比为一种分布式数据库技术，通过维护数据快的链式结构，维持持续增长的、不可篡改的数据记录\n<!-- more-->\n**基本原理**\n交易transaction：一次对账本的操作，导致账本状态的一次改变\n区块block：计算一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识\n链chain：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录\n\n假设存在一个分布式账本，只允许添加、不允许删除。账本底层是数据结构一个线性链表，链表由一个个区块串联而成，后继区块记录前导区块的Hash值，新数据要加入，必须放到一个新的区块中，而这个块是否合法，可以通过计算哈希值的方式快速检验出来\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-3/47102201.jpg)\n工作量证明PoW:基于算力寻找nonce串的共识机制\n\n**技术演化和分类**\n智能合约smart contract:提供除了货币交易外更灵活的合约功能，执行更复杂的操作\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-3/43523210.jpg)\n\n基于区块链的分布式账本特点：\n1.维护一条不断增长的链，只能添加记录，发生过的记录不可修改\n2.去中心化，或多中心化，无需集中控制而能达成共识，实现上尽量采用分布式\n3.通过密码学的机制确保交易无法被抵赖和破坏，尽量保护用户信息和记录的隐私性\n\n*分类*：\n* 公有链; 任何人可以参与使用和维护\n *进一步引入许可机制，可实现：*\n* 私有链：由集中管理者进行管理限制，只有少数人可以使用，信息不公开\n* 联盟链：介于其他两者之间，有若干组织一起维护一条区块链，该区块链的使用必须带有权限的限制访问，相关信息会得到保护，如供应链或银行联盟\n\n二、分布式系统核心问题\n---\n**一致性问题**\n*一致性*指对于分布式系统中的多个服务节点，给定一系列操作，在约定协议的保障下，试图使得他们对处理结果达成“某种程度”的认同\n*一致性要求*：\n1.可终止性：一致的结果能在有限时间内完成\n2.约同性：不同节点最终完成决策的结果是相同的\n3.合法性：决策的结果必须是某个节点提出的提案\n**共识算法**\n共识算法解决的是对某个提案大家达成一致意见的过程\n非拜占庭错误：出现错误但不会伪造信息的情况\n拜占庭错误：伪造信息恶意响应的情况，对应节点为拜占庭节点\n共识算法：\n解决非拜占庭错误CTF：Paxos、Paft等\n解决拜占庭错误BFT：pbft,PoW等\n**FLP不可能原理**\n在网络可靠，但允许节点失败的最小化异步模型系统中，不存在一個可以解决一致性问题的确定性共识算法\n**CAP原理**\n分布式计算系统不可能同时确保三个特性：一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的保证。\n> 一致性：任何操作都是原子的，发生在后面的事件能看到前面时间发生导致的结果\n> 可用性：在有限时间内，任何非失败节点都能应答请求\n> 分区容忍性：网络可能发生分区，节点之间通信不可保障\n\n**Paxos算法**\n基于“两阶段提交“算法并进行泛化扩展，基本原理是将节点分为三种逻辑角色，在实现上一个人可以担任多个角色：\n* Proposer提案者：提树一个提案，等待大家批准为结案，一般客户端担任此角色\n* Accepter接受者：负责对提案进行投票，接受提案，一般服务器担任此角色\n* Learner学习者：获取批准结果，并帮忙传播，不参与投票过程，可能为客户端或者服务器端\n\n*算法约束*：\n- Safey约束:保证决议是对的，无歧义的，不会出现错误情况\n- LIveness约束：保证决议过程能在有限时间内完成\n\n*两阶段提交*\n准备阶段：\n> 1. 提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多个接收者的支持。\n> 2. 接受者时刻保留收到过的提案的最大编号和接受的最大提案，如果收到的提案号比目前保留的最大的提案号还大，更新当前最大提案号，并说明不再接受小于最大提案号的提案\n\n提交阶段：\n> 1.提案者如果收到大多数的回复，则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功。则使用自己的提案内容，如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没有收到足够的回复，则需要再次发出请求。\n> 2. 接受者收到”接受消息“后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。\n\n**Raft算法**\n　在Raft中，任何时候一个服务器可以扮演下面角色之一：\n\n    Leader: 处理所有客户端交互，日志复制等，一般一次只有一个Leader.\n    Follower: 类似选民，完全被动\n    Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。\n\nRaft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等\n\n","source":"_posts/《区块链原理、设计与应用》读书摘要.md","raw":"---\ntitle: 《区块链原理、设计与应用》读书摘要\ndate: 2018-04-03 14:41:06\ntags: 区块链\n---\n实验室项目需要了解区块链的有关原理和技术，将自己的读书摘要记录到此处\n一、技术核心概览\n---\n**定义与原理**\n中本聪：区块链是用于记录比特币交易账目历史的数据结构\nWikipedia：将区块链类比为一种分布式数据库技术，通过维护数据快的链式结构，维持持续增长的、不可篡改的数据记录\n<!-- more-->\n**基本原理**\n交易transaction：一次对账本的操作，导致账本状态的一次改变\n区块block：计算一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识\n链chain：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录\n\n假设存在一个分布式账本，只允许添加、不允许删除。账本底层是数据结构一个线性链表，链表由一个个区块串联而成，后继区块记录前导区块的Hash值，新数据要加入，必须放到一个新的区块中，而这个块是否合法，可以通过计算哈希值的方式快速检验出来\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-3/47102201.jpg)\n工作量证明PoW:基于算力寻找nonce串的共识机制\n\n**技术演化和分类**\n智能合约smart contract:提供除了货币交易外更灵活的合约功能，执行更复杂的操作\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-3/43523210.jpg)\n\n基于区块链的分布式账本特点：\n1.维护一条不断增长的链，只能添加记录，发生过的记录不可修改\n2.去中心化，或多中心化，无需集中控制而能达成共识，实现上尽量采用分布式\n3.通过密码学的机制确保交易无法被抵赖和破坏，尽量保护用户信息和记录的隐私性\n\n*分类*：\n* 公有链; 任何人可以参与使用和维护\n *进一步引入许可机制，可实现：*\n* 私有链：由集中管理者进行管理限制，只有少数人可以使用，信息不公开\n* 联盟链：介于其他两者之间，有若干组织一起维护一条区块链，该区块链的使用必须带有权限的限制访问，相关信息会得到保护，如供应链或银行联盟\n\n二、分布式系统核心问题\n---\n**一致性问题**\n*一致性*指对于分布式系统中的多个服务节点，给定一系列操作，在约定协议的保障下，试图使得他们对处理结果达成“某种程度”的认同\n*一致性要求*：\n1.可终止性：一致的结果能在有限时间内完成\n2.约同性：不同节点最终完成决策的结果是相同的\n3.合法性：决策的结果必须是某个节点提出的提案\n**共识算法**\n共识算法解决的是对某个提案大家达成一致意见的过程\n非拜占庭错误：出现错误但不会伪造信息的情况\n拜占庭错误：伪造信息恶意响应的情况，对应节点为拜占庭节点\n共识算法：\n解决非拜占庭错误CTF：Paxos、Paft等\n解决拜占庭错误BFT：pbft,PoW等\n**FLP不可能原理**\n在网络可靠，但允许节点失败的最小化异步模型系统中，不存在一個可以解决一致性问题的确定性共识算法\n**CAP原理**\n分布式计算系统不可能同时确保三个特性：一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的保证。\n> 一致性：任何操作都是原子的，发生在后面的事件能看到前面时间发生导致的结果\n> 可用性：在有限时间内，任何非失败节点都能应答请求\n> 分区容忍性：网络可能发生分区，节点之间通信不可保障\n\n**Paxos算法**\n基于“两阶段提交“算法并进行泛化扩展，基本原理是将节点分为三种逻辑角色，在实现上一个人可以担任多个角色：\n* Proposer提案者：提树一个提案，等待大家批准为结案，一般客户端担任此角色\n* Accepter接受者：负责对提案进行投票，接受提案，一般服务器担任此角色\n* Learner学习者：获取批准结果，并帮忙传播，不参与投票过程，可能为客户端或者服务器端\n\n*算法约束*：\n- Safey约束:保证决议是对的，无歧义的，不会出现错误情况\n- LIveness约束：保证决议过程能在有限时间内完成\n\n*两阶段提交*\n准备阶段：\n> 1. 提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多个接收者的支持。\n> 2. 接受者时刻保留收到过的提案的最大编号和接受的最大提案，如果收到的提案号比目前保留的最大的提案号还大，更新当前最大提案号，并说明不再接受小于最大提案号的提案\n\n提交阶段：\n> 1.提案者如果收到大多数的回复，则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功。则使用自己的提案内容，如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没有收到足够的回复，则需要再次发出请求。\n> 2. 接受者收到”接受消息“后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。\n\n**Raft算法**\n　在Raft中，任何时候一个服务器可以扮演下面角色之一：\n\n    Leader: 处理所有客户端交互，日志复制等，一般一次只有一个Leader.\n    Follower: 类似选民，完全被动\n    Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。\n\nRaft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等\n\n","slug":"《区块链原理、设计与应用》读书摘要","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6u0012cf96lyh19wwk","content":"<p>实验室项目需要了解区块链的有关原理和技术，将自己的读书摘要记录到此处</p>\n<h2 id=\"一、技术核心概览\"><a href=\"#一、技术核心概览\" class=\"headerlink\" title=\"一、技术核心概览\"></a>一、技术核心概览</h2><p><strong>定义与原理</strong><br>中本聪：区块链是用于记录比特币交易账目历史的数据结构<br>Wikipedia：将区块链类比为一种分布式数据库技术，通过维护数据快的链式结构，维持持续增长的、不可篡改的数据记录<br><a id=\"more\"></a><br><strong>基本原理</strong><br>交易transaction：一次对账本的操作，导致账本状态的一次改变<br>区块block：计算一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识<br>链chain：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录</p>\n<p>假设存在一个分布式账本，只允许添加、不允许删除。账本底层是数据结构一个线性链表，链表由一个个区块串联而成，后继区块记录前导区块的Hash值，新数据要加入，必须放到一个新的区块中，而这个块是否合法，可以通过计算哈希值的方式快速检验出来<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-3/47102201.jpg\" alt=\"\"><br>工作量证明PoW:基于算力寻找nonce串的共识机制</p>\n<p><strong>技术演化和分类</strong><br>智能合约smart contract:提供除了货币交易外更灵活的合约功能，执行更复杂的操作<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-3/43523210.jpg\" alt=\"\"></p>\n<p>基于区块链的分布式账本特点：<br>1.维护一条不断增长的链，只能添加记录，发生过的记录不可修改<br>2.去中心化，或多中心化，无需集中控制而能达成共识，实现上尽量采用分布式<br>3.通过密码学的机制确保交易无法被抵赖和破坏，尽量保护用户信息和记录的隐私性</p>\n<p><em>分类</em>：</p>\n<ul>\n<li>公有链; 任何人可以参与使用和维护<br><em>进一步引入许可机制，可实现：</em></li>\n<li>私有链：由集中管理者进行管理限制，只有少数人可以使用，信息不公开</li>\n<li>联盟链：介于其他两者之间，有若干组织一起维护一条区块链，该区块链的使用必须带有权限的限制访问，相关信息会得到保护，如供应链或银行联盟</li>\n</ul>\n<h2 id=\"二、分布式系统核心问题\"><a href=\"#二、分布式系统核心问题\" class=\"headerlink\" title=\"二、分布式系统核心问题\"></a>二、分布式系统核心问题</h2><p><strong>一致性问题</strong><br><em>一致性</em>指对于分布式系统中的多个服务节点，给定一系列操作，在约定协议的保障下，试图使得他们对处理结果达成“某种程度”的认同<br><em>一致性要求</em>：<br>1.可终止性：一致的结果能在有限时间内完成<br>2.约同性：不同节点最终完成决策的结果是相同的<br>3.合法性：决策的结果必须是某个节点提出的提案<br><strong>共识算法</strong><br>共识算法解决的是对某个提案大家达成一致意见的过程<br>非拜占庭错误：出现错误但不会伪造信息的情况<br>拜占庭错误：伪造信息恶意响应的情况，对应节点为拜占庭节点<br>共识算法：<br>解决非拜占庭错误CTF：Paxos、Paft等<br>解决拜占庭错误BFT：pbft,PoW等<br><strong>FLP不可能原理</strong><br>在网络可靠，但允许节点失败的最小化异步模型系统中，不存在一個可以解决一致性问题的确定性共识算法<br><strong>CAP原理</strong><br>分布式计算系统不可能同时确保三个特性：一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的保证。</p>\n<blockquote>\n<p>一致性：任何操作都是原子的，发生在后面的事件能看到前面时间发生导致的结果<br>可用性：在有限时间内，任何非失败节点都能应答请求<br>分区容忍性：网络可能发生分区，节点之间通信不可保障</p>\n</blockquote>\n<p><strong>Paxos算法</strong><br>基于“两阶段提交“算法并进行泛化扩展，基本原理是将节点分为三种逻辑角色，在实现上一个人可以担任多个角色：</p>\n<ul>\n<li>Proposer提案者：提树一个提案，等待大家批准为结案，一般客户端担任此角色</li>\n<li>Accepter接受者：负责对提案进行投票，接受提案，一般服务器担任此角色</li>\n<li>Learner学习者：获取批准结果，并帮忙传播，不参与投票过程，可能为客户端或者服务器端</li>\n</ul>\n<p><em>算法约束</em>：</p>\n<ul>\n<li>Safey约束:保证决议是对的，无歧义的，不会出现错误情况</li>\n<li>LIveness约束：保证决议过程能在有限时间内完成</li>\n</ul>\n<p><em>两阶段提交</em><br>准备阶段：</p>\n<blockquote>\n<ol>\n<li>提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多个接收者的支持。</li>\n<li>接受者时刻保留收到过的提案的最大编号和接受的最大提案，如果收到的提案号比目前保留的最大的提案号还大，更新当前最大提案号，并说明不再接受小于最大提案号的提案</li>\n</ol>\n</blockquote>\n<p>提交阶段：</p>\n<blockquote>\n<p>1.提案者如果收到大多数的回复，则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功。则使用自己的提案内容，如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没有收到足够的回复，则需要再次发出请求。</p>\n<ol>\n<li>接受者收到”接受消息“后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。</li>\n</ol>\n</blockquote>\n<p><strong>Raft算法</strong><br>　在Raft中，任何时候一个服务器可以扮演下面角色之一：</p>\n<pre><code>Leader: 处理所有客户端交互，日志复制等，一般一次只有一个Leader.\nFollower: 类似选民，完全被动\nCandidate候选人: 类似Proposer律师，可以被选为一个新的领导人。\n</code></pre><p>Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等</p>\n","site":{"data":{}},"excerpt":"<p>实验室项目需要了解区块链的有关原理和技术，将自己的读书摘要记录到此处</p>\n<h2 id=\"一、技术核心概览\"><a href=\"#一、技术核心概览\" class=\"headerlink\" title=\"一、技术核心概览\"></a>一、技术核心概览</h2><p><strong>定义与原理</strong><br>中本聪：区块链是用于记录比特币交易账目历史的数据结构<br>Wikipedia：将区块链类比为一种分布式数据库技术，通过维护数据快的链式结构，维持持续增长的、不可篡改的数据记录<br>","more":"<br><strong>基本原理</strong><br>交易transaction：一次对账本的操作，导致账本状态的一次改变<br>区块block：计算一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识<br>链chain：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录</p>\n<p>假设存在一个分布式账本，只允许添加、不允许删除。账本底层是数据结构一个线性链表，链表由一个个区块串联而成，后继区块记录前导区块的Hash值，新数据要加入，必须放到一个新的区块中，而这个块是否合法，可以通过计算哈希值的方式快速检验出来<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-3/47102201.jpg\" alt=\"\"><br>工作量证明PoW:基于算力寻找nonce串的共识机制</p>\n<p><strong>技术演化和分类</strong><br>智能合约smart contract:提供除了货币交易外更灵活的合约功能，执行更复杂的操作<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-3/43523210.jpg\" alt=\"\"></p>\n<p>基于区块链的分布式账本特点：<br>1.维护一条不断增长的链，只能添加记录，发生过的记录不可修改<br>2.去中心化，或多中心化，无需集中控制而能达成共识，实现上尽量采用分布式<br>3.通过密码学的机制确保交易无法被抵赖和破坏，尽量保护用户信息和记录的隐私性</p>\n<p><em>分类</em>：</p>\n<ul>\n<li>公有链; 任何人可以参与使用和维护<br><em>进一步引入许可机制，可实现：</em></li>\n<li>私有链：由集中管理者进行管理限制，只有少数人可以使用，信息不公开</li>\n<li>联盟链：介于其他两者之间，有若干组织一起维护一条区块链，该区块链的使用必须带有权限的限制访问，相关信息会得到保护，如供应链或银行联盟</li>\n</ul>\n<h2 id=\"二、分布式系统核心问题\"><a href=\"#二、分布式系统核心问题\" class=\"headerlink\" title=\"二、分布式系统核心问题\"></a>二、分布式系统核心问题</h2><p><strong>一致性问题</strong><br><em>一致性</em>指对于分布式系统中的多个服务节点，给定一系列操作，在约定协议的保障下，试图使得他们对处理结果达成“某种程度”的认同<br><em>一致性要求</em>：<br>1.可终止性：一致的结果能在有限时间内完成<br>2.约同性：不同节点最终完成决策的结果是相同的<br>3.合法性：决策的结果必须是某个节点提出的提案<br><strong>共识算法</strong><br>共识算法解决的是对某个提案大家达成一致意见的过程<br>非拜占庭错误：出现错误但不会伪造信息的情况<br>拜占庭错误：伪造信息恶意响应的情况，对应节点为拜占庭节点<br>共识算法：<br>解决非拜占庭错误CTF：Paxos、Paft等<br>解决拜占庭错误BFT：pbft,PoW等<br><strong>FLP不可能原理</strong><br>在网络可靠，但允许节点失败的最小化异步模型系统中，不存在一個可以解决一致性问题的确定性共识算法<br><strong>CAP原理</strong><br>分布式计算系统不可能同时确保三个特性：一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的保证。</p>\n<blockquote>\n<p>一致性：任何操作都是原子的，发生在后面的事件能看到前面时间发生导致的结果<br>可用性：在有限时间内，任何非失败节点都能应答请求<br>分区容忍性：网络可能发生分区，节点之间通信不可保障</p>\n</blockquote>\n<p><strong>Paxos算法</strong><br>基于“两阶段提交“算法并进行泛化扩展，基本原理是将节点分为三种逻辑角色，在实现上一个人可以担任多个角色：</p>\n<ul>\n<li>Proposer提案者：提树一个提案，等待大家批准为结案，一般客户端担任此角色</li>\n<li>Accepter接受者：负责对提案进行投票，接受提案，一般服务器担任此角色</li>\n<li>Learner学习者：获取批准结果，并帮忙传播，不参与投票过程，可能为客户端或者服务器端</li>\n</ul>\n<p><em>算法约束</em>：</p>\n<ul>\n<li>Safey约束:保证决议是对的，无歧义的，不会出现错误情况</li>\n<li>LIveness约束：保证决议过程能在有限时间内完成</li>\n</ul>\n<p><em>两阶段提交</em><br>准备阶段：</p>\n<blockquote>\n<ol>\n<li>提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多个接收者的支持。</li>\n<li>接受者时刻保留收到过的提案的最大编号和接受的最大提案，如果收到的提案号比目前保留的最大的提案号还大，更新当前最大提案号，并说明不再接受小于最大提案号的提案</li>\n</ol>\n</blockquote>\n<p>提交阶段：</p>\n<blockquote>\n<p>1.提案者如果收到大多数的回复，则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功。则使用自己的提案内容，如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没有收到足够的回复，则需要再次发出请求。</p>\n<ol>\n<li>接受者收到”接受消息“后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。</li>\n</ol>\n</blockquote>\n<p><strong>Raft算法</strong><br>　在Raft中，任何时候一个服务器可以扮演下面角色之一：</p>\n<pre><code>Leader: 处理所有客户端交互，日志复制等，一般一次只有一个Leader.\nFollower: 类似选民，完全被动\nCandidate候选人: 类似Proposer律师，可以被选为一个新的领导人。\n</code></pre><p>Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等</p>"},{"title":"今日头条2018春季实习生笔试题----BFS两道","date":"2018-03-24T13:27:38.000Z","_content":"\n帮师姐做笔试,先留坑,有空填\n一道字符串\n一道上台阶\n\n","source":"_posts/今日头条2018春季实习生笔试题-BFS两道.md","raw":"---\ntitle: 今日头条2018春季实习生笔试题----BFS两道\ndate: 2018-03-24 21:27:38\ntags: 算法\n---\n\n帮师姐做笔试,先留坑,有空填\n一道字符串\n一道上台阶\n\n","slug":"今日头条2018春季实习生笔试题-BFS两道","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6v0015cf96h8drtgv8","content":"<p>帮师姐做笔试,先留坑,有空填<br>一道字符串<br>一道上台阶</p>\n","site":{"data":{}},"excerpt":"","more":"<p>帮师姐做笔试,先留坑,有空填<br>一道字符串<br>一道上台阶</p>\n"},{"title":"关于Crunch","date":"2018-03-21T02:20:16.000Z","_content":"> 本篇文章主要来自<<Hadoop权威指南>>Crunch部分学习笔记\n\nCrunch是用来写MapReduce管线的高层API,它注重程序员友好的JAVA类型和旧式的纯JAVA对象,还有一组丰富的数据变换操作和多级管线.因为Crunch位于上层,故Crunch管线是高度可组合的,可以把常用功能提取到库中给其他程序重用.Crunch不依赖于MapReduce,也可以用Spark作为分布式引擎来运行Crunch管线.\n  <!-- more-->\n示例\n---\n以如下实例引出基本概念:\n```java\nimport org.apache.crunch.*;\nimport org.apache.crunch.fn.Aggregators;\nimport org.apache.crunch.impl.mr.MRPipeline;\nimport org.apache.crunch.io.To;\n\nimport static org.apache.crunch.types.writable.Writables.*;\n\npublic class MaxTemperatureCrunch {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.err.printf(\"Usage: MaxtemperatureCrunch <input> <output>\");\n            System.exit(-1);\n        }\n\n        Pipeline pipeline = new MRPipeline(MaxTemperatureCrunch.class);\n        PCollection<String> records = pipeline.readTextFile(args[0]);\n        PTable<String, Integer> yearTemperatures = records.parallelDo(toYearTemPairFn(), tableOf(strings(), ints()));\n        PTable<String, Integer> maxTemps = yearTemperatures.groupByKey().combineValues(Aggregators.MAX_INTS());\n        maxTemps.write(To.textFile(args[1]));\n        PipelineResult result = pipeline.done();\n        System.exit(result.succeeded() ? 0 : 1);\n    }\n\n    static DoFn<String, Pair<String, Integer>> toYearTemPairFn() {\n       return new DoFn<String, Pair<String, Integer>>() {\n           NcdcRecordParser parser = new NcdcRecordParser();\n           @Override\n           public void process(String input, Emitter<Pair<String, Integer>> emitter) {\n               parser.parse(input);\n               if (parser.isValidTemperature()) {\n                   emitter.emit(Pair.of(parser.getYear(), parser.getAirTemperature()));\n               }\n           }\n       };\n    }\n}\n```\n先构建Crunch pipline对象,代表希望运行的计算, pipeline可以有多个阶段,即具有多个输入,输出,分支和迭代都是有可能的.\n\n使用MapReduce运行管线,因此创建MRPipeline,也可使用MemPipeline在内存中运行管线或者SparkPipeline运行在Spark中.\n\nPipeline.readTextFile()可以将文本文件转换为String类型的PCollection对象,每个String代表一行文本.\n\nPCollection< S >是最基本的Crunch数据类型,表示由S型元素组成的*不可修改*且*无序*的分布式集合,可被视为非物化的Collection,因为*它的元素没有被读取到内存*.Crunch对PCollection做各种操作并产生一个新的PCollection.\nPCollection.parallellDo()为PCollection中的*每个元素*都执行某种操作,返回一个新的PCollection.\nParallelDo()的方法签名如下:\n>`<T> PCollection <T> parallelDo(DoFn <S, T> var1, PType <T> var2);`\n\n第二个参数PType< T >向Crunch传递有关T的java类型以及如何序列化该类型的信息\nPTable < K,V >是一个扩展的PCollection,它是由键值对构成的分布式multi-map,可以具有重复键值对.\nPTable.GroupBy执行的是MR的shuffle操作,按键对表分组,返回PGroupedTable < K,V >,它的combineValues()方法能把一个键的所有值聚合起来,就像MR中reducer做的那样.\n管线的最后一步操作就是调用write()将表写入文件,write()输入就是通过静态工厂TO的textFile方法创建的一个文本文件对象,实际上使用了TextOutputFormat格式来完成这个操作.\n为了执行管线,必须调用done()方法,程序阻塞直至管线执行完毕.\n\nCrunch核心API\n---\n**基本操作**\n- union() : 对两个PCollection进行\"并集\"操作(如果两个PCollection中有相同的元素,这个元素在union后会出现多次),进行union()操作时他们必须由同一管线创建,并且具有相同的类型.\n```java\nPCollection<Integer> a = MemPipeline.collectionOf(1, 2, 3);\nPCollection<Integer> b = MemPipeline.collectionOf(2);\nPCollection<Integer> c = a.union(b);\nassertEquals(\"{2,1,2,3}\", dump(c));```\n- parallelDo() : 为输入的PCollection< S >中的每个元素调用某个函数,并返回包含该调用结果的一个新的输出PCollection<T>.\n ```java\n        PCollection<String> a = MemPipeline.collectionOf(\"cherry\", \"apple\", \"banana\");\n        PCollection<Integer> b = a.parallelDo(new MapFn<String, Integer>() {\n            @Override\n            public Integer map(String input) {\n                return input.length();\n            }\n        }, ints());\n        assertEquals(\"{6,5,6}\", dump(b));```\nparallelDo常用来过滤在后续步骤中不需要的数据,Crunch专门提供了filter()方法,参数是一个特殊DoFn,为FilterFn,只用实现accept()即可只是是否保留该数据到输出中,他的方法签名没有PType,因为输入与输出类型相同.\n```java\n        PCollection<String> a = MemPipeline.collectionOf(\"cherry\", \"apple\", \"banana\");\n        PCollection<String> b = a.filter(new FilterFn<String>() {\n            @Override\n            public boolean accept(String s) {\n                return s.length() %2 == 0;\n            }\n        });\n        assertEquals(\"{cherry,banana}\", dump(b));```\n从由某些值构成的PCollection中提取键以形成一个PTable是常见操作,Crunch为此提供了by()方法,参数是MapFn()< S, K >,将值映S射成键K.\n```java\n        PCollection<String> a = MemPipeline.typedCollectionOf(strings(), \"cherry\", \"apple\",\n                \"banana\");\n        PTable<Integer,String> b = a.by(new MapFn<String, Integer>() {\n            @Override\n            public Integer map(String input) {\n                return input.length();\n            }\n        }, ints());\n        assertEquals(\"{(6,cherry),(5,apple),(6,banana)}\", dump(b));\n```\n- groupByKey() : 把PTable< K,V >中具有相同键的所有值聚合起来,可以看做MR中的混洗操作,返回PGroupedTable< K,V >,Crunch可以根据表的大小为groupByKey()设置分区数量,也可以通过重载groupByKey(int i)指定分区数量.\n```java\n        PGroupedTable<Integer,String> c = b.groupByKey();\n        assertEquals(\"{(5,[apple]),(6,[cherry,banana])}\", dump(c));```\n- combineValues() : 最常见以组合函数CombineFn< K,V >作为输入,CombineFn< K,V >就是`DoFn<Pair<K,Iterable<V>>, Pair<K,V>>`的简写,返回一个```PTable<K,V>```\n```java\n        PTable<Integer, String> d = c.combineValues(new CombineFn<Integer, String>() {\n            @Override\n            public void process(Pair<Integer, Iterable<String>> integerIterablePair, Emitter<Pair<Integer, String>> emitter) {\n                StringBuilder sb = new StringBuilder();\n                for (Iterator i = integerIterablePair.second().iterator(); i.hasNext(); ) {\n                    sb.append(i.next());\n                    if(i.hasNext())\n                        sb.append(\";\");\n                }\n                emitter.emit(Pair.of(integerIterablePair.first(), sb.toString()));\n            }\n        });\n        assertEquals(\"{(5,apple),(6,cherry;banana)}\", dump(d));```\n由于没有对键进行改变,可以使用重载的combineValues(),以Aggregator对象作为输入,仅对值进行操作,可以使用Aggregators内置的Aggregator实现操作,比如之前的Aggregators.MAX_INTS().\n```java\n        PTable<Integer, String> e = c.combineValues(Aggregators.STRING_CONCAT(\";\",false));\n        assertEquals(\"{(5,apple),(6,cherry;banana)}\", dump(e));```\n想要聚合PGroupedTable中的值并返回一个与被分组的值的类型不同的结果,可用mapValues()实现,\n```java\n PTable<Integer, Integer> f = c.mapValues(new MapFn<Iterable<String>, Integer>() {\n            @Override\n            public Integer map(Iterable<String> strings) {\n                return Iterables.size(strings);\n            }\n        },ints());\n        assertEquals(\"{(5,1),(6,2)}\", dump(f));```\ncombineValues()可被当作MR的combiner来运行,而mapValues()被解释为ParallelDo()操作,只能在reduce端运行.\n\n**类型**\n\n每个PCollection< S >都有一个关联的类PType< S >,用于封装有关PCollection中的元素类型的信息,也给出了从持久化存储器读取到PCollection的序列化格式和反方向的序列化格式.\n两个PType家族,用哪个取决于管线的文件格式,都可用于文本文件:\n1. Hadoop Writables: 顺序文件\n2. Avro: Avro数据文件\n\nPCollection使用的PType在PCollection创建时指定,有时隐式指定,例如读取文本文件时使用默认的Writables.\n\n*记录和元组*\n记录record : 通过名称来访问字段的类,用记录写的Crunch程序更易于理解和阅读\n元组tuple : 通过位置来访问字段的类,用于少量元素组成元组的便捷类:Pair< K,V >, Tuple3< V1, V2, V3 >等\n\n在Crunch管线中使用记录的便捷方式是定义一个字段能够被Avro Reflect序列化的,和一个无参构造器.\n```java\npublic class WeatherRecord {\n    private int year;\n    private int temperature;\n    private String stationId;\n\n    public WeatherRecord() {\n    }\n\n    public WeatherRecord(int year, int temperature, String stationId) {\n        this.year = year;\n        this.temperature = temperature;\n        this.stationId = stationId;\n    }\n    ...\n}```\n这样就可以从PCollection< String >生成PCollection< WeatherRecord >,并利用parallelDo()将每一行文本解析到WeatherRecord中:\n```java\n        PCollection<String> lines = pipeline.read(From.textFile(inputPath));\n        PCollection<WeatherRecord> records = lines.parallelDo(new DoFn<String, WeatherRecord>() {\n                NcdcRecordParser parser = new NcdcRecordParser();\n            public void process(String s, Emitter<WeatherRecord> emitter) {\n                parser.parse(s);\n                if(parser.isValidTemperature()) {\n                    emitter.emit(new WeatherRecord(parser.getYearInt(), parser.getAirTemperature(), parser.getStationId()));\n                }\n            }\n        }, Avros.records(WeatherRecord.class));\n        //按照字段定义的顺序对记录排序\n        PCollection<WeatherRecord> sortedREcords = Sort.sort(records);```\n上段代码末尾Avro.records()方法为Avro Reflect数据类型返回了一个Crunch PType.\n\n**源和目标**\n- 读取源\nCrunch管线的起点是一个或多个Source< T >实例,它们指明了输入数据的存储位置和PType<T>,读取文本用readTextFile就可以,但是其他类型的数据源则需要使用read()方法,以Source<T>对象为输入,From类是各种文件源静态工厂方法的集合,用作为read()的参数.\n\nCrunch的数据源包括:\n * From.textFile(inputPath)\n * From.AvroFile(inputPath, Avros.records())\n * From.SequenceFile(inputPath, Writable(), Writable())\n * AvroParquetFileSource\n * FromHbase.table() 等.\n\n- 写入文件\n在写入目标时调用PCollection.write()方法,传入Traget即可,可以通过TO类的静态工厂方法来选择文件类型\n\n- 输入已存在\n如果目标文件已经存在,再调用write()方法时会引发错误, 除非在write()方法中传入参数Target.WriteMode.OVERWRITE.\n> 写入模式:\n> * OVERWRITE:管线运行前删除已存在文件\n> * APPEND:在输出目录下新建文件,保留旧文件,通过文件名区分新旧文件\n> * CHECKPOINT:将当前工作保存在一个文件中,从而使新管线可从检查点而不是管线起点开始执行.\n\n- 组合的源和目标\n希望一个文件既作为写入目标又作为读取的源,在AT类中有一些静态方法可用于创建SourceTarget实例.\n\n**函数**\n- 函数序列化\nCrunch在管线执行时将所有DoFn实例都序列化到一个文件中,并通过Hadoop分布式缓存机制将文件分发给各任务节点,然后任务本身反序列化,使得能被调用.因此,需要确保自己的DoFn实现能通过标准的Java序列化机制进行序列化.\n如果DoFn作为内部类被定义在没有实现Serializable的外部类中,会出现问题.\n如果函数依赖于一个以实例变量形式表示的非序列化状态,且他的类没有被Serializable,这种情况下将该实例标为transient(瞬态),从而不会序列化该状态.\n\n- 对象重用\n在MR中,reducer的值迭代器中的对象是可重用的,其目的是为了提高效率,对于PGroupedTable的conbineValues()和mapValues()方法的迭代器来说,Crunch有相同的行为.因此想要在迭代器外部引用一个对象,就应当复制该对象,以避免对象标识错误.\n> 可重用:[reduce方法会反复执行多次，但key和value相关的对象只有两个，reduce会反复重用这两个对象。所以如果要保存key或者value的结果，只能将其中的值取出另存或者重新clone一个对象（例如Text store = new Text(value) 或者 String a = value.toString()），而不能直接赋引用。因为引用从始至终都是指向同一个对象，你如果直接保存它们，那最后它们都指向最后一个输入记录。会影响最终计算结果而出错。](http://blog.csdn.net/fxdaniel/article/details/50255197)\n```java\n public static <K,V> PTable<K,Collection<V>> uniqueValues(PTable<K, V> table) {\n        PTypeFamily tf = table.getTypeFamily();\n        final PType<V> valueType = table.getValueType();\n        return table.groupByKey().mapValues(\"unique\", new MapFn<Iterable<V>, Collection<V>>() {\n            @Override\n            public void initialize() {\n                valueType.initialize(getConfiguration());//初始化PType使其能够访问配置以执行复制操作\n            }\n            @Override\n            public Collection<V> map(Iterable<V> vs) {\n                Set<V> collected = new HashSet<V>();\n                for(V value : vs){\n                    collected.add(valueType.getDetachedValue(value));//PType.getDetachedValue()复制JAVA类.\n                }\n                return collected;\n            }\n        },tf.collections(table.getValueType()));\n    }```\n\n**物化**\n\n物化(Materlization)是让PCollection中的值变得可用的过程,只有物化后的值才能被程序读取\n物化最直接的方法是调用PCollection.materialize(),它返回了一个Iterable集合.\n```java\n Pipeline pipeline = new MRPipeline(getClass());\n    PCollection<String> lines = pipeline.readTextFile(inputPath);\n    PCollection<String> lower = lines.parallelDo(new ToLowerFn(), strings());\n\n    Iterable<String> materialized = lower.materialize();\n    for (String s : materialized) { // pipeline从这个位置开始执行\n      System.out.println(s);\n    }```\n 调用materlize并不会导致管线执行,只有从Iterable中创建一个Iterator后,Crunch才执行管线,执行完毕后才执行迭代操作.\n\n* PObject\n  物化PCollection的另一种方式是使用PObject,PObject<T>是一个被标记为future的对象,程序在创建PObject时,类型为T的值得计算可能还未完成.计算结果调用getValue()方法获取,计算完成之前他会一直处于阻塞状态.\n ```java\n    Pipeline pipeline = new MRPipeline(getClass());\n    PCollection<String> lines = pipeline.readTextFile(inputPath);\n    PCollection<String> lower = lines.parallelDo(new ToLowerFn(), strings());\n\n    PObject<Collection<String>> po = lower.asCollection();\n    for (String s : po.getValue()) { // pipeline is run\n      System.out.println(s);\n    }\n    assertEquals(expectedContent, po.getValue());\n\n    System.out.println(\"About to call done()\");\n    PipelineResult result = pipeline.done();```\n   asCollection()方法将PCollection<T>变换为普通的Java Collection<T>.\n\n管线执行\n---\n管线构建期间,Crunch会建立一个内部执行计划,每个计划都是由PCollection操作构成的一个有向无环图,每个计划内的PCollection都与产生它的操作之间存在引用关系,另外,每个PCollection都有一个内部状态,用于记录他是否已被物化.\n**运行管线**\n调用Pipeline.run()可以显式执行管线操作,步骤:\n优化处理,将执行计划分为若干阶段 --> 执行优化计划中的各阶段,使得到的PCololection物化(此时可能会得到中间文件) --> 向调用者返回PipelineResult对象,包含每个阶段的信息以及管线是否成功.\nclean()清除物化PCollection时创建的临时中间文件.\ndone() = 先run()后clean()\nrunAsync()是run()的配对方法,它在管线启动后立刻返回,返回类型是PipelineExecution,它实现了Future< PiplineResult >.\n```java\n        pipeline.writeTextFile(table, tmpDir.getFileName(\"output\"));\n        PipelineExecution execution = pipeline.runAsync();\n        PipelineResult result = execution.get();\n        assertTrue(result.succeeded());```\n**停止管线**\n为了正确停止管线,需要异步启动该管线,以保留对PipelineExecution对象的引用.\n`PipelineExecution execution = pipeline.runAsync();`\n这种情况调用kill()方法并等待其完成即可关闭管线.这样管线在此之前运行在这个集群上的所有作业都将被杀死\n```java\nexecution.kill();\nexecution.waitUntilDone();\n```\n**查看Crunch计划**\n通过 PipelineExecution.getPlanDotFile()可以获得一个以字符串形式表现的管线操作图的DOT文件.\n另一种在隐式运行的管线中获取操作图的方式是将DOT文件的表示存储在作业配置中,一边在管线执行完后检查.\n```JAVA\n        PCollection<String> lines = pipeline.readTextFile(inputPath);\n        PCollection<String> lower = lines.parallelDo(\"lower\", new ToLowerFn(), strings());\n        PTable<String, Long> counts = lower.count();\n        PTable<Long, String> inverseCounts = counts.parallelDo(\"inverse\", new InversePairFn<String, Long>(), tableOf(longs(), strings()));\n        PTable<Long, Integer> hist = inverseCounts.groupByKey().mapValues(\"count values\", new CountValuesFn<String>(), ints());\n        hist.write(To.textFile(outputPath), Target.WriteMode.OVERWRITE);\n        PipelineExecution execution = pipeline.runAsync();\n        String dot = execution.getPlanDotFile();\n        Files.write(dot, dotFile(), Charsets.UTF_8);\n        execution.waitUntilDone();\n        pipeline.done();```\n用命令`dot -Tpng -O *.dot`将.dot文件转换为.png文件\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-21/79771268.jpg)\n\n每个GBK操作将作为MapReduce的混洗步骤实现.\n","source":"_posts/关于Crunch.md","raw":"---\ntitle: 关于Crunch\ndate: 2018-03-21 10:20:16\ntags: [Hadoop, 大数据, Crunch]\n---\n> 本篇文章主要来自<<Hadoop权威指南>>Crunch部分学习笔记\n\nCrunch是用来写MapReduce管线的高层API,它注重程序员友好的JAVA类型和旧式的纯JAVA对象,还有一组丰富的数据变换操作和多级管线.因为Crunch位于上层,故Crunch管线是高度可组合的,可以把常用功能提取到库中给其他程序重用.Crunch不依赖于MapReduce,也可以用Spark作为分布式引擎来运行Crunch管线.\n  <!-- more-->\n示例\n---\n以如下实例引出基本概念:\n```java\nimport org.apache.crunch.*;\nimport org.apache.crunch.fn.Aggregators;\nimport org.apache.crunch.impl.mr.MRPipeline;\nimport org.apache.crunch.io.To;\n\nimport static org.apache.crunch.types.writable.Writables.*;\n\npublic class MaxTemperatureCrunch {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.err.printf(\"Usage: MaxtemperatureCrunch <input> <output>\");\n            System.exit(-1);\n        }\n\n        Pipeline pipeline = new MRPipeline(MaxTemperatureCrunch.class);\n        PCollection<String> records = pipeline.readTextFile(args[0]);\n        PTable<String, Integer> yearTemperatures = records.parallelDo(toYearTemPairFn(), tableOf(strings(), ints()));\n        PTable<String, Integer> maxTemps = yearTemperatures.groupByKey().combineValues(Aggregators.MAX_INTS());\n        maxTemps.write(To.textFile(args[1]));\n        PipelineResult result = pipeline.done();\n        System.exit(result.succeeded() ? 0 : 1);\n    }\n\n    static DoFn<String, Pair<String, Integer>> toYearTemPairFn() {\n       return new DoFn<String, Pair<String, Integer>>() {\n           NcdcRecordParser parser = new NcdcRecordParser();\n           @Override\n           public void process(String input, Emitter<Pair<String, Integer>> emitter) {\n               parser.parse(input);\n               if (parser.isValidTemperature()) {\n                   emitter.emit(Pair.of(parser.getYear(), parser.getAirTemperature()));\n               }\n           }\n       };\n    }\n}\n```\n先构建Crunch pipline对象,代表希望运行的计算, pipeline可以有多个阶段,即具有多个输入,输出,分支和迭代都是有可能的.\n\n使用MapReduce运行管线,因此创建MRPipeline,也可使用MemPipeline在内存中运行管线或者SparkPipeline运行在Spark中.\n\nPipeline.readTextFile()可以将文本文件转换为String类型的PCollection对象,每个String代表一行文本.\n\nPCollection< S >是最基本的Crunch数据类型,表示由S型元素组成的*不可修改*且*无序*的分布式集合,可被视为非物化的Collection,因为*它的元素没有被读取到内存*.Crunch对PCollection做各种操作并产生一个新的PCollection.\nPCollection.parallellDo()为PCollection中的*每个元素*都执行某种操作,返回一个新的PCollection.\nParallelDo()的方法签名如下:\n>`<T> PCollection <T> parallelDo(DoFn <S, T> var1, PType <T> var2);`\n\n第二个参数PType< T >向Crunch传递有关T的java类型以及如何序列化该类型的信息\nPTable < K,V >是一个扩展的PCollection,它是由键值对构成的分布式multi-map,可以具有重复键值对.\nPTable.GroupBy执行的是MR的shuffle操作,按键对表分组,返回PGroupedTable < K,V >,它的combineValues()方法能把一个键的所有值聚合起来,就像MR中reducer做的那样.\n管线的最后一步操作就是调用write()将表写入文件,write()输入就是通过静态工厂TO的textFile方法创建的一个文本文件对象,实际上使用了TextOutputFormat格式来完成这个操作.\n为了执行管线,必须调用done()方法,程序阻塞直至管线执行完毕.\n\nCrunch核心API\n---\n**基本操作**\n- union() : 对两个PCollection进行\"并集\"操作(如果两个PCollection中有相同的元素,这个元素在union后会出现多次),进行union()操作时他们必须由同一管线创建,并且具有相同的类型.\n```java\nPCollection<Integer> a = MemPipeline.collectionOf(1, 2, 3);\nPCollection<Integer> b = MemPipeline.collectionOf(2);\nPCollection<Integer> c = a.union(b);\nassertEquals(\"{2,1,2,3}\", dump(c));```\n- parallelDo() : 为输入的PCollection< S >中的每个元素调用某个函数,并返回包含该调用结果的一个新的输出PCollection<T>.\n ```java\n        PCollection<String> a = MemPipeline.collectionOf(\"cherry\", \"apple\", \"banana\");\n        PCollection<Integer> b = a.parallelDo(new MapFn<String, Integer>() {\n            @Override\n            public Integer map(String input) {\n                return input.length();\n            }\n        }, ints());\n        assertEquals(\"{6,5,6}\", dump(b));```\nparallelDo常用来过滤在后续步骤中不需要的数据,Crunch专门提供了filter()方法,参数是一个特殊DoFn,为FilterFn,只用实现accept()即可只是是否保留该数据到输出中,他的方法签名没有PType,因为输入与输出类型相同.\n```java\n        PCollection<String> a = MemPipeline.collectionOf(\"cherry\", \"apple\", \"banana\");\n        PCollection<String> b = a.filter(new FilterFn<String>() {\n            @Override\n            public boolean accept(String s) {\n                return s.length() %2 == 0;\n            }\n        });\n        assertEquals(\"{cherry,banana}\", dump(b));```\n从由某些值构成的PCollection中提取键以形成一个PTable是常见操作,Crunch为此提供了by()方法,参数是MapFn()< S, K >,将值映S射成键K.\n```java\n        PCollection<String> a = MemPipeline.typedCollectionOf(strings(), \"cherry\", \"apple\",\n                \"banana\");\n        PTable<Integer,String> b = a.by(new MapFn<String, Integer>() {\n            @Override\n            public Integer map(String input) {\n                return input.length();\n            }\n        }, ints());\n        assertEquals(\"{(6,cherry),(5,apple),(6,banana)}\", dump(b));\n```\n- groupByKey() : 把PTable< K,V >中具有相同键的所有值聚合起来,可以看做MR中的混洗操作,返回PGroupedTable< K,V >,Crunch可以根据表的大小为groupByKey()设置分区数量,也可以通过重载groupByKey(int i)指定分区数量.\n```java\n        PGroupedTable<Integer,String> c = b.groupByKey();\n        assertEquals(\"{(5,[apple]),(6,[cherry,banana])}\", dump(c));```\n- combineValues() : 最常见以组合函数CombineFn< K,V >作为输入,CombineFn< K,V >就是`DoFn<Pair<K,Iterable<V>>, Pair<K,V>>`的简写,返回一个```PTable<K,V>```\n```java\n        PTable<Integer, String> d = c.combineValues(new CombineFn<Integer, String>() {\n            @Override\n            public void process(Pair<Integer, Iterable<String>> integerIterablePair, Emitter<Pair<Integer, String>> emitter) {\n                StringBuilder sb = new StringBuilder();\n                for (Iterator i = integerIterablePair.second().iterator(); i.hasNext(); ) {\n                    sb.append(i.next());\n                    if(i.hasNext())\n                        sb.append(\";\");\n                }\n                emitter.emit(Pair.of(integerIterablePair.first(), sb.toString()));\n            }\n        });\n        assertEquals(\"{(5,apple),(6,cherry;banana)}\", dump(d));```\n由于没有对键进行改变,可以使用重载的combineValues(),以Aggregator对象作为输入,仅对值进行操作,可以使用Aggregators内置的Aggregator实现操作,比如之前的Aggregators.MAX_INTS().\n```java\n        PTable<Integer, String> e = c.combineValues(Aggregators.STRING_CONCAT(\";\",false));\n        assertEquals(\"{(5,apple),(6,cherry;banana)}\", dump(e));```\n想要聚合PGroupedTable中的值并返回一个与被分组的值的类型不同的结果,可用mapValues()实现,\n```java\n PTable<Integer, Integer> f = c.mapValues(new MapFn<Iterable<String>, Integer>() {\n            @Override\n            public Integer map(Iterable<String> strings) {\n                return Iterables.size(strings);\n            }\n        },ints());\n        assertEquals(\"{(5,1),(6,2)}\", dump(f));```\ncombineValues()可被当作MR的combiner来运行,而mapValues()被解释为ParallelDo()操作,只能在reduce端运行.\n\n**类型**\n\n每个PCollection< S >都有一个关联的类PType< S >,用于封装有关PCollection中的元素类型的信息,也给出了从持久化存储器读取到PCollection的序列化格式和反方向的序列化格式.\n两个PType家族,用哪个取决于管线的文件格式,都可用于文本文件:\n1. Hadoop Writables: 顺序文件\n2. Avro: Avro数据文件\n\nPCollection使用的PType在PCollection创建时指定,有时隐式指定,例如读取文本文件时使用默认的Writables.\n\n*记录和元组*\n记录record : 通过名称来访问字段的类,用记录写的Crunch程序更易于理解和阅读\n元组tuple : 通过位置来访问字段的类,用于少量元素组成元组的便捷类:Pair< K,V >, Tuple3< V1, V2, V3 >等\n\n在Crunch管线中使用记录的便捷方式是定义一个字段能够被Avro Reflect序列化的,和一个无参构造器.\n```java\npublic class WeatherRecord {\n    private int year;\n    private int temperature;\n    private String stationId;\n\n    public WeatherRecord() {\n    }\n\n    public WeatherRecord(int year, int temperature, String stationId) {\n        this.year = year;\n        this.temperature = temperature;\n        this.stationId = stationId;\n    }\n    ...\n}```\n这样就可以从PCollection< String >生成PCollection< WeatherRecord >,并利用parallelDo()将每一行文本解析到WeatherRecord中:\n```java\n        PCollection<String> lines = pipeline.read(From.textFile(inputPath));\n        PCollection<WeatherRecord> records = lines.parallelDo(new DoFn<String, WeatherRecord>() {\n                NcdcRecordParser parser = new NcdcRecordParser();\n            public void process(String s, Emitter<WeatherRecord> emitter) {\n                parser.parse(s);\n                if(parser.isValidTemperature()) {\n                    emitter.emit(new WeatherRecord(parser.getYearInt(), parser.getAirTemperature(), parser.getStationId()));\n                }\n            }\n        }, Avros.records(WeatherRecord.class));\n        //按照字段定义的顺序对记录排序\n        PCollection<WeatherRecord> sortedREcords = Sort.sort(records);```\n上段代码末尾Avro.records()方法为Avro Reflect数据类型返回了一个Crunch PType.\n\n**源和目标**\n- 读取源\nCrunch管线的起点是一个或多个Source< T >实例,它们指明了输入数据的存储位置和PType<T>,读取文本用readTextFile就可以,但是其他类型的数据源则需要使用read()方法,以Source<T>对象为输入,From类是各种文件源静态工厂方法的集合,用作为read()的参数.\n\nCrunch的数据源包括:\n * From.textFile(inputPath)\n * From.AvroFile(inputPath, Avros.records())\n * From.SequenceFile(inputPath, Writable(), Writable())\n * AvroParquetFileSource\n * FromHbase.table() 等.\n\n- 写入文件\n在写入目标时调用PCollection.write()方法,传入Traget即可,可以通过TO类的静态工厂方法来选择文件类型\n\n- 输入已存在\n如果目标文件已经存在,再调用write()方法时会引发错误, 除非在write()方法中传入参数Target.WriteMode.OVERWRITE.\n> 写入模式:\n> * OVERWRITE:管线运行前删除已存在文件\n> * APPEND:在输出目录下新建文件,保留旧文件,通过文件名区分新旧文件\n> * CHECKPOINT:将当前工作保存在一个文件中,从而使新管线可从检查点而不是管线起点开始执行.\n\n- 组合的源和目标\n希望一个文件既作为写入目标又作为读取的源,在AT类中有一些静态方法可用于创建SourceTarget实例.\n\n**函数**\n- 函数序列化\nCrunch在管线执行时将所有DoFn实例都序列化到一个文件中,并通过Hadoop分布式缓存机制将文件分发给各任务节点,然后任务本身反序列化,使得能被调用.因此,需要确保自己的DoFn实现能通过标准的Java序列化机制进行序列化.\n如果DoFn作为内部类被定义在没有实现Serializable的外部类中,会出现问题.\n如果函数依赖于一个以实例变量形式表示的非序列化状态,且他的类没有被Serializable,这种情况下将该实例标为transient(瞬态),从而不会序列化该状态.\n\n- 对象重用\n在MR中,reducer的值迭代器中的对象是可重用的,其目的是为了提高效率,对于PGroupedTable的conbineValues()和mapValues()方法的迭代器来说,Crunch有相同的行为.因此想要在迭代器外部引用一个对象,就应当复制该对象,以避免对象标识错误.\n> 可重用:[reduce方法会反复执行多次，但key和value相关的对象只有两个，reduce会反复重用这两个对象。所以如果要保存key或者value的结果，只能将其中的值取出另存或者重新clone一个对象（例如Text store = new Text(value) 或者 String a = value.toString()），而不能直接赋引用。因为引用从始至终都是指向同一个对象，你如果直接保存它们，那最后它们都指向最后一个输入记录。会影响最终计算结果而出错。](http://blog.csdn.net/fxdaniel/article/details/50255197)\n```java\n public static <K,V> PTable<K,Collection<V>> uniqueValues(PTable<K, V> table) {\n        PTypeFamily tf = table.getTypeFamily();\n        final PType<V> valueType = table.getValueType();\n        return table.groupByKey().mapValues(\"unique\", new MapFn<Iterable<V>, Collection<V>>() {\n            @Override\n            public void initialize() {\n                valueType.initialize(getConfiguration());//初始化PType使其能够访问配置以执行复制操作\n            }\n            @Override\n            public Collection<V> map(Iterable<V> vs) {\n                Set<V> collected = new HashSet<V>();\n                for(V value : vs){\n                    collected.add(valueType.getDetachedValue(value));//PType.getDetachedValue()复制JAVA类.\n                }\n                return collected;\n            }\n        },tf.collections(table.getValueType()));\n    }```\n\n**物化**\n\n物化(Materlization)是让PCollection中的值变得可用的过程,只有物化后的值才能被程序读取\n物化最直接的方法是调用PCollection.materialize(),它返回了一个Iterable集合.\n```java\n Pipeline pipeline = new MRPipeline(getClass());\n    PCollection<String> lines = pipeline.readTextFile(inputPath);\n    PCollection<String> lower = lines.parallelDo(new ToLowerFn(), strings());\n\n    Iterable<String> materialized = lower.materialize();\n    for (String s : materialized) { // pipeline从这个位置开始执行\n      System.out.println(s);\n    }```\n 调用materlize并不会导致管线执行,只有从Iterable中创建一个Iterator后,Crunch才执行管线,执行完毕后才执行迭代操作.\n\n* PObject\n  物化PCollection的另一种方式是使用PObject,PObject<T>是一个被标记为future的对象,程序在创建PObject时,类型为T的值得计算可能还未完成.计算结果调用getValue()方法获取,计算完成之前他会一直处于阻塞状态.\n ```java\n    Pipeline pipeline = new MRPipeline(getClass());\n    PCollection<String> lines = pipeline.readTextFile(inputPath);\n    PCollection<String> lower = lines.parallelDo(new ToLowerFn(), strings());\n\n    PObject<Collection<String>> po = lower.asCollection();\n    for (String s : po.getValue()) { // pipeline is run\n      System.out.println(s);\n    }\n    assertEquals(expectedContent, po.getValue());\n\n    System.out.println(\"About to call done()\");\n    PipelineResult result = pipeline.done();```\n   asCollection()方法将PCollection<T>变换为普通的Java Collection<T>.\n\n管线执行\n---\n管线构建期间,Crunch会建立一个内部执行计划,每个计划都是由PCollection操作构成的一个有向无环图,每个计划内的PCollection都与产生它的操作之间存在引用关系,另外,每个PCollection都有一个内部状态,用于记录他是否已被物化.\n**运行管线**\n调用Pipeline.run()可以显式执行管线操作,步骤:\n优化处理,将执行计划分为若干阶段 --> 执行优化计划中的各阶段,使得到的PCololection物化(此时可能会得到中间文件) --> 向调用者返回PipelineResult对象,包含每个阶段的信息以及管线是否成功.\nclean()清除物化PCollection时创建的临时中间文件.\ndone() = 先run()后clean()\nrunAsync()是run()的配对方法,它在管线启动后立刻返回,返回类型是PipelineExecution,它实现了Future< PiplineResult >.\n```java\n        pipeline.writeTextFile(table, tmpDir.getFileName(\"output\"));\n        PipelineExecution execution = pipeline.runAsync();\n        PipelineResult result = execution.get();\n        assertTrue(result.succeeded());```\n**停止管线**\n为了正确停止管线,需要异步启动该管线,以保留对PipelineExecution对象的引用.\n`PipelineExecution execution = pipeline.runAsync();`\n这种情况调用kill()方法并等待其完成即可关闭管线.这样管线在此之前运行在这个集群上的所有作业都将被杀死\n```java\nexecution.kill();\nexecution.waitUntilDone();\n```\n**查看Crunch计划**\n通过 PipelineExecution.getPlanDotFile()可以获得一个以字符串形式表现的管线操作图的DOT文件.\n另一种在隐式运行的管线中获取操作图的方式是将DOT文件的表示存储在作业配置中,一边在管线执行完后检查.\n```JAVA\n        PCollection<String> lines = pipeline.readTextFile(inputPath);\n        PCollection<String> lower = lines.parallelDo(\"lower\", new ToLowerFn(), strings());\n        PTable<String, Long> counts = lower.count();\n        PTable<Long, String> inverseCounts = counts.parallelDo(\"inverse\", new InversePairFn<String, Long>(), tableOf(longs(), strings()));\n        PTable<Long, Integer> hist = inverseCounts.groupByKey().mapValues(\"count values\", new CountValuesFn<String>(), ints());\n        hist.write(To.textFile(outputPath), Target.WriteMode.OVERWRITE);\n        PipelineExecution execution = pipeline.runAsync();\n        String dot = execution.getPlanDotFile();\n        Files.write(dot, dotFile(), Charsets.UTF_8);\n        execution.waitUntilDone();\n        pipeline.done();```\n用命令`dot -Tpng -O *.dot`将.dot文件转换为.png文件\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-21/79771268.jpg)\n\n每个GBK操作将作为MapReduce的混洗步骤实现.\n","slug":"关于Crunch","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6w0017cf966mlfjki3","content":"<blockquote>\n<p>本篇文章主要来自&lt;&lt;Hadoop权威指南&gt;&gt;Crunch部分学习笔记</p>\n</blockquote>\n<p>Crunch是用来写MapReduce管线的高层API,它注重程序员友好的JAVA类型和旧式的纯JAVA对象,还有一组丰富的数据变换操作和多级管线.因为Crunch位于上层,故Crunch管线是高度可组合的,可以把常用功能提取到库中给其他程序重用.Crunch不依赖于MapReduce,也可以用Spark作为分布式引擎来运行Crunch管线.<br>  <a id=\"more\"></a></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>以如下实例引出基本概念:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.fn.Aggregators;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.impl.mr.MRPipeline;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.io.To;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.crunch.types.writable.Writables.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxTemperatureCrunch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            System.err.printf(<span class=\"string\">\"Usage: MaxtemperatureCrunch &lt;input&gt; &lt;output&gt;\"</span>);</span><br><span class=\"line\">            System.exit(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Pipeline pipeline = <span class=\"keyword\">new</span> MRPipeline(MaxTemperatureCrunch.class);</span><br><span class=\"line\">        PCollection&lt;String&gt; records = pipeline.readTextFile(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        PTable&lt;String, Integer&gt; yearTemperatures = records.parallelDo(toYearTemPairFn(), tableOf(strings(), ints()));</span><br><span class=\"line\">        PTable&lt;String, Integer&gt; maxTemps = yearTemperatures.groupByKey().combineValues(Aggregators.MAX_INTS());</span><br><span class=\"line\">        maxTemps.write(To.textFile(args[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        PipelineResult result = pipeline.done();</span><br><span class=\"line\">        System.exit(result.succeeded() ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> DoFn&lt;String, Pair&lt;String, Integer&gt;&gt; toYearTemPairFn() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DoFn&lt;String, Pair&lt;String, Integer&gt;&gt;() &#123;</span><br><span class=\"line\">           NcdcRecordParser parser = <span class=\"keyword\">new</span> NcdcRecordParser();</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(String input, Emitter&lt;Pair&lt;String, Integer&gt;&gt; emitter)</span> </span>&#123;</span><br><span class=\"line\">               parser.parse(input);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (parser.isValidTemperature()) &#123;</span><br><span class=\"line\">                   emitter.emit(Pair.of(parser.getYear(), parser.getAirTemperature()));</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先构建Crunch pipline对象,代表希望运行的计算, pipeline可以有多个阶段,即具有多个输入,输出,分支和迭代都是有可能的.</p>\n<p>使用MapReduce运行管线,因此创建MRPipeline,也可使用MemPipeline在内存中运行管线或者SparkPipeline运行在Spark中.</p>\n<p>Pipeline.readTextFile()可以将文本文件转换为String类型的PCollection对象,每个String代表一行文本.</p>\n<p>PCollection&lt; S &gt;是最基本的Crunch数据类型,表示由S型元素组成的<em>不可修改</em>且<em>无序</em>的分布式集合,可被视为非物化的Collection,因为<em>它的元素没有被读取到内存</em>.Crunch对PCollection做各种操作并产生一个新的PCollection.<br>PCollection.parallellDo()为PCollection中的<em>每个元素</em>都执行某种操作,返回一个新的PCollection.<br>ParallelDo()的方法签名如下:</p>\n<blockquote>\n<p><code>&lt;T&gt; PCollection &lt;T&gt; parallelDo(DoFn &lt;S, T&gt; var1, PType &lt;T&gt; var2);</code></p>\n</blockquote>\n<p>第二个参数PType&lt; T &gt;向Crunch传递有关T的java类型以及如何序列化该类型的信息<br>PTable &lt; K,V &gt;是一个扩展的PCollection,它是由键值对构成的分布式multi-map,可以具有重复键值对.<br>PTable.GroupBy执行的是MR的shuffle操作,按键对表分组,返回PGroupedTable &lt; K,V &gt;,它的combineValues()方法能把一个键的所有值聚合起来,就像MR中reducer做的那样.<br>管线的最后一步操作就是调用write()将表写入文件,write()输入就是通过静态工厂TO的textFile方法创建的一个文本文件对象,实际上使用了TextOutputFormat格式来完成这个操作.<br>为了执行管线,必须调用done()方法,程序阻塞直至管线执行完毕.</p>\n<h2 id=\"Crunch核心API\"><a href=\"#Crunch核心API\" class=\"headerlink\" title=\"Crunch核心API\"></a>Crunch核心API</h2><p><strong>基本操作</strong></p>\n<ul>\n<li><p>union() : 对两个PCollection进行”并集”操作(如果两个PCollection中有相同的元素,这个元素在union后会出现多次),进行union()操作时他们必须由同一管线创建,并且具有相同的类型.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;Integer&gt; a = MemPipeline.collectionOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">PCollection&lt;Integer&gt; b = MemPipeline.collectionOf(<span class=\"number\">2</span>);</span><br><span class=\"line\">PCollection&lt;Integer&gt; c = a.union(b);</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;2,1,2,3&#125;\"</span>, dump(c));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>parallelDo() : 为输入的PCollection&lt; S &gt;中的每个元素调用某个函数,并返回包含该调用结果的一个新的输出PCollection<t>.</t></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; a = MemPipeline.collectionOf(<span class=\"string\">\"cherry\"</span>, <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"banana\"</span>);</span><br><span class=\"line\">PCollection&lt;Integer&gt; b = a.parallelDo(<span class=\"keyword\">new</span> MapFn&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">map</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, ints());</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;6,5,6&#125;\"</span>, dump(b));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>parallelDo常用来过滤在后续步骤中不需要的数据,Crunch专门提供了filter()方法,参数是一个特殊DoFn,为FilterFn,只用实现accept()即可只是是否保留该数据到输出中,他的方法签名没有PType,因为输入与输出类型相同.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; a = MemPipeline.collectionOf(<span class=\"string\">\"cherry\"</span>, <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"banana\"</span>);</span><br><span class=\"line\">PCollection&lt;String&gt; b = a.filter(<span class=\"keyword\">new</span> FilterFn&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">accept</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.length() %<span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;cherry,banana&#125;\"</span>, dump(b));</span><br></pre></td></tr></table></figure></p>\n<p>从由某些值构成的PCollection中提取键以形成一个PTable是常见操作,Crunch为此提供了by()方法,参数是MapFn()&lt; S, K &gt;,将值映S射成键K.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; a = MemPipeline.typedCollectionOf(strings(), <span class=\"string\">\"cherry\"</span>, <span class=\"string\">\"apple\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"banana\"</span>);</span><br><span class=\"line\">PTable&lt;Integer,String&gt; b = a.by(<span class=\"keyword\">new</span> MapFn&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">map</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, ints());</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;(6,cherry),(5,apple),(6,banana)&#125;\"</span>, dump(b));</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>groupByKey() : 把PTable&lt; K,V &gt;中具有相同键的所有值聚合起来,可以看做MR中的混洗操作,返回PGroupedTable&lt; K,V &gt;,Crunch可以根据表的大小为groupByKey()设置分区数量,也可以通过重载groupByKey(int i)指定分区数量.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PGroupedTable&lt;Integer,String&gt; c = b.groupByKey();</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;(5,[apple]),(6,[cherry,banana])&#125;\"</span>, dump(c));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>combineValues() : 最常见以组合函数CombineFn&lt; K,V &gt;作为输入,CombineFn&lt; K,V &gt;就是<code>DoFn&lt;Pair&lt;K,Iterable&lt;V&gt;&gt;, Pair&lt;K,V&gt;&gt;</code>的简写,返回一个<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```java</span><br><span class=\"line\">        PTable&lt;Integer, String&gt; d = c.combineValues(new CombineFn&lt;Integer, String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void process(Pair&lt;Integer, Iterable&lt;String&gt;&gt; integerIterablePair, Emitter&lt;Pair&lt;Integer, String&gt;&gt; emitter) &#123;</span><br><span class=\"line\">                StringBuilder sb = new StringBuilder();</span><br><span class=\"line\">                for (Iterator i = integerIterablePair.second().iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">                    sb.append(i.next());</span><br><span class=\"line\">                    if(i.hasNext())</span><br><span class=\"line\">                        sb.append(&quot;;&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                emitter.emit(Pair.of(integerIterablePair.first(), sb.toString()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        assertEquals(&quot;&#123;(5,apple),(6,cherry;banana)&#125;&quot;, dump(d));</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p>由于没有对键进行改变,可以使用重载的combineValues(),以Aggregator对象作为输入,仅对值进行操作,可以使用Aggregators内置的Aggregator实现操作,比如之前的Aggregators.MAX_INTS().<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTable&lt;Integer, String&gt; e = c.combineValues(Aggregators.STRING_CONCAT(<span class=\"string\">\";\"</span>,<span class=\"keyword\">false</span>));</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;(5,apple),(6,cherry;banana)&#125;\"</span>, dump(e));</span><br></pre></td></tr></table></figure></p>\n<p>想要聚合PGroupedTable中的值并返回一个与被分组的值的类型不同的结果,可用mapValues()实现,<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTable&lt;Integer, Integer&gt; f = c.mapValues(<span class=\"keyword\">new</span> MapFn&lt;Iterable&lt;String&gt;, Integer&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">map</span><span class=\"params\">(Iterable&lt;String&gt; strings)</span> </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Iterables.size(strings);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;,ints());</span><br><span class=\"line\">       assertEquals(<span class=\"string\">\"&#123;(5,1),(6,2)&#125;\"</span>, dump(f));</span><br></pre></td></tr></table></figure></p>\n<p>combineValues()可被当作MR的combiner来运行,而mapValues()被解释为ParallelDo()操作,只能在reduce端运行.</p>\n<p><strong>类型</strong></p>\n<p>每个PCollection&lt; S &gt;都有一个关联的类PType&lt; S &gt;,用于封装有关PCollection中的元素类型的信息,也给出了从持久化存储器读取到PCollection的序列化格式和反方向的序列化格式.<br>两个PType家族,用哪个取决于管线的文件格式,都可用于文本文件:</p>\n<ol>\n<li>Hadoop Writables: 顺序文件</li>\n<li>Avro: Avro数据文件</li>\n</ol>\n<p>PCollection使用的PType在PCollection创建时指定,有时隐式指定,例如读取文本文件时使用默认的Writables.</p>\n<p><em>记录和元组</em><br>记录record : 通过名称来访问字段的类,用记录写的Crunch程序更易于理解和阅读<br>元组tuple : 通过位置来访问字段的类,用于少量元素组成元组的便捷类:Pair&lt; K,V &gt;, Tuple3&lt; V1, V2, V3 &gt;等</p>\n<p>在Crunch管线中使用记录的便捷方式是定义一个字段能够被Avro Reflect序列化的,和一个无参构造器.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherRecord</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> year;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> temperature;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String stationId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherRecord</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherRecord</span><span class=\"params\">(<span class=\"keyword\">int</span> year, <span class=\"keyword\">int</span> temperature, String stationId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.year = year;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temperature;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stationId = stationId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以从PCollection&lt; String &gt;生成PCollection&lt; WeatherRecord &gt;,并利用parallelDo()将每一行文本解析到WeatherRecord中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; lines = pipeline.read(From.textFile(inputPath));</span><br><span class=\"line\">PCollection&lt;WeatherRecord&gt; records = lines.parallelDo(<span class=\"keyword\">new</span> DoFn&lt;String, WeatherRecord&gt;() &#123;</span><br><span class=\"line\">        NcdcRecordParser parser = <span class=\"keyword\">new</span> NcdcRecordParser();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(String s, Emitter&lt;WeatherRecord&gt; emitter)</span> </span>&#123;</span><br><span class=\"line\">        parser.parse(s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parser.isValidTemperature()) &#123;</span><br><span class=\"line\">            emitter.emit(<span class=\"keyword\">new</span> WeatherRecord(parser.getYearInt(), parser.getAirTemperature(), parser.getStationId()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, Avros.records(WeatherRecord.class));</span><br><span class=\"line\"><span class=\"comment\">//按照字段定义的顺序对记录排序</span></span><br><span class=\"line\">PCollection&lt;WeatherRecord&gt; sortedREcords = Sort.sort(records);</span><br></pre></td></tr></table></figure></p>\n<p>上段代码末尾Avro.records()方法为Avro Reflect数据类型返回了一个Crunch PType.</p>\n<p><strong>源和目标</strong></p>\n<ul>\n<li>读取源<br>Crunch管线的起点是一个或多个Source&lt; T &gt;实例,它们指明了输入数据的存储位置和PType<t>,读取文本用readTextFile就可以,但是其他类型的数据源则需要使用read()方法,以Source<t>对象为输入,From类是各种文件源静态工厂方法的集合,用作为read()的参数.</t></t></li>\n</ul>\n<p>Crunch的数据源包括:</p>\n<ul>\n<li>From.textFile(inputPath)</li>\n<li>From.AvroFile(inputPath, Avros.records())</li>\n<li>From.SequenceFile(inputPath, Writable(), Writable())</li>\n<li>AvroParquetFileSource</li>\n<li>FromHbase.table() 等.</li>\n</ul>\n<ul>\n<li><p>写入文件<br>在写入目标时调用PCollection.write()方法,传入Traget即可,可以通过TO类的静态工厂方法来选择文件类型</p>\n</li>\n<li><p>输入已存在<br>如果目标文件已经存在,再调用write()方法时会引发错误, 除非在write()方法中传入参数Target.WriteMode.OVERWRITE.</p>\n<blockquote>\n<p>写入模式:</p>\n<ul>\n<li>OVERWRITE:管线运行前删除已存在文件</li>\n<li>APPEND:在输出目录下新建文件,保留旧文件,通过文件名区分新旧文件</li>\n<li>CHECKPOINT:将当前工作保存在一个文件中,从而使新管线可从检查点而不是管线起点开始执行.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>组合的源和目标<br>希望一个文件既作为写入目标又作为读取的源,在AT类中有一些静态方法可用于创建SourceTarget实例.</p>\n</li>\n</ul>\n<p><strong>函数</strong></p>\n<ul>\n<li><p>函数序列化<br>Crunch在管线执行时将所有DoFn实例都序列化到一个文件中,并通过Hadoop分布式缓存机制将文件分发给各任务节点,然后任务本身反序列化,使得能被调用.因此,需要确保自己的DoFn实现能通过标准的Java序列化机制进行序列化.<br>如果DoFn作为内部类被定义在没有实现Serializable的外部类中,会出现问题.<br>如果函数依赖于一个以实例变量形式表示的非序列化状态,且他的类没有被Serializable,这种情况下将该实例标为transient(瞬态),从而不会序列化该状态.</p>\n</li>\n<li><p>对象重用<br>在MR中,reducer的值迭代器中的对象是可重用的,其目的是为了提高效率,对于PGroupedTable的conbineValues()和mapValues()方法的迭代器来说,Crunch有相同的行为.因此想要在迭代器外部引用一个对象,就应当复制该对象,以避免对象标识错误.</p>\n<blockquote>\n<p>可重用:<a href=\"http://blog.csdn.net/fxdaniel/article/details/50255197\" target=\"_blank\" rel=\"noopener\">reduce方法会反复执行多次，但key和value相关的对象只有两个，reduce会反复重用这两个对象。所以如果要保存key或者value的结果，只能将其中的值取出另存或者重新clone一个对象（例如Text store = new Text(value) 或者 String a = value.toString()），而不能直接赋引用。因为引用从始至终都是指向同一个对象，你如果直接保存它们，那最后它们都指向最后一个输入记录。会影响最终计算结果而出错。</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K,V&gt; PTable&lt;K,Collection&lt;V&gt;&gt; uniqueValues(PTable&lt;K, V&gt; table) &#123;</span><br><span class=\"line\">       PTypeFamily tf = table.getTypeFamily();</span><br><span class=\"line\">       <span class=\"keyword\">final</span> PType&lt;V&gt; valueType = table.getValueType();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> table.groupByKey().mapValues(<span class=\"string\">\"unique\"</span>, <span class=\"keyword\">new</span> MapFn&lt;Iterable&lt;V&gt;, Collection&lt;V&gt;&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">               valueType.initialize(getConfiguration());<span class=\"comment\">//初始化PType使其能够访问配置以执行复制操作</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> Collection&lt;V&gt; <span class=\"title\">map</span><span class=\"params\">(Iterable&lt;V&gt; vs)</span> </span>&#123;</span><br><span class=\"line\">               Set&lt;V&gt; collected = <span class=\"keyword\">new</span> HashSet&lt;V&gt;();</span><br><span class=\"line\">               <span class=\"keyword\">for</span>(V value : vs)&#123;</span><br><span class=\"line\">                   collected.add(valueType.getDetachedValue(value));<span class=\"comment\">//PType.getDetachedValue()复制JAVA类.</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> collected;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;,tf.collections(table.getValueType()));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p><strong>物化</strong></p>\n<p>物化(Materlization)是让PCollection中的值变得可用的过程,只有物化后的值才能被程序读取<br>物化最直接的方法是调用PCollection.materialize(),它返回了一个Iterable集合.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pipeline pipeline = <span class=\"keyword\">new</span> MRPipeline(getClass());</span><br><span class=\"line\">   PCollection&lt;String&gt; lines = pipeline.readTextFile(inputPath);</span><br><span class=\"line\">   PCollection&lt;String&gt; lower = lines.parallelDo(<span class=\"keyword\">new</span> ToLowerFn(), strings());</span><br><span class=\"line\"></span><br><span class=\"line\">   Iterable&lt;String&gt; materialized = lower.materialize();</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String s : materialized) &#123; <span class=\"comment\">// pipeline从这个位置开始执行</span></span><br><span class=\"line\">     System.out.println(s);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p> 调用materlize并不会导致管线执行,只有从Iterable中创建一个Iterator后,Crunch才执行管线,执行完毕后才执行迭代操作.</p>\n<ul>\n<li><p>PObject<br>物化PCollection的另一种方式是使用PObject,PObject<t>是一个被标记为future的对象,程序在创建PObject时,类型为T的值得计算可能还未完成.计算结果调用getValue()方法获取,计算完成之前他会一直处于阻塞状态.</t></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pipeline pipeline = <span class=\"keyword\">new</span> MRPipeline(getClass());</span><br><span class=\"line\">PCollection&lt;String&gt; lines = pipeline.readTextFile(inputPath);</span><br><span class=\"line\">PCollection&lt;String&gt; lower = lines.parallelDo(<span class=\"keyword\">new</span> ToLowerFn(), strings());</span><br><span class=\"line\"></span><br><span class=\"line\">PObject&lt;Collection&lt;String&gt;&gt; po = lower.asCollection();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s : po.getValue()) &#123; <span class=\"comment\">// pipeline is run</span></span><br><span class=\"line\">  System.out.println(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">assertEquals(expectedContent, po.getValue());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"About to call done()\"</span>);</span><br><span class=\"line\">PipelineResult result = pipeline.done();</span><br></pre></td></tr></table></figure>\n<p> asCollection()方法将PCollection<t>变换为普通的Java Collection<t>.</t></t></p>\n</li>\n</ul>\n<h2 id=\"管线执行\"><a href=\"#管线执行\" class=\"headerlink\" title=\"管线执行\"></a>管线执行</h2><p>管线构建期间,Crunch会建立一个内部执行计划,每个计划都是由PCollection操作构成的一个有向无环图,每个计划内的PCollection都与产生它的操作之间存在引用关系,另外,每个PCollection都有一个内部状态,用于记录他是否已被物化.<br><strong>运行管线</strong><br>调用Pipeline.run()可以显式执行管线操作,步骤:<br>优化处理,将执行计划分为若干阶段 –&gt; 执行优化计划中的各阶段,使得到的PCololection物化(此时可能会得到中间文件) –&gt; 向调用者返回PipelineResult对象,包含每个阶段的信息以及管线是否成功.<br>clean()清除物化PCollection时创建的临时中间文件.<br>done() = 先run()后clean()<br>runAsync()是run()的配对方法,它在管线启动后立刻返回,返回类型是PipelineExecution,它实现了Future&lt; PiplineResult &gt;.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline.writeTextFile(table, tmpDir.getFileName(<span class=\"string\">\"output\"</span>));</span><br><span class=\"line\">PipelineExecution execution = pipeline.runAsync();</span><br><span class=\"line\">PipelineResult result = execution.get();</span><br><span class=\"line\">assertTrue(result.succeeded());</span><br></pre></td></tr></table></figure></p>\n<p><strong>停止管线</strong><br>为了正确停止管线,需要异步启动该管线,以保留对PipelineExecution对象的引用.<br><code>PipelineExecution execution = pipeline.runAsync();</code><br>这种情况调用kill()方法并等待其完成即可关闭管线.这样管线在此之前运行在这个集群上的所有作业都将被杀死<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execution.kill();</span><br><span class=\"line\">execution.waitUntilDone();</span><br></pre></td></tr></table></figure></p>\n<p><strong>查看Crunch计划</strong><br>通过 PipelineExecution.getPlanDotFile()可以获得一个以字符串形式表现的管线操作图的DOT文件.<br>另一种在隐式运行的管线中获取操作图的方式是将DOT文件的表示存储在作业配置中,一边在管线执行完后检查.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; lines = pipeline.readTextFile(inputPath);</span><br><span class=\"line\">PCollection&lt;String&gt; lower = lines.parallelDo(<span class=\"string\">\"lower\"</span>, <span class=\"keyword\">new</span> ToLowerFn(), strings());</span><br><span class=\"line\">PTable&lt;String, Long&gt; counts = lower.count();</span><br><span class=\"line\">PTable&lt;Long, String&gt; inverseCounts = counts.parallelDo(<span class=\"string\">\"inverse\"</span>, <span class=\"keyword\">new</span> InversePairFn&lt;String, Long&gt;(), tableOf(longs(), strings()));</span><br><span class=\"line\">PTable&lt;Long, Integer&gt; hist = inverseCounts.groupByKey().mapValues(<span class=\"string\">\"count values\"</span>, <span class=\"keyword\">new</span> CountValuesFn&lt;String&gt;(), ints());</span><br><span class=\"line\">hist.write(To.textFile(outputPath), Target.WriteMode.OVERWRITE);</span><br><span class=\"line\">PipelineExecution execution = pipeline.runAsync();</span><br><span class=\"line\">String dot = execution.getPlanDotFile();</span><br><span class=\"line\">Files.write(dot, dotFile(), Charsets.UTF_8);</span><br><span class=\"line\">execution.waitUntilDone();</span><br><span class=\"line\">pipeline.done();</span><br></pre></td></tr></table></figure></p>\n<p>用命令<code>dot -Tpng -O *.dot</code>将.dot文件转换为.png文件<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-21/79771268.jpg\" alt=\"\"></p>\n<p>每个GBK操作将作为MapReduce的混洗步骤实现.</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇文章主要来自&lt;&lt;Hadoop权威指南&gt;&gt;Crunch部分学习笔记</p>\n</blockquote>\n<p>Crunch是用来写MapReduce管线的高层API,它注重程序员友好的JAVA类型和旧式的纯JAVA对象,还有一组丰富的数据变换操作和多级管线.因为Crunch位于上层,故Crunch管线是高度可组合的,可以把常用功能提取到库中给其他程序重用.Crunch不依赖于MapReduce,也可以用Spark作为分布式引擎来运行Crunch管线.<br>","more":"</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>以如下实例引出基本概念:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.fn.Aggregators;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.impl.mr.MRPipeline;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.crunch.io.To;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.crunch.types.writable.Writables.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxTemperatureCrunch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            System.err.printf(<span class=\"string\">\"Usage: MaxtemperatureCrunch &lt;input&gt; &lt;output&gt;\"</span>);</span><br><span class=\"line\">            System.exit(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Pipeline pipeline = <span class=\"keyword\">new</span> MRPipeline(MaxTemperatureCrunch.class);</span><br><span class=\"line\">        PCollection&lt;String&gt; records = pipeline.readTextFile(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        PTable&lt;String, Integer&gt; yearTemperatures = records.parallelDo(toYearTemPairFn(), tableOf(strings(), ints()));</span><br><span class=\"line\">        PTable&lt;String, Integer&gt; maxTemps = yearTemperatures.groupByKey().combineValues(Aggregators.MAX_INTS());</span><br><span class=\"line\">        maxTemps.write(To.textFile(args[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        PipelineResult result = pipeline.done();</span><br><span class=\"line\">        System.exit(result.succeeded() ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> DoFn&lt;String, Pair&lt;String, Integer&gt;&gt; toYearTemPairFn() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DoFn&lt;String, Pair&lt;String, Integer&gt;&gt;() &#123;</span><br><span class=\"line\">           NcdcRecordParser parser = <span class=\"keyword\">new</span> NcdcRecordParser();</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(String input, Emitter&lt;Pair&lt;String, Integer&gt;&gt; emitter)</span> </span>&#123;</span><br><span class=\"line\">               parser.parse(input);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (parser.isValidTemperature()) &#123;</span><br><span class=\"line\">                   emitter.emit(Pair.of(parser.getYear(), parser.getAirTemperature()));</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先构建Crunch pipline对象,代表希望运行的计算, pipeline可以有多个阶段,即具有多个输入,输出,分支和迭代都是有可能的.</p>\n<p>使用MapReduce运行管线,因此创建MRPipeline,也可使用MemPipeline在内存中运行管线或者SparkPipeline运行在Spark中.</p>\n<p>Pipeline.readTextFile()可以将文本文件转换为String类型的PCollection对象,每个String代表一行文本.</p>\n<p>PCollection&lt; S &gt;是最基本的Crunch数据类型,表示由S型元素组成的<em>不可修改</em>且<em>无序</em>的分布式集合,可被视为非物化的Collection,因为<em>它的元素没有被读取到内存</em>.Crunch对PCollection做各种操作并产生一个新的PCollection.<br>PCollection.parallellDo()为PCollection中的<em>每个元素</em>都执行某种操作,返回一个新的PCollection.<br>ParallelDo()的方法签名如下:</p>\n<blockquote>\n<p><code>&lt;T&gt; PCollection &lt;T&gt; parallelDo(DoFn &lt;S, T&gt; var1, PType &lt;T&gt; var2);</code></p>\n</blockquote>\n<p>第二个参数PType&lt; T &gt;向Crunch传递有关T的java类型以及如何序列化该类型的信息<br>PTable &lt; K,V &gt;是一个扩展的PCollection,它是由键值对构成的分布式multi-map,可以具有重复键值对.<br>PTable.GroupBy执行的是MR的shuffle操作,按键对表分组,返回PGroupedTable &lt; K,V &gt;,它的combineValues()方法能把一个键的所有值聚合起来,就像MR中reducer做的那样.<br>管线的最后一步操作就是调用write()将表写入文件,write()输入就是通过静态工厂TO的textFile方法创建的一个文本文件对象,实际上使用了TextOutputFormat格式来完成这个操作.<br>为了执行管线,必须调用done()方法,程序阻塞直至管线执行完毕.</p>\n<h2 id=\"Crunch核心API\"><a href=\"#Crunch核心API\" class=\"headerlink\" title=\"Crunch核心API\"></a>Crunch核心API</h2><p><strong>基本操作</strong></p>\n<ul>\n<li><p>union() : 对两个PCollection进行”并集”操作(如果两个PCollection中有相同的元素,这个元素在union后会出现多次),进行union()操作时他们必须由同一管线创建,并且具有相同的类型.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;Integer&gt; a = MemPipeline.collectionOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">PCollection&lt;Integer&gt; b = MemPipeline.collectionOf(<span class=\"number\">2</span>);</span><br><span class=\"line\">PCollection&lt;Integer&gt; c = a.union(b);</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;2,1,2,3&#125;\"</span>, dump(c));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>parallelDo() : 为输入的PCollection&lt; S &gt;中的每个元素调用某个函数,并返回包含该调用结果的一个新的输出PCollection<t>.</t></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; a = MemPipeline.collectionOf(<span class=\"string\">\"cherry\"</span>, <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"banana\"</span>);</span><br><span class=\"line\">PCollection&lt;Integer&gt; b = a.parallelDo(<span class=\"keyword\">new</span> MapFn&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">map</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, ints());</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;6,5,6&#125;\"</span>, dump(b));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>parallelDo常用来过滤在后续步骤中不需要的数据,Crunch专门提供了filter()方法,参数是一个特殊DoFn,为FilterFn,只用实现accept()即可只是是否保留该数据到输出中,他的方法签名没有PType,因为输入与输出类型相同.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; a = MemPipeline.collectionOf(<span class=\"string\">\"cherry\"</span>, <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"banana\"</span>);</span><br><span class=\"line\">PCollection&lt;String&gt; b = a.filter(<span class=\"keyword\">new</span> FilterFn&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">accept</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.length() %<span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;cherry,banana&#125;\"</span>, dump(b));</span><br></pre></td></tr></table></figure></p>\n<p>从由某些值构成的PCollection中提取键以形成一个PTable是常见操作,Crunch为此提供了by()方法,参数是MapFn()&lt; S, K &gt;,将值映S射成键K.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; a = MemPipeline.typedCollectionOf(strings(), <span class=\"string\">\"cherry\"</span>, <span class=\"string\">\"apple\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"banana\"</span>);</span><br><span class=\"line\">PTable&lt;Integer,String&gt; b = a.by(<span class=\"keyword\">new</span> MapFn&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">map</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, ints());</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;(6,cherry),(5,apple),(6,banana)&#125;\"</span>, dump(b));</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>groupByKey() : 把PTable&lt; K,V &gt;中具有相同键的所有值聚合起来,可以看做MR中的混洗操作,返回PGroupedTable&lt; K,V &gt;,Crunch可以根据表的大小为groupByKey()设置分区数量,也可以通过重载groupByKey(int i)指定分区数量.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PGroupedTable&lt;Integer,String&gt; c = b.groupByKey();</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;(5,[apple]),(6,[cherry,banana])&#125;\"</span>, dump(c));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>combineValues() : 最常见以组合函数CombineFn&lt; K,V &gt;作为输入,CombineFn&lt; K,V &gt;就是<code>DoFn&lt;Pair&lt;K,Iterable&lt;V&gt;&gt;, Pair&lt;K,V&gt;&gt;</code>的简写,返回一个<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```java</span><br><span class=\"line\">        PTable&lt;Integer, String&gt; d = c.combineValues(new CombineFn&lt;Integer, String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void process(Pair&lt;Integer, Iterable&lt;String&gt;&gt; integerIterablePair, Emitter&lt;Pair&lt;Integer, String&gt;&gt; emitter) &#123;</span><br><span class=\"line\">                StringBuilder sb = new StringBuilder();</span><br><span class=\"line\">                for (Iterator i = integerIterablePair.second().iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">                    sb.append(i.next());</span><br><span class=\"line\">                    if(i.hasNext())</span><br><span class=\"line\">                        sb.append(&quot;;&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                emitter.emit(Pair.of(integerIterablePair.first(), sb.toString()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        assertEquals(&quot;&#123;(5,apple),(6,cherry;banana)&#125;&quot;, dump(d));</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p>由于没有对键进行改变,可以使用重载的combineValues(),以Aggregator对象作为输入,仅对值进行操作,可以使用Aggregators内置的Aggregator实现操作,比如之前的Aggregators.MAX_INTS().<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTable&lt;Integer, String&gt; e = c.combineValues(Aggregators.STRING_CONCAT(<span class=\"string\">\";\"</span>,<span class=\"keyword\">false</span>));</span><br><span class=\"line\">assertEquals(<span class=\"string\">\"&#123;(5,apple),(6,cherry;banana)&#125;\"</span>, dump(e));</span><br></pre></td></tr></table></figure></p>\n<p>想要聚合PGroupedTable中的值并返回一个与被分组的值的类型不同的结果,可用mapValues()实现,<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTable&lt;Integer, Integer&gt; f = c.mapValues(<span class=\"keyword\">new</span> MapFn&lt;Iterable&lt;String&gt;, Integer&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">map</span><span class=\"params\">(Iterable&lt;String&gt; strings)</span> </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Iterables.size(strings);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;,ints());</span><br><span class=\"line\">       assertEquals(<span class=\"string\">\"&#123;(5,1),(6,2)&#125;\"</span>, dump(f));</span><br></pre></td></tr></table></figure></p>\n<p>combineValues()可被当作MR的combiner来运行,而mapValues()被解释为ParallelDo()操作,只能在reduce端运行.</p>\n<p><strong>类型</strong></p>\n<p>每个PCollection&lt; S &gt;都有一个关联的类PType&lt; S &gt;,用于封装有关PCollection中的元素类型的信息,也给出了从持久化存储器读取到PCollection的序列化格式和反方向的序列化格式.<br>两个PType家族,用哪个取决于管线的文件格式,都可用于文本文件:</p>\n<ol>\n<li>Hadoop Writables: 顺序文件</li>\n<li>Avro: Avro数据文件</li>\n</ol>\n<p>PCollection使用的PType在PCollection创建时指定,有时隐式指定,例如读取文本文件时使用默认的Writables.</p>\n<p><em>记录和元组</em><br>记录record : 通过名称来访问字段的类,用记录写的Crunch程序更易于理解和阅读<br>元组tuple : 通过位置来访问字段的类,用于少量元素组成元组的便捷类:Pair&lt; K,V &gt;, Tuple3&lt; V1, V2, V3 &gt;等</p>\n<p>在Crunch管线中使用记录的便捷方式是定义一个字段能够被Avro Reflect序列化的,和一个无参构造器.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherRecord</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> year;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> temperature;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String stationId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherRecord</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherRecord</span><span class=\"params\">(<span class=\"keyword\">int</span> year, <span class=\"keyword\">int</span> temperature, String stationId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.year = year;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temperature;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stationId = stationId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以从PCollection&lt; String &gt;生成PCollection&lt; WeatherRecord &gt;,并利用parallelDo()将每一行文本解析到WeatherRecord中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; lines = pipeline.read(From.textFile(inputPath));</span><br><span class=\"line\">PCollection&lt;WeatherRecord&gt; records = lines.parallelDo(<span class=\"keyword\">new</span> DoFn&lt;String, WeatherRecord&gt;() &#123;</span><br><span class=\"line\">        NcdcRecordParser parser = <span class=\"keyword\">new</span> NcdcRecordParser();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(String s, Emitter&lt;WeatherRecord&gt; emitter)</span> </span>&#123;</span><br><span class=\"line\">        parser.parse(s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parser.isValidTemperature()) &#123;</span><br><span class=\"line\">            emitter.emit(<span class=\"keyword\">new</span> WeatherRecord(parser.getYearInt(), parser.getAirTemperature(), parser.getStationId()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, Avros.records(WeatherRecord.class));</span><br><span class=\"line\"><span class=\"comment\">//按照字段定义的顺序对记录排序</span></span><br><span class=\"line\">PCollection&lt;WeatherRecord&gt; sortedREcords = Sort.sort(records);</span><br></pre></td></tr></table></figure></p>\n<p>上段代码末尾Avro.records()方法为Avro Reflect数据类型返回了一个Crunch PType.</p>\n<p><strong>源和目标</strong></p>\n<ul>\n<li>读取源<br>Crunch管线的起点是一个或多个Source&lt; T &gt;实例,它们指明了输入数据的存储位置和PType<t>,读取文本用readTextFile就可以,但是其他类型的数据源则需要使用read()方法,以Source<t>对象为输入,From类是各种文件源静态工厂方法的集合,用作为read()的参数.</t></t></li>\n</ul>\n<p>Crunch的数据源包括:</p>\n<ul>\n<li>From.textFile(inputPath)</li>\n<li>From.AvroFile(inputPath, Avros.records())</li>\n<li>From.SequenceFile(inputPath, Writable(), Writable())</li>\n<li>AvroParquetFileSource</li>\n<li>FromHbase.table() 等.</li>\n</ul>\n<ul>\n<li><p>写入文件<br>在写入目标时调用PCollection.write()方法,传入Traget即可,可以通过TO类的静态工厂方法来选择文件类型</p>\n</li>\n<li><p>输入已存在<br>如果目标文件已经存在,再调用write()方法时会引发错误, 除非在write()方法中传入参数Target.WriteMode.OVERWRITE.</p>\n<blockquote>\n<p>写入模式:</p>\n<ul>\n<li>OVERWRITE:管线运行前删除已存在文件</li>\n<li>APPEND:在输出目录下新建文件,保留旧文件,通过文件名区分新旧文件</li>\n<li>CHECKPOINT:将当前工作保存在一个文件中,从而使新管线可从检查点而不是管线起点开始执行.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>组合的源和目标<br>希望一个文件既作为写入目标又作为读取的源,在AT类中有一些静态方法可用于创建SourceTarget实例.</p>\n</li>\n</ul>\n<p><strong>函数</strong></p>\n<ul>\n<li><p>函数序列化<br>Crunch在管线执行时将所有DoFn实例都序列化到一个文件中,并通过Hadoop分布式缓存机制将文件分发给各任务节点,然后任务本身反序列化,使得能被调用.因此,需要确保自己的DoFn实现能通过标准的Java序列化机制进行序列化.<br>如果DoFn作为内部类被定义在没有实现Serializable的外部类中,会出现问题.<br>如果函数依赖于一个以实例变量形式表示的非序列化状态,且他的类没有被Serializable,这种情况下将该实例标为transient(瞬态),从而不会序列化该状态.</p>\n</li>\n<li><p>对象重用<br>在MR中,reducer的值迭代器中的对象是可重用的,其目的是为了提高效率,对于PGroupedTable的conbineValues()和mapValues()方法的迭代器来说,Crunch有相同的行为.因此想要在迭代器外部引用一个对象,就应当复制该对象,以避免对象标识错误.</p>\n<blockquote>\n<p>可重用:<a href=\"http://blog.csdn.net/fxdaniel/article/details/50255197\" target=\"_blank\" rel=\"noopener\">reduce方法会反复执行多次，但key和value相关的对象只有两个，reduce会反复重用这两个对象。所以如果要保存key或者value的结果，只能将其中的值取出另存或者重新clone一个对象（例如Text store = new Text(value) 或者 String a = value.toString()），而不能直接赋引用。因为引用从始至终都是指向同一个对象，你如果直接保存它们，那最后它们都指向最后一个输入记录。会影响最终计算结果而出错。</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K,V&gt; PTable&lt;K,Collection&lt;V&gt;&gt; uniqueValues(PTable&lt;K, V&gt; table) &#123;</span><br><span class=\"line\">       PTypeFamily tf = table.getTypeFamily();</span><br><span class=\"line\">       <span class=\"keyword\">final</span> PType&lt;V&gt; valueType = table.getValueType();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> table.groupByKey().mapValues(<span class=\"string\">\"unique\"</span>, <span class=\"keyword\">new</span> MapFn&lt;Iterable&lt;V&gt;, Collection&lt;V&gt;&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">               valueType.initialize(getConfiguration());<span class=\"comment\">//初始化PType使其能够访问配置以执行复制操作</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> Collection&lt;V&gt; <span class=\"title\">map</span><span class=\"params\">(Iterable&lt;V&gt; vs)</span> </span>&#123;</span><br><span class=\"line\">               Set&lt;V&gt; collected = <span class=\"keyword\">new</span> HashSet&lt;V&gt;();</span><br><span class=\"line\">               <span class=\"keyword\">for</span>(V value : vs)&#123;</span><br><span class=\"line\">                   collected.add(valueType.getDetachedValue(value));<span class=\"comment\">//PType.getDetachedValue()复制JAVA类.</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> collected;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;,tf.collections(table.getValueType()));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p><strong>物化</strong></p>\n<p>物化(Materlization)是让PCollection中的值变得可用的过程,只有物化后的值才能被程序读取<br>物化最直接的方法是调用PCollection.materialize(),它返回了一个Iterable集合.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pipeline pipeline = <span class=\"keyword\">new</span> MRPipeline(getClass());</span><br><span class=\"line\">   PCollection&lt;String&gt; lines = pipeline.readTextFile(inputPath);</span><br><span class=\"line\">   PCollection&lt;String&gt; lower = lines.parallelDo(<span class=\"keyword\">new</span> ToLowerFn(), strings());</span><br><span class=\"line\"></span><br><span class=\"line\">   Iterable&lt;String&gt; materialized = lower.materialize();</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String s : materialized) &#123; <span class=\"comment\">// pipeline从这个位置开始执行</span></span><br><span class=\"line\">     System.out.println(s);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p> 调用materlize并不会导致管线执行,只有从Iterable中创建一个Iterator后,Crunch才执行管线,执行完毕后才执行迭代操作.</p>\n<ul>\n<li><p>PObject<br>物化PCollection的另一种方式是使用PObject,PObject<t>是一个被标记为future的对象,程序在创建PObject时,类型为T的值得计算可能还未完成.计算结果调用getValue()方法获取,计算完成之前他会一直处于阻塞状态.</t></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pipeline pipeline = <span class=\"keyword\">new</span> MRPipeline(getClass());</span><br><span class=\"line\">PCollection&lt;String&gt; lines = pipeline.readTextFile(inputPath);</span><br><span class=\"line\">PCollection&lt;String&gt; lower = lines.parallelDo(<span class=\"keyword\">new</span> ToLowerFn(), strings());</span><br><span class=\"line\"></span><br><span class=\"line\">PObject&lt;Collection&lt;String&gt;&gt; po = lower.asCollection();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s : po.getValue()) &#123; <span class=\"comment\">// pipeline is run</span></span><br><span class=\"line\">  System.out.println(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">assertEquals(expectedContent, po.getValue());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"About to call done()\"</span>);</span><br><span class=\"line\">PipelineResult result = pipeline.done();</span><br></pre></td></tr></table></figure>\n<p> asCollection()方法将PCollection<t>变换为普通的Java Collection<t>.</t></t></p>\n</li>\n</ul>\n<h2 id=\"管线执行\"><a href=\"#管线执行\" class=\"headerlink\" title=\"管线执行\"></a>管线执行</h2><p>管线构建期间,Crunch会建立一个内部执行计划,每个计划都是由PCollection操作构成的一个有向无环图,每个计划内的PCollection都与产生它的操作之间存在引用关系,另外,每个PCollection都有一个内部状态,用于记录他是否已被物化.<br><strong>运行管线</strong><br>调用Pipeline.run()可以显式执行管线操作,步骤:<br>优化处理,将执行计划分为若干阶段 –&gt; 执行优化计划中的各阶段,使得到的PCololection物化(此时可能会得到中间文件) –&gt; 向调用者返回PipelineResult对象,包含每个阶段的信息以及管线是否成功.<br>clean()清除物化PCollection时创建的临时中间文件.<br>done() = 先run()后clean()<br>runAsync()是run()的配对方法,它在管线启动后立刻返回,返回类型是PipelineExecution,它实现了Future&lt; PiplineResult &gt;.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline.writeTextFile(table, tmpDir.getFileName(<span class=\"string\">\"output\"</span>));</span><br><span class=\"line\">PipelineExecution execution = pipeline.runAsync();</span><br><span class=\"line\">PipelineResult result = execution.get();</span><br><span class=\"line\">assertTrue(result.succeeded());</span><br></pre></td></tr></table></figure></p>\n<p><strong>停止管线</strong><br>为了正确停止管线,需要异步启动该管线,以保留对PipelineExecution对象的引用.<br><code>PipelineExecution execution = pipeline.runAsync();</code><br>这种情况调用kill()方法并等待其完成即可关闭管线.这样管线在此之前运行在这个集群上的所有作业都将被杀死<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execution.kill();</span><br><span class=\"line\">execution.waitUntilDone();</span><br></pre></td></tr></table></figure></p>\n<p><strong>查看Crunch计划</strong><br>通过 PipelineExecution.getPlanDotFile()可以获得一个以字符串形式表现的管线操作图的DOT文件.<br>另一种在隐式运行的管线中获取操作图的方式是将DOT文件的表示存储在作业配置中,一边在管线执行完后检查.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PCollection&lt;String&gt; lines = pipeline.readTextFile(inputPath);</span><br><span class=\"line\">PCollection&lt;String&gt; lower = lines.parallelDo(<span class=\"string\">\"lower\"</span>, <span class=\"keyword\">new</span> ToLowerFn(), strings());</span><br><span class=\"line\">PTable&lt;String, Long&gt; counts = lower.count();</span><br><span class=\"line\">PTable&lt;Long, String&gt; inverseCounts = counts.parallelDo(<span class=\"string\">\"inverse\"</span>, <span class=\"keyword\">new</span> InversePairFn&lt;String, Long&gt;(), tableOf(longs(), strings()));</span><br><span class=\"line\">PTable&lt;Long, Integer&gt; hist = inverseCounts.groupByKey().mapValues(<span class=\"string\">\"count values\"</span>, <span class=\"keyword\">new</span> CountValuesFn&lt;String&gt;(), ints());</span><br><span class=\"line\">hist.write(To.textFile(outputPath), Target.WriteMode.OVERWRITE);</span><br><span class=\"line\">PipelineExecution execution = pipeline.runAsync();</span><br><span class=\"line\">String dot = execution.getPlanDotFile();</span><br><span class=\"line\">Files.write(dot, dotFile(), Charsets.UTF_8);</span><br><span class=\"line\">execution.waitUntilDone();</span><br><span class=\"line\">pipeline.done();</span><br></pre></td></tr></table></figure></p>\n<p>用命令<code>dot -Tpng -O *.dot</code>将.dot文件转换为.png文件<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-21/79771268.jpg\" alt=\"\"></p>\n<p>每个GBK操作将作为MapReduce的混洗步骤实现.</p>"},{"title":"关于HBase","date":"2018-03-21T02:32:23.000Z","_content":"HBase是一个在HDFS上开发的面向列的分布式数据库,可以用来实时的随机访问超大规模数据集,它自底向上的进行构建,能够简单的通过增加节点来达到线性扩展,HBase不是关系型数据库,不支持SQL,它能在廉价的硬件构成的集群上管理超大规模的稀疏表.\n\n相关概念\n---\n应用将数据存放在带标签的表中,表格的\"单元格\"由行和列的坐标交叉决定,是*有版本*的,版本号默认是自动分配的,为插入单元格的时间戳.单元格内容是未解释的字节数组.\n <!-- more-->\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-21/37375528.jpg)\n\n表中行的键也是字节数组,行根据行的键进行排序,排序根据字节序进行,所有对表的访问都要通过表的主键,HBase不支持表中的其他列建立索引.\n行中的列被分为列族,同一个列族成员具有相同的前缀,info:format和info:geo都是列族info的成员,列族前缀必须是\"可打印的\",修饰符可以是任意字节,列族和修饰符用(:)分隔.\n\n一个表的*列族*必须作为表模式的定义一部分*预先给出*,但*列组成员*可以随后按需加入.物理上,所有的*列族成员*都一起存放在文件系统中,HBase更确切地说是面向列族的存储器.调优和存储都是在列族层面上进行的,所以最好使所有列族成员有相同的访问模式和大小特征.\n*区域*\nHBase自动将表水平划分为区域,每个区域由表中行的子集构成,每个区域由他所属于的表,它包含的第一行和最后一行(不包括这行)来表示.一开始一个表只有一个区域,当区域大小超出设定的阈值是便会在某行的边界上分成*两个大小基本相同的新分区*,区域是在HBase集群上分布数据最小的单位,因为太大而无法存放在单台服务器上的表会被放到服务器集群上,每个节点负责管理所有区域的一个子集.在线的所有区域按次序排列就构成了表的所有内容.\n\n*加锁*\nHBase对行的更新是原子的\n\n**实现**\nHbase = 1个master节点 + 多个regionserver从属机\n主控机master负责启动一个全新的安装,把区域分配给注册的regionserver,恢复regionserver故障.\nregionserver负责将0个或者多个区域的管理和响应客户端的读写请求.还负责区域划分并告知master有新的子区域.\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-21/16805306.jpg)\nHBase依赖于ZooKeeper,zookeeper集合体负责管理诸如hbase:meta目录表的位置以及当前集群主控机地址等重要信息.\n\nHBase使用基于SSH的机制来运行远程命令,其配置方式类似于Hadoop,HBase通过Hadoop文件系统API来持久化存储数据,但在默认情况下,HBase会将存储写入本地文件系统,因此需要把它的存储配置指向要使用的HDFS集群.\n\n*运行中的HBase*\nHBase内部保留名为hbase:meta的特殊目录表,维护当前集群上所有区域的列表,状态和位置.区域变化时,目录表会重新进行相应的更新,这样集群上的信息状态就能保持是最新的.\n新连接到zookeeper集群上的客户端首先查找hbase:meta位置,然后客户端通过查找合适的hbase:meta区域来获取用户空间区域所在节点和位置,接设客户端就可以直接和管理那个区域的regionserver交互.\n\n每个行操作可能要访问三次远程节点,为节省代价,客户端会缓存hbase:meta时获取的信息.\n到达regionserver的写操作首先追加到\"提交日志\",然后加入内存中的memstore.如果memstore满,它的内容会刷入文件系统.\n\n简单使用\n---\n配置好hbase后,可用mingling`hbase shell`进入shell,输入help可以查看命令列表.\n*创建一个表*\n要新建一个表,必须为表起一个名字,并为其定义模式,一个表的模式包含表的属性和列族的列表,列族本身也有属性.模式可以被修改,需要修改时用`disable`将其设为'离线'即可,`alter`命令可以进行修改,`enable`将表定义为在线.\n```sql\nhbase(main):002:0> create 'test','data'\n0 row(s) in 1.2920 seconds\n```\n新建一个名为test的表,只包含一个名为data的列,表和列族属性都为默认值.\n```SQL\nhbase(main):003:0> list\nTABLE\ntest\n1 row(s) in 0.0110 seconds```\nlist输出所有表.\n```sql\nhbase(main):004:0> put 'test','row1','data:1','value1'\n0 row(s) in 0.1720 seconds\n\nhbase(main):005:0> put 'test','row2','data:2','value2'\n0 row(s) in 0.0120 seconds\n\nhbase(main):006:0> put 'test','row3','data:3','valle3'\n0 row(s) in 0.0080 seconds\n\nhbase(main):007:0> get 'test','row1'\nCOLUMN                        CELL\n data:1                       timestamp=1521615103952, value=value1\n1 row(s) in 0.0250 seconds\n\nhbase(main):008:0> scan 'test'\nROW                           COLUMN+CELL\n row1                         column=data:1, timestamp=1521615103952, value=value1                              \n row2                         column=data:2, timestamp=1521615113126, value=value2                              \n row3                         column=data:3, timestamp=1521615131948, value=valle3                              \n3 row(s) in 0.0210 seconds```\n在列表中三行插入数据,get获取第一行,scan预览表的内容.\n```sql\nhbase(main):003:0> disable 'test'\n0 row(s) in 2.3790 seconds\n\nhbase(main):004:0> drop 'test'\n0 row(s) in 1.2580 seconds\n\nhbase(main):005:0> list\nTABLE\n0 row(s) in 0.0060 seconds\n```\n删除表之前先禁用.\n\n客户端\n---\n**Java**\n```java\npublic class ExampleClient {\n    public static void main(String[] args) throws IOException {\n       Configuration config = HBaseConfiguration.create();\n       Connection conn = ConnectionFactory.createConnection(config);\n       Admin admin  = conn.getAdmin();\n\n        try {\n            TableName tableName = TableName.valueOf(\"test\");\n            HTableDescriptor htd = new HTableDescriptor(tableName);\n            HColumnDescriptor hcd = new HColumnDescriptor(\"data\");\n            htd.addFamily(hcd);\n            admin.createTable(htd);\n            HTableDescriptor[] tables = admin.listTables();\n            if (tables.length != 1 && Bytes.equals(tableName.getName(), tables[0].getTableName().getName())) {\n                throw new IOException(\"Failed create of table\");\n            }\n\n            Table table = conn.getTable(tableName);\n            try {\n                for (int i = 1; i <= 3; i++) {\n                    byte[] row = Bytes.toBytes(\"row\" + i);\n                    Put put = new Put(row);\n                    byte[] columnFalily = Bytes.toBytes(\"data\");\n                    byte[] qualifier = Bytes.toBytes(String.valueOf(i));\n                    byte[] value = Bytes.toBytes(\"value\" + i);\n                    put.add(columnFalily, qualifier, value);\n                    table.put(put);\n                }\n                Get get = new Get(Bytes.toBytes(\"row1\"));\n                Result result = table.get(get);\n                System.out.println(\"Get: \" + result);\n                Scan scan = new Scan();//scanner和cursor类似,不过在使用后要关闭\n                ResultScanner scanner = table.getScanner(scan);\n                try {\n                    for (Result scannerResult : scanner) {\n                        System.out.println(\"Scan: \" + scannerResult);\n                    }\n                } finally {\n                    scanner.close();\n                }\n                //先禁用,再丢弃\n                admin.disableTable(tableName);\n                admin.deleteTable(tableName);\n            } finally {\n                table.close();\n            }\n        } finally {\n            admin.close();\n        }\n    }\n}```\nConfiguration对象读入了程序classpath下hbase-site.xml等文件中的配置,客户端用ConnectionFactory创建了一个Connection对象,可以检索Admin和Table实例.Admin用于管理HBase集群,添加和丢弃表,Table用于访问指定的表.\n\n**MapReduce**\nHBase可以作为MR的源和输出,TableInputFormat类可以在区域边界进行分隔,使map能够拿到单个的区域进行处理,TableOutputFormat将把reduce的结果写入HBase;\n```java\npublic class SimpleRowCounter extends Configured implements Tool {\n    static class RowCounterMapper extends TableMapper<ImmutableBytesWritable, Result> {\n        public static enum Counters { Rows }\n\n        @Override\n        protected void map(ImmutableBytesWritable key, Result value, Context context) throws IOException, InterruptedException {\n            context.getCounter(Counters.Rows).increment(1);\n        }\n    }\n    public int run(String[] args) throws Exception {\n        if (args.length != 1) {\n            System.err.println(\"Usage SimpleRowCounter <tablename>\");\n            return -1;\n        }\n\n        String tableName = args[0];\n        Scan scan = new Scan();\n        scan.setFilter(new FirstKeyOnlyFilter());\n        Job job  = new Job(getConf(), getClass().getSimpleName());\n        job.setJarByClass(getClass());\n        TableMapReduceUtil.initTableMapperJob(tableName, scan, RowCounterMapper.class, ImmutableBytesWritable.class, Result.class, job);\n        job.setNumReduceTasks(0);\n        job.setOutputFormatClass(NullOutputFormat.class);\n        return job.waitForCompletion(true) ? 0 : 1;\n    }\n\n    public static void main(String[] args) throws Exception {\n        int exitCode = ToolRunner.run(HBaseConfiguration.create(), new SimpleRowCounter(), args);\n        System.exit(exitCode);\n    }\n}```\n TableMapper是MR.Mapper的特化,他设定map输入类型由TableInputFormat来传递,输入键为ImmutableBytesWritable(行键), 值为Result(扫描行结果).TableMapReduceUtil.initTableMapperJob()对作业进行配置.\n\n**加载数据**将要写入的数据库必须在作业配置中通过设置TableOutoputFormat.OUTPUTTABLE属性来指定.\n```java\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, \"observations\");\n        job.setMapperClass(HBaseTemperatureMapper.class);\n        job.setNumReduceTasks(0);\n        job.setOutputFormatClass(TableOutputFormat.class);```\n*批量加载*\nHBase有批量加载(bulk loading)工具,他从MR把以内部格式表示的数据直接写入文件系统,从而实现批量加载.这样比用API写入数据的方式快至少一个数量级.\n>在使用Jar包向hbase加载数据时会出现如下错误\n>2018-03-21 20:38:01,165 INFO  [main] mapreduce.Job: Running job: job_1521635550341_0002\n2018-03-21 20:38:06,216 INFO  [main] mapreduce.Job: Job job_1521635550341_0002 running in uber mode : false\n2018-03-21 20:38:06,217 INFO  [main] mapreduce.Job:  map 0% reduce 0%\n2018-03-21 20:38:06,234 INFO  [main] mapreduce.Job: doop.util.Shell.run(Shell.java:869)\n        at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute(Shell.java:1170)\n        at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer(DefaultContainerExecutor.java:236)\n        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:305)\n        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:84)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n        at java.lang.Thread.run(Thread.java:748)\n解决办法:yarn-site.xml的yarn.application.classpath配置项中，加上hbase相关的jar包。\n\n\nContainer exited with a non-zero exit code 1\nFor more detailed output, check the application tracking page: http://*********:8088/cluster/app/application_1521635550341_0002 Then click on links to logs of each attempt.\n. Failing the application.\n\n批量加载过程:\n1. 使用HFileOutputFormat2通过一个MR作业将HFile写入HDFS目录\n2. 将HFiles从HDFS一如现有的HBase表中,该表在此过程可以是活跃的\n\nHBase和RDBMS比较\n---\nHBASE:\n分布式,面向列的数据存储系统,在HDFS上提供随机读写,聚焦于各种可伸缩问题,表可以很宽,很高,水平分区在上千个普通商用机节点复制.\nRDBMS:\n模式固定, 面向行,ACID性质,扩展性不强\n\n\n\n\n\n\n","source":"_posts/关于HBase.md","raw":"---\ntitle: 关于HBase\ndate: 2018-03-21 10:32:23\ntags: [大数据, Hadoop, HBase]\n---\nHBase是一个在HDFS上开发的面向列的分布式数据库,可以用来实时的随机访问超大规模数据集,它自底向上的进行构建,能够简单的通过增加节点来达到线性扩展,HBase不是关系型数据库,不支持SQL,它能在廉价的硬件构成的集群上管理超大规模的稀疏表.\n\n相关概念\n---\n应用将数据存放在带标签的表中,表格的\"单元格\"由行和列的坐标交叉决定,是*有版本*的,版本号默认是自动分配的,为插入单元格的时间戳.单元格内容是未解释的字节数组.\n <!-- more-->\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-21/37375528.jpg)\n\n表中行的键也是字节数组,行根据行的键进行排序,排序根据字节序进行,所有对表的访问都要通过表的主键,HBase不支持表中的其他列建立索引.\n行中的列被分为列族,同一个列族成员具有相同的前缀,info:format和info:geo都是列族info的成员,列族前缀必须是\"可打印的\",修饰符可以是任意字节,列族和修饰符用(:)分隔.\n\n一个表的*列族*必须作为表模式的定义一部分*预先给出*,但*列组成员*可以随后按需加入.物理上,所有的*列族成员*都一起存放在文件系统中,HBase更确切地说是面向列族的存储器.调优和存储都是在列族层面上进行的,所以最好使所有列族成员有相同的访问模式和大小特征.\n*区域*\nHBase自动将表水平划分为区域,每个区域由表中行的子集构成,每个区域由他所属于的表,它包含的第一行和最后一行(不包括这行)来表示.一开始一个表只有一个区域,当区域大小超出设定的阈值是便会在某行的边界上分成*两个大小基本相同的新分区*,区域是在HBase集群上分布数据最小的单位,因为太大而无法存放在单台服务器上的表会被放到服务器集群上,每个节点负责管理所有区域的一个子集.在线的所有区域按次序排列就构成了表的所有内容.\n\n*加锁*\nHBase对行的更新是原子的\n\n**实现**\nHbase = 1个master节点 + 多个regionserver从属机\n主控机master负责启动一个全新的安装,把区域分配给注册的regionserver,恢复regionserver故障.\nregionserver负责将0个或者多个区域的管理和响应客户端的读写请求.还负责区域划分并告知master有新的子区域.\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-21/16805306.jpg)\nHBase依赖于ZooKeeper,zookeeper集合体负责管理诸如hbase:meta目录表的位置以及当前集群主控机地址等重要信息.\n\nHBase使用基于SSH的机制来运行远程命令,其配置方式类似于Hadoop,HBase通过Hadoop文件系统API来持久化存储数据,但在默认情况下,HBase会将存储写入本地文件系统,因此需要把它的存储配置指向要使用的HDFS集群.\n\n*运行中的HBase*\nHBase内部保留名为hbase:meta的特殊目录表,维护当前集群上所有区域的列表,状态和位置.区域变化时,目录表会重新进行相应的更新,这样集群上的信息状态就能保持是最新的.\n新连接到zookeeper集群上的客户端首先查找hbase:meta位置,然后客户端通过查找合适的hbase:meta区域来获取用户空间区域所在节点和位置,接设客户端就可以直接和管理那个区域的regionserver交互.\n\n每个行操作可能要访问三次远程节点,为节省代价,客户端会缓存hbase:meta时获取的信息.\n到达regionserver的写操作首先追加到\"提交日志\",然后加入内存中的memstore.如果memstore满,它的内容会刷入文件系统.\n\n简单使用\n---\n配置好hbase后,可用mingling`hbase shell`进入shell,输入help可以查看命令列表.\n*创建一个表*\n要新建一个表,必须为表起一个名字,并为其定义模式,一个表的模式包含表的属性和列族的列表,列族本身也有属性.模式可以被修改,需要修改时用`disable`将其设为'离线'即可,`alter`命令可以进行修改,`enable`将表定义为在线.\n```sql\nhbase(main):002:0> create 'test','data'\n0 row(s) in 1.2920 seconds\n```\n新建一个名为test的表,只包含一个名为data的列,表和列族属性都为默认值.\n```SQL\nhbase(main):003:0> list\nTABLE\ntest\n1 row(s) in 0.0110 seconds```\nlist输出所有表.\n```sql\nhbase(main):004:0> put 'test','row1','data:1','value1'\n0 row(s) in 0.1720 seconds\n\nhbase(main):005:0> put 'test','row2','data:2','value2'\n0 row(s) in 0.0120 seconds\n\nhbase(main):006:0> put 'test','row3','data:3','valle3'\n0 row(s) in 0.0080 seconds\n\nhbase(main):007:0> get 'test','row1'\nCOLUMN                        CELL\n data:1                       timestamp=1521615103952, value=value1\n1 row(s) in 0.0250 seconds\n\nhbase(main):008:0> scan 'test'\nROW                           COLUMN+CELL\n row1                         column=data:1, timestamp=1521615103952, value=value1                              \n row2                         column=data:2, timestamp=1521615113126, value=value2                              \n row3                         column=data:3, timestamp=1521615131948, value=valle3                              \n3 row(s) in 0.0210 seconds```\n在列表中三行插入数据,get获取第一行,scan预览表的内容.\n```sql\nhbase(main):003:0> disable 'test'\n0 row(s) in 2.3790 seconds\n\nhbase(main):004:0> drop 'test'\n0 row(s) in 1.2580 seconds\n\nhbase(main):005:0> list\nTABLE\n0 row(s) in 0.0060 seconds\n```\n删除表之前先禁用.\n\n客户端\n---\n**Java**\n```java\npublic class ExampleClient {\n    public static void main(String[] args) throws IOException {\n       Configuration config = HBaseConfiguration.create();\n       Connection conn = ConnectionFactory.createConnection(config);\n       Admin admin  = conn.getAdmin();\n\n        try {\n            TableName tableName = TableName.valueOf(\"test\");\n            HTableDescriptor htd = new HTableDescriptor(tableName);\n            HColumnDescriptor hcd = new HColumnDescriptor(\"data\");\n            htd.addFamily(hcd);\n            admin.createTable(htd);\n            HTableDescriptor[] tables = admin.listTables();\n            if (tables.length != 1 && Bytes.equals(tableName.getName(), tables[0].getTableName().getName())) {\n                throw new IOException(\"Failed create of table\");\n            }\n\n            Table table = conn.getTable(tableName);\n            try {\n                for (int i = 1; i <= 3; i++) {\n                    byte[] row = Bytes.toBytes(\"row\" + i);\n                    Put put = new Put(row);\n                    byte[] columnFalily = Bytes.toBytes(\"data\");\n                    byte[] qualifier = Bytes.toBytes(String.valueOf(i));\n                    byte[] value = Bytes.toBytes(\"value\" + i);\n                    put.add(columnFalily, qualifier, value);\n                    table.put(put);\n                }\n                Get get = new Get(Bytes.toBytes(\"row1\"));\n                Result result = table.get(get);\n                System.out.println(\"Get: \" + result);\n                Scan scan = new Scan();//scanner和cursor类似,不过在使用后要关闭\n                ResultScanner scanner = table.getScanner(scan);\n                try {\n                    for (Result scannerResult : scanner) {\n                        System.out.println(\"Scan: \" + scannerResult);\n                    }\n                } finally {\n                    scanner.close();\n                }\n                //先禁用,再丢弃\n                admin.disableTable(tableName);\n                admin.deleteTable(tableName);\n            } finally {\n                table.close();\n            }\n        } finally {\n            admin.close();\n        }\n    }\n}```\nConfiguration对象读入了程序classpath下hbase-site.xml等文件中的配置,客户端用ConnectionFactory创建了一个Connection对象,可以检索Admin和Table实例.Admin用于管理HBase集群,添加和丢弃表,Table用于访问指定的表.\n\n**MapReduce**\nHBase可以作为MR的源和输出,TableInputFormat类可以在区域边界进行分隔,使map能够拿到单个的区域进行处理,TableOutputFormat将把reduce的结果写入HBase;\n```java\npublic class SimpleRowCounter extends Configured implements Tool {\n    static class RowCounterMapper extends TableMapper<ImmutableBytesWritable, Result> {\n        public static enum Counters { Rows }\n\n        @Override\n        protected void map(ImmutableBytesWritable key, Result value, Context context) throws IOException, InterruptedException {\n            context.getCounter(Counters.Rows).increment(1);\n        }\n    }\n    public int run(String[] args) throws Exception {\n        if (args.length != 1) {\n            System.err.println(\"Usage SimpleRowCounter <tablename>\");\n            return -1;\n        }\n\n        String tableName = args[0];\n        Scan scan = new Scan();\n        scan.setFilter(new FirstKeyOnlyFilter());\n        Job job  = new Job(getConf(), getClass().getSimpleName());\n        job.setJarByClass(getClass());\n        TableMapReduceUtil.initTableMapperJob(tableName, scan, RowCounterMapper.class, ImmutableBytesWritable.class, Result.class, job);\n        job.setNumReduceTasks(0);\n        job.setOutputFormatClass(NullOutputFormat.class);\n        return job.waitForCompletion(true) ? 0 : 1;\n    }\n\n    public static void main(String[] args) throws Exception {\n        int exitCode = ToolRunner.run(HBaseConfiguration.create(), new SimpleRowCounter(), args);\n        System.exit(exitCode);\n    }\n}```\n TableMapper是MR.Mapper的特化,他设定map输入类型由TableInputFormat来传递,输入键为ImmutableBytesWritable(行键), 值为Result(扫描行结果).TableMapReduceUtil.initTableMapperJob()对作业进行配置.\n\n**加载数据**将要写入的数据库必须在作业配置中通过设置TableOutoputFormat.OUTPUTTABLE属性来指定.\n```java\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, \"observations\");\n        job.setMapperClass(HBaseTemperatureMapper.class);\n        job.setNumReduceTasks(0);\n        job.setOutputFormatClass(TableOutputFormat.class);```\n*批量加载*\nHBase有批量加载(bulk loading)工具,他从MR把以内部格式表示的数据直接写入文件系统,从而实现批量加载.这样比用API写入数据的方式快至少一个数量级.\n>在使用Jar包向hbase加载数据时会出现如下错误\n>2018-03-21 20:38:01,165 INFO  [main] mapreduce.Job: Running job: job_1521635550341_0002\n2018-03-21 20:38:06,216 INFO  [main] mapreduce.Job: Job job_1521635550341_0002 running in uber mode : false\n2018-03-21 20:38:06,217 INFO  [main] mapreduce.Job:  map 0% reduce 0%\n2018-03-21 20:38:06,234 INFO  [main] mapreduce.Job: doop.util.Shell.run(Shell.java:869)\n        at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute(Shell.java:1170)\n        at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer(DefaultContainerExecutor.java:236)\n        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:305)\n        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:84)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n        at java.lang.Thread.run(Thread.java:748)\n解决办法:yarn-site.xml的yarn.application.classpath配置项中，加上hbase相关的jar包。\n\n\nContainer exited with a non-zero exit code 1\nFor more detailed output, check the application tracking page: http://*********:8088/cluster/app/application_1521635550341_0002 Then click on links to logs of each attempt.\n. Failing the application.\n\n批量加载过程:\n1. 使用HFileOutputFormat2通过一个MR作业将HFile写入HDFS目录\n2. 将HFiles从HDFS一如现有的HBase表中,该表在此过程可以是活跃的\n\nHBase和RDBMS比较\n---\nHBASE:\n分布式,面向列的数据存储系统,在HDFS上提供随机读写,聚焦于各种可伸缩问题,表可以很宽,很高,水平分区在上千个普通商用机节点复制.\nRDBMS:\n模式固定, 面向行,ACID性质,扩展性不强\n\n\n\n\n\n\n","slug":"关于HBase","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i6x001acf96p8y61fzy","content":"<p>HBase是一个在HDFS上开发的面向列的分布式数据库,可以用来实时的随机访问超大规模数据集,它自底向上的进行构建,能够简单的通过增加节点来达到线性扩展,HBase不是关系型数据库,不支持SQL,它能在廉价的硬件构成的集群上管理超大规模的稀疏表.</p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><p>应用将数据存放在带标签的表中,表格的”单元格”由行和列的坐标交叉决定,是<em>有版本</em>的,版本号默认是自动分配的,为插入单元格的时间戳.单元格内容是未解释的字节数组.<br> <a id=\"more\"></a></p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-21/37375528.jpg\" alt=\"\"></p>\n<p>表中行的键也是字节数组,行根据行的键进行排序,排序根据字节序进行,所有对表的访问都要通过表的主键,HBase不支持表中的其他列建立索引.<br>行中的列被分为列族,同一个列族成员具有相同的前缀,info:format和info:geo都是列族info的成员,列族前缀必须是”可打印的”,修饰符可以是任意字节,列族和修饰符用(:)分隔.</p>\n<p>一个表的<em>列族</em>必须作为表模式的定义一部分<em>预先给出</em>,但<em>列组成员</em>可以随后按需加入.物理上,所有的<em>列族成员</em>都一起存放在文件系统中,HBase更确切地说是面向列族的存储器.调优和存储都是在列族层面上进行的,所以最好使所有列族成员有相同的访问模式和大小特征.<br><em>区域</em><br>HBase自动将表水平划分为区域,每个区域由表中行的子集构成,每个区域由他所属于的表,它包含的第一行和最后一行(不包括这行)来表示.一开始一个表只有一个区域,当区域大小超出设定的阈值是便会在某行的边界上分成<em>两个大小基本相同的新分区</em>,区域是在HBase集群上分布数据最小的单位,因为太大而无法存放在单台服务器上的表会被放到服务器集群上,每个节点负责管理所有区域的一个子集.在线的所有区域按次序排列就构成了表的所有内容.</p>\n<p><em>加锁</em><br>HBase对行的更新是原子的</p>\n<p><strong>实现</strong><br>Hbase = 1个master节点 + 多个regionserver从属机<br>主控机master负责启动一个全新的安装,把区域分配给注册的regionserver,恢复regionserver故障.<br>regionserver负责将0个或者多个区域的管理和响应客户端的读写请求.还负责区域划分并告知master有新的子区域.</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-21/16805306.jpg\" alt=\"\"><br>HBase依赖于ZooKeeper,zookeeper集合体负责管理诸如hbase:meta目录表的位置以及当前集群主控机地址等重要信息.</p>\n<p>HBase使用基于SSH的机制来运行远程命令,其配置方式类似于Hadoop,HBase通过Hadoop文件系统API来持久化存储数据,但在默认情况下,HBase会将存储写入本地文件系统,因此需要把它的存储配置指向要使用的HDFS集群.</p>\n<p><em>运行中的HBase</em><br>HBase内部保留名为hbase:meta的特殊目录表,维护当前集群上所有区域的列表,状态和位置.区域变化时,目录表会重新进行相应的更新,这样集群上的信息状态就能保持是最新的.<br>新连接到zookeeper集群上的客户端首先查找hbase:meta位置,然后客户端通过查找合适的hbase:meta区域来获取用户空间区域所在节点和位置,接设客户端就可以直接和管理那个区域的regionserver交互.</p>\n<p>每个行操作可能要访问三次远程节点,为节省代价,客户端会缓存hbase:meta时获取的信息.<br>到达regionserver的写操作首先追加到”提交日志”,然后加入内存中的memstore.如果memstore满,它的内容会刷入文件系统.</p>\n<h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><p>配置好hbase后,可用mingling<code>hbase shell</code>进入shell,输入help可以查看命令列表.<br><em>创建一个表</em><br>要新建一个表,必须为表起一个名字,并为其定义模式,一个表的模式包含表的属性和列族的列表,列族本身也有属性.模式可以被修改,需要修改时用<code>disable</code>将其设为’离线’即可,<code>alter</code>命令可以进行修改,<code>enable</code>将表定义为在线.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):002:0&gt; create 'test','data'</span><br><span class=\"line\">0 row(s) in 1.2920 seconds</span><br></pre></td></tr></table></figure></p>\n<p>新建一个名为test的表,只包含一个名为data的列,表和列族属性都为默认值.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):003:0&gt; list</span><br><span class=\"line\">TABLE</span><br><span class=\"line\">test</span><br><span class=\"line\">1 row(s) in 0.0110 seconds</span><br></pre></td></tr></table></figure></p>\n<p>list输出所有表.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):004:0&gt; put 'test','row1','data:1','value1'</span><br><span class=\"line\">0 row(s) in 0.1720 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):005:0&gt; put 'test','row2','data:2','value2'</span><br><span class=\"line\">0 row(s) in 0.0120 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):006:0&gt; put 'test','row3','data:3','valle3'</span><br><span class=\"line\">0 row(s) in 0.0080 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):007:0&gt; get 'test','row1'</span><br><span class=\"line\">COLUMN                        CELL</span><br><span class=\"line\"> data:1                       timestamp=1521615103952, value=value1</span><br><span class=\"line\">1 row(s) in 0.0250 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):008:0&gt; scan 'test'</span><br><span class=\"line\">ROW                           COLUMN+CELL</span><br><span class=\"line\"> row1                         column=data:1, timestamp=1521615103952, value=value1                              </span><br><span class=\"line\"> row2                         column=data:2, timestamp=1521615113126, value=value2                              </span><br><span class=\"line\"> row3                         column=data:3, timestamp=1521615131948, value=valle3                              </span><br><span class=\"line\">3 row(s) in 0.0210 seconds</span><br></pre></td></tr></table></figure></p>\n<p>在列表中三行插入数据,get获取第一行,scan预览表的内容.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):003:0&gt; disable 'test'</span><br><span class=\"line\">0 row(s) in 2.3790 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):004:0&gt; drop 'test'</span><br><span class=\"line\">0 row(s) in 1.2580 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):005:0&gt; list</span><br><span class=\"line\">TABLE</span><br><span class=\"line\">0 row(s) in 0.0060 seconds</span><br></pre></td></tr></table></figure></p>\n<p>删除表之前先禁用.</p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p><strong>Java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">       Configuration config = HBaseConfiguration.create();</span><br><span class=\"line\">       Connection conn = ConnectionFactory.createConnection(config);</span><br><span class=\"line\">       Admin admin  = conn.getAdmin();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TableName tableName = TableName.valueOf(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">            HTableDescriptor htd = <span class=\"keyword\">new</span> HTableDescriptor(tableName);</span><br><span class=\"line\">            HColumnDescriptor hcd = <span class=\"keyword\">new</span> HColumnDescriptor(<span class=\"string\">\"data\"</span>);</span><br><span class=\"line\">            htd.addFamily(hcd);</span><br><span class=\"line\">            admin.createTable(htd);</span><br><span class=\"line\">            HTableDescriptor[] tables = admin.listTables();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tables.length != <span class=\"number\">1</span> &amp;&amp; Bytes.equals(tableName.getName(), tables[<span class=\"number\">0</span>].getTableName().getName())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Failed create of table\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Table table = conn.getTable(tableName);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] row = Bytes.toBytes(<span class=\"string\">\"row\"</span> + i);</span><br><span class=\"line\">                    Put put = <span class=\"keyword\">new</span> Put(row);</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] columnFalily = Bytes.toBytes(<span class=\"string\">\"data\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] qualifier = Bytes.toBytes(String.valueOf(i));</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] value = Bytes.toBytes(<span class=\"string\">\"value\"</span> + i);</span><br><span class=\"line\">                    put.add(columnFalily, qualifier, value);</span><br><span class=\"line\">                    table.put(put);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Get get = <span class=\"keyword\">new</span> Get(Bytes.toBytes(<span class=\"string\">\"row1\"</span>));</span><br><span class=\"line\">                Result result = table.get(get);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Get: \"</span> + result);</span><br><span class=\"line\">                Scan scan = <span class=\"keyword\">new</span> Scan();<span class=\"comment\">//scanner和cursor类似,不过在使用后要关闭</span></span><br><span class=\"line\">                ResultScanner scanner = table.getScanner(scan);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Result scannerResult : scanner) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Scan: \"</span> + scannerResult);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    scanner.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//先禁用,再丢弃</span></span><br><span class=\"line\">                admin.disableTable(tableName);</span><br><span class=\"line\">                admin.deleteTable(tableName);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                table.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            admin.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Configuration对象读入了程序classpath下hbase-site.xml等文件中的配置,客户端用ConnectionFactory创建了一个Connection对象,可以检索Admin和Table实例.Admin用于管理HBase集群,添加和丢弃表,Table用于访问指定的表.</p>\n<p><strong>MapReduce</strong><br>HBase可以作为MR的源和输出,TableInputFormat类可以在区域边界进行分隔,使map能够拿到单个的区域进行处理,TableOutputFormat将把reduce的结果写入HBase;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRowCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Configured</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RowCounterMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">TableMapper</span>&lt;<span class=\"title\">ImmutableBytesWritable</span>, <span class=\"title\">Result</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> Counters &#123; Rows &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(ImmutableBytesWritable key, Result value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            context.getCounter(Counters.Rows).increment(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">run</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"Usage SimpleRowCounter &lt;tablename&gt;\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String tableName = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        Scan scan = <span class=\"keyword\">new</span> Scan();</span><br><span class=\"line\">        scan.setFilter(<span class=\"keyword\">new</span> FirstKeyOnlyFilter());</span><br><span class=\"line\">        Job job  = <span class=\"keyword\">new</span> Job(getConf(), getClass().getSimpleName());</span><br><span class=\"line\">        job.setJarByClass(getClass());</span><br><span class=\"line\">        TableMapReduceUtil.initTableMapperJob(tableName, scan, RowCounterMapper.class, ImmutableBytesWritable.class, Result.class, job);</span><br><span class=\"line\">        job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">        job.setOutputFormatClass(NullOutputFormat.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> job.waitForCompletion(<span class=\"keyword\">true</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> exitCode = ToolRunner.run(HBaseConfiguration.create(), <span class=\"keyword\">new</span> SimpleRowCounter(), args);</span><br><span class=\"line\">        System.exit(exitCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> TableMapper是MR.Mapper的特化,他设定map输入类型由TableInputFormat来传递,输入键为ImmutableBytesWritable(行键), 值为Result(扫描行结果).TableMapReduceUtil.initTableMapperJob()对作业进行配置.</p>\n<p><strong>加载数据</strong>将要写入的数据库必须在作业配置中通过设置TableOutoputFormat.OUTPUTTABLE属性来指定.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputFormat.addInputPath(job, <span class=\"keyword\">new</span> Path(args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, <span class=\"string\">\"observations\"</span>);</span><br><span class=\"line\">job.setMapperClass(HBaseTemperatureMapper.class);</span><br><span class=\"line\">job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">job.setOutputFormatClass(TableOutputFormat.class);</span><br></pre></td></tr></table></figure></p>\n<p><em>批量加载</em><br>HBase有批量加载(bulk loading)工具,他从MR把以内部格式表示的数据直接写入文件系统,从而实现批量加载.这样比用API写入数据的方式快至少一个数量级.</p>\n<blockquote>\n<p>在使用Jar包向hbase加载数据时会出现如下错误<br>2018-03-21 20:38:01,165 INFO  [main] mapreduce.Job: Running job: job_1521635550341_0002<br>2018-03-21 20:38:06,216 INFO  [main] mapreduce.Job: Job job_1521635550341_0002 running in uber mode : false<br>2018-03-21 20:38:06,217 INFO  [main] mapreduce.Job:  map 0% reduce 0%<br>2018-03-21 20:38:06,234 INFO  [main] mapreduce.Job: doop.util.Shell.run(Shell.java:869)<br>        at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute(Shell.java:1170)<br>        at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer(DefaultContainerExecutor.java:236)<br>        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:305)<br>        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:84)<br>        at java.util.concurrent.FutureTask.run(FutureTask.java:266)<br>        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)<br>        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br>        at java.lang.Thread.run(Thread.java:748)<br>解决办法:yarn-site.xml的yarn.application.classpath配置项中，加上hbase相关的jar包。</p>\n</blockquote>\n<p>Container exited with a non-zero exit code 1<br>For more detailed output, check the application tracking page: http://<strong><strong>*</strong></strong>:8088/cluster/app/application_1521635550341_0002 Then click on links to logs of each attempt.<br>. Failing the application.</p>\n<p>批量加载过程:</p>\n<ol>\n<li>使用HFileOutputFormat2通过一个MR作业将HFile写入HDFS目录</li>\n<li>将HFiles从HDFS一如现有的HBase表中,该表在此过程可以是活跃的</li>\n</ol>\n<h2 id=\"HBase和RDBMS比较\"><a href=\"#HBase和RDBMS比较\" class=\"headerlink\" title=\"HBase和RDBMS比较\"></a>HBase和RDBMS比较</h2><p>HBASE:<br>分布式,面向列的数据存储系统,在HDFS上提供随机读写,聚焦于各种可伸缩问题,表可以很宽,很高,水平分区在上千个普通商用机节点复制.<br>RDBMS:<br>模式固定, 面向行,ACID性质,扩展性不强</p>\n","site":{"data":{}},"excerpt":"<p>HBase是一个在HDFS上开发的面向列的分布式数据库,可以用来实时的随机访问超大规模数据集,它自底向上的进行构建,能够简单的通过增加节点来达到线性扩展,HBase不是关系型数据库,不支持SQL,它能在廉价的硬件构成的集群上管理超大规模的稀疏表.</p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><p>应用将数据存放在带标签的表中,表格的”单元格”由行和列的坐标交叉决定,是<em>有版本</em>的,版本号默认是自动分配的,为插入单元格的时间戳.单元格内容是未解释的字节数组.<br>","more":"</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-21/37375528.jpg\" alt=\"\"></p>\n<p>表中行的键也是字节数组,行根据行的键进行排序,排序根据字节序进行,所有对表的访问都要通过表的主键,HBase不支持表中的其他列建立索引.<br>行中的列被分为列族,同一个列族成员具有相同的前缀,info:format和info:geo都是列族info的成员,列族前缀必须是”可打印的”,修饰符可以是任意字节,列族和修饰符用(:)分隔.</p>\n<p>一个表的<em>列族</em>必须作为表模式的定义一部分<em>预先给出</em>,但<em>列组成员</em>可以随后按需加入.物理上,所有的<em>列族成员</em>都一起存放在文件系统中,HBase更确切地说是面向列族的存储器.调优和存储都是在列族层面上进行的,所以最好使所有列族成员有相同的访问模式和大小特征.<br><em>区域</em><br>HBase自动将表水平划分为区域,每个区域由表中行的子集构成,每个区域由他所属于的表,它包含的第一行和最后一行(不包括这行)来表示.一开始一个表只有一个区域,当区域大小超出设定的阈值是便会在某行的边界上分成<em>两个大小基本相同的新分区</em>,区域是在HBase集群上分布数据最小的单位,因为太大而无法存放在单台服务器上的表会被放到服务器集群上,每个节点负责管理所有区域的一个子集.在线的所有区域按次序排列就构成了表的所有内容.</p>\n<p><em>加锁</em><br>HBase对行的更新是原子的</p>\n<p><strong>实现</strong><br>Hbase = 1个master节点 + 多个regionserver从属机<br>主控机master负责启动一个全新的安装,把区域分配给注册的regionserver,恢复regionserver故障.<br>regionserver负责将0个或者多个区域的管理和响应客户端的读写请求.还负责区域划分并告知master有新的子区域.</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-21/16805306.jpg\" alt=\"\"><br>HBase依赖于ZooKeeper,zookeeper集合体负责管理诸如hbase:meta目录表的位置以及当前集群主控机地址等重要信息.</p>\n<p>HBase使用基于SSH的机制来运行远程命令,其配置方式类似于Hadoop,HBase通过Hadoop文件系统API来持久化存储数据,但在默认情况下,HBase会将存储写入本地文件系统,因此需要把它的存储配置指向要使用的HDFS集群.</p>\n<p><em>运行中的HBase</em><br>HBase内部保留名为hbase:meta的特殊目录表,维护当前集群上所有区域的列表,状态和位置.区域变化时,目录表会重新进行相应的更新,这样集群上的信息状态就能保持是最新的.<br>新连接到zookeeper集群上的客户端首先查找hbase:meta位置,然后客户端通过查找合适的hbase:meta区域来获取用户空间区域所在节点和位置,接设客户端就可以直接和管理那个区域的regionserver交互.</p>\n<p>每个行操作可能要访问三次远程节点,为节省代价,客户端会缓存hbase:meta时获取的信息.<br>到达regionserver的写操作首先追加到”提交日志”,然后加入内存中的memstore.如果memstore满,它的内容会刷入文件系统.</p>\n<h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><p>配置好hbase后,可用mingling<code>hbase shell</code>进入shell,输入help可以查看命令列表.<br><em>创建一个表</em><br>要新建一个表,必须为表起一个名字,并为其定义模式,一个表的模式包含表的属性和列族的列表,列族本身也有属性.模式可以被修改,需要修改时用<code>disable</code>将其设为’离线’即可,<code>alter</code>命令可以进行修改,<code>enable</code>将表定义为在线.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):002:0&gt; create 'test','data'</span><br><span class=\"line\">0 row(s) in 1.2920 seconds</span><br></pre></td></tr></table></figure></p>\n<p>新建一个名为test的表,只包含一个名为data的列,表和列族属性都为默认值.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):003:0&gt; list</span><br><span class=\"line\">TABLE</span><br><span class=\"line\">test</span><br><span class=\"line\">1 row(s) in 0.0110 seconds</span><br></pre></td></tr></table></figure></p>\n<p>list输出所有表.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):004:0&gt; put 'test','row1','data:1','value1'</span><br><span class=\"line\">0 row(s) in 0.1720 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):005:0&gt; put 'test','row2','data:2','value2'</span><br><span class=\"line\">0 row(s) in 0.0120 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):006:0&gt; put 'test','row3','data:3','valle3'</span><br><span class=\"line\">0 row(s) in 0.0080 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):007:0&gt; get 'test','row1'</span><br><span class=\"line\">COLUMN                        CELL</span><br><span class=\"line\"> data:1                       timestamp=1521615103952, value=value1</span><br><span class=\"line\">1 row(s) in 0.0250 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):008:0&gt; scan 'test'</span><br><span class=\"line\">ROW                           COLUMN+CELL</span><br><span class=\"line\"> row1                         column=data:1, timestamp=1521615103952, value=value1                              </span><br><span class=\"line\"> row2                         column=data:2, timestamp=1521615113126, value=value2                              </span><br><span class=\"line\"> row3                         column=data:3, timestamp=1521615131948, value=valle3                              </span><br><span class=\"line\">3 row(s) in 0.0210 seconds</span><br></pre></td></tr></table></figure></p>\n<p>在列表中三行插入数据,get获取第一行,scan预览表的内容.<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hbase(main):003:0&gt; disable 'test'</span><br><span class=\"line\">0 row(s) in 2.3790 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):004:0&gt; drop 'test'</span><br><span class=\"line\">0 row(s) in 1.2580 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">hbase(main):005:0&gt; list</span><br><span class=\"line\">TABLE</span><br><span class=\"line\">0 row(s) in 0.0060 seconds</span><br></pre></td></tr></table></figure></p>\n<p>删除表之前先禁用.</p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p><strong>Java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">       Configuration config = HBaseConfiguration.create();</span><br><span class=\"line\">       Connection conn = ConnectionFactory.createConnection(config);</span><br><span class=\"line\">       Admin admin  = conn.getAdmin();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TableName tableName = TableName.valueOf(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">            HTableDescriptor htd = <span class=\"keyword\">new</span> HTableDescriptor(tableName);</span><br><span class=\"line\">            HColumnDescriptor hcd = <span class=\"keyword\">new</span> HColumnDescriptor(<span class=\"string\">\"data\"</span>);</span><br><span class=\"line\">            htd.addFamily(hcd);</span><br><span class=\"line\">            admin.createTable(htd);</span><br><span class=\"line\">            HTableDescriptor[] tables = admin.listTables();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tables.length != <span class=\"number\">1</span> &amp;&amp; Bytes.equals(tableName.getName(), tables[<span class=\"number\">0</span>].getTableName().getName())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Failed create of table\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Table table = conn.getTable(tableName);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] row = Bytes.toBytes(<span class=\"string\">\"row\"</span> + i);</span><br><span class=\"line\">                    Put put = <span class=\"keyword\">new</span> Put(row);</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] columnFalily = Bytes.toBytes(<span class=\"string\">\"data\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] qualifier = Bytes.toBytes(String.valueOf(i));</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] value = Bytes.toBytes(<span class=\"string\">\"value\"</span> + i);</span><br><span class=\"line\">                    put.add(columnFalily, qualifier, value);</span><br><span class=\"line\">                    table.put(put);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Get get = <span class=\"keyword\">new</span> Get(Bytes.toBytes(<span class=\"string\">\"row1\"</span>));</span><br><span class=\"line\">                Result result = table.get(get);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Get: \"</span> + result);</span><br><span class=\"line\">                Scan scan = <span class=\"keyword\">new</span> Scan();<span class=\"comment\">//scanner和cursor类似,不过在使用后要关闭</span></span><br><span class=\"line\">                ResultScanner scanner = table.getScanner(scan);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Result scannerResult : scanner) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Scan: \"</span> + scannerResult);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    scanner.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//先禁用,再丢弃</span></span><br><span class=\"line\">                admin.disableTable(tableName);</span><br><span class=\"line\">                admin.deleteTable(tableName);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                table.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            admin.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Configuration对象读入了程序classpath下hbase-site.xml等文件中的配置,客户端用ConnectionFactory创建了一个Connection对象,可以检索Admin和Table实例.Admin用于管理HBase集群,添加和丢弃表,Table用于访问指定的表.</p>\n<p><strong>MapReduce</strong><br>HBase可以作为MR的源和输出,TableInputFormat类可以在区域边界进行分隔,使map能够拿到单个的区域进行处理,TableOutputFormat将把reduce的结果写入HBase;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRowCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Configured</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RowCounterMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">TableMapper</span>&lt;<span class=\"title\">ImmutableBytesWritable</span>, <span class=\"title\">Result</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> Counters &#123; Rows &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(ImmutableBytesWritable key, Result value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            context.getCounter(Counters.Rows).increment(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">run</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"Usage SimpleRowCounter &lt;tablename&gt;\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String tableName = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        Scan scan = <span class=\"keyword\">new</span> Scan();</span><br><span class=\"line\">        scan.setFilter(<span class=\"keyword\">new</span> FirstKeyOnlyFilter());</span><br><span class=\"line\">        Job job  = <span class=\"keyword\">new</span> Job(getConf(), getClass().getSimpleName());</span><br><span class=\"line\">        job.setJarByClass(getClass());</span><br><span class=\"line\">        TableMapReduceUtil.initTableMapperJob(tableName, scan, RowCounterMapper.class, ImmutableBytesWritable.class, Result.class, job);</span><br><span class=\"line\">        job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">        job.setOutputFormatClass(NullOutputFormat.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> job.waitForCompletion(<span class=\"keyword\">true</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> exitCode = ToolRunner.run(HBaseConfiguration.create(), <span class=\"keyword\">new</span> SimpleRowCounter(), args);</span><br><span class=\"line\">        System.exit(exitCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> TableMapper是MR.Mapper的特化,他设定map输入类型由TableInputFormat来传递,输入键为ImmutableBytesWritable(行键), 值为Result(扫描行结果).TableMapReduceUtil.initTableMapperJob()对作业进行配置.</p>\n<p><strong>加载数据</strong>将要写入的数据库必须在作业配置中通过设置TableOutoputFormat.OUTPUTTABLE属性来指定.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputFormat.addInputPath(job, <span class=\"keyword\">new</span> Path(args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, <span class=\"string\">\"observations\"</span>);</span><br><span class=\"line\">job.setMapperClass(HBaseTemperatureMapper.class);</span><br><span class=\"line\">job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">job.setOutputFormatClass(TableOutputFormat.class);</span><br></pre></td></tr></table></figure></p>\n<p><em>批量加载</em><br>HBase有批量加载(bulk loading)工具,他从MR把以内部格式表示的数据直接写入文件系统,从而实现批量加载.这样比用API写入数据的方式快至少一个数量级.</p>\n<blockquote>\n<p>在使用Jar包向hbase加载数据时会出现如下错误<br>2018-03-21 20:38:01,165 INFO  [main] mapreduce.Job: Running job: job_1521635550341_0002<br>2018-03-21 20:38:06,216 INFO  [main] mapreduce.Job: Job job_1521635550341_0002 running in uber mode : false<br>2018-03-21 20:38:06,217 INFO  [main] mapreduce.Job:  map 0% reduce 0%<br>2018-03-21 20:38:06,234 INFO  [main] mapreduce.Job: doop.util.Shell.run(Shell.java:869)<br>        at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute(Shell.java:1170)<br>        at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer(DefaultContainerExecutor.java:236)<br>        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:305)<br>        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:84)<br>        at java.util.concurrent.FutureTask.run(FutureTask.java:266)<br>        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)<br>        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br>        at java.lang.Thread.run(Thread.java:748)<br>解决办法:yarn-site.xml的yarn.application.classpath配置项中，加上hbase相关的jar包。</p>\n</blockquote>\n<p>Container exited with a non-zero exit code 1<br>For more detailed output, check the application tracking page: http://<strong><strong>*</strong></strong>:8088/cluster/app/application_1521635550341_0002 Then click on links to logs of each attempt.<br>. Failing the application.</p>\n<p>批量加载过程:</p>\n<ol>\n<li>使用HFileOutputFormat2通过一个MR作业将HFile写入HDFS目录</li>\n<li>将HFiles从HDFS一如现有的HBase表中,该表在此过程可以是活跃的</li>\n</ol>\n<h2 id=\"HBase和RDBMS比较\"><a href=\"#HBase和RDBMS比较\" class=\"headerlink\" title=\"HBase和RDBMS比较\"></a>HBase和RDBMS比较</h2><p>HBASE:<br>分布式,面向列的数据存储系统,在HDFS上提供随机读写,聚焦于各种可伸缩问题,表可以很宽,很高,水平分区在上千个普通商用机节点复制.<br>RDBMS:<br>模式固定, 面向行,ACID性质,扩展性不强</p>"},{"title":"关于Hive","date":"2018-03-17T03:43:31.000Z","_content":"\n>本篇博客主要来自于本人学习<<Hadoop权威指南>>Hive部分的笔记和一些理解\n\nHive是构建在Hadoop上的数据仓库框架,它把SQL查询转换为一系列在Hadoop集群上运行的作业,它的数据组织为表,元数据(eg.表模式)存储在metastore数据库中. metastore默认模本式为运行在本机上.\n\nHive shell环境\n---\n\nHiveQL是Hive的查询语言,类似Mysql,运行方式有:\n  <!-- more-->\n*\t**交互模式** : hive命令进入shell\n\t\n    > 第一次使用时会花几秒时间,因为系统采用**\"延迟\"**策略,直到执行第一个命令才在运行hive命令的那个位置下的metastore_db目录中创建metastore数据库.\n\n*\t**非交互模式** : \n\t`hive -f script.q` -f选项运行指定文件中的命令\n\t`hive -e 'SELECT * FROM DUMMY'` -e选项在行内嵌入命令\n    \n**用到的HiveQL特有的关键字**:\n\n>`create table records (year STRING, temperature INT, quality INT) ROW FORMAT DELIMITED FIELDS TERMINATED BY '\\t';`\n\n* \tROW FORMAT : 声明数据文件的每一行是由制表符分割的文本\n\n> `LOAD DATA LOCAL INPATH 'input/ncdc/micro-tab/sample.txt' OVERWRITE INTO TABLE records;`\n\n* 告诉Hive将本地文件放入其仓库目录,此操作并不解析文件或将它存储为内部数据库格式,因为Hive不强制使用任何特定文件格式. 在Hive中,表存储为目录,可由hive.metastore.warehouse.dir控制目录位置.\n\n* OVERWRITE\t: 删除表对应目录中的所有文件\n\n>`select year ,MAX(temperature) from records where temperature != 9999 and quality in (0,1,4,5,9) group by year;`\n\n* Hive 将查询转化为一个作业并执行作业,将结果打印到console\n\n**Hive设置属性优先级(顺序递减)**:\n\n\t. SET命令\n\t. 命令行 -hiveconf选项\n\t. hive-site.xml 和 Hadoop站点文件\n\t. Hive默认值和Hadoop默认值\n\n***MetaStore***\n---\nmetastore是Hive元数据的存放地,包括*服务*和*后台数据*的存储,默认情况下metastore和Hive运行在同个JVM,包含一个内嵌的以本地磁盘作为存储的[Derby数据库](https://www.cnblogs.com/zuzZ/p/8107915.html)实例,称为**内嵌metastore配置**.\n\n> 内嵌配置的缺点:每次只有一个内嵌Derby数据库可访问磁盘上的数据库文件,一次只能为每个metast打开一个Hive会话.\n\n要支持多个会话,需使用一个独立的数据库,称为**本地metastore配置**需要设置本地Mysql的用户名,密码等,还可以利用**远程metastore配置**使得一个或多个metastore服务器和Hive服务器运行在不同进程内,客户端不需数据库凭据.\n\n传统数据库与Hive对比\n---\n1. 传统数据库: **写时模式**,表的模式在加载时强制确定\n\t>缺点: 加载慢,需要读取数据进行解析->序列化->以内部格式存入磁盘.\n\t>优点: 有利于提升查询性能,因为可以对列进行索引,对数据压缩.\n\n   Hive: **读时模式**,在查询时才验证数据模式,加载迅速,仅仅是文件的复制和移动\n\n2. 更新,事务和索引\n\n \tHDFS不支持就地更新,插入,更新删除操作引起的一切变化都被保存在一个增量文件中,由metastore在后台运行的mapreduce作业会定期将增量文件合并到基表.\n    \n    Hive引入了表级和分区级的锁,由ZooKeeper透明管理,用户不用执行获得和释放锁的操作.\n    \n    Hive索引分为*紧凑*和*位图*索引,可插拔,紧凑索引存储每个值的HDFS块号而不是文件内偏移量,不会占用过多磁盘空间;位图索引使用压缩的bitset来高效存储具有特殊值的行,适用于具有极少取值的列.\n    \n表\n---\nHive中的表在逻辑上由存储的数据和描述表中数据形式的相关元数据组成.*数据*一般存放在HDFS上,也可以是其他Hadoop文件系统,Hive把*元数据*存放在关系型数据库\n\n**托管表和外部表**\nHive创建表时,默认由Hive管理数据,将数据移入它的\"仓库目录\",称为*托管表*.另一种方式是*外部表*,Hive到仓库目录以外的位置访问数据. 区别体现在DROP 和 LOAD上.\n\n* 托管表:\n> 加载操作就是文件系统中文件移动或重命名,执行速度快,如果要手动检查是否满足模式,可以通过查询为缺失字段返回的空值NULL才知道不匹配的行.\n>`load data local inpath 'input/hive/dummy.txt' into table managed_table;`\n>执行删除操作后,它的元数据和数据会被一起删除,在HDFS中可以看到删除表后/user/hive/warehouse中的managed_table也被删除了.\n>`drop table managed_table;`\n\n* 外部表\n> 创建表示需要指明外部数据的位置,定义时Hive不会检查外部位置是否存在,故可以在创建表之后再创建数据\n> `create external table external_table (dummy STRING) LOCATION /user/harold/external_table`;\n> 丢弃外部表时,Hive只会删除元数据,不会删除数据\n\n**分区和桶**\nHive把表组织成*分区*,使用分区可以加快数据分片的查询速度.表或分区可以进一部分为桶(bucket)它会为数据提供额外的结构以获得更高效的查询处理.\n\n- *分区* : 分区使得表对限制到某个特定范围的数据的查询变得非常高效(比如按照日期分区),只需扫描查询范围内分区中的文件,而且不会影响大范围查询的执行.一个表可以以多个维度分区,即进行子分区.\n\n分区是在创建表时用PARTITIONED BY子句定义的:\n >`CREATE TABLE logs (ts BIGINT, line STRING) PARTITIONED BY (dt STRING, country      STRING);`\n\n  在将数据加载到分区表时,要显示指定分区值:\n > `LOAD DATA LOCAL INPATH 'input/hive/partitions/file1' INTO TABLE logs PARTITION (dt='2001-01-01', country='GB');`\n > `SHOW PARTITON logs;` 可以展示表中的分区\n\n- *桶* :\n\t将表或分区组织成桶的理由:\n   > . 获得高效的查询处理效率\n   > . 使取样更高效\n创建被划分成桶的表:\n   >`CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) INTO 4 BUCKETS;`\n   桶中的数据可以根据一个列或者多个列排序,这样对每个桶的连接变成了高效的归并排序,提升了map端连接的效率:\n   > `CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) SORTED BY (id) INTO 4 BUCKETS;`\n\n   Hive并不检查数据文件中的桶是否和表定义中的桶一致,无论是桶的数量还是用来划分的列, 如果不匹配会 ,查询时会碰到错误或未定义的结果.\n   将一个没有划分桶的数据集users填充进分桶后的表的步骤如下:\n   > `SET hive.enforce.bucketing=true;` 这样Hive就知道用表中声明的数量来创建桶\n   > `INSERT OVERWRITE TABLE bucketed_users SELECT * FROM users;`Insert 即可\n   \n物理上,每个桶就是表目录中的一个文件,一个作业产生的桶(输出文件)和reduce任务个数相同.\n   \n用TABLESAMPLE子句对表取样:\n`SELECT * FROM bucketed_users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);`\n和\n`SELECT * FROM users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);`\n \n得到的结果一样.\n \n**存储格式**\n \n Hive从两个维度对表的存储进行管理:\n * 行格式: 行和行中的字段如何存储,行格式由SerDe(Serializer-Deserializer)定义. 当作为反序列化工具使用时(即查询表),SerDe将把文件中字节形式的数据反序列化为Hive内部操作行时所使用的对象形式,作为序列化工具时(INSERT,CTAS),表的SerDe会把Hive的数据行内部表示形式序列化成字节形式并写道输出文件中.\n * 文件格式: 一行中字段容器的格式\n \n*默认的存储格式----分隔的文本*\n\n在创建表时如果没有用ROW FORMAT或STORED AS子句,Hive所使用的默认格式是分隔的文本,每行存储一个数据行.\n\n默认行内分隔符不是制表符,而是ASCII控制码集合中的Control-A,原因是它出现在字段文本中的可能性较小,Hive中无法对分隔符进行转义,因此挑选一个不会在数据字段中用到的字符作为分隔符非常重要.\n> 集合类的默认分隔符为Control-B,用于分隔ARRAY,STRUCT或MAP的键值对中的元素\n> 默认的映射键(map key)分隔符为Control-C,用于分隔map的键和值\n> 表中各行用换行符分隔\n> 可以用hexdump查看输出文件的分隔符\n\nHive支持8级分隔符,对应ASCII编码的1-8,但只能重载前三个.可用8进制形式表示分隔符,如001表示Control-A.\n\nHivene内部使用LazySimpleSerDe来处理这种分隔格式以及面向行的MapReduce文本输入输出格式,他对字段的反序列化是延时处理的,只有在访问字段时才进行反序列化.\n\n*二进制存储格式: 顺序文件 Avro数据文件 Parquet文件 RCFile ORCFile*\n\n二进制格式:\n1. 面向行的格式(Avro,顺序文件): 适合同时处理一行中很多列\n\t> `SET hive.exec.compress.output=true;`\n\t> `SET avro.output.codec=snappy;`\n\t> `CREATE TABLE ... STORE AS AVRO;`\n\t> 可以将表存储为Avro格式\n2. 面向列的格式(Parquet文件 RCFile ORCFile): 对于只访问表中一小部分列的查询有效\n\n使用定制的SerDe: RegexSerDe\n>`REATE TABLE stations (usaf STRING, wban STRING, name STRING) ROW FORMAT SERDE 'org.apache.hadoop.hive.contrib.serde2.RegexSerDe' WITH SERDEPROPERTIES (\"input.regex\" = \"(\\\\d{6}) (\\\\d{5}) (\\\\.{29}) .*\");`\n>\n>使用SERDE关键字和JAVA类完整类名指明使用哪个SerDe.用 WITH SERDEPROPERTIES设置SERDE的额外属性.\n>\n>`LOAD DATA LOCAL INPATH \"input/ncdc/metadata/stations-fixed-width.txt\" INTO TABLE stations;`\n>\n>`hive> SELECT * FROM stations LIMIT 4;\nOK\n010000\t99999\tBOGUS NORWAY\n010003\t99999\tBOGUS NORWAY\n010010\t99999\tJAN MAYEN\n010013\t99999\tROST `\n效率比较低,一般用二进制存储格式\n\n*导入数据*\n> **INSERT语句**\n> 动态分区插入:\n>>`INSERT OVERWRITE TABLE target PARTITION(dt) SELECT COL1, CLO2, dt FROM source`\n\n>**多表插入**\n>>`FROM records2`\n`INSERT OVERWRITE TABLE stations_by_year SELECT year,COUNT(DISTINCT station) GROUP BY year`\n`INSERT OVERWRITE TABLE records_by_year SELECT year, COUNT(1) GROUP BY year`\n`INSERT OVERWRITE TABLE good_records_by_year SELECT year, COUNT(1) WHERE temperature != 9999 AND quality IN (0, 1, 4, 5, 9) GROUP BY year;`\n比单表效率高,只需扫一遍原表就可以生成多个不想交的输出\n\n>**CTAS**\n>`CREATA TABLE target AS SELECT col1, col2 FROM source;`\n>CTAS操作是原子的,如select查询由于某种原因失败,则不会创建表target\n\n*表的修改*\nHive使用读时模式,创建表后可以灵活的支持对表的修改,但是需要警惕确保修改数据以符合新的结构.\n>`ALTER TABLE source RENAME TO target;`\n\n重命名表,在更新元数据以外ALTER TABLE还把表目录移到新名称对应的目录下,对于外部表则只更新元数据.\n\n>`ALTER TABLE target ADD COLUMNS (cols3 STRING);`\n\n添加新的列cols3在已有(非分区)列的后面,数据文件并没有更新,原来的查询会为cols3的结果返回null,Hive不允许更新已有的记录,故一般创建一个定义了新列的新表.然后使用SELECT语句把数据填充进去.\n\n*表的丢弃*\nDROP TABLE;删除表中数据和元数据(外部表数据除外)\nTRUNCATE TABLE my_table;删除表内所有数据,但保留定义(对外部表不起作用)\nCREATE TABLE new_table LIKE existing_table;达到类似TRUNCATE的目的.\n\n查询数据\n---\n**排序和聚集**\n* ORDER BY : 对输入执行并行全排序\n* SORT BY : 为每个reducer产生一个排序文件\n* DISTRIBUTE BY : 控制特定行到某个reducer,便于后续的聚集操作\n>`FROM records2 SELECT year, temperature DISTRIBUTE BY year SORT BY year ASC, temperature DESC;`\n\n**MapReduce脚本**\nTRANSFORM,MAP,REDUCE子句可在Hive中调用外部脚本或程序.\n> ``` python\n>#is_good_quality.py\n>import re\nimport sys\nfor line in sys.stdin:\n    (year,temp,q) = line.strip().split()\n    if (temp != \"9999\" and re.match(\"[01459]\"),q)):\n        print(\"%s\\t%s\" % (year, temp))```\n\n>`ADD FILE /input/is_good_quality.py;` 在Hive中注册脚本,Hive将脚本文件传到Hadoop集群\n>`FROM records2 select TRANSFORM(year,temperature,quality) USING 'is_good_quality.py' as year, temperature;` \n\n这一实例并未使用reducer.如果要使用嵌套模式,可以指定map和reduce函数:\n>```python\n>FROM (\n  FROM records2\n  MAP year, temperature, quality\n  USING 'is_good_quality.py'\n  AS year, temperature) map_output\nREDUCE year, temperature\nUSING 'max_temperature_reduce.py'\nAS year, temperature;```\n和\n```python\nFROM (\n  FROM records2\n  SELECT TRANSFORM(year, temperature, quality)\n  USING 'is_good_quality.py'\n  AS year, temperature) map_output\nSELECT TRANSFORM(year, temperature)\nUSING 'max_temperature_reduce.py'\nAS year, temperature;```\n结果一致\n\n**连接**\n\n*内连接*:输入表之间每次匹配都会在输出行里生成一行:\n>```\n>SELECT * FROM sales;\nJoe\t2\nHank\t4\nAli\t0\nEve\t3\nHank\t2```\n>```\n> SELECT * FROM things;\n2\tTie\n4\tCoat\n3\tHat\n1\tScarf```\n\n>```\nSELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);\nJoe\t2\t2\tTie\nHank\t4\t4\tCoat\nEve\t3\t3\tHat\nHank\t2\t2\tTie\n```\n>JOIN子句中的顺序很重要:一般将最大的表放到最后,因为JOIN前一阶段生成的数据会存在于Reducer的buffer中，通过stream最后面的表，直接从Reducer的buffer中读取已经缓冲的中间结果数据（这个中间结果数据可能是JOIN顺序中，前面表连接的结果的Key，数据量相对较小，内存开销就小），这样，与后面的大表进行连接时，只需要从buffer中读取缓存的Key，与大表中的指定Key进行连接，速度会更快，也可能避免内存缓冲区溢出.(出自[简单之美](http://shiyanjun.cn/archives/588.html))\n>\nHive只支持等值连接,在连接谓词中只能使用等号,还可以在在查询中使用多个JOIN...ON...子句来连接多个表,Hive会智能的以最少的MapReduce作业数来执行连接.单个连接用一个MR作业实现,如果多个连接条件中使用了相同的列那么平均每个连接可以使用少于一个MR作业来实现.\n\n**外连接**\n外连接可以找到表中不能匹配的数据行:\n>```\n>左连接\nSELECT sales.*, things.* FROM sales LEFT OUTER JOIN things ON (sales.id = things.id);\nJoe\t2\t2\tTie\nHank\t4\t4\tCoat\nAli\t0\tNULL\tNULL\nEve\t3\t3\tHat\nHank\t2\t2\tTie\n```\n当然Hive也支持右连接和全外连接:\n>```右连接\nSELECT sales.*, things.* FROM sales RIGHT OUTER JOIN things ON (sales.id = things.id);\nJoe\t2\t2\tTie\nHank\t2\t2\tTie\nHank\t4\t4\tCoat\nEve\t3\t3\tHat\nNULL\tNULL\t1\tScarf```\n>```\n>SELECT sales.*, things.* FROM sales FULL OUTER JOIN things ON (sales.id = things.id)\n>Ali\t0\tNULL\tNULL\nNULL\tNULL\t1\tScarf\nHank\t2\t2\tTie\nJoe\t2\t2\tTie\nEve\t3\t3\tHat\nHank\t4\t4\tCoat\n```\n**半连接**\nLEFT SEMI JOIN:\n>```\nselect * from sales left semi join things on (sales.id = things.id);\nJoe\t2\nHank\t4\nEve\t3\nHank\t2```\n右表只能在ON子句中出现,不能在SELECT表达式中引用右表.\n\n**map连接**\n如果有一个连接表小到足以放入内存,Hive就将较小的表放入每个mapper的内存来执行连接操作.\nmap连接不适用Reducer,因此对于RIGHT或者FULL OUTER JOIN无效,因为只有在对所有输入上进行聚集的步骤(reduce)才能检测到那个数据行无法匹配.\nmap连接可以利用分桶的表,因为作用于左侧表的桶的mapper加载右侧表中对应的桶即可执行连接.需要`SET hive.optimize.bucketmapjoin=true`启用优化选项.\n\n**子查询**\n子查询是内嵌在另一个SQL语句中的SELECT语句,Hive只允许子查询出现在SELECT语句的FROM子句中,或某些特殊情况下的WHERE子句中.\n>```\n>hive> SELECT station, year, AVG(max_temperature)\n     FROM (\n     SELECT station, year, MAX(temperature) AS max_temperature\n     FROM records2\n     WHERE temperature != 9999 AND quality IN (0,1,4,5,9)\n     GROUP BY station, year\n     ) mt\n     GROUP BY station, year;\n```\n外层查询像访问表那样访问子查询的结果,所以必须为子查询赋予一个别名(mt),子查询中的列必须有唯一的名称,以便外层访问引用这些列.\n\n**视图**\n用SELECT语句定义的虚表,可以限制用户,使其只能访问被授权可以看到的表的子集.Hive中,创建视图并不把视图物化存储到磁盘上,视图的SELECT语句只在执行引用视图的语句时才执行.要手工物化视图,可以新建一个表,将视图内容存储到新表中.\n创建方式:CREATE VIEW\n> ```\n> CREATE VIEW valid_records AS SELECT * FROM records2 WHERE temperature != 9999 AND quality IN (0,1,4,5,9);```\n> 创建视图时并不执行查询,查询只是存储在metastore中,SHOW TABLES命令结果包含视图,可用DESCRIBE EXTENDED view_name来查看视图的详细信息.\n> ![](/home/harold/Pictures/Selection_021.png)\n\nHive可以把使用视图的查询组织为一系列作业,效果与不使用视图一样.即使在执行时,Hive也不会再不必要的情况下物化视图.\n\nHive中的视图是只读的,无法通过视图为基表加载或插入数据.\n\n用户定义函数----UDF\n---\n用户定义函数(user-defined function)必须用Java编写,其他语言可以用之前用过的`SELECT TRANSFORM`查询.\n\nHive三种UDF, 他们所接受的输入和产生的输出的数据行的数量不同 :\n* 普通UDF : 作用于单个数据行,产生一个数据行\n* 用户定义聚集函数 UDAF : 接受多个数据行,产生一个输出行, 类似COUNT , MAX\n* 用户定义表生成函数 UDTF : 作用于单个数据行, 产生多个输出行\n\n*UDTF*:\n```>\nhive> create table arrays (x ARRAY<STRING>) ROW\n    > FORMAT DELIMITED\n    > FIELDS TERMINATED BY '\\001'\n    > COLLECTION ITEMS TERMINATED BY '\\002';```\n\n```>\nhive> SELECT * FROM arrays;\nOK\n[\"a\",\"b\"]\n[\"c\",\"d\",\"e\"]\n```\nexplode UDTF对表进行变换,为数组中的每一项输出一行.\n```>\nhive> SELECT explode(x) AS y from arrays;\nOK\na\nb\nc\nd\ne```\n\n常用的UDTF还有SPLIT() 等,还有更强大的LATERAL VIEW查询,笔者会在之后的博客详细介绍.\n\n**写UDF**\n```java\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.hadoop.hive.ql.exec.UDF;\nimport org.apache.hadoop.io.Text;\n\npublic class Strip extends UDF {\n    private Text result = new Text();\n    public Text evaluate (Text str) {\n        if (str == null) {\n            return null;\n        }\n\n        result.set(StringUtils.strip(str.toString()));\n        return result;\n    }\n\n    public Text evaluate(Text str, String stripChars) {\n        if(str == null) {\n            return null;\n        }\n        result.set(StringUtils.strip(str.toString(), stripChars));\n        return result;\n    }\n}```\n\n一个UDF必须满足:\n1. 是org.apache.hadoop.hive.ql.exec.UDF的子类\n2. 至少实现了evaluate()方法\n\nevaluate()不是由接口定义的,它接受的参数个数和类型以及返回值都是不确定的,Hive会检查UDF,看能否找到相匹配的evaluate().\n\n使用UDF:\n1.在metastore中注册函数并用CTREATE FUNCTION为它取名:\n> CREATE FUNCTION strip AS 'com.hadoopbook.hive.Strip' USING JAR 'path/hive-example.jar'\n\n2.使用内置函数:\n>SELECT strip(' bee ') FROM dummy; UDF名对大小写不敏感\n\n3.删除函数:\n>DROP FUNCTION strip;\n\n4.用TEMPORARY创建仅在Hive会话期间有效的函数,不在metastore中持久化:\n>`ADD JAR /path/hive-example.jar;`\n>`CREATE TEMPORARY FUNCTION strip AS 'com.hadoopbook.hive.Strip';`\n\n**写UDAF**\n```java\nimport org.apache.hadoop.hive.ql.exec.UDAF;\nimport org.apache.hadoop.hive.ql.exec.UDAFEvaluator;\nimport org.apache.hadoop.io.IntWritable;\n\npublic class Maximum extends UDAF{\n    public static class MaximumIntUDAFEvaluator implements UDAFEvaluator{\n        private IntWritable result;\n\n        @Override\n        public void init() {\n            result = null;\n        }\n\n\n        public boolean iterate(IntWritable value) {\n            if (value == null) {\n                return true;\n            }\n            if (result == null) {\n                result = new IntWritable(value.get());\n            } else {\n                result.set(Math.max(result.get(), value.get()));\n            }\n            return true;\n        }\n\n        public IntWritable terminatePartial() {\n            return result;\n        }\n\n        public boolean merge(IntWritable other) {\n            return iterate(other);\n        }\n\n        public IntWritable terminate() {\n            return result;\n        }\n    }\n}\n```\nUDAF必须是org.apache.hadoop.hive.ql.exec.UDAF的子类(*UDAF类已经过时弃用了，现在是实现GenericUDAFResolver2接口,请看本博客另一篇相关的文内容*), 且包含一个或多个嵌套的实现了Org.apache.hadoop.hive.ql.exec.UDAFEvaluator的*静态类*.\n\n一个计算函数必须实现以下五个方法:\n\n* init() : 负责初始化计算函数并设置他的内部状态\n\n* inerate() : 每次对一个新值进行聚集计算都会调用此方法,iterate()接受的参数和Hive中被调用函数的参数是对应的.\n\n* terminate() : Hive需要部分聚集结果时会调用此方法,这个方法必须返回一个封装了聚集计算当前状态的对象.\n\n*  merge()方法 : 在Hive合并两个部分聚集值时会调用merge()方法.该方法接受一个对象作为输入,其类型必须和terminatePartial()方法的返回类型一致.\n \n*  terminate()方法 : Hive需要最终聚集结果时会调用此方法\n\n*  计算流程见下图:\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-18/61809116.jpg)\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/关于HIVE.md","raw":"---\ntitle: 关于Hive\ndate: 2018-03-17 11:43:31\ntags: [大数据, Hive, Hadoop]\n---\n\n>本篇博客主要来自于本人学习<<Hadoop权威指南>>Hive部分的笔记和一些理解\n\nHive是构建在Hadoop上的数据仓库框架,它把SQL查询转换为一系列在Hadoop集群上运行的作业,它的数据组织为表,元数据(eg.表模式)存储在metastore数据库中. metastore默认模本式为运行在本机上.\n\nHive shell环境\n---\n\nHiveQL是Hive的查询语言,类似Mysql,运行方式有:\n  <!-- more-->\n*\t**交互模式** : hive命令进入shell\n\t\n    > 第一次使用时会花几秒时间,因为系统采用**\"延迟\"**策略,直到执行第一个命令才在运行hive命令的那个位置下的metastore_db目录中创建metastore数据库.\n\n*\t**非交互模式** : \n\t`hive -f script.q` -f选项运行指定文件中的命令\n\t`hive -e 'SELECT * FROM DUMMY'` -e选项在行内嵌入命令\n    \n**用到的HiveQL特有的关键字**:\n\n>`create table records (year STRING, temperature INT, quality INT) ROW FORMAT DELIMITED FIELDS TERMINATED BY '\\t';`\n\n* \tROW FORMAT : 声明数据文件的每一行是由制表符分割的文本\n\n> `LOAD DATA LOCAL INPATH 'input/ncdc/micro-tab/sample.txt' OVERWRITE INTO TABLE records;`\n\n* 告诉Hive将本地文件放入其仓库目录,此操作并不解析文件或将它存储为内部数据库格式,因为Hive不强制使用任何特定文件格式. 在Hive中,表存储为目录,可由hive.metastore.warehouse.dir控制目录位置.\n\n* OVERWRITE\t: 删除表对应目录中的所有文件\n\n>`select year ,MAX(temperature) from records where temperature != 9999 and quality in (0,1,4,5,9) group by year;`\n\n* Hive 将查询转化为一个作业并执行作业,将结果打印到console\n\n**Hive设置属性优先级(顺序递减)**:\n\n\t. SET命令\n\t. 命令行 -hiveconf选项\n\t. hive-site.xml 和 Hadoop站点文件\n\t. Hive默认值和Hadoop默认值\n\n***MetaStore***\n---\nmetastore是Hive元数据的存放地,包括*服务*和*后台数据*的存储,默认情况下metastore和Hive运行在同个JVM,包含一个内嵌的以本地磁盘作为存储的[Derby数据库](https://www.cnblogs.com/zuzZ/p/8107915.html)实例,称为**内嵌metastore配置**.\n\n> 内嵌配置的缺点:每次只有一个内嵌Derby数据库可访问磁盘上的数据库文件,一次只能为每个metast打开一个Hive会话.\n\n要支持多个会话,需使用一个独立的数据库,称为**本地metastore配置**需要设置本地Mysql的用户名,密码等,还可以利用**远程metastore配置**使得一个或多个metastore服务器和Hive服务器运行在不同进程内,客户端不需数据库凭据.\n\n传统数据库与Hive对比\n---\n1. 传统数据库: **写时模式**,表的模式在加载时强制确定\n\t>缺点: 加载慢,需要读取数据进行解析->序列化->以内部格式存入磁盘.\n\t>优点: 有利于提升查询性能,因为可以对列进行索引,对数据压缩.\n\n   Hive: **读时模式**,在查询时才验证数据模式,加载迅速,仅仅是文件的复制和移动\n\n2. 更新,事务和索引\n\n \tHDFS不支持就地更新,插入,更新删除操作引起的一切变化都被保存在一个增量文件中,由metastore在后台运行的mapreduce作业会定期将增量文件合并到基表.\n    \n    Hive引入了表级和分区级的锁,由ZooKeeper透明管理,用户不用执行获得和释放锁的操作.\n    \n    Hive索引分为*紧凑*和*位图*索引,可插拔,紧凑索引存储每个值的HDFS块号而不是文件内偏移量,不会占用过多磁盘空间;位图索引使用压缩的bitset来高效存储具有特殊值的行,适用于具有极少取值的列.\n    \n表\n---\nHive中的表在逻辑上由存储的数据和描述表中数据形式的相关元数据组成.*数据*一般存放在HDFS上,也可以是其他Hadoop文件系统,Hive把*元数据*存放在关系型数据库\n\n**托管表和外部表**\nHive创建表时,默认由Hive管理数据,将数据移入它的\"仓库目录\",称为*托管表*.另一种方式是*外部表*,Hive到仓库目录以外的位置访问数据. 区别体现在DROP 和 LOAD上.\n\n* 托管表:\n> 加载操作就是文件系统中文件移动或重命名,执行速度快,如果要手动检查是否满足模式,可以通过查询为缺失字段返回的空值NULL才知道不匹配的行.\n>`load data local inpath 'input/hive/dummy.txt' into table managed_table;`\n>执行删除操作后,它的元数据和数据会被一起删除,在HDFS中可以看到删除表后/user/hive/warehouse中的managed_table也被删除了.\n>`drop table managed_table;`\n\n* 外部表\n> 创建表示需要指明外部数据的位置,定义时Hive不会检查外部位置是否存在,故可以在创建表之后再创建数据\n> `create external table external_table (dummy STRING) LOCATION /user/harold/external_table`;\n> 丢弃外部表时,Hive只会删除元数据,不会删除数据\n\n**分区和桶**\nHive把表组织成*分区*,使用分区可以加快数据分片的查询速度.表或分区可以进一部分为桶(bucket)它会为数据提供额外的结构以获得更高效的查询处理.\n\n- *分区* : 分区使得表对限制到某个特定范围的数据的查询变得非常高效(比如按照日期分区),只需扫描查询范围内分区中的文件,而且不会影响大范围查询的执行.一个表可以以多个维度分区,即进行子分区.\n\n分区是在创建表时用PARTITIONED BY子句定义的:\n >`CREATE TABLE logs (ts BIGINT, line STRING) PARTITIONED BY (dt STRING, country      STRING);`\n\n  在将数据加载到分区表时,要显示指定分区值:\n > `LOAD DATA LOCAL INPATH 'input/hive/partitions/file1' INTO TABLE logs PARTITION (dt='2001-01-01', country='GB');`\n > `SHOW PARTITON logs;` 可以展示表中的分区\n\n- *桶* :\n\t将表或分区组织成桶的理由:\n   > . 获得高效的查询处理效率\n   > . 使取样更高效\n创建被划分成桶的表:\n   >`CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) INTO 4 BUCKETS;`\n   桶中的数据可以根据一个列或者多个列排序,这样对每个桶的连接变成了高效的归并排序,提升了map端连接的效率:\n   > `CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) SORTED BY (id) INTO 4 BUCKETS;`\n\n   Hive并不检查数据文件中的桶是否和表定义中的桶一致,无论是桶的数量还是用来划分的列, 如果不匹配会 ,查询时会碰到错误或未定义的结果.\n   将一个没有划分桶的数据集users填充进分桶后的表的步骤如下:\n   > `SET hive.enforce.bucketing=true;` 这样Hive就知道用表中声明的数量来创建桶\n   > `INSERT OVERWRITE TABLE bucketed_users SELECT * FROM users;`Insert 即可\n   \n物理上,每个桶就是表目录中的一个文件,一个作业产生的桶(输出文件)和reduce任务个数相同.\n   \n用TABLESAMPLE子句对表取样:\n`SELECT * FROM bucketed_users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);`\n和\n`SELECT * FROM users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);`\n \n得到的结果一样.\n \n**存储格式**\n \n Hive从两个维度对表的存储进行管理:\n * 行格式: 行和行中的字段如何存储,行格式由SerDe(Serializer-Deserializer)定义. 当作为反序列化工具使用时(即查询表),SerDe将把文件中字节形式的数据反序列化为Hive内部操作行时所使用的对象形式,作为序列化工具时(INSERT,CTAS),表的SerDe会把Hive的数据行内部表示形式序列化成字节形式并写道输出文件中.\n * 文件格式: 一行中字段容器的格式\n \n*默认的存储格式----分隔的文本*\n\n在创建表时如果没有用ROW FORMAT或STORED AS子句,Hive所使用的默认格式是分隔的文本,每行存储一个数据行.\n\n默认行内分隔符不是制表符,而是ASCII控制码集合中的Control-A,原因是它出现在字段文本中的可能性较小,Hive中无法对分隔符进行转义,因此挑选一个不会在数据字段中用到的字符作为分隔符非常重要.\n> 集合类的默认分隔符为Control-B,用于分隔ARRAY,STRUCT或MAP的键值对中的元素\n> 默认的映射键(map key)分隔符为Control-C,用于分隔map的键和值\n> 表中各行用换行符分隔\n> 可以用hexdump查看输出文件的分隔符\n\nHive支持8级分隔符,对应ASCII编码的1-8,但只能重载前三个.可用8进制形式表示分隔符,如001表示Control-A.\n\nHivene内部使用LazySimpleSerDe来处理这种分隔格式以及面向行的MapReduce文本输入输出格式,他对字段的反序列化是延时处理的,只有在访问字段时才进行反序列化.\n\n*二进制存储格式: 顺序文件 Avro数据文件 Parquet文件 RCFile ORCFile*\n\n二进制格式:\n1. 面向行的格式(Avro,顺序文件): 适合同时处理一行中很多列\n\t> `SET hive.exec.compress.output=true;`\n\t> `SET avro.output.codec=snappy;`\n\t> `CREATE TABLE ... STORE AS AVRO;`\n\t> 可以将表存储为Avro格式\n2. 面向列的格式(Parquet文件 RCFile ORCFile): 对于只访问表中一小部分列的查询有效\n\n使用定制的SerDe: RegexSerDe\n>`REATE TABLE stations (usaf STRING, wban STRING, name STRING) ROW FORMAT SERDE 'org.apache.hadoop.hive.contrib.serde2.RegexSerDe' WITH SERDEPROPERTIES (\"input.regex\" = \"(\\\\d{6}) (\\\\d{5}) (\\\\.{29}) .*\");`\n>\n>使用SERDE关键字和JAVA类完整类名指明使用哪个SerDe.用 WITH SERDEPROPERTIES设置SERDE的额外属性.\n>\n>`LOAD DATA LOCAL INPATH \"input/ncdc/metadata/stations-fixed-width.txt\" INTO TABLE stations;`\n>\n>`hive> SELECT * FROM stations LIMIT 4;\nOK\n010000\t99999\tBOGUS NORWAY\n010003\t99999\tBOGUS NORWAY\n010010\t99999\tJAN MAYEN\n010013\t99999\tROST `\n效率比较低,一般用二进制存储格式\n\n*导入数据*\n> **INSERT语句**\n> 动态分区插入:\n>>`INSERT OVERWRITE TABLE target PARTITION(dt) SELECT COL1, CLO2, dt FROM source`\n\n>**多表插入**\n>>`FROM records2`\n`INSERT OVERWRITE TABLE stations_by_year SELECT year,COUNT(DISTINCT station) GROUP BY year`\n`INSERT OVERWRITE TABLE records_by_year SELECT year, COUNT(1) GROUP BY year`\n`INSERT OVERWRITE TABLE good_records_by_year SELECT year, COUNT(1) WHERE temperature != 9999 AND quality IN (0, 1, 4, 5, 9) GROUP BY year;`\n比单表效率高,只需扫一遍原表就可以生成多个不想交的输出\n\n>**CTAS**\n>`CREATA TABLE target AS SELECT col1, col2 FROM source;`\n>CTAS操作是原子的,如select查询由于某种原因失败,则不会创建表target\n\n*表的修改*\nHive使用读时模式,创建表后可以灵活的支持对表的修改,但是需要警惕确保修改数据以符合新的结构.\n>`ALTER TABLE source RENAME TO target;`\n\n重命名表,在更新元数据以外ALTER TABLE还把表目录移到新名称对应的目录下,对于外部表则只更新元数据.\n\n>`ALTER TABLE target ADD COLUMNS (cols3 STRING);`\n\n添加新的列cols3在已有(非分区)列的后面,数据文件并没有更新,原来的查询会为cols3的结果返回null,Hive不允许更新已有的记录,故一般创建一个定义了新列的新表.然后使用SELECT语句把数据填充进去.\n\n*表的丢弃*\nDROP TABLE;删除表中数据和元数据(外部表数据除外)\nTRUNCATE TABLE my_table;删除表内所有数据,但保留定义(对外部表不起作用)\nCREATE TABLE new_table LIKE existing_table;达到类似TRUNCATE的目的.\n\n查询数据\n---\n**排序和聚集**\n* ORDER BY : 对输入执行并行全排序\n* SORT BY : 为每个reducer产生一个排序文件\n* DISTRIBUTE BY : 控制特定行到某个reducer,便于后续的聚集操作\n>`FROM records2 SELECT year, temperature DISTRIBUTE BY year SORT BY year ASC, temperature DESC;`\n\n**MapReduce脚本**\nTRANSFORM,MAP,REDUCE子句可在Hive中调用外部脚本或程序.\n> ``` python\n>#is_good_quality.py\n>import re\nimport sys\nfor line in sys.stdin:\n    (year,temp,q) = line.strip().split()\n    if (temp != \"9999\" and re.match(\"[01459]\"),q)):\n        print(\"%s\\t%s\" % (year, temp))```\n\n>`ADD FILE /input/is_good_quality.py;` 在Hive中注册脚本,Hive将脚本文件传到Hadoop集群\n>`FROM records2 select TRANSFORM(year,temperature,quality) USING 'is_good_quality.py' as year, temperature;` \n\n这一实例并未使用reducer.如果要使用嵌套模式,可以指定map和reduce函数:\n>```python\n>FROM (\n  FROM records2\n  MAP year, temperature, quality\n  USING 'is_good_quality.py'\n  AS year, temperature) map_output\nREDUCE year, temperature\nUSING 'max_temperature_reduce.py'\nAS year, temperature;```\n和\n```python\nFROM (\n  FROM records2\n  SELECT TRANSFORM(year, temperature, quality)\n  USING 'is_good_quality.py'\n  AS year, temperature) map_output\nSELECT TRANSFORM(year, temperature)\nUSING 'max_temperature_reduce.py'\nAS year, temperature;```\n结果一致\n\n**连接**\n\n*内连接*:输入表之间每次匹配都会在输出行里生成一行:\n>```\n>SELECT * FROM sales;\nJoe\t2\nHank\t4\nAli\t0\nEve\t3\nHank\t2```\n>```\n> SELECT * FROM things;\n2\tTie\n4\tCoat\n3\tHat\n1\tScarf```\n\n>```\nSELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);\nJoe\t2\t2\tTie\nHank\t4\t4\tCoat\nEve\t3\t3\tHat\nHank\t2\t2\tTie\n```\n>JOIN子句中的顺序很重要:一般将最大的表放到最后,因为JOIN前一阶段生成的数据会存在于Reducer的buffer中，通过stream最后面的表，直接从Reducer的buffer中读取已经缓冲的中间结果数据（这个中间结果数据可能是JOIN顺序中，前面表连接的结果的Key，数据量相对较小，内存开销就小），这样，与后面的大表进行连接时，只需要从buffer中读取缓存的Key，与大表中的指定Key进行连接，速度会更快，也可能避免内存缓冲区溢出.(出自[简单之美](http://shiyanjun.cn/archives/588.html))\n>\nHive只支持等值连接,在连接谓词中只能使用等号,还可以在在查询中使用多个JOIN...ON...子句来连接多个表,Hive会智能的以最少的MapReduce作业数来执行连接.单个连接用一个MR作业实现,如果多个连接条件中使用了相同的列那么平均每个连接可以使用少于一个MR作业来实现.\n\n**外连接**\n外连接可以找到表中不能匹配的数据行:\n>```\n>左连接\nSELECT sales.*, things.* FROM sales LEFT OUTER JOIN things ON (sales.id = things.id);\nJoe\t2\t2\tTie\nHank\t4\t4\tCoat\nAli\t0\tNULL\tNULL\nEve\t3\t3\tHat\nHank\t2\t2\tTie\n```\n当然Hive也支持右连接和全外连接:\n>```右连接\nSELECT sales.*, things.* FROM sales RIGHT OUTER JOIN things ON (sales.id = things.id);\nJoe\t2\t2\tTie\nHank\t2\t2\tTie\nHank\t4\t4\tCoat\nEve\t3\t3\tHat\nNULL\tNULL\t1\tScarf```\n>```\n>SELECT sales.*, things.* FROM sales FULL OUTER JOIN things ON (sales.id = things.id)\n>Ali\t0\tNULL\tNULL\nNULL\tNULL\t1\tScarf\nHank\t2\t2\tTie\nJoe\t2\t2\tTie\nEve\t3\t3\tHat\nHank\t4\t4\tCoat\n```\n**半连接**\nLEFT SEMI JOIN:\n>```\nselect * from sales left semi join things on (sales.id = things.id);\nJoe\t2\nHank\t4\nEve\t3\nHank\t2```\n右表只能在ON子句中出现,不能在SELECT表达式中引用右表.\n\n**map连接**\n如果有一个连接表小到足以放入内存,Hive就将较小的表放入每个mapper的内存来执行连接操作.\nmap连接不适用Reducer,因此对于RIGHT或者FULL OUTER JOIN无效,因为只有在对所有输入上进行聚集的步骤(reduce)才能检测到那个数据行无法匹配.\nmap连接可以利用分桶的表,因为作用于左侧表的桶的mapper加载右侧表中对应的桶即可执行连接.需要`SET hive.optimize.bucketmapjoin=true`启用优化选项.\n\n**子查询**\n子查询是内嵌在另一个SQL语句中的SELECT语句,Hive只允许子查询出现在SELECT语句的FROM子句中,或某些特殊情况下的WHERE子句中.\n>```\n>hive> SELECT station, year, AVG(max_temperature)\n     FROM (\n     SELECT station, year, MAX(temperature) AS max_temperature\n     FROM records2\n     WHERE temperature != 9999 AND quality IN (0,1,4,5,9)\n     GROUP BY station, year\n     ) mt\n     GROUP BY station, year;\n```\n外层查询像访问表那样访问子查询的结果,所以必须为子查询赋予一个别名(mt),子查询中的列必须有唯一的名称,以便外层访问引用这些列.\n\n**视图**\n用SELECT语句定义的虚表,可以限制用户,使其只能访问被授权可以看到的表的子集.Hive中,创建视图并不把视图物化存储到磁盘上,视图的SELECT语句只在执行引用视图的语句时才执行.要手工物化视图,可以新建一个表,将视图内容存储到新表中.\n创建方式:CREATE VIEW\n> ```\n> CREATE VIEW valid_records AS SELECT * FROM records2 WHERE temperature != 9999 AND quality IN (0,1,4,5,9);```\n> 创建视图时并不执行查询,查询只是存储在metastore中,SHOW TABLES命令结果包含视图,可用DESCRIBE EXTENDED view_name来查看视图的详细信息.\n> ![](/home/harold/Pictures/Selection_021.png)\n\nHive可以把使用视图的查询组织为一系列作业,效果与不使用视图一样.即使在执行时,Hive也不会再不必要的情况下物化视图.\n\nHive中的视图是只读的,无法通过视图为基表加载或插入数据.\n\n用户定义函数----UDF\n---\n用户定义函数(user-defined function)必须用Java编写,其他语言可以用之前用过的`SELECT TRANSFORM`查询.\n\nHive三种UDF, 他们所接受的输入和产生的输出的数据行的数量不同 :\n* 普通UDF : 作用于单个数据行,产生一个数据行\n* 用户定义聚集函数 UDAF : 接受多个数据行,产生一个输出行, 类似COUNT , MAX\n* 用户定义表生成函数 UDTF : 作用于单个数据行, 产生多个输出行\n\n*UDTF*:\n```>\nhive> create table arrays (x ARRAY<STRING>) ROW\n    > FORMAT DELIMITED\n    > FIELDS TERMINATED BY '\\001'\n    > COLLECTION ITEMS TERMINATED BY '\\002';```\n\n```>\nhive> SELECT * FROM arrays;\nOK\n[\"a\",\"b\"]\n[\"c\",\"d\",\"e\"]\n```\nexplode UDTF对表进行变换,为数组中的每一项输出一行.\n```>\nhive> SELECT explode(x) AS y from arrays;\nOK\na\nb\nc\nd\ne```\n\n常用的UDTF还有SPLIT() 等,还有更强大的LATERAL VIEW查询,笔者会在之后的博客详细介绍.\n\n**写UDF**\n```java\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.hadoop.hive.ql.exec.UDF;\nimport org.apache.hadoop.io.Text;\n\npublic class Strip extends UDF {\n    private Text result = new Text();\n    public Text evaluate (Text str) {\n        if (str == null) {\n            return null;\n        }\n\n        result.set(StringUtils.strip(str.toString()));\n        return result;\n    }\n\n    public Text evaluate(Text str, String stripChars) {\n        if(str == null) {\n            return null;\n        }\n        result.set(StringUtils.strip(str.toString(), stripChars));\n        return result;\n    }\n}```\n\n一个UDF必须满足:\n1. 是org.apache.hadoop.hive.ql.exec.UDF的子类\n2. 至少实现了evaluate()方法\n\nevaluate()不是由接口定义的,它接受的参数个数和类型以及返回值都是不确定的,Hive会检查UDF,看能否找到相匹配的evaluate().\n\n使用UDF:\n1.在metastore中注册函数并用CTREATE FUNCTION为它取名:\n> CREATE FUNCTION strip AS 'com.hadoopbook.hive.Strip' USING JAR 'path/hive-example.jar'\n\n2.使用内置函数:\n>SELECT strip(' bee ') FROM dummy; UDF名对大小写不敏感\n\n3.删除函数:\n>DROP FUNCTION strip;\n\n4.用TEMPORARY创建仅在Hive会话期间有效的函数,不在metastore中持久化:\n>`ADD JAR /path/hive-example.jar;`\n>`CREATE TEMPORARY FUNCTION strip AS 'com.hadoopbook.hive.Strip';`\n\n**写UDAF**\n```java\nimport org.apache.hadoop.hive.ql.exec.UDAF;\nimport org.apache.hadoop.hive.ql.exec.UDAFEvaluator;\nimport org.apache.hadoop.io.IntWritable;\n\npublic class Maximum extends UDAF{\n    public static class MaximumIntUDAFEvaluator implements UDAFEvaluator{\n        private IntWritable result;\n\n        @Override\n        public void init() {\n            result = null;\n        }\n\n\n        public boolean iterate(IntWritable value) {\n            if (value == null) {\n                return true;\n            }\n            if (result == null) {\n                result = new IntWritable(value.get());\n            } else {\n                result.set(Math.max(result.get(), value.get()));\n            }\n            return true;\n        }\n\n        public IntWritable terminatePartial() {\n            return result;\n        }\n\n        public boolean merge(IntWritable other) {\n            return iterate(other);\n        }\n\n        public IntWritable terminate() {\n            return result;\n        }\n    }\n}\n```\nUDAF必须是org.apache.hadoop.hive.ql.exec.UDAF的子类(*UDAF类已经过时弃用了，现在是实现GenericUDAFResolver2接口,请看本博客另一篇相关的文内容*), 且包含一个或多个嵌套的实现了Org.apache.hadoop.hive.ql.exec.UDAFEvaluator的*静态类*.\n\n一个计算函数必须实现以下五个方法:\n\n* init() : 负责初始化计算函数并设置他的内部状态\n\n* inerate() : 每次对一个新值进行聚集计算都会调用此方法,iterate()接受的参数和Hive中被调用函数的参数是对应的.\n\n* terminate() : Hive需要部分聚集结果时会调用此方法,这个方法必须返回一个封装了聚集计算当前状态的对象.\n\n*  merge()方法 : 在Hive合并两个部分聚集值时会调用merge()方法.该方法接受一个对象作为输入,其类型必须和terminatePartial()方法的返回类型一致.\n \n*  terminate()方法 : Hive需要最终聚集结果时会调用此方法\n\n*  计算流程见下图:\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-18/61809116.jpg)\n\n\n\n\n\n\n\n\n\n\n","slug":"关于HIVE","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7i003acf96g2fq1gez","content":"<blockquote>\n<p>本篇博客主要来自于本人学习&lt;&lt;Hadoop权威指南&gt;&gt;Hive部分的笔记和一些理解</p>\n</blockquote>\n<p>Hive是构建在Hadoop上的数据仓库框架,它把SQL查询转换为一系列在Hadoop集群上运行的作业,它的数据组织为表,元数据(eg.表模式)存储在metastore数据库中. metastore默认模本式为运行在本机上.</p>\n<h2 id=\"Hive-shell环境\"><a href=\"#Hive-shell环境\" class=\"headerlink\" title=\"Hive shell环境\"></a>Hive shell环境</h2><p>HiveQL是Hive的查询语言,类似Mysql,运行方式有:<br>  <a id=\"more\"></a></p>\n<ul>\n<li><p><strong>交互模式</strong> : hive命令进入shell</p>\n<blockquote>\n<p>第一次使用时会花几秒时间,因为系统采用<strong>“延迟”</strong>策略,直到执行第一个命令才在运行hive命令的那个位置下的metastore_db目录中创建metastore数据库.</p>\n</blockquote>\n</li>\n<li><p><strong>非交互模式</strong> :<br><code>hive -f script.q</code> -f选项运行指定文件中的命令<br><code>hive -e &#39;SELECT * FROM DUMMY&#39;</code> -e选项在行内嵌入命令</p>\n</li>\n</ul>\n<p><strong>用到的HiveQL特有的关键字</strong>:</p>\n<blockquote>\n<p><code>create table records (year STRING, temperature INT, quality INT) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\\t&#39;;</code></p>\n</blockquote>\n<ul>\n<li>ROW FORMAT : 声明数据文件的每一行是由制表符分割的文本</li>\n</ul>\n<blockquote>\n<p><code>LOAD DATA LOCAL INPATH &#39;input/ncdc/micro-tab/sample.txt&#39; OVERWRITE INTO TABLE records;</code></p>\n</blockquote>\n<ul>\n<li><p>告诉Hive将本地文件放入其仓库目录,此操作并不解析文件或将它存储为内部数据库格式,因为Hive不强制使用任何特定文件格式. 在Hive中,表存储为目录,可由hive.metastore.warehouse.dir控制目录位置.</p>\n</li>\n<li><p>OVERWRITE    : 删除表对应目录中的所有文件</p>\n</li>\n</ul>\n<blockquote>\n<p><code>select year ,MAX(temperature) from records where temperature != 9999 and quality in (0,1,4,5,9) group by year;</code></p>\n</blockquote>\n<ul>\n<li>Hive 将查询转化为一个作业并执行作业,将结果打印到console</li>\n</ul>\n<p><strong>Hive设置属性优先级(顺序递减)</strong>:</p>\n<pre><code>. SET命令\n. 命令行 -hiveconf选项\n. hive-site.xml 和 Hadoop站点文件\n. Hive默认值和Hadoop默认值\n</code></pre><h2 id=\"MetaStore\"><a href=\"#MetaStore\" class=\"headerlink\" title=\"MetaStore\"></a><strong><em>MetaStore</em></strong></h2><p>metastore是Hive元数据的存放地,包括<em>服务</em>和<em>后台数据</em>的存储,默认情况下metastore和Hive运行在同个JVM,包含一个内嵌的以本地磁盘作为存储的<a href=\"https://www.cnblogs.com/zuzZ/p/8107915.html\" target=\"_blank\" rel=\"noopener\">Derby数据库</a>实例,称为<strong>内嵌metastore配置</strong>.</p>\n<blockquote>\n<p>内嵌配置的缺点:每次只有一个内嵌Derby数据库可访问磁盘上的数据库文件,一次只能为每个metast打开一个Hive会话.</p>\n</blockquote>\n<p>要支持多个会话,需使用一个独立的数据库,称为<strong>本地metastore配置</strong>需要设置本地Mysql的用户名,密码等,还可以利用<strong>远程metastore配置</strong>使得一个或多个metastore服务器和Hive服务器运行在不同进程内,客户端不需数据库凭据.</p>\n<h2 id=\"传统数据库与Hive对比\"><a href=\"#传统数据库与Hive对比\" class=\"headerlink\" title=\"传统数据库与Hive对比\"></a>传统数据库与Hive对比</h2><ol>\n<li><p>传统数据库: <strong>写时模式</strong>,表的模式在加载时强制确定</p>\n<blockquote>\n<p>缺点: 加载慢,需要读取数据进行解析-&gt;序列化-&gt;以内部格式存入磁盘.<br>优点: 有利于提升查询性能,因为可以对列进行索引,对数据压缩.</p>\n</blockquote>\n<p>Hive: <strong>读时模式</strong>,在查询时才验证数据模式,加载迅速,仅仅是文件的复制和移动</p>\n</li>\n<li><p>更新,事务和索引</p>\n<p>  HDFS不支持就地更新,插入,更新删除操作引起的一切变化都被保存在一个增量文件中,由metastore在后台运行的mapreduce作业会定期将增量文件合并到基表.</p>\n<p> Hive引入了表级和分区级的锁,由ZooKeeper透明管理,用户不用执行获得和释放锁的操作.</p>\n<p> Hive索引分为<em>紧凑</em>和<em>位图</em>索引,可插拔,紧凑索引存储每个值的HDFS块号而不是文件内偏移量,不会占用过多磁盘空间;位图索引使用压缩的bitset来高效存储具有特殊值的行,适用于具有极少取值的列.</p>\n</li>\n</ol>\n<h2 id=\"表\"><a href=\"#表\" class=\"headerlink\" title=\"表\"></a>表</h2><p>Hive中的表在逻辑上由存储的数据和描述表中数据形式的相关元数据组成.<em>数据</em>一般存放在HDFS上,也可以是其他Hadoop文件系统,Hive把<em>元数据</em>存放在关系型数据库</p>\n<p><strong>托管表和外部表</strong><br>Hive创建表时,默认由Hive管理数据,将数据移入它的”仓库目录”,称为<em>托管表</em>.另一种方式是<em>外部表</em>,Hive到仓库目录以外的位置访问数据. 区别体现在DROP 和 LOAD上.</p>\n<ul>\n<li><p>托管表:</p>\n<blockquote>\n<p>加载操作就是文件系统中文件移动或重命名,执行速度快,如果要手动检查是否满足模式,可以通过查询为缺失字段返回的空值NULL才知道不匹配的行.<br><code>load data local inpath &#39;input/hive/dummy.txt&#39; into table managed_table;</code><br>执行删除操作后,它的元数据和数据会被一起删除,在HDFS中可以看到删除表后/user/hive/warehouse中的managed_table也被删除了.<br><code>drop table managed_table;</code></p>\n</blockquote>\n</li>\n<li><p>外部表</p>\n<blockquote>\n<p>创建表示需要指明外部数据的位置,定义时Hive不会检查外部位置是否存在,故可以在创建表之后再创建数据<br><code>create external table external_table (dummy STRING) LOCATION /user/harold/external_table</code>;<br>丢弃外部表时,Hive只会删除元数据,不会删除数据</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>分区和桶</strong><br>Hive把表组织成<em>分区</em>,使用分区可以加快数据分片的查询速度.表或分区可以进一部分为桶(bucket)它会为数据提供额外的结构以获得更高效的查询处理.</p>\n<ul>\n<li><em>分区</em> : 分区使得表对限制到某个特定范围的数据的查询变得非常高效(比如按照日期分区),只需扫描查询范围内分区中的文件,而且不会影响大范围查询的执行.一个表可以以多个维度分区,即进行子分区.</li>\n</ul>\n<p>分区是在创建表时用PARTITIONED BY子句定义的:</p>\n<blockquote>\n<p><code>CREATE TABLE logs (ts BIGINT, line STRING) PARTITIONED BY (dt STRING, country      STRING);</code></p>\n</blockquote>\n<p>  在将数据加载到分区表时,要显示指定分区值:</p>\n<blockquote>\n<p><code>LOAD DATA LOCAL INPATH &#39;input/hive/partitions/file1&#39; INTO TABLE logs PARTITION (dt=&#39;2001-01-01&#39;, country=&#39;GB&#39;);</code><br><code>SHOW PARTITON logs;</code> 可以展示表中的分区</p>\n</blockquote>\n<ul>\n<li><p><em>桶</em> :<br>  将表或分区组织成桶的理由:</p>\n<blockquote>\n<p>. 获得高效的查询处理效率<br>. 使取样更高效<br>创建被划分成桶的表:<br><code>CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) INTO 4 BUCKETS;</code><br> 桶中的数据可以根据一个列或者多个列排序,这样对每个桶的连接变成了高效的归并排序,提升了map端连接的效率:<br><code>CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) SORTED BY (id) INTO 4 BUCKETS;</code></p>\n</blockquote>\n<p> Hive并不检查数据文件中的桶是否和表定义中的桶一致,无论是桶的数量还是用来划分的列, 如果不匹配会 ,查询时会碰到错误或未定义的结果.<br> 将一个没有划分桶的数据集users填充进分桶后的表的步骤如下:</p>\n<blockquote>\n<p><code>SET hive.enforce.bucketing=true;</code> 这样Hive就知道用表中声明的数量来创建桶<br><code>INSERT OVERWRITE TABLE bucketed_users SELECT * FROM users;</code>Insert 即可</p>\n</blockquote>\n</li>\n</ul>\n<p>物理上,每个桶就是表目录中的一个文件,一个作业产生的桶(输出文件)和reduce任务个数相同.</p>\n<p>用TABLESAMPLE子句对表取样:<br><code>SELECT * FROM bucketed_users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);</code><br>和<br><code>SELECT * FROM users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);</code></p>\n<p>得到的结果一样.</p>\n<p><strong>存储格式</strong></p>\n<p> Hive从两个维度对表的存储进行管理:</p>\n<ul>\n<li>行格式: 行和行中的字段如何存储,行格式由SerDe(Serializer-Deserializer)定义. 当作为反序列化工具使用时(即查询表),SerDe将把文件中字节形式的数据反序列化为Hive内部操作行时所使用的对象形式,作为序列化工具时(INSERT,CTAS),表的SerDe会把Hive的数据行内部表示形式序列化成字节形式并写道输出文件中.</li>\n<li>文件格式: 一行中字段容器的格式</li>\n</ul>\n<p><em>默认的存储格式—-分隔的文本</em></p>\n<p>在创建表时如果没有用ROW FORMAT或STORED AS子句,Hive所使用的默认格式是分隔的文本,每行存储一个数据行.</p>\n<p>默认行内分隔符不是制表符,而是ASCII控制码集合中的Control-A,原因是它出现在字段文本中的可能性较小,Hive中无法对分隔符进行转义,因此挑选一个不会在数据字段中用到的字符作为分隔符非常重要.</p>\n<blockquote>\n<p>集合类的默认分隔符为Control-B,用于分隔ARRAY,STRUCT或MAP的键值对中的元素<br>默认的映射键(map key)分隔符为Control-C,用于分隔map的键和值<br>表中各行用换行符分隔<br>可以用hexdump查看输出文件的分隔符</p>\n</blockquote>\n<p>Hive支持8级分隔符,对应ASCII编码的1-8,但只能重载前三个.可用8进制形式表示分隔符,如001表示Control-A.</p>\n<p>Hivene内部使用LazySimpleSerDe来处理这种分隔格式以及面向行的MapReduce文本输入输出格式,他对字段的反序列化是延时处理的,只有在访问字段时才进行反序列化.</p>\n<p><em>二进制存储格式: 顺序文件 Avro数据文件 Parquet文件 RCFile ORCFile</em></p>\n<p>二进制格式:</p>\n<ol>\n<li>面向行的格式(Avro,顺序文件): 适合同时处理一行中很多列<blockquote>\n<p><code>SET hive.exec.compress.output=true;</code><br><code>SET avro.output.codec=snappy;</code><br><code>CREATE TABLE ... STORE AS AVRO;</code><br>可以将表存储为Avro格式</p>\n</blockquote>\n</li>\n<li>面向列的格式(Parquet文件 RCFile ORCFile): 对于只访问表中一小部分列的查询有效</li>\n</ol>\n<p>使用定制的SerDe: RegexSerDe</p>\n<blockquote>\n<p><code>REATE TABLE stations (usaf STRING, wban STRING, name STRING) ROW FORMAT SERDE &#39;org.apache.hadoop.hive.contrib.serde2.RegexSerDe&#39; WITH SERDEPROPERTIES (&quot;input.regex&quot; = &quot;(\\\\d{6}) (\\\\d{5}) (\\\\.{29}) .*&quot;);</code></p>\n<p>使用SERDE关键字和JAVA类完整类名指明使用哪个SerDe.用 WITH SERDEPROPERTIES设置SERDE的额外属性.</p>\n<p><code>LOAD DATA LOCAL INPATH &quot;input/ncdc/metadata/stations-fixed-width.txt&quot; INTO TABLE stations;</code></p>\n<p><code>hive&gt; SELECT * FROM stations LIMIT 4;\nOK\n010000    99999    BOGUS NORWAY\n010003    99999    BOGUS NORWAY\n010010    99999    JAN MAYEN\n010013    99999    ROST</code><br>效率比较低,一般用二进制存储格式</p>\n</blockquote>\n<p><em>导入数据</em></p>\n<blockquote>\n<p><strong>INSERT语句</strong><br>动态分区插入:</p>\n<blockquote>\n<p><code>INSERT OVERWRITE TABLE target PARTITION(dt) SELECT COL1, CLO2, dt FROM source</code></p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong>多表插入</strong></p>\n<blockquote>\n<p><code>FROM records2</code><br><code>INSERT OVERWRITE TABLE stations_by_year SELECT year,COUNT(DISTINCT station) GROUP BY year</code><br><code>INSERT OVERWRITE TABLE records_by_year SELECT year, COUNT(1) GROUP BY year</code><br><code>INSERT OVERWRITE TABLE good_records_by_year SELECT year, COUNT(1) WHERE temperature != 9999 AND quality IN (0, 1, 4, 5, 9) GROUP BY year;</code><br>比单表效率高,只需扫一遍原表就可以生成多个不想交的输出</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong>CTAS</strong><br><code>CREATA TABLE target AS SELECT col1, col2 FROM source;</code><br>CTAS操作是原子的,如select查询由于某种原因失败,则不会创建表target</p>\n</blockquote>\n<p><em>表的修改</em><br>Hive使用读时模式,创建表后可以灵活的支持对表的修改,但是需要警惕确保修改数据以符合新的结构.</p>\n<blockquote>\n<p><code>ALTER TABLE source RENAME TO target;</code></p>\n</blockquote>\n<p>重命名表,在更新元数据以外ALTER TABLE还把表目录移到新名称对应的目录下,对于外部表则只更新元数据.</p>\n<blockquote>\n<p><code>ALTER TABLE target ADD COLUMNS (cols3 STRING);</code></p>\n</blockquote>\n<p>添加新的列cols3在已有(非分区)列的后面,数据文件并没有更新,原来的查询会为cols3的结果返回null,Hive不允许更新已有的记录,故一般创建一个定义了新列的新表.然后使用SELECT语句把数据填充进去.</p>\n<p><em>表的丢弃</em><br>DROP TABLE;删除表中数据和元数据(外部表数据除外)<br>TRUNCATE TABLE my_table;删除表内所有数据,但保留定义(对外部表不起作用)<br>CREATE TABLE new_table LIKE existing_table;达到类似TRUNCATE的目的.</p>\n<h2 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h2><p><strong>排序和聚集</strong></p>\n<ul>\n<li>ORDER BY : 对输入执行并行全排序</li>\n<li>SORT BY : 为每个reducer产生一个排序文件</li>\n<li>DISTRIBUTE BY : 控制特定行到某个reducer,便于后续的聚集操作<blockquote>\n<p><code>FROM records2 SELECT year, temperature DISTRIBUTE BY year SORT BY year ASC, temperature DESC;</code></p>\n</blockquote>\n</li>\n</ul>\n<p><strong>MapReduce脚本</strong><br>TRANSFORM,MAP,REDUCE子句可在Hive中调用外部脚本或程序.</p>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"comment\">#is_good_quality.py</span></span><br><span class=\"line\">&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</span><br><span class=\"line\">    (year,temp,q) = line.strip().split()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (temp != <span class=\"string\">\"9999\"</span> <span class=\"keyword\">and</span> re.match(<span class=\"string\">\"[01459]\"</span>),q)):</span><br><span class=\"line\">        print(<span class=\"string\">\"%s\\t%s\"</span> % (year, temp))</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><code>ADD FILE /input/is_good_quality.py;</code> 在Hive中注册脚本,Hive将脚本文件传到Hadoop集群<br><code>FROM records2 select TRANSFORM(year,temperature,quality) USING &#39;is_good_quality.py&#39; as year, temperature;</code> </p>\n</blockquote>\n<p>这一实例并未使用reducer.如果要使用嵌套模式,可以指定map和reduce函数:</p>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;FROM (</span><br><span class=\"line\">  FROM records2</span><br><span class=\"line\">  MAP year, temperature, quality</span><br><span class=\"line\">  USING <span class=\"string\">'is_good_quality.py'</span></span><br><span class=\"line\">  AS year, temperature) map_output</span><br><span class=\"line\">REDUCE year, temperature</span><br><span class=\"line\">USING <span class=\"string\">'max_temperature_reduce.py'</span></span><br><span class=\"line\">AS year, temperature;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>和<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM (</span><br><span class=\"line\">  FROM records2</span><br><span class=\"line\">  SELECT TRANSFORM(year, temperature, quality)</span><br><span class=\"line\">  USING <span class=\"string\">'is_good_quality.py'</span></span><br><span class=\"line\">  AS year, temperature) map_output</span><br><span class=\"line\">SELECT TRANSFORM(year, temperature)</span><br><span class=\"line\">USING <span class=\"string\">'max_temperature_reduce.py'</span></span><br><span class=\"line\">AS year, temperature;</span><br></pre></td></tr></table></figure></p>\n<p>结果一致</p>\n<p><strong>连接</strong></p>\n<p><em>内连接</em>:输入表之间每次匹配都会在输出行里生成一行:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;SELECT * FROM sales;</span><br><span class=\"line\">Joe\t2</span><br><span class=\"line\">Hank\t4</span><br><span class=\"line\">Ali\t0</span><br><span class=\"line\">Eve\t3</span><br><span class=\"line\">Hank\t2</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SELECT * FROM things;</span><br><span class=\"line\">2\tTie</span><br><span class=\"line\">4\tCoat</span><br><span class=\"line\">3\tHat</span><br><span class=\"line\">1\tScarf</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>JOIN子句中的顺序很重要:一般将最大的表放到最后,因为JOIN前一阶段生成的数据会存在于Reducer的buffer中，通过stream最后面的表，直接从Reducer的buffer中读取已经缓冲的中间结果数据（这个中间结果数据可能是JOIN顺序中，前面表连接的结果的Key，数据量相对较小，内存开销就小），这样，与后面的大表进行连接时，只需要从buffer中读取缓存的Key，与大表中的指定Key进行连接，速度会更快，也可能避免内存缓冲区溢出.(出自<a href=\"http://shiyanjun.cn/archives/588.html\" target=\"_blank\" rel=\"noopener\">简单之美</a>)</p>\n</blockquote>\n<p>Hive只支持等值连接,在连接谓词中只能使用等号,还可以在在查询中使用多个JOIN…ON…子句来连接多个表,Hive会智能的以最少的MapReduce作业数来执行连接.单个连接用一个MR作业实现,如果多个连接条件中使用了相同的列那么平均每个连接可以使用少于一个MR作业来实现.</p>\n<p><strong>外连接</strong><br>外连接可以找到表中不能匹配的数据行:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;左连接</span><br><span class=\"line\">SELECT sales.*, things.* FROM sales LEFT OUTER JOIN things ON (sales.id = things.id);</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br><span class=\"line\">Ali\t0\tNULL\tNULL</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>当然Hive也支持右连接和全外连接:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sales.*, things.* FROM sales RIGHT OUTER JOIN things ON (sales.id = things.id);</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">NULL\tNULL\t1\tScarf</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;SELECT sales.*, things.* FROM sales FULL OUTER JOIN things ON (sales.id = things.id)</span><br><span class=\"line\">&gt;Ali\t0\tNULL\tNULL</span><br><span class=\"line\">NULL\tNULL\t1\tScarf</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>半连接</strong><br>LEFT SEMI JOIN:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from sales left semi join things on (sales.id = things.id);</span><br><span class=\"line\">Joe\t2</span><br><span class=\"line\">Hank\t4</span><br><span class=\"line\">Eve\t3</span><br><span class=\"line\">Hank\t2</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>右表只能在ON子句中出现,不能在SELECT表达式中引用右表.</p>\n<p><strong>map连接</strong><br>如果有一个连接表小到足以放入内存,Hive就将较小的表放入每个mapper的内存来执行连接操作.<br>map连接不适用Reducer,因此对于RIGHT或者FULL OUTER JOIN无效,因为只有在对所有输入上进行聚集的步骤(reduce)才能检测到那个数据行无法匹配.<br>map连接可以利用分桶的表,因为作用于左侧表的桶的mapper加载右侧表中对应的桶即可执行连接.需要<code>SET hive.optimize.bucketmapjoin=true</code>启用优化选项.</p>\n<p><strong>子查询</strong><br>子查询是内嵌在另一个SQL语句中的SELECT语句,Hive只允许子查询出现在SELECT语句的FROM子句中,或某些特殊情况下的WHERE子句中.</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;hive&gt; SELECT station, year, AVG(max_temperature)</span><br><span class=\"line\">     FROM (</span><br><span class=\"line\">     SELECT station, year, MAX(temperature) AS max_temperature</span><br><span class=\"line\">     FROM records2</span><br><span class=\"line\">     WHERE temperature != 9999 AND quality IN (0,1,4,5,9)</span><br><span class=\"line\">     GROUP BY station, year</span><br><span class=\"line\">     ) mt</span><br><span class=\"line\">     GROUP BY station, year;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>外层查询像访问表那样访问子查询的结果,所以必须为子查询赋予一个别名(mt),子查询中的列必须有唯一的名称,以便外层访问引用这些列.</p>\n<p><strong>视图</strong><br>用SELECT语句定义的虚表,可以限制用户,使其只能访问被授权可以看到的表的子集.Hive中,创建视图并不把视图物化存储到磁盘上,视图的SELECT语句只在执行引用视图的语句时才执行.要手工物化视图,可以新建一个表,将视图内容存储到新表中.<br>创建方式:CREATE VIEW</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; CREATE VIEW valid_records AS SELECT * FROM records2 WHERE temperature != 9999 AND quality IN (0,1,4,5,9);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>创建视图时并不执行查询,查询只是存储在metastore中,SHOW TABLES命令结果包含视图,可用DESCRIBE EXTENDED view_name来查看视图的详细信息.<br><img src=\"/home/harold/Pictures/Selection_021.png\" alt=\"\"></p>\n</blockquote>\n<p>Hive可以把使用视图的查询组织为一系列作业,效果与不使用视图一样.即使在执行时,Hive也不会再不必要的情况下物化视图.</p>\n<p>Hive中的视图是只读的,无法通过视图为基表加载或插入数据.</p>\n<h2 id=\"用户定义函数—-UDF\"><a href=\"#用户定义函数—-UDF\" class=\"headerlink\" title=\"用户定义函数—-UDF\"></a>用户定义函数—-UDF</h2><p>用户定义函数(user-defined function)必须用Java编写,其他语言可以用之前用过的<code>SELECT TRANSFORM</code>查询.</p>\n<p>Hive三种UDF, 他们所接受的输入和产生的输出的数据行的数量不同 :</p>\n<ul>\n<li>普通UDF : 作用于单个数据行,产生一个数据行</li>\n<li>用户定义聚集函数 UDAF : 接受多个数据行,产生一个输出行, 类似COUNT , MAX</li>\n<li>用户定义表生成函数 UDTF : 作用于单个数据行, 产生多个输出行</li>\n</ul>\n<p><em>UDTF</em>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; create table arrays (x ARRAY&lt;STRING&gt;) ROW</span><br><span class=\"line\">    &gt; FORMAT DELIMITED</span><br><span class=\"line\">    &gt; FIELDS TERMINATED BY &apos;\\001&apos;</span><br><span class=\"line\">    &gt; COLLECTION ITEMS TERMINATED BY &apos;\\002&apos;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; SELECT * FROM arrays;</span><br><span class=\"line\">OK</span><br><span class=\"line\">[&quot;a&quot;,&quot;b&quot;]</span><br><span class=\"line\">[&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br></pre></td></tr></table></figure>\n<p>explode UDTF对表进行变换,为数组中的每一项输出一行.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; SELECT explode(x) AS y from arrays;</span><br><span class=\"line\">OK</span><br><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">c</span><br><span class=\"line\">d</span><br><span class=\"line\">e</span><br></pre></td></tr></table></figure></p>\n<p>常用的UDTF还有SPLIT() 等,还有更强大的LATERAL VIEW查询,笔者会在之后的博客详细介绍.</p>\n<p><strong>写UDF</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.lang.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Strip</span> <span class=\"keyword\">extends</span> <span class=\"title\">UDF</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Text result = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">evaluate</span> <span class=\"params\">(Text str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.set(StringUtils.strip(str.toString()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">evaluate</span><span class=\"params\">(Text str, String stripChars)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result.set(StringUtils.strip(str.toString(), stripChars));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个UDF必须满足:</p>\n<ol>\n<li>是org.apache.hadoop.hive.ql.exec.UDF的子类</li>\n<li>至少实现了evaluate()方法</li>\n</ol>\n<p>evaluate()不是由接口定义的,它接受的参数个数和类型以及返回值都是不确定的,Hive会检查UDF,看能否找到相匹配的evaluate().</p>\n<p>使用UDF:<br>1.在metastore中注册函数并用CTREATE FUNCTION为它取名:</p>\n<blockquote>\n<p>CREATE FUNCTION strip AS ‘com.hadoopbook.hive.Strip’ USING JAR ‘path/hive-example.jar’</p>\n</blockquote>\n<p>2.使用内置函数:</p>\n<blockquote>\n<p>SELECT strip(‘ bee ‘) FROM dummy; UDF名对大小写不敏感</p>\n</blockquote>\n<p>3.删除函数:</p>\n<blockquote>\n<p>DROP FUNCTION strip;</p>\n</blockquote>\n<p>4.用TEMPORARY创建仅在Hive会话期间有效的函数,不在metastore中持久化:</p>\n<blockquote>\n<p><code>ADD JAR /path/hive-example.jar;</code><br><code>CREATE TEMPORARY FUNCTION strip AS &#39;com.hadoopbook.hive.Strip&#39;;</code></p>\n</blockquote>\n<p><strong>写UDAF</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.hive.ql.exec.UDAF;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.hive.ql.exec.UDAFEvaluator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maximum</span> <span class=\"keyword\">extends</span> <span class=\"title\">UDAF</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaximumIntUDAFEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">UDAFEvaluator</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> IntWritable result;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">iterate</span><span class=\"params\">(IntWritable value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">new</span> IntWritable(value.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result.set(Math.max(result.get(), value.get()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> IntWritable <span class=\"title\">terminatePartial</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">merge</span><span class=\"params\">(IntWritable other)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> iterate(other);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> IntWritable <span class=\"title\">terminate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>UDAF必须是org.apache.hadoop.hive.ql.exec.UDAF的子类(<em>UDAF类已经过时弃用了，现在是实现GenericUDAFResolver2接口,请看本博客另一篇相关的文内容</em>), 且包含一个或多个嵌套的实现了Org.apache.hadoop.hive.ql.exec.UDAFEvaluator的<em>静态类</em>.</p>\n<p>一个计算函数必须实现以下五个方法:</p>\n<ul>\n<li><p>init() : 负责初始化计算函数并设置他的内部状态</p>\n</li>\n<li><p>inerate() : 每次对一个新值进行聚集计算都会调用此方法,iterate()接受的参数和Hive中被调用函数的参数是对应的.</p>\n</li>\n<li><p>terminate() : Hive需要部分聚集结果时会调用此方法,这个方法必须返回一个封装了聚集计算当前状态的对象.</p>\n</li>\n<li><p>merge()方法 : 在Hive合并两个部分聚集值时会调用merge()方法.该方法接受一个对象作为输入,其类型必须和terminatePartial()方法的返回类型一致.</p>\n</li>\n<li><p>terminate()方法 : Hive需要最终聚集结果时会调用此方法</p>\n</li>\n<li><p>计算流程见下图:<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-18/61809116.jpg\" alt=\"\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇博客主要来自于本人学习&lt;&lt;Hadoop权威指南&gt;&gt;Hive部分的笔记和一些理解</p>\n</blockquote>\n<p>Hive是构建在Hadoop上的数据仓库框架,它把SQL查询转换为一系列在Hadoop集群上运行的作业,它的数据组织为表,元数据(eg.表模式)存储在metastore数据库中. metastore默认模本式为运行在本机上.</p>\n<h2 id=\"Hive-shell环境\"><a href=\"#Hive-shell环境\" class=\"headerlink\" title=\"Hive shell环境\"></a>Hive shell环境</h2><p>HiveQL是Hive的查询语言,类似Mysql,运行方式有:<br>","more":"</p>\n<ul>\n<li><p><strong>交互模式</strong> : hive命令进入shell</p>\n<blockquote>\n<p>第一次使用时会花几秒时间,因为系统采用<strong>“延迟”</strong>策略,直到执行第一个命令才在运行hive命令的那个位置下的metastore_db目录中创建metastore数据库.</p>\n</blockquote>\n</li>\n<li><p><strong>非交互模式</strong> :<br><code>hive -f script.q</code> -f选项运行指定文件中的命令<br><code>hive -e &#39;SELECT * FROM DUMMY&#39;</code> -e选项在行内嵌入命令</p>\n</li>\n</ul>\n<p><strong>用到的HiveQL特有的关键字</strong>:</p>\n<blockquote>\n<p><code>create table records (year STRING, temperature INT, quality INT) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\\t&#39;;</code></p>\n</blockquote>\n<ul>\n<li>ROW FORMAT : 声明数据文件的每一行是由制表符分割的文本</li>\n</ul>\n<blockquote>\n<p><code>LOAD DATA LOCAL INPATH &#39;input/ncdc/micro-tab/sample.txt&#39; OVERWRITE INTO TABLE records;</code></p>\n</blockquote>\n<ul>\n<li><p>告诉Hive将本地文件放入其仓库目录,此操作并不解析文件或将它存储为内部数据库格式,因为Hive不强制使用任何特定文件格式. 在Hive中,表存储为目录,可由hive.metastore.warehouse.dir控制目录位置.</p>\n</li>\n<li><p>OVERWRITE    : 删除表对应目录中的所有文件</p>\n</li>\n</ul>\n<blockquote>\n<p><code>select year ,MAX(temperature) from records where temperature != 9999 and quality in (0,1,4,5,9) group by year;</code></p>\n</blockquote>\n<ul>\n<li>Hive 将查询转化为一个作业并执行作业,将结果打印到console</li>\n</ul>\n<p><strong>Hive设置属性优先级(顺序递减)</strong>:</p>\n<pre><code>. SET命令\n. 命令行 -hiveconf选项\n. hive-site.xml 和 Hadoop站点文件\n. Hive默认值和Hadoop默认值\n</code></pre><h2 id=\"MetaStore\"><a href=\"#MetaStore\" class=\"headerlink\" title=\"MetaStore\"></a><strong><em>MetaStore</em></strong></h2><p>metastore是Hive元数据的存放地,包括<em>服务</em>和<em>后台数据</em>的存储,默认情况下metastore和Hive运行在同个JVM,包含一个内嵌的以本地磁盘作为存储的<a href=\"https://www.cnblogs.com/zuzZ/p/8107915.html\" target=\"_blank\" rel=\"noopener\">Derby数据库</a>实例,称为<strong>内嵌metastore配置</strong>.</p>\n<blockquote>\n<p>内嵌配置的缺点:每次只有一个内嵌Derby数据库可访问磁盘上的数据库文件,一次只能为每个metast打开一个Hive会话.</p>\n</blockquote>\n<p>要支持多个会话,需使用一个独立的数据库,称为<strong>本地metastore配置</strong>需要设置本地Mysql的用户名,密码等,还可以利用<strong>远程metastore配置</strong>使得一个或多个metastore服务器和Hive服务器运行在不同进程内,客户端不需数据库凭据.</p>\n<h2 id=\"传统数据库与Hive对比\"><a href=\"#传统数据库与Hive对比\" class=\"headerlink\" title=\"传统数据库与Hive对比\"></a>传统数据库与Hive对比</h2><ol>\n<li><p>传统数据库: <strong>写时模式</strong>,表的模式在加载时强制确定</p>\n<blockquote>\n<p>缺点: 加载慢,需要读取数据进行解析-&gt;序列化-&gt;以内部格式存入磁盘.<br>优点: 有利于提升查询性能,因为可以对列进行索引,对数据压缩.</p>\n</blockquote>\n<p>Hive: <strong>读时模式</strong>,在查询时才验证数据模式,加载迅速,仅仅是文件的复制和移动</p>\n</li>\n<li><p>更新,事务和索引</p>\n<p>  HDFS不支持就地更新,插入,更新删除操作引起的一切变化都被保存在一个增量文件中,由metastore在后台运行的mapreduce作业会定期将增量文件合并到基表.</p>\n<p> Hive引入了表级和分区级的锁,由ZooKeeper透明管理,用户不用执行获得和释放锁的操作.</p>\n<p> Hive索引分为<em>紧凑</em>和<em>位图</em>索引,可插拔,紧凑索引存储每个值的HDFS块号而不是文件内偏移量,不会占用过多磁盘空间;位图索引使用压缩的bitset来高效存储具有特殊值的行,适用于具有极少取值的列.</p>\n</li>\n</ol>\n<h2 id=\"表\"><a href=\"#表\" class=\"headerlink\" title=\"表\"></a>表</h2><p>Hive中的表在逻辑上由存储的数据和描述表中数据形式的相关元数据组成.<em>数据</em>一般存放在HDFS上,也可以是其他Hadoop文件系统,Hive把<em>元数据</em>存放在关系型数据库</p>\n<p><strong>托管表和外部表</strong><br>Hive创建表时,默认由Hive管理数据,将数据移入它的”仓库目录”,称为<em>托管表</em>.另一种方式是<em>外部表</em>,Hive到仓库目录以外的位置访问数据. 区别体现在DROP 和 LOAD上.</p>\n<ul>\n<li><p>托管表:</p>\n<blockquote>\n<p>加载操作就是文件系统中文件移动或重命名,执行速度快,如果要手动检查是否满足模式,可以通过查询为缺失字段返回的空值NULL才知道不匹配的行.<br><code>load data local inpath &#39;input/hive/dummy.txt&#39; into table managed_table;</code><br>执行删除操作后,它的元数据和数据会被一起删除,在HDFS中可以看到删除表后/user/hive/warehouse中的managed_table也被删除了.<br><code>drop table managed_table;</code></p>\n</blockquote>\n</li>\n<li><p>外部表</p>\n<blockquote>\n<p>创建表示需要指明外部数据的位置,定义时Hive不会检查外部位置是否存在,故可以在创建表之后再创建数据<br><code>create external table external_table (dummy STRING) LOCATION /user/harold/external_table</code>;<br>丢弃外部表时,Hive只会删除元数据,不会删除数据</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>分区和桶</strong><br>Hive把表组织成<em>分区</em>,使用分区可以加快数据分片的查询速度.表或分区可以进一部分为桶(bucket)它会为数据提供额外的结构以获得更高效的查询处理.</p>\n<ul>\n<li><em>分区</em> : 分区使得表对限制到某个特定范围的数据的查询变得非常高效(比如按照日期分区),只需扫描查询范围内分区中的文件,而且不会影响大范围查询的执行.一个表可以以多个维度分区,即进行子分区.</li>\n</ul>\n<p>分区是在创建表时用PARTITIONED BY子句定义的:</p>\n<blockquote>\n<p><code>CREATE TABLE logs (ts BIGINT, line STRING) PARTITIONED BY (dt STRING, country      STRING);</code></p>\n</blockquote>\n<p>  在将数据加载到分区表时,要显示指定分区值:</p>\n<blockquote>\n<p><code>LOAD DATA LOCAL INPATH &#39;input/hive/partitions/file1&#39; INTO TABLE logs PARTITION (dt=&#39;2001-01-01&#39;, country=&#39;GB&#39;);</code><br><code>SHOW PARTITON logs;</code> 可以展示表中的分区</p>\n</blockquote>\n<ul>\n<li><p><em>桶</em> :<br>  将表或分区组织成桶的理由:</p>\n<blockquote>\n<p>. 获得高效的查询处理效率<br>. 使取样更高效<br>创建被划分成桶的表:<br><code>CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) INTO 4 BUCKETS;</code><br> 桶中的数据可以根据一个列或者多个列排序,这样对每个桶的连接变成了高效的归并排序,提升了map端连接的效率:<br><code>CREATE TABLE bucketed_users (id INT, name STRING) CLUSTERED BY (id) SORTED BY (id) INTO 4 BUCKETS;</code></p>\n</blockquote>\n<p> Hive并不检查数据文件中的桶是否和表定义中的桶一致,无论是桶的数量还是用来划分的列, 如果不匹配会 ,查询时会碰到错误或未定义的结果.<br> 将一个没有划分桶的数据集users填充进分桶后的表的步骤如下:</p>\n<blockquote>\n<p><code>SET hive.enforce.bucketing=true;</code> 这样Hive就知道用表中声明的数量来创建桶<br><code>INSERT OVERWRITE TABLE bucketed_users SELECT * FROM users;</code>Insert 即可</p>\n</blockquote>\n</li>\n</ul>\n<p>物理上,每个桶就是表目录中的一个文件,一个作业产生的桶(输出文件)和reduce任务个数相同.</p>\n<p>用TABLESAMPLE子句对表取样:<br><code>SELECT * FROM bucketed_users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);</code><br>和<br><code>SELECT * FROM users TABLESAMPLE(BUCKET 1 OUT OF 4 ON id);</code></p>\n<p>得到的结果一样.</p>\n<p><strong>存储格式</strong></p>\n<p> Hive从两个维度对表的存储进行管理:</p>\n<ul>\n<li>行格式: 行和行中的字段如何存储,行格式由SerDe(Serializer-Deserializer)定义. 当作为反序列化工具使用时(即查询表),SerDe将把文件中字节形式的数据反序列化为Hive内部操作行时所使用的对象形式,作为序列化工具时(INSERT,CTAS),表的SerDe会把Hive的数据行内部表示形式序列化成字节形式并写道输出文件中.</li>\n<li>文件格式: 一行中字段容器的格式</li>\n</ul>\n<p><em>默认的存储格式—-分隔的文本</em></p>\n<p>在创建表时如果没有用ROW FORMAT或STORED AS子句,Hive所使用的默认格式是分隔的文本,每行存储一个数据行.</p>\n<p>默认行内分隔符不是制表符,而是ASCII控制码集合中的Control-A,原因是它出现在字段文本中的可能性较小,Hive中无法对分隔符进行转义,因此挑选一个不会在数据字段中用到的字符作为分隔符非常重要.</p>\n<blockquote>\n<p>集合类的默认分隔符为Control-B,用于分隔ARRAY,STRUCT或MAP的键值对中的元素<br>默认的映射键(map key)分隔符为Control-C,用于分隔map的键和值<br>表中各行用换行符分隔<br>可以用hexdump查看输出文件的分隔符</p>\n</blockquote>\n<p>Hive支持8级分隔符,对应ASCII编码的1-8,但只能重载前三个.可用8进制形式表示分隔符,如001表示Control-A.</p>\n<p>Hivene内部使用LazySimpleSerDe来处理这种分隔格式以及面向行的MapReduce文本输入输出格式,他对字段的反序列化是延时处理的,只有在访问字段时才进行反序列化.</p>\n<p><em>二进制存储格式: 顺序文件 Avro数据文件 Parquet文件 RCFile ORCFile</em></p>\n<p>二进制格式:</p>\n<ol>\n<li>面向行的格式(Avro,顺序文件): 适合同时处理一行中很多列<blockquote>\n<p><code>SET hive.exec.compress.output=true;</code><br><code>SET avro.output.codec=snappy;</code><br><code>CREATE TABLE ... STORE AS AVRO;</code><br>可以将表存储为Avro格式</p>\n</blockquote>\n</li>\n<li>面向列的格式(Parquet文件 RCFile ORCFile): 对于只访问表中一小部分列的查询有效</li>\n</ol>\n<p>使用定制的SerDe: RegexSerDe</p>\n<blockquote>\n<p><code>REATE TABLE stations (usaf STRING, wban STRING, name STRING) ROW FORMAT SERDE &#39;org.apache.hadoop.hive.contrib.serde2.RegexSerDe&#39; WITH SERDEPROPERTIES (&quot;input.regex&quot; = &quot;(\\\\d{6}) (\\\\d{5}) (\\\\.{29}) .*&quot;);</code></p>\n<p>使用SERDE关键字和JAVA类完整类名指明使用哪个SerDe.用 WITH SERDEPROPERTIES设置SERDE的额外属性.</p>\n<p><code>LOAD DATA LOCAL INPATH &quot;input/ncdc/metadata/stations-fixed-width.txt&quot; INTO TABLE stations;</code></p>\n<p><code>hive&gt; SELECT * FROM stations LIMIT 4;\nOK\n010000    99999    BOGUS NORWAY\n010003    99999    BOGUS NORWAY\n010010    99999    JAN MAYEN\n010013    99999    ROST</code><br>效率比较低,一般用二进制存储格式</p>\n</blockquote>\n<p><em>导入数据</em></p>\n<blockquote>\n<p><strong>INSERT语句</strong><br>动态分区插入:</p>\n<blockquote>\n<p><code>INSERT OVERWRITE TABLE target PARTITION(dt) SELECT COL1, CLO2, dt FROM source</code></p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong>多表插入</strong></p>\n<blockquote>\n<p><code>FROM records2</code><br><code>INSERT OVERWRITE TABLE stations_by_year SELECT year,COUNT(DISTINCT station) GROUP BY year</code><br><code>INSERT OVERWRITE TABLE records_by_year SELECT year, COUNT(1) GROUP BY year</code><br><code>INSERT OVERWRITE TABLE good_records_by_year SELECT year, COUNT(1) WHERE temperature != 9999 AND quality IN (0, 1, 4, 5, 9) GROUP BY year;</code><br>比单表效率高,只需扫一遍原表就可以生成多个不想交的输出</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong>CTAS</strong><br><code>CREATA TABLE target AS SELECT col1, col2 FROM source;</code><br>CTAS操作是原子的,如select查询由于某种原因失败,则不会创建表target</p>\n</blockquote>\n<p><em>表的修改</em><br>Hive使用读时模式,创建表后可以灵活的支持对表的修改,但是需要警惕确保修改数据以符合新的结构.</p>\n<blockquote>\n<p><code>ALTER TABLE source RENAME TO target;</code></p>\n</blockquote>\n<p>重命名表,在更新元数据以外ALTER TABLE还把表目录移到新名称对应的目录下,对于外部表则只更新元数据.</p>\n<blockquote>\n<p><code>ALTER TABLE target ADD COLUMNS (cols3 STRING);</code></p>\n</blockquote>\n<p>添加新的列cols3在已有(非分区)列的后面,数据文件并没有更新,原来的查询会为cols3的结果返回null,Hive不允许更新已有的记录,故一般创建一个定义了新列的新表.然后使用SELECT语句把数据填充进去.</p>\n<p><em>表的丢弃</em><br>DROP TABLE;删除表中数据和元数据(外部表数据除外)<br>TRUNCATE TABLE my_table;删除表内所有数据,但保留定义(对外部表不起作用)<br>CREATE TABLE new_table LIKE existing_table;达到类似TRUNCATE的目的.</p>\n<h2 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h2><p><strong>排序和聚集</strong></p>\n<ul>\n<li>ORDER BY : 对输入执行并行全排序</li>\n<li>SORT BY : 为每个reducer产生一个排序文件</li>\n<li>DISTRIBUTE BY : 控制特定行到某个reducer,便于后续的聚集操作<blockquote>\n<p><code>FROM records2 SELECT year, temperature DISTRIBUTE BY year SORT BY year ASC, temperature DESC;</code></p>\n</blockquote>\n</li>\n</ul>\n<p><strong>MapReduce脚本</strong><br>TRANSFORM,MAP,REDUCE子句可在Hive中调用外部脚本或程序.</p>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"comment\">#is_good_quality.py</span></span><br><span class=\"line\">&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</span><br><span class=\"line\">    (year,temp,q) = line.strip().split()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (temp != <span class=\"string\">\"9999\"</span> <span class=\"keyword\">and</span> re.match(<span class=\"string\">\"[01459]\"</span>),q)):</span><br><span class=\"line\">        print(<span class=\"string\">\"%s\\t%s\"</span> % (year, temp))</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><code>ADD FILE /input/is_good_quality.py;</code> 在Hive中注册脚本,Hive将脚本文件传到Hadoop集群<br><code>FROM records2 select TRANSFORM(year,temperature,quality) USING &#39;is_good_quality.py&#39; as year, temperature;</code> </p>\n</blockquote>\n<p>这一实例并未使用reducer.如果要使用嵌套模式,可以指定map和reduce函数:</p>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;FROM (</span><br><span class=\"line\">  FROM records2</span><br><span class=\"line\">  MAP year, temperature, quality</span><br><span class=\"line\">  USING <span class=\"string\">'is_good_quality.py'</span></span><br><span class=\"line\">  AS year, temperature) map_output</span><br><span class=\"line\">REDUCE year, temperature</span><br><span class=\"line\">USING <span class=\"string\">'max_temperature_reduce.py'</span></span><br><span class=\"line\">AS year, temperature;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>和<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM (</span><br><span class=\"line\">  FROM records2</span><br><span class=\"line\">  SELECT TRANSFORM(year, temperature, quality)</span><br><span class=\"line\">  USING <span class=\"string\">'is_good_quality.py'</span></span><br><span class=\"line\">  AS year, temperature) map_output</span><br><span class=\"line\">SELECT TRANSFORM(year, temperature)</span><br><span class=\"line\">USING <span class=\"string\">'max_temperature_reduce.py'</span></span><br><span class=\"line\">AS year, temperature;</span><br></pre></td></tr></table></figure></p>\n<p>结果一致</p>\n<p><strong>连接</strong></p>\n<p><em>内连接</em>:输入表之间每次匹配都会在输出行里生成一行:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;SELECT * FROM sales;</span><br><span class=\"line\">Joe\t2</span><br><span class=\"line\">Hank\t4</span><br><span class=\"line\">Ali\t0</span><br><span class=\"line\">Eve\t3</span><br><span class=\"line\">Hank\t2</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SELECT * FROM things;</span><br><span class=\"line\">2\tTie</span><br><span class=\"line\">4\tCoat</span><br><span class=\"line\">3\tHat</span><br><span class=\"line\">1\tScarf</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>JOIN子句中的顺序很重要:一般将最大的表放到最后,因为JOIN前一阶段生成的数据会存在于Reducer的buffer中，通过stream最后面的表，直接从Reducer的buffer中读取已经缓冲的中间结果数据（这个中间结果数据可能是JOIN顺序中，前面表连接的结果的Key，数据量相对较小，内存开销就小），这样，与后面的大表进行连接时，只需要从buffer中读取缓存的Key，与大表中的指定Key进行连接，速度会更快，也可能避免内存缓冲区溢出.(出自<a href=\"http://shiyanjun.cn/archives/588.html\" target=\"_blank\" rel=\"noopener\">简单之美</a>)</p>\n</blockquote>\n<p>Hive只支持等值连接,在连接谓词中只能使用等号,还可以在在查询中使用多个JOIN…ON…子句来连接多个表,Hive会智能的以最少的MapReduce作业数来执行连接.单个连接用一个MR作业实现,如果多个连接条件中使用了相同的列那么平均每个连接可以使用少于一个MR作业来实现.</p>\n<p><strong>外连接</strong><br>外连接可以找到表中不能匹配的数据行:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;左连接</span><br><span class=\"line\">SELECT sales.*, things.* FROM sales LEFT OUTER JOIN things ON (sales.id = things.id);</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br><span class=\"line\">Ali\t0\tNULL\tNULL</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>当然Hive也支持右连接和全外连接:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT sales.*, things.* FROM sales RIGHT OUTER JOIN things ON (sales.id = things.id);</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">NULL\tNULL\t1\tScarf</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;SELECT sales.*, things.* FROM sales FULL OUTER JOIN things ON (sales.id = things.id)</span><br><span class=\"line\">&gt;Ali\t0\tNULL\tNULL</span><br><span class=\"line\">NULL\tNULL\t1\tScarf</span><br><span class=\"line\">Hank\t2\t2\tTie</span><br><span class=\"line\">Joe\t2\t2\tTie</span><br><span class=\"line\">Eve\t3\t3\tHat</span><br><span class=\"line\">Hank\t4\t4\tCoat</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>半连接</strong><br>LEFT SEMI JOIN:</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from sales left semi join things on (sales.id = things.id);</span><br><span class=\"line\">Joe\t2</span><br><span class=\"line\">Hank\t4</span><br><span class=\"line\">Eve\t3</span><br><span class=\"line\">Hank\t2</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>右表只能在ON子句中出现,不能在SELECT表达式中引用右表.</p>\n<p><strong>map连接</strong><br>如果有一个连接表小到足以放入内存,Hive就将较小的表放入每个mapper的内存来执行连接操作.<br>map连接不适用Reducer,因此对于RIGHT或者FULL OUTER JOIN无效,因为只有在对所有输入上进行聚集的步骤(reduce)才能检测到那个数据行无法匹配.<br>map连接可以利用分桶的表,因为作用于左侧表的桶的mapper加载右侧表中对应的桶即可执行连接.需要<code>SET hive.optimize.bucketmapjoin=true</code>启用优化选项.</p>\n<p><strong>子查询</strong><br>子查询是内嵌在另一个SQL语句中的SELECT语句,Hive只允许子查询出现在SELECT语句的FROM子句中,或某些特殊情况下的WHERE子句中.</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;hive&gt; SELECT station, year, AVG(max_temperature)</span><br><span class=\"line\">     FROM (</span><br><span class=\"line\">     SELECT station, year, MAX(temperature) AS max_temperature</span><br><span class=\"line\">     FROM records2</span><br><span class=\"line\">     WHERE temperature != 9999 AND quality IN (0,1,4,5,9)</span><br><span class=\"line\">     GROUP BY station, year</span><br><span class=\"line\">     ) mt</span><br><span class=\"line\">     GROUP BY station, year;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>外层查询像访问表那样访问子查询的结果,所以必须为子查询赋予一个别名(mt),子查询中的列必须有唯一的名称,以便外层访问引用这些列.</p>\n<p><strong>视图</strong><br>用SELECT语句定义的虚表,可以限制用户,使其只能访问被授权可以看到的表的子集.Hive中,创建视图并不把视图物化存储到磁盘上,视图的SELECT语句只在执行引用视图的语句时才执行.要手工物化视图,可以新建一个表,将视图内容存储到新表中.<br>创建方式:CREATE VIEW</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; CREATE VIEW valid_records AS SELECT * FROM records2 WHERE temperature != 9999 AND quality IN (0,1,4,5,9);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>创建视图时并不执行查询,查询只是存储在metastore中,SHOW TABLES命令结果包含视图,可用DESCRIBE EXTENDED view_name来查看视图的详细信息.<br><img src=\"/home/harold/Pictures/Selection_021.png\" alt=\"\"></p>\n</blockquote>\n<p>Hive可以把使用视图的查询组织为一系列作业,效果与不使用视图一样.即使在执行时,Hive也不会再不必要的情况下物化视图.</p>\n<p>Hive中的视图是只读的,无法通过视图为基表加载或插入数据.</p>\n<h2 id=\"用户定义函数—-UDF\"><a href=\"#用户定义函数—-UDF\" class=\"headerlink\" title=\"用户定义函数—-UDF\"></a>用户定义函数—-UDF</h2><p>用户定义函数(user-defined function)必须用Java编写,其他语言可以用之前用过的<code>SELECT TRANSFORM</code>查询.</p>\n<p>Hive三种UDF, 他们所接受的输入和产生的输出的数据行的数量不同 :</p>\n<ul>\n<li>普通UDF : 作用于单个数据行,产生一个数据行</li>\n<li>用户定义聚集函数 UDAF : 接受多个数据行,产生一个输出行, 类似COUNT , MAX</li>\n<li>用户定义表生成函数 UDTF : 作用于单个数据行, 产生多个输出行</li>\n</ul>\n<p><em>UDTF</em>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; create table arrays (x ARRAY&lt;STRING&gt;) ROW</span><br><span class=\"line\">    &gt; FORMAT DELIMITED</span><br><span class=\"line\">    &gt; FIELDS TERMINATED BY &apos;\\001&apos;</span><br><span class=\"line\">    &gt; COLLECTION ITEMS TERMINATED BY &apos;\\002&apos;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; SELECT * FROM arrays;</span><br><span class=\"line\">OK</span><br><span class=\"line\">[&quot;a&quot;,&quot;b&quot;]</span><br><span class=\"line\">[&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br></pre></td></tr></table></figure>\n<p>explode UDTF对表进行变换,为数组中的每一项输出一行.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; SELECT explode(x) AS y from arrays;</span><br><span class=\"line\">OK</span><br><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">c</span><br><span class=\"line\">d</span><br><span class=\"line\">e</span><br></pre></td></tr></table></figure></p>\n<p>常用的UDTF还有SPLIT() 等,还有更强大的LATERAL VIEW查询,笔者会在之后的博客详细介绍.</p>\n<p><strong>写UDF</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.lang.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Strip</span> <span class=\"keyword\">extends</span> <span class=\"title\">UDF</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Text result = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">evaluate</span> <span class=\"params\">(Text str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.set(StringUtils.strip(str.toString()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">evaluate</span><span class=\"params\">(Text str, String stripChars)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result.set(StringUtils.strip(str.toString(), stripChars));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个UDF必须满足:</p>\n<ol>\n<li>是org.apache.hadoop.hive.ql.exec.UDF的子类</li>\n<li>至少实现了evaluate()方法</li>\n</ol>\n<p>evaluate()不是由接口定义的,它接受的参数个数和类型以及返回值都是不确定的,Hive会检查UDF,看能否找到相匹配的evaluate().</p>\n<p>使用UDF:<br>1.在metastore中注册函数并用CTREATE FUNCTION为它取名:</p>\n<blockquote>\n<p>CREATE FUNCTION strip AS ‘com.hadoopbook.hive.Strip’ USING JAR ‘path/hive-example.jar’</p>\n</blockquote>\n<p>2.使用内置函数:</p>\n<blockquote>\n<p>SELECT strip(‘ bee ‘) FROM dummy; UDF名对大小写不敏感</p>\n</blockquote>\n<p>3.删除函数:</p>\n<blockquote>\n<p>DROP FUNCTION strip;</p>\n</blockquote>\n<p>4.用TEMPORARY创建仅在Hive会话期间有效的函数,不在metastore中持久化:</p>\n<blockquote>\n<p><code>ADD JAR /path/hive-example.jar;</code><br><code>CREATE TEMPORARY FUNCTION strip AS &#39;com.hadoopbook.hive.Strip&#39;;</code></p>\n</blockquote>\n<p><strong>写UDAF</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.hive.ql.exec.UDAF;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.hive.ql.exec.UDAFEvaluator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maximum</span> <span class=\"keyword\">extends</span> <span class=\"title\">UDAF</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaximumIntUDAFEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">UDAFEvaluator</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> IntWritable result;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">iterate</span><span class=\"params\">(IntWritable value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">new</span> IntWritable(value.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result.set(Math.max(result.get(), value.get()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> IntWritable <span class=\"title\">terminatePartial</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">merge</span><span class=\"params\">(IntWritable other)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> iterate(other);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> IntWritable <span class=\"title\">terminate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>UDAF必须是org.apache.hadoop.hive.ql.exec.UDAF的子类(<em>UDAF类已经过时弃用了，现在是实现GenericUDAFResolver2接口,请看本博客另一篇相关的文内容</em>), 且包含一个或多个嵌套的实现了Org.apache.hadoop.hive.ql.exec.UDAFEvaluator的<em>静态类</em>.</p>\n<p>一个计算函数必须实现以下五个方法:</p>\n<ul>\n<li><p>init() : 负责初始化计算函数并设置他的内部状态</p>\n</li>\n<li><p>inerate() : 每次对一个新值进行聚集计算都会调用此方法,iterate()接受的参数和Hive中被调用函数的参数是对应的.</p>\n</li>\n<li><p>terminate() : Hive需要部分聚集结果时会调用此方法,这个方法必须返回一个封装了聚集计算当前状态的对象.</p>\n</li>\n<li><p>merge()方法 : 在Hive合并两个部分聚集值时会调用merge()方法.该方法接受一个对象作为输入,其类型必须和terminatePartial()方法的返回类型一致.</p>\n</li>\n<li><p>terminate()方法 : Hive需要最终聚集结果时会调用此方法</p>\n</li>\n<li><p>计算流程见下图:<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-18/61809116.jpg\" alt=\"\"></p>\n</li>\n</ul>"},{"title":"动态规划算法面试题----硬币组合问题","date":"2018-03-23T15:02:10.000Z","_content":"\n师兄做腾讯春季实习生笔试题目算法第二道题目,小明有2^k个硬币各两个,如1,1,2,2,4,4,8,8...,给定一个币值n,问小明有多少种方法从自己已有的硬币中组合出n.\n\n第一眼看到这个题目有两个想法,要么用二进制的方式解决,要么用动态规划解决,二进制的办法现场没想出来,试着用动态规划解,开始想的是自底向上的解法,写了一小段代码,可以输出一部分解,方案不完备,晚上回来系统的写一下此类问题的解法.\n  <!-- more-->\n先看一下典型的币值组合问题的描述:\n> In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:\n>    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).\n>It is possible to make £2 in the following way:\n>    1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p\n>How many different ways can £2 be made using any number of coins?\n\n不难发现,这是一道完全背包问题,第i种硬币i最多可以被选择`sum/coin[i]`个,我们用`dp[i][sum]`表示用前i种硬币构成sum的所有组合数,用`Xi`表示第i种硬币被选择的数量,`Vi`表示第i种硬币的币值,以最后一种硬币被选择的数量来写递归公式:\n> `sum = X1*V1 + X2*V2 + ... +  0*V8`\n`sum = X1*V1 + X2*V2 + ... +  1*V8`\n`sum = X1*V1 + X2*V2 + ... +  2*V8`\n`...`\n>`sum = X1*V1 + X2*V2 + ... +  (sum/V8)*V8`\n\n可以看出,前i种硬币组合出sum的组合数量等于当第i种硬币取0,1,2...sum/Vi时,前i-1种硬币组合出sum-(Xi*Vi)的组合数之和,\n因此状态转移方程是 :\n```java\ndp[i][sum] = dp[i-1][sum-0*Vi] + dp[i-1][sum-1*Vi] + ... + dp[i-1][sum-(sum/Vi)*Vi] ```\n\n当sum=0时,只有一种可能组成sum,因此`dp[i][0]=0`\n如果我们用二位数组表示dp[i][sum], 我们发现第i行的值全部依赖与i-1行的值，所以我们可以逐行求解该数组。如果前0种硬币要组成sum，我们规定为dp[0][sum] = 0.\n\n代码:\n```java\n\t\tScanner scanner = new Scanner(System.in);\n        int sum = scanner.nextInt();\n        int [] coin = {1,2,5,10,20,50,100,200};\n        int [][] dp = new int[8][sum+1];\n\n        for (int i = 1; i<=sum; i++)\n            dp[0][i] = 0;\n\n        for (int i = 0 ; i < 8; i++)\n            dp[i][0] = 1;\n\n        for (int i = 1; i< 8; i++) {\n            for (int j = 1; j<=sum; j++){\n                dp[i][j] = 0;\n                for (int k = 0; k <= j/coin[i-1]; k++)\n                    dp[i][j] += dp[i-1][j-k*coin[i-1]];\n            }\n        }\n        System.out.println(dp[7][sum]);```\n\n现在让我们回到一开始的题目中,笔试题中每种硬币最多只能选两次,因此我们需要对上面代码的k添加K<=2的约束.\n```java\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CoinCombination {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int sum = scanner.nextInt();\n        int e = (int) (Math.log(sum) / Math.log(2));//计算sum是2的几次方\n        int coinType = e + 2;//此处+2是为了能够将最后一种硬币计算进去,否则后面循环会少算,因为dp[i][j]表示的是前i个硬币组合成j的数目.\n        int coin[] = new int[coinType];\n        for (int i = 0; i < coinType; i++) { //构造coin[]\n            coin[i] = (int) Math.pow(2, i);\n        }\n        int[][] dp = new int[coinType][sum + 1];\n\n        for (int i = 1; i <= sum; i++)\n            dp[0][i] = 0;\n\n        for (int i = 0; i < coinType; i++)\n            dp[i][0] = 1;\n\n        for (int i = 1; i < coinType; i++) {\n            for (int j = 1; j <= sum; j++) {\n                dp[i][j] = 0;\n                for (int k = 0; k <= j / coin[i - 1] && k <= 2; k++)//此处添加K<=2的约束\n                    dp[i][j] += dp[i - 1][j - k * coin[i - 1]];\n            }\n        }\n        System.out.println(dp[e + 1][sum]);\n    }\n}\n```\n\n\n\n\n","source":"_posts/动态规划算法面试题-硬币组合问题.md","raw":"---\ntitle: 动态规划算法面试题----硬币组合问题\ndate: 2018-03-23 23:02:10\ntags: 算法\n---\n\n师兄做腾讯春季实习生笔试题目算法第二道题目,小明有2^k个硬币各两个,如1,1,2,2,4,4,8,8...,给定一个币值n,问小明有多少种方法从自己已有的硬币中组合出n.\n\n第一眼看到这个题目有两个想法,要么用二进制的方式解决,要么用动态规划解决,二进制的办法现场没想出来,试着用动态规划解,开始想的是自底向上的解法,写了一小段代码,可以输出一部分解,方案不完备,晚上回来系统的写一下此类问题的解法.\n  <!-- more-->\n先看一下典型的币值组合问题的描述:\n> In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:\n>    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).\n>It is possible to make £2 in the following way:\n>    1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p\n>How many different ways can £2 be made using any number of coins?\n\n不难发现,这是一道完全背包问题,第i种硬币i最多可以被选择`sum/coin[i]`个,我们用`dp[i][sum]`表示用前i种硬币构成sum的所有组合数,用`Xi`表示第i种硬币被选择的数量,`Vi`表示第i种硬币的币值,以最后一种硬币被选择的数量来写递归公式:\n> `sum = X1*V1 + X2*V2 + ... +  0*V8`\n`sum = X1*V1 + X2*V2 + ... +  1*V8`\n`sum = X1*V1 + X2*V2 + ... +  2*V8`\n`...`\n>`sum = X1*V1 + X2*V2 + ... +  (sum/V8)*V8`\n\n可以看出,前i种硬币组合出sum的组合数量等于当第i种硬币取0,1,2...sum/Vi时,前i-1种硬币组合出sum-(Xi*Vi)的组合数之和,\n因此状态转移方程是 :\n```java\ndp[i][sum] = dp[i-1][sum-0*Vi] + dp[i-1][sum-1*Vi] + ... + dp[i-1][sum-(sum/Vi)*Vi] ```\n\n当sum=0时,只有一种可能组成sum,因此`dp[i][0]=0`\n如果我们用二位数组表示dp[i][sum], 我们发现第i行的值全部依赖与i-1行的值，所以我们可以逐行求解该数组。如果前0种硬币要组成sum，我们规定为dp[0][sum] = 0.\n\n代码:\n```java\n\t\tScanner scanner = new Scanner(System.in);\n        int sum = scanner.nextInt();\n        int [] coin = {1,2,5,10,20,50,100,200};\n        int [][] dp = new int[8][sum+1];\n\n        for (int i = 1; i<=sum; i++)\n            dp[0][i] = 0;\n\n        for (int i = 0 ; i < 8; i++)\n            dp[i][0] = 1;\n\n        for (int i = 1; i< 8; i++) {\n            for (int j = 1; j<=sum; j++){\n                dp[i][j] = 0;\n                for (int k = 0; k <= j/coin[i-1]; k++)\n                    dp[i][j] += dp[i-1][j-k*coin[i-1]];\n            }\n        }\n        System.out.println(dp[7][sum]);```\n\n现在让我们回到一开始的题目中,笔试题中每种硬币最多只能选两次,因此我们需要对上面代码的k添加K<=2的约束.\n```java\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CoinCombination {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int sum = scanner.nextInt();\n        int e = (int) (Math.log(sum) / Math.log(2));//计算sum是2的几次方\n        int coinType = e + 2;//此处+2是为了能够将最后一种硬币计算进去,否则后面循环会少算,因为dp[i][j]表示的是前i个硬币组合成j的数目.\n        int coin[] = new int[coinType];\n        for (int i = 0; i < coinType; i++) { //构造coin[]\n            coin[i] = (int) Math.pow(2, i);\n        }\n        int[][] dp = new int[coinType][sum + 1];\n\n        for (int i = 1; i <= sum; i++)\n            dp[0][i] = 0;\n\n        for (int i = 0; i < coinType; i++)\n            dp[i][0] = 1;\n\n        for (int i = 1; i < coinType; i++) {\n            for (int j = 1; j <= sum; j++) {\n                dp[i][j] = 0;\n                for (int k = 0; k <= j / coin[i - 1] && k <= 2; k++)//此处添加K<=2的约束\n                    dp[i][j] += dp[i - 1][j - k * coin[i - 1]];\n            }\n        }\n        System.out.println(dp[e + 1][sum]);\n    }\n}\n```\n\n\n\n\n","slug":"动态规划算法面试题-硬币组合问题","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7j003bcf96qkey09h5","content":"<p>师兄做腾讯春季实习生笔试题目算法第二道题目,小明有2^k个硬币各两个,如1,1,2,2,4,4,8,8…,给定一个币值n,问小明有多少种方法从自己已有的硬币中组合出n.</p>\n<p>第一眼看到这个题目有两个想法,要么用二进制的方式解决,要么用动态规划解决,二进制的办法现场没想出来,试着用动态规划解,开始想的是自底向上的解法,写了一小段代码,可以输出一部分解,方案不完备,晚上回来系统的写一下此类问题的解法.<br>  <a id=\"more\"></a><br>先看一下典型的币值组合问题的描述:</p>\n<blockquote>\n<p>In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:<br>   1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).<br>It is possible to make £2 in the following way:<br>   1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p<br>How many different ways can £2 be made using any number of coins?</p>\n</blockquote>\n<p>不难发现,这是一道完全背包问题,第i种硬币i最多可以被选择<code>sum/coin[i]</code>个,我们用<code>dp[i][sum]</code>表示用前i种硬币构成sum的所有组合数,用<code>Xi</code>表示第i种硬币被选择的数量,<code>Vi</code>表示第i种硬币的币值,以最后一种硬币被选择的数量来写递归公式:</p>\n<blockquote>\n<p><code>sum = X1*V1 + X2*V2 + ... +  0*V8</code><br><code>sum = X1*V1 + X2*V2 + ... +  1*V8</code><br><code>sum = X1*V1 + X2*V2 + ... +  2*V8</code><br><code>...</code><br><code>sum = X1*V1 + X2*V2 + ... +  (sum/V8)*V8</code></p>\n</blockquote>\n<p>可以看出,前i种硬币组合出sum的组合数量等于当第i种硬币取0,1,2…sum/Vi时,前i-1种硬币组合出sum-(Xi*Vi)的组合数之和,<br>因此状态转移方程是 :<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][sum] = dp[i-<span class=\"number\">1</span>][sum-<span class=\"number\">0</span>*Vi] + dp[i-<span class=\"number\">1</span>][sum-<span class=\"number\">1</span>*Vi] + ... + dp[i-<span class=\"number\">1</span>][sum-(sum/Vi)*Vi]</span><br></pre></td></tr></table></figure></p>\n<p>当sum=0时,只有一种可能组成sum,因此<code>dp[i][0]=0</code><br>如果我们用二位数组表示dp[i][sum], 我们发现第i行的值全部依赖与i-1行的值，所以我们可以逐行求解该数组。如果前0种硬币要组成sum，我们规定为dp[0][sum] = 0.</p>\n<p>代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">      <span class=\"keyword\">int</span> sum = scanner.nextInt();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> [] coin = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">50</span>,<span class=\"number\">100</span>,<span class=\"number\">200</span>&#125;;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> [][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">8</span>][sum+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i&lt;=sum; i++)</span><br><span class=\"line\">          dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">          dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i&lt; <span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j&lt;=sum; j++)&#123;</span><br><span class=\"line\">              dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= j/coin[i-<span class=\"number\">1</span>]; k++)</span><br><span class=\"line\">                  dp[i][j] += dp[i-<span class=\"number\">1</span>][j-k*coin[i-<span class=\"number\">1</span>]];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(dp[<span class=\"number\">7</span>][sum]);</span><br></pre></td></tr></table></figure></p>\n<p>现在让我们回到一开始的题目中,笔试题中每种硬币最多只能选两次,因此我们需要对上面代码的k添加K&lt;=2的约束.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoinCombination</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = scanner.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> e = (<span class=\"keyword\">int</span>) (Math.log(sum) / Math.log(<span class=\"number\">2</span>));<span class=\"comment\">//计算sum是2的几次方</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> coinType = e + <span class=\"number\">2</span>;<span class=\"comment\">//此处+2是为了能够将最后一种硬币计算进去,否则后面循环会少算,因为dp[i][j]表示的是前i个硬币组合成j的数目.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> coin[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[coinType];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; coinType; i++) &#123; <span class=\"comment\">//构造coin[]</span></span><br><span class=\"line\">            coin[i] = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[coinType][sum + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= sum; i++)</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; coinType; i++)</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; coinType; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= sum; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= j / coin[i - <span class=\"number\">1</span>] &amp;&amp; k &lt;= <span class=\"number\">2</span>; k++)<span class=\"comment\">//此处添加K&lt;=2的约束</span></span><br><span class=\"line\">                    dp[i][j] += dp[i - <span class=\"number\">1</span>][j - k * coin[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(dp[e + <span class=\"number\">1</span>][sum]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>师兄做腾讯春季实习生笔试题目算法第二道题目,小明有2^k个硬币各两个,如1,1,2,2,4,4,8,8…,给定一个币值n,问小明有多少种方法从自己已有的硬币中组合出n.</p>\n<p>第一眼看到这个题目有两个想法,要么用二进制的方式解决,要么用动态规划解决,二进制的办法现场没想出来,试着用动态规划解,开始想的是自底向上的解法,写了一小段代码,可以输出一部分解,方案不完备,晚上回来系统的写一下此类问题的解法.<br>","more":"<br>先看一下典型的币值组合问题的描述:</p>\n<blockquote>\n<p>In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:<br>   1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).<br>It is possible to make £2 in the following way:<br>   1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p<br>How many different ways can £2 be made using any number of coins?</p>\n</blockquote>\n<p>不难发现,这是一道完全背包问题,第i种硬币i最多可以被选择<code>sum/coin[i]</code>个,我们用<code>dp[i][sum]</code>表示用前i种硬币构成sum的所有组合数,用<code>Xi</code>表示第i种硬币被选择的数量,<code>Vi</code>表示第i种硬币的币值,以最后一种硬币被选择的数量来写递归公式:</p>\n<blockquote>\n<p><code>sum = X1*V1 + X2*V2 + ... +  0*V8</code><br><code>sum = X1*V1 + X2*V2 + ... +  1*V8</code><br><code>sum = X1*V1 + X2*V2 + ... +  2*V8</code><br><code>...</code><br><code>sum = X1*V1 + X2*V2 + ... +  (sum/V8)*V8</code></p>\n</blockquote>\n<p>可以看出,前i种硬币组合出sum的组合数量等于当第i种硬币取0,1,2…sum/Vi时,前i-1种硬币组合出sum-(Xi*Vi)的组合数之和,<br>因此状态转移方程是 :<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][sum] = dp[i-<span class=\"number\">1</span>][sum-<span class=\"number\">0</span>*Vi] + dp[i-<span class=\"number\">1</span>][sum-<span class=\"number\">1</span>*Vi] + ... + dp[i-<span class=\"number\">1</span>][sum-(sum/Vi)*Vi]</span><br></pre></td></tr></table></figure></p>\n<p>当sum=0时,只有一种可能组成sum,因此<code>dp[i][0]=0</code><br>如果我们用二位数组表示dp[i][sum], 我们发现第i行的值全部依赖与i-1行的值，所以我们可以逐行求解该数组。如果前0种硬币要组成sum，我们规定为dp[0][sum] = 0.</p>\n<p>代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">      <span class=\"keyword\">int</span> sum = scanner.nextInt();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> [] coin = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">50</span>,<span class=\"number\">100</span>,<span class=\"number\">200</span>&#125;;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> [][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">8</span>][sum+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i&lt;=sum; i++)</span><br><span class=\"line\">          dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">          dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i&lt; <span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j&lt;=sum; j++)&#123;</span><br><span class=\"line\">              dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= j/coin[i-<span class=\"number\">1</span>]; k++)</span><br><span class=\"line\">                  dp[i][j] += dp[i-<span class=\"number\">1</span>][j-k*coin[i-<span class=\"number\">1</span>]];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(dp[<span class=\"number\">7</span>][sum]);</span><br></pre></td></tr></table></figure></p>\n<p>现在让我们回到一开始的题目中,笔试题中每种硬币最多只能选两次,因此我们需要对上面代码的k添加K&lt;=2的约束.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoinCombination</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = scanner.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> e = (<span class=\"keyword\">int</span>) (Math.log(sum) / Math.log(<span class=\"number\">2</span>));<span class=\"comment\">//计算sum是2的几次方</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> coinType = e + <span class=\"number\">2</span>;<span class=\"comment\">//此处+2是为了能够将最后一种硬币计算进去,否则后面循环会少算,因为dp[i][j]表示的是前i个硬币组合成j的数目.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> coin[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[coinType];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; coinType; i++) &#123; <span class=\"comment\">//构造coin[]</span></span><br><span class=\"line\">            coin[i] = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[coinType][sum + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= sum; i++)</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; coinType; i++)</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; coinType; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= sum; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= j / coin[i - <span class=\"number\">1</span>] &amp;&amp; k &lt;= <span class=\"number\">2</span>; k++)<span class=\"comment\">//此处添加K&lt;=2的约束</span></span><br><span class=\"line\">                    dp[i][j] += dp[i - <span class=\"number\">1</span>][j - k * coin[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(dp[e + <span class=\"number\">1</span>][sum]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"scala——Actor、柯里化与隐式转换","date":"2018-04-28T13:09:45.000Z","_content":"\n* 高阶函数：\n  接受一个或多个函数作为输入或输出一个函数的函数称为高阶函数\n<!-- more-->\n\n  ```scala\n  scala> val func : Int => Int = x => x*x\n  func: Int => Int = $$Lambda$1046/1620041759@2687725a\n\n  scala> func(4)\n  res0: Int = 16\n  scala> val arr = Array(1,2,3,4,5,6)\n  arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)\n\n  scala> arr.map(x => func(x))//匿名函数\n  res1: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> def m1(x :Int) = x*x\n  m1: (x: Int)Int\n\n  scala> arr.map(x => m1(x))//方法转换为函数\n  res2: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> arr.map(m1)\n  res3: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> arr.map(func)\n  res4: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n  ```\n\n* 柯里化：\n\n  将接受多个参数的函数转变为接受一个参数的函数的过程\n\n  柯里化方法会在上下文中找最的隐式的值，作为柯里化方法的值，如果有多个隐式的值会报错\n\n  ```scala\n  scala> arr.map(func)\n  res4: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> def currying(x: Int)(y: Int) = x * y\n  currying: (x: Int)(y: Int)Int\n\n  scala> currying(3)(4)\n  res5: Int = 12\n\n  scala> val curry = currying(3) _//柯里化方法第一种用法\n  curry: Int => Int = $$Lambda$1187/1535571147@468646ea\n\n  scala> curry(4)\n  res6: Int = 12\n\n  scala> def m1(x: Int, y: Int) = x*y\n  m1: (x: Int, y: Int)Int\n\n  scala> m1(5,10)\n  res8: Int = 50\n\n  scala> def m2(x:Int)(implicit y :Int = 5) = x * y//柯里化的第2种用法，指定默认值，调用是不指定参数就使用默认值\n  m2: (x: Int)(implicit y: Int)Int\n\n  scala> m2(4)\n  res9: Int = 20\n\n  scala> m2(4)(6)\n  res11: Int = 24\n\n  scala> implicit val x = 100//设置一个隐式的量\n  x: Int = 100\n\n  scala> m2(4)\n  res12: Int = 400\n\n  scala> implicit val y = 200//设置第二个隐式的量\n  y: Int = 200\n\n  scala> m2(5)//此时会发生错误，因为有两个隐式量\n  <console>:15: error: ambiguous implicit values:\n   both value x of type => Int\n   and value y of type => Int\n   match expected type Int\n         m2(5)\n           ^\n\n  scala> val arr = Array((\"scala\",1),(\"scala\",2),(\"scala\",3))\n  arr: Array[(String, Int)] = Array((scala,1), (scala,2), (scala,3))\n\n  scala> arr.foldLeft(0)(_ + _._2)\n  res14: Int = 6\n\n  scala> def curry(x:Int) = (y:Int) => x * y\n  curry: (x: Int)Int => Int\n\n  scala> val func = curry(2)//柯里化方法第3中用法\n  func: Int => Int = $$Lambda$1058/191351920@45c9b3\n\n  scala> func(3)\n  res0: Int = 6\n  ```\n  ```scala\n  object Content {//这个静态块只有放在Currying上面才能用a或b替代默认值，因为scala是顺序编译执行的\n    implicit val a = \"java\"\n    implicit val b = \"python\"\n  }\n\n  object CurryingDemo {\n    def m1(str: String)(implicit name : String = \"scala\") = {\n      println(str + name)\n    }\n    def main(args: Array[String]): Unit = {\n      m1(\"Hi~\")\n    }\n  }\n  ```\n\n* 隐式转换与隐式参数\n\n  1. 作用：能够丰富现有类库的功能，对类的方法进行增强\n  2. 隐式转换函数：以implicit关键字声明带有单个参数的函数\n  3. 隐式转换用到了装饰模式和门面模式\n\n```scala\nobject ImplicitContext {\n  implicit object OrderingGirl extends Ordering[Girl]{\n  override def compare(x: Girl, y: Girl): Int = if (x.faveValue > y.faveValue) 1 else  -1}\n}\nclass Girl(val name: String, var faveValue: Int){\n  override def toString: String = s\"name:$name\"\n}\n\nclass Goddess[T: Ordering](val v1 :T, val v2: T) {\n  def choose()(implicit ord :Ordering[T]) =if (ord.gt(v1,v2)) v1 else v2\n}\n\nobject Goddess {\n  def main(args: Array[String]): Unit = {\n    import ImplicitContext.OrderingGirl\n    val g1 = new Girl(\"lili\",90)\n    val g2 = new Girl(\"huahua\",70)\n    val goddess = new Goddess(g1, g2)\n    val res = goddess.choose()\n    println(res)\n  }\n}\n```\n\n* 泛型\n\n  [B <: A]  UpperBound 上界： B类型的上界是A类型，即B类型的父类是A类型\n\n  [B >: A] LowerBound 下界： B类型的下界是A类型，即B类型的子类是A类型\n\n  [B <% A]  ViewBound 表示B类型要转换成A类型，需要一个隐式转换函数\n\n  [B : A]  ContextBound 需要一个隐式转换的值\n\n[-A, +B]\n\n​\t[-A]  逆变，作为参数类型。如果A是T的子类，那C[T]是C[A]的子类\n\n​\t[+B ]协变，作为返回类型。如果B是T的子类，那么C[B]是C[T]的子类\n\n```scala\n/*\n上界 UpperBound\n */\nclass UpperBoundDemo[T <: Comparable[T]] {\n  def select(first: T, second: T) = {\n    if (first.compareTo(second) > 0)\n      first\n    else\n      second\n  }\n}\n\nobject UpperBoundDemo {\n  def main(args: Array[String]): Unit = {\n    val u = new UpperBoundDemo[MissRight]\n    val m1 = new MissRight(\"LILI\", 95)\n    val m2 = new MissRight(\"erniu\", 999)\n\n    println(u.select(m1, m2))\n  }\n}\n\nclass MissRight(val name: String, val faceValue: Int) extends Comparable[MissRight] {\n  override def compareTo(o: MissRight): Int = {\n    this.faceValue - o.faceValue\n  }\n\n  override def toString: String = s\"name:$name\"\n}\n```\n\n","source":"_posts/scala——Actor、柯里化与隐式转换.md","raw":"---\ntitle: scala——Actor、柯里化与隐式转换\ndate: 2018-04-28 21:09:45\ntags: scala\n---\n\n* 高阶函数：\n  接受一个或多个函数作为输入或输出一个函数的函数称为高阶函数\n<!-- more-->\n\n  ```scala\n  scala> val func : Int => Int = x => x*x\n  func: Int => Int = $$Lambda$1046/1620041759@2687725a\n\n  scala> func(4)\n  res0: Int = 16\n  scala> val arr = Array(1,2,3,4,5,6)\n  arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)\n\n  scala> arr.map(x => func(x))//匿名函数\n  res1: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> def m1(x :Int) = x*x\n  m1: (x: Int)Int\n\n  scala> arr.map(x => m1(x))//方法转换为函数\n  res2: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> arr.map(m1)\n  res3: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> arr.map(func)\n  res4: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n  ```\n\n* 柯里化：\n\n  将接受多个参数的函数转变为接受一个参数的函数的过程\n\n  柯里化方法会在上下文中找最的隐式的值，作为柯里化方法的值，如果有多个隐式的值会报错\n\n  ```scala\n  scala> arr.map(func)\n  res4: Array[Int] = Array(1, 4, 9, 16, 25, 36)\n\n  scala> def currying(x: Int)(y: Int) = x * y\n  currying: (x: Int)(y: Int)Int\n\n  scala> currying(3)(4)\n  res5: Int = 12\n\n  scala> val curry = currying(3) _//柯里化方法第一种用法\n  curry: Int => Int = $$Lambda$1187/1535571147@468646ea\n\n  scala> curry(4)\n  res6: Int = 12\n\n  scala> def m1(x: Int, y: Int) = x*y\n  m1: (x: Int, y: Int)Int\n\n  scala> m1(5,10)\n  res8: Int = 50\n\n  scala> def m2(x:Int)(implicit y :Int = 5) = x * y//柯里化的第2种用法，指定默认值，调用是不指定参数就使用默认值\n  m2: (x: Int)(implicit y: Int)Int\n\n  scala> m2(4)\n  res9: Int = 20\n\n  scala> m2(4)(6)\n  res11: Int = 24\n\n  scala> implicit val x = 100//设置一个隐式的量\n  x: Int = 100\n\n  scala> m2(4)\n  res12: Int = 400\n\n  scala> implicit val y = 200//设置第二个隐式的量\n  y: Int = 200\n\n  scala> m2(5)//此时会发生错误，因为有两个隐式量\n  <console>:15: error: ambiguous implicit values:\n   both value x of type => Int\n   and value y of type => Int\n   match expected type Int\n         m2(5)\n           ^\n\n  scala> val arr = Array((\"scala\",1),(\"scala\",2),(\"scala\",3))\n  arr: Array[(String, Int)] = Array((scala,1), (scala,2), (scala,3))\n\n  scala> arr.foldLeft(0)(_ + _._2)\n  res14: Int = 6\n\n  scala> def curry(x:Int) = (y:Int) => x * y\n  curry: (x: Int)Int => Int\n\n  scala> val func = curry(2)//柯里化方法第3中用法\n  func: Int => Int = $$Lambda$1058/191351920@45c9b3\n\n  scala> func(3)\n  res0: Int = 6\n  ```\n  ```scala\n  object Content {//这个静态块只有放在Currying上面才能用a或b替代默认值，因为scala是顺序编译执行的\n    implicit val a = \"java\"\n    implicit val b = \"python\"\n  }\n\n  object CurryingDemo {\n    def m1(str: String)(implicit name : String = \"scala\") = {\n      println(str + name)\n    }\n    def main(args: Array[String]): Unit = {\n      m1(\"Hi~\")\n    }\n  }\n  ```\n\n* 隐式转换与隐式参数\n\n  1. 作用：能够丰富现有类库的功能，对类的方法进行增强\n  2. 隐式转换函数：以implicit关键字声明带有单个参数的函数\n  3. 隐式转换用到了装饰模式和门面模式\n\n```scala\nobject ImplicitContext {\n  implicit object OrderingGirl extends Ordering[Girl]{\n  override def compare(x: Girl, y: Girl): Int = if (x.faveValue > y.faveValue) 1 else  -1}\n}\nclass Girl(val name: String, var faveValue: Int){\n  override def toString: String = s\"name:$name\"\n}\n\nclass Goddess[T: Ordering](val v1 :T, val v2: T) {\n  def choose()(implicit ord :Ordering[T]) =if (ord.gt(v1,v2)) v1 else v2\n}\n\nobject Goddess {\n  def main(args: Array[String]): Unit = {\n    import ImplicitContext.OrderingGirl\n    val g1 = new Girl(\"lili\",90)\n    val g2 = new Girl(\"huahua\",70)\n    val goddess = new Goddess(g1, g2)\n    val res = goddess.choose()\n    println(res)\n  }\n}\n```\n\n* 泛型\n\n  [B <: A]  UpperBound 上界： B类型的上界是A类型，即B类型的父类是A类型\n\n  [B >: A] LowerBound 下界： B类型的下界是A类型，即B类型的子类是A类型\n\n  [B <% A]  ViewBound 表示B类型要转换成A类型，需要一个隐式转换函数\n\n  [B : A]  ContextBound 需要一个隐式转换的值\n\n[-A, +B]\n\n​\t[-A]  逆变，作为参数类型。如果A是T的子类，那C[T]是C[A]的子类\n\n​\t[+B ]协变，作为返回类型。如果B是T的子类，那么C[B]是C[T]的子类\n\n```scala\n/*\n上界 UpperBound\n */\nclass UpperBoundDemo[T <: Comparable[T]] {\n  def select(first: T, second: T) = {\n    if (first.compareTo(second) > 0)\n      first\n    else\n      second\n  }\n}\n\nobject UpperBoundDemo {\n  def main(args: Array[String]): Unit = {\n    val u = new UpperBoundDemo[MissRight]\n    val m1 = new MissRight(\"LILI\", 95)\n    val m2 = new MissRight(\"erniu\", 999)\n\n    println(u.select(m1, m2))\n  }\n}\n\nclass MissRight(val name: String, val faceValue: Int) extends Comparable[MissRight] {\n  override def compareTo(o: MissRight): Int = {\n    this.faceValue - o.faceValue\n  }\n\n  override def toString: String = s\"name:$name\"\n}\n```\n\n","slug":"scala——Actor、柯里化与隐式转换","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7l003dcf96nmunr7iz","content":"<ul>\n<li><p>高阶函数：<br>接受一个或多个函数作为输入或输出一个函数的函数称为高阶函数</p>\n<a id=\"more\"></a>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> func : <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = x =&gt; x*x</span><br><span class=\"line\">func: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1046</span>/<span class=\"number\">1620041759</span>@<span class=\"number\">2687725</span>a</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; func(<span class=\"number\">4</span>)</span><br><span class=\"line\">res0: <span class=\"type\">Int</span> = <span class=\"number\">16</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(x =&gt; func(x))<span class=\"comment\">//匿名函数</span></span><br><span class=\"line\">res1: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x :<span class=\"type\">Int</span>) = x*x</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(x =&gt; m1(x))<span class=\"comment\">//方法转换为函数</span></span><br><span class=\"line\">res2: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(m1)</span><br><span class=\"line\">res3: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(func)</span><br><span class=\"line\">res4: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>柯里化：</p>\n<p>将接受多个参数的函数转变为接受一个参数的函数的过程</p>\n<p>柯里化方法会在上下文中找最的隐式的值，作为柯里化方法的值，如果有多个隐式的值会报错</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; arr.map(func)</span><br><span class=\"line\">res4: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">currying</span></span>(x: <span class=\"type\">Int</span>)(y: <span class=\"type\">Int</span>) = x * y</span><br><span class=\"line\">currying: (x: <span class=\"type\">Int</span>)(y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; currying(<span class=\"number\">3</span>)(<span class=\"number\">4</span>)</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> curry = currying(<span class=\"number\">3</span>) _<span class=\"comment\">//柯里化方法第一种用法</span></span><br><span class=\"line\">curry: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1187</span>/<span class=\"number\">1535571147</span>@<span class=\"number\">468646</span>ea</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; curry(<span class=\"number\">4</span>)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>) = x*y</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m1(<span class=\"number\">5</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">res8: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m2</span></span>(x:<span class=\"type\">Int</span>)(<span class=\"keyword\">implicit</span> y :<span class=\"type\">Int</span> = <span class=\"number\">5</span>) = x * y<span class=\"comment\">//柯里化的第2种用法，指定默认值，调用是不指定参数就使用默认值</span></span><br><span class=\"line\">m2: (x: <span class=\"type\">Int</span>)(<span class=\"keyword\">implicit</span> y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">4</span>)</span><br><span class=\"line\">res9: <span class=\"type\">Int</span> = <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">4</span>)(<span class=\"number\">6</span>)</span><br><span class=\"line\">res11: <span class=\"type\">Int</span> = <span class=\"number\">24</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> x = <span class=\"number\">100</span><span class=\"comment\">//设置一个隐式的量</span></span><br><span class=\"line\">x: <span class=\"type\">Int</span> = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">4</span>)</span><br><span class=\"line\">res12: <span class=\"type\">Int</span> = <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> y = <span class=\"number\">200</span><span class=\"comment\">//设置第二个隐式的量</span></span><br><span class=\"line\">y: <span class=\"type\">Int</span> = <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">5</span>)<span class=\"comment\">//此时会发生错误，因为有两个隐式量</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">15</span>: error: ambiguous <span class=\"keyword\">implicit</span> values:</span><br><span class=\"line\"> both value x of <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Int</span></span></span><br><span class=\"line\"><span class=\"class\"> <span class=\"title\">and</span> <span class=\"title\">value</span> <span class=\"title\">y</span> <span class=\"title\">of</span> <span class=\"title\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Int</span></span></span><br><span class=\"line\"><span class=\"class\"> <span class=\"title\">match</span> <span class=\"title\">expected</span> <span class=\"title\">type</span> <span class=\"title\">Int</span></span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"title\">m2</span>(<span class=\"params\">5</span>)</span></span><br><span class=\"line\"><span class=\"class\">         <span class=\"title\">^</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">scala&gt;</span> <span class=\"title\">val</span> <span class=\"title\">arr</span> </span>= <span class=\"type\">Array</span>((<span class=\"string\">\"scala\"</span>,<span class=\"number\">1</span>),(<span class=\"string\">\"scala\"</span>,<span class=\"number\">2</span>),(<span class=\"string\">\"scala\"</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((scala,<span class=\"number\">1</span>), (scala,<span class=\"number\">2</span>), (scala,<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.foldLeft(<span class=\"number\">0</span>)(_ + _._2)</span><br><span class=\"line\">res14: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curry</span></span>(x:<span class=\"type\">Int</span>) = (y:<span class=\"type\">Int</span>) =&gt; x * y</span><br><span class=\"line\">curry: (x: <span class=\"type\">Int</span>)<span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> func = curry(<span class=\"number\">2</span>)<span class=\"comment\">//柯里化方法第3中用法</span></span><br><span class=\"line\">func: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1058</span>/<span class=\"number\">191351920</span>@<span class=\"number\">45</span>c9b3</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; func(<span class=\"number\">3</span>)</span><br><span class=\"line\">res0: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Content</span> </span>&#123;<span class=\"comment\">//这个静态块只有放在Currying上面才能用a或b替代默认值，因为scala是顺序编译执行的</span></span><br><span class=\"line\">  <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> a = <span class=\"string\">\"java\"</span></span><br><span class=\"line\">  <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> b = <span class=\"string\">\"python\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">CurryingDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(str: <span class=\"type\">String</span>)(<span class=\"keyword\">implicit</span> name : <span class=\"type\">String</span> = <span class=\"string\">\"scala\"</span>) = &#123;</span><br><span class=\"line\">    println(str + name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    m1(<span class=\"string\">\"Hi~\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>隐式转换与隐式参数</p>\n<ol>\n<li>作用：能够丰富现有类库的功能，对类的方法进行增强</li>\n<li>隐式转换函数：以implicit关键字声明带有单个参数的函数</li>\n<li>隐式转换用到了装饰模式和门面模式</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ImplicitContext</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">implicit</span> <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">OrderingGirl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Ordering</span>[<span class=\"type\">Girl</span>]</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare</span></span>(x: <span class=\"type\">Girl</span>, y: <span class=\"type\">Girl</span>): <span class=\"type\">Int</span> = <span class=\"keyword\">if</span> (x.faveValue &gt; y.faveValue) <span class=\"number\">1</span> <span class=\"keyword\">else</span>  <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Girl</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, var faveValue: <span class=\"type\">Int</span></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span></span>: <span class=\"type\">String</span> = <span class=\"string\">s\"name:<span class=\"subst\">$name</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goddess</span>[<span class=\"type\">T</span>: <span class=\"type\">Ordering</span>](<span class=\"params\">val v1 :<span class=\"type\">T</span>, val v2: <span class=\"type\">T</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">choose</span></span>()(<span class=\"keyword\">implicit</span> ord :<span class=\"type\">Ordering</span>[<span class=\"type\">T</span>]) =<span class=\"keyword\">if</span> (ord.gt(v1,v2)) v1 <span class=\"keyword\">else</span> v2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Goddess</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> <span class=\"type\">ImplicitContext</span>.<span class=\"type\">OrderingGirl</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> g1 = <span class=\"keyword\">new</span> <span class=\"type\">Girl</span>(<span class=\"string\">\"lili\"</span>,<span class=\"number\">90</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> g2 = <span class=\"keyword\">new</span> <span class=\"type\">Girl</span>(<span class=\"string\">\"huahua\"</span>,<span class=\"number\">70</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> goddess = <span class=\"keyword\">new</span> <span class=\"type\">Goddess</span>(g1, g2)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = goddess.choose()</span><br><span class=\"line\">    println(res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>泛型</p>\n<p>[B &lt;: A]  UpperBound 上界： B类型的上界是A类型，即B类型的父类是A类型</p>\n<p>[B &gt;: A] LowerBound 下界： B类型的下界是A类型，即B类型的子类是A类型</p>\n<p>[B &lt;% A]  ViewBound 表示B类型要转换成A类型，需要一个隐式转换函数</p>\n<p>[B : A]  ContextBound 需要一个隐式转换的值</p>\n</li>\n</ul>\n<p>[-A, +B]</p>\n<p>​    [-A]  逆变，作为参数类型。如果A是T的子类，那C[T]是C[A]的子类</p>\n<p>​    [+B ]协变，作为返回类型。如果B是T的子类，那么C[B]是C[T]的子类</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">上界 UpperBound</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperBoundDemo</span>[<span class=\"type\">T</span> &lt;: <span class=\"type\">Comparable</span>[<span class=\"type\">T</span>]] </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select</span></span>(first: <span class=\"type\">T</span>, second: <span class=\"type\">T</span>) = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first.compareTo(second) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">      first</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      second</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">UpperBoundDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> u = <span class=\"keyword\">new</span> <span class=\"type\">UpperBoundDemo</span>[<span class=\"type\">MissRight</span>]</span><br><span class=\"line\">    <span class=\"keyword\">val</span> m1 = <span class=\"keyword\">new</span> <span class=\"type\">MissRight</span>(<span class=\"string\">\"LILI\"</span>, <span class=\"number\">95</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> m2 = <span class=\"keyword\">new</span> <span class=\"type\">MissRight</span>(<span class=\"string\">\"erniu\"</span>, <span class=\"number\">999</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    println(u.select(m1, m2))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MissRight</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val faceValue: <span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>[<span class=\"type\">MissRight</span>] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compareTo</span></span>(o: <span class=\"type\">MissRight</span>): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.faceValue - o.faceValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span></span>: <span class=\"type\">String</span> = <span class=\"string\">s\"name:<span class=\"subst\">$name</span>\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>高阶函数：<br>接受一个或多个函数作为输入或输出一个函数的函数称为高阶函数</p>","more":"<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> func : <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = x =&gt; x*x</span><br><span class=\"line\">func: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1046</span>/<span class=\"number\">1620041759</span>@<span class=\"number\">2687725</span>a</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; func(<span class=\"number\">4</span>)</span><br><span class=\"line\">res0: <span class=\"type\">Int</span> = <span class=\"number\">16</span></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(x =&gt; func(x))<span class=\"comment\">//匿名函数</span></span><br><span class=\"line\">res1: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x :<span class=\"type\">Int</span>) = x*x</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(x =&gt; m1(x))<span class=\"comment\">//方法转换为函数</span></span><br><span class=\"line\">res2: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(m1)</span><br><span class=\"line\">res3: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.map(func)</span><br><span class=\"line\">res4: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>柯里化：</p>\n<p>将接受多个参数的函数转变为接受一个参数的函数的过程</p>\n<p>柯里化方法会在上下文中找最的隐式的值，作为柯里化方法的值，如果有多个隐式的值会报错</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; arr.map(func)</span><br><span class=\"line\">res4: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">currying</span></span>(x: <span class=\"type\">Int</span>)(y: <span class=\"type\">Int</span>) = x * y</span><br><span class=\"line\">currying: (x: <span class=\"type\">Int</span>)(y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; currying(<span class=\"number\">3</span>)(<span class=\"number\">4</span>)</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> curry = currying(<span class=\"number\">3</span>) _<span class=\"comment\">//柯里化方法第一种用法</span></span><br><span class=\"line\">curry: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1187</span>/<span class=\"number\">1535571147</span>@<span class=\"number\">468646</span>ea</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; curry(<span class=\"number\">4</span>)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>) = x*y</span><br><span class=\"line\">m1: (x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m1(<span class=\"number\">5</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">res8: <span class=\"type\">Int</span> = <span class=\"number\">50</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m2</span></span>(x:<span class=\"type\">Int</span>)(<span class=\"keyword\">implicit</span> y :<span class=\"type\">Int</span> = <span class=\"number\">5</span>) = x * y<span class=\"comment\">//柯里化的第2种用法，指定默认值，调用是不指定参数就使用默认值</span></span><br><span class=\"line\">m2: (x: <span class=\"type\">Int</span>)(<span class=\"keyword\">implicit</span> y: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">4</span>)</span><br><span class=\"line\">res9: <span class=\"type\">Int</span> = <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">4</span>)(<span class=\"number\">6</span>)</span><br><span class=\"line\">res11: <span class=\"type\">Int</span> = <span class=\"number\">24</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> x = <span class=\"number\">100</span><span class=\"comment\">//设置一个隐式的量</span></span><br><span class=\"line\">x: <span class=\"type\">Int</span> = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">4</span>)</span><br><span class=\"line\">res12: <span class=\"type\">Int</span> = <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> y = <span class=\"number\">200</span><span class=\"comment\">//设置第二个隐式的量</span></span><br><span class=\"line\">y: <span class=\"type\">Int</span> = <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m2(<span class=\"number\">5</span>)<span class=\"comment\">//此时会发生错误，因为有两个隐式量</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">15</span>: error: ambiguous <span class=\"keyword\">implicit</span> values:</span><br><span class=\"line\"> both value x of <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Int</span></span></span><br><span class=\"line\"><span class=\"class\"> <span class=\"title\">and</span> <span class=\"title\">value</span> <span class=\"title\">y</span> <span class=\"title\">of</span> <span class=\"title\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Int</span></span></span><br><span class=\"line\"><span class=\"class\"> <span class=\"title\">match</span> <span class=\"title\">expected</span> <span class=\"title\">type</span> <span class=\"title\">Int</span></span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"title\">m2</span>(<span class=\"params\">5</span>)</span></span><br><span class=\"line\"><span class=\"class\">         <span class=\"title\">^</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">scala&gt;</span> <span class=\"title\">val</span> <span class=\"title\">arr</span> </span>= <span class=\"type\">Array</span>((<span class=\"string\">\"scala\"</span>,<span class=\"number\">1</span>),(<span class=\"string\">\"scala\"</span>,<span class=\"number\">2</span>),(<span class=\"string\">\"scala\"</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((scala,<span class=\"number\">1</span>), (scala,<span class=\"number\">2</span>), (scala,<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr.foldLeft(<span class=\"number\">0</span>)(_ + _._2)</span><br><span class=\"line\">res14: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curry</span></span>(x:<span class=\"type\">Int</span>) = (y:<span class=\"type\">Int</span>) =&gt; x * y</span><br><span class=\"line\">curry: (x: <span class=\"type\">Int</span>)<span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> func = curry(<span class=\"number\">2</span>)<span class=\"comment\">//柯里化方法第3中用法</span></span><br><span class=\"line\">func: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">1058</span>/<span class=\"number\">191351920</span>@<span class=\"number\">45</span>c9b3</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; func(<span class=\"number\">3</span>)</span><br><span class=\"line\">res0: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Content</span> </span>&#123;<span class=\"comment\">//这个静态块只有放在Currying上面才能用a或b替代默认值，因为scala是顺序编译执行的</span></span><br><span class=\"line\">  <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> a = <span class=\"string\">\"java\"</span></span><br><span class=\"line\">  <span class=\"keyword\">implicit</span> <span class=\"keyword\">val</span> b = <span class=\"string\">\"python\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">CurryingDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m1</span></span>(str: <span class=\"type\">String</span>)(<span class=\"keyword\">implicit</span> name : <span class=\"type\">String</span> = <span class=\"string\">\"scala\"</span>) = &#123;</span><br><span class=\"line\">    println(str + name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    m1(<span class=\"string\">\"Hi~\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>隐式转换与隐式参数</p>\n<ol>\n<li>作用：能够丰富现有类库的功能，对类的方法进行增强</li>\n<li>隐式转换函数：以implicit关键字声明带有单个参数的函数</li>\n<li>隐式转换用到了装饰模式和门面模式</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ImplicitContext</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">implicit</span> <span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">OrderingGirl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Ordering</span>[<span class=\"type\">Girl</span>]</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare</span></span>(x: <span class=\"type\">Girl</span>, y: <span class=\"type\">Girl</span>): <span class=\"type\">Int</span> = <span class=\"keyword\">if</span> (x.faveValue &gt; y.faveValue) <span class=\"number\">1</span> <span class=\"keyword\">else</span>  <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Girl</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, var faveValue: <span class=\"type\">Int</span></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span></span>: <span class=\"type\">String</span> = <span class=\"string\">s\"name:<span class=\"subst\">$name</span>\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goddess</span>[<span class=\"type\">T</span>: <span class=\"type\">Ordering</span>](<span class=\"params\">val v1 :<span class=\"type\">T</span>, val v2: <span class=\"type\">T</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">choose</span></span>()(<span class=\"keyword\">implicit</span> ord :<span class=\"type\">Ordering</span>[<span class=\"type\">T</span>]) =<span class=\"keyword\">if</span> (ord.gt(v1,v2)) v1 <span class=\"keyword\">else</span> v2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Goddess</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> <span class=\"type\">ImplicitContext</span>.<span class=\"type\">OrderingGirl</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> g1 = <span class=\"keyword\">new</span> <span class=\"type\">Girl</span>(<span class=\"string\">\"lili\"</span>,<span class=\"number\">90</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> g2 = <span class=\"keyword\">new</span> <span class=\"type\">Girl</span>(<span class=\"string\">\"huahua\"</span>,<span class=\"number\">70</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> goddess = <span class=\"keyword\">new</span> <span class=\"type\">Goddess</span>(g1, g2)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = goddess.choose()</span><br><span class=\"line\">    println(res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>泛型</p>\n<p>[B &lt;: A]  UpperBound 上界： B类型的上界是A类型，即B类型的父类是A类型</p>\n<p>[B &gt;: A] LowerBound 下界： B类型的下界是A类型，即B类型的子类是A类型</p>\n<p>[B &lt;% A]  ViewBound 表示B类型要转换成A类型，需要一个隐式转换函数</p>\n<p>[B : A]  ContextBound 需要一个隐式转换的值</p>\n</li>\n</ul>\n<p>[-A, +B]</p>\n<p>​    [-A]  逆变，作为参数类型。如果A是T的子类，那C[T]是C[A]的子类</p>\n<p>​    [+B ]协变，作为返回类型。如果B是T的子类，那么C[B]是C[T]的子类</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">上界 UpperBound</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperBoundDemo</span>[<span class=\"type\">T</span> &lt;: <span class=\"type\">Comparable</span>[<span class=\"type\">T</span>]] </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select</span></span>(first: <span class=\"type\">T</span>, second: <span class=\"type\">T</span>) = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first.compareTo(second) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">      first</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      second</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">UpperBoundDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> u = <span class=\"keyword\">new</span> <span class=\"type\">UpperBoundDemo</span>[<span class=\"type\">MissRight</span>]</span><br><span class=\"line\">    <span class=\"keyword\">val</span> m1 = <span class=\"keyword\">new</span> <span class=\"type\">MissRight</span>(<span class=\"string\">\"LILI\"</span>, <span class=\"number\">95</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> m2 = <span class=\"keyword\">new</span> <span class=\"type\">MissRight</span>(<span class=\"string\">\"erniu\"</span>, <span class=\"number\">999</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    println(u.select(m1, m2))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MissRight</span>(<span class=\"params\">val name: <span class=\"type\">String</span>, val faceValue: <span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>[<span class=\"type\">MissRight</span>] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compareTo</span></span>(o: <span class=\"type\">MissRight</span>): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.faceValue - o.faceValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toString</span></span>: <span class=\"type\">String</span> = <span class=\"string\">s\"name:<span class=\"subst\">$name</span>\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Scala常用方法","date":"2018-04-25T12:48:43.000Z","_content":"\n* lazy关键字\n\n  lazy一般在变量前边作为修饰字符，表示该变量是一个**惰性变量**（想想spark里面的转换操作），会实现**延迟加载**，惰性变量只能是*不可变变量*， 只有在调用惰性变量时才会实例化该变量。\n\n<!-- more-->\n\n  未使用lazy：\n\n  ```scala\n  object ScalaLazyDemo {\n    def init(): Unit = {\n      println(\"call init()\")\n    }\n    def main(args: Array[String]): Unit = {\n      val property = init()//未使用lazy关键字\n      println(\"after init\")\n      println(property)\n    }\n  }\n\n  output：\n  call init()\n  after init\n  ()\n  ```\n\n  使用lazy：\n\n  ```scala\n  object ScalaLazyDemo2 {\n    def init(): Unit = {\n      println(\"call init()\")\n    }\n    def main(args: Array[String]): Unit = {\n      lazy val property = init()//使用lazy关键字\n      println(\"after init\")//先执行这一句\n      println(property)//到这里才执行init（）\n    }\n  }\n  output：\n  after init\n  call init()\n  ()\n  ```\n\n* 函数式编程连续\n\n  ```scala\n  object Exercise {\n    def main(args: Array[String]): Unit = {\n      //创建一个list\n      val list0 = List(5, 9, 5, 152, 85, 41)\n      //list中的每个元素乘2\n      val list1 = list0.map(_ * 2)\n      //将list中的偶数取出来生成一个新集合\n      val list2 = list0.filter(_ % 2 == 0)\n      //将list排序\n      val list3 = list0.sorted\n      //反转list\n      val listt4 = list0.reverse\n      //将list中的元素4个一组，类型为Iterator[List[Int]]\n      val it = list0.grouped(4)\n      //将iterator转为list\n      val list5 = it.toList\n      //输出为：List(List(5, 9, 5, 152), List(85, 41))\n      //将多个list压扁\n      val list6 = list5.flatten\n\n      val lines = List(\"hello dd sdjjs sj wehjh\", \"hello ddd ws\", \"sawdxgyua hello jjs\")\n      //先按照空格切分，再压平\n      //    val words = lines.map(_.split(\" \"))\n      //    val flatten_words = words.flatten 比较费事，可以用flatMap\n      val word = lines.flatMap(_.split(\" \"))\n\n      /*\n     tips：系统中有多个任务同时存在可称之为“并发”，系统内有多个任务同时执行可称之为“并行”；\n           并发是并行的子集。比如在单核CPU系统上，只可能存在并发而不可能存在并行。\n      */\n      //并行计算求和\n      val arr = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n      //val res = arr.sum\n      //和线程有关，每个线程计算一部分，（1，+2+3+4）+ （5+6+7+8）+（9+10）//\n      val res = arr.par.sum //par方法实现并行计算\n\n      //按照特定顺序进行聚合 res2 和 res3\n      //    （（（（1 + 2）+ 3） + 4） + 5）   ...\n      val res2 = arr.reduce(_ + _)\n      val res3 = arr.reduceLeft(_ + _)\n      val res4 = arr.par.reduce(_ + _) //没有顺序\n\n      //折叠：有初始值（无特定顺序）\n      val res5 = arr.par.fold(10)(_ + _) //有初始值时，在每个线程中都会加一次初始值，但是调用有顺序的fold就只计算一次初始值，比如foldLeft\n\n      //折叠：有初始值（有特定顺序）\n      val res6 = arr.foldLeft(10)(_ + _) //有初始值时，在每个线程中都会加一次初始值\n\n      //聚合\n      val list7 = List(List(1, 2, 3), List(3, 4, 5), List(2), List(0))\n      //val res7 = list7.flatten.reduce(_+_)\n      val res8 = list7.aggregate(0)(_ + _.sum, _ + _)\n\n      val l1 = List(1, 2, 3, 4)\n      val l2 = List(2, 3, 4, 5)\n\n      //并集\n      val res9 = l1 union l2 //不会去重\n\n      //交集\n      val res10 = l1 intersect l2\n\n      //差集\n      val res11 = l1 diff l2\n    }\n  }\n\n  ```\n\n  ​\n","source":"_posts/Scala常用方法.md","raw":"---\ntitle: Scala常用方法\ndate: 2018-04-25 20:48:43\ntags: scala\n---\n\n* lazy关键字\n\n  lazy一般在变量前边作为修饰字符，表示该变量是一个**惰性变量**（想想spark里面的转换操作），会实现**延迟加载**，惰性变量只能是*不可变变量*， 只有在调用惰性变量时才会实例化该变量。\n\n<!-- more-->\n\n  未使用lazy：\n\n  ```scala\n  object ScalaLazyDemo {\n    def init(): Unit = {\n      println(\"call init()\")\n    }\n    def main(args: Array[String]): Unit = {\n      val property = init()//未使用lazy关键字\n      println(\"after init\")\n      println(property)\n    }\n  }\n\n  output：\n  call init()\n  after init\n  ()\n  ```\n\n  使用lazy：\n\n  ```scala\n  object ScalaLazyDemo2 {\n    def init(): Unit = {\n      println(\"call init()\")\n    }\n    def main(args: Array[String]): Unit = {\n      lazy val property = init()//使用lazy关键字\n      println(\"after init\")//先执行这一句\n      println(property)//到这里才执行init（）\n    }\n  }\n  output：\n  after init\n  call init()\n  ()\n  ```\n\n* 函数式编程连续\n\n  ```scala\n  object Exercise {\n    def main(args: Array[String]): Unit = {\n      //创建一个list\n      val list0 = List(5, 9, 5, 152, 85, 41)\n      //list中的每个元素乘2\n      val list1 = list0.map(_ * 2)\n      //将list中的偶数取出来生成一个新集合\n      val list2 = list0.filter(_ % 2 == 0)\n      //将list排序\n      val list3 = list0.sorted\n      //反转list\n      val listt4 = list0.reverse\n      //将list中的元素4个一组，类型为Iterator[List[Int]]\n      val it = list0.grouped(4)\n      //将iterator转为list\n      val list5 = it.toList\n      //输出为：List(List(5, 9, 5, 152), List(85, 41))\n      //将多个list压扁\n      val list6 = list5.flatten\n\n      val lines = List(\"hello dd sdjjs sj wehjh\", \"hello ddd ws\", \"sawdxgyua hello jjs\")\n      //先按照空格切分，再压平\n      //    val words = lines.map(_.split(\" \"))\n      //    val flatten_words = words.flatten 比较费事，可以用flatMap\n      val word = lines.flatMap(_.split(\" \"))\n\n      /*\n     tips：系统中有多个任务同时存在可称之为“并发”，系统内有多个任务同时执行可称之为“并行”；\n           并发是并行的子集。比如在单核CPU系统上，只可能存在并发而不可能存在并行。\n      */\n      //并行计算求和\n      val arr = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n      //val res = arr.sum\n      //和线程有关，每个线程计算一部分，（1，+2+3+4）+ （5+6+7+8）+（9+10）//\n      val res = arr.par.sum //par方法实现并行计算\n\n      //按照特定顺序进行聚合 res2 和 res3\n      //    （（（（1 + 2）+ 3） + 4） + 5）   ...\n      val res2 = arr.reduce(_ + _)\n      val res3 = arr.reduceLeft(_ + _)\n      val res4 = arr.par.reduce(_ + _) //没有顺序\n\n      //折叠：有初始值（无特定顺序）\n      val res5 = arr.par.fold(10)(_ + _) //有初始值时，在每个线程中都会加一次初始值，但是调用有顺序的fold就只计算一次初始值，比如foldLeft\n\n      //折叠：有初始值（有特定顺序）\n      val res6 = arr.foldLeft(10)(_ + _) //有初始值时，在每个线程中都会加一次初始值\n\n      //聚合\n      val list7 = List(List(1, 2, 3), List(3, 4, 5), List(2), List(0))\n      //val res7 = list7.flatten.reduce(_+_)\n      val res8 = list7.aggregate(0)(_ + _.sum, _ + _)\n\n      val l1 = List(1, 2, 3, 4)\n      val l2 = List(2, 3, 4, 5)\n\n      //并集\n      val res9 = l1 union l2 //不会去重\n\n      //交集\n      val res10 = l1 intersect l2\n\n      //差集\n      val res11 = l1 diff l2\n    }\n  }\n\n  ```\n\n  ​\n","slug":"Scala常用方法","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7m003fcf96fz23gwzg","content":"<ul>\n<li><p>lazy关键字</p>\n<p>lazy一般在变量前边作为修饰字符，表示该变量是一个<strong>惰性变量</strong>（想想spark里面的转换操作），会实现<strong>延迟加载</strong>，惰性变量只能是<em>不可变变量</em>， 只有在调用惰性变量时才会实例化该变量。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>  未使用lazy：</p>\n  <figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ScalaLazyDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span></span>(): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"call init()\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> property = init()<span class=\"comment\">//未使用lazy关键字</span></span><br><span class=\"line\">    println(<span class=\"string\">\"after init\"</span>)</span><br><span class=\"line\">    println(property)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output：</span><br><span class=\"line\">call init()</span><br><span class=\"line\">after init</span><br><span class=\"line\">()</span><br></pre></td></tr></table></figure>\n<p>  使用lazy：</p>\n  <figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ScalaLazyDemo2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span></span>(): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"call init()\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">val</span> property = init()<span class=\"comment\">//使用lazy关键字</span></span><br><span class=\"line\">    println(<span class=\"string\">\"after init\"</span>)<span class=\"comment\">//先执行这一句</span></span><br><span class=\"line\">    println(property)<span class=\"comment\">//到这里才执行init（）</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output：</span><br><span class=\"line\">after init</span><br><span class=\"line\">call init()</span><br><span class=\"line\">()</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>函数式编程连续</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Exercise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个list</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list0 = <span class=\"type\">List</span>(<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">152</span>, <span class=\"number\">85</span>, <span class=\"number\">41</span>)</span><br><span class=\"line\">    <span class=\"comment\">//list中的每个元素乘2</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list1 = list0.map(_ * <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将list中的偶数取出来生成一个新集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list2 = list0.filter(_ % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将list排序</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list3 = list0.sorted</span><br><span class=\"line\">    <span class=\"comment\">//反转list</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> listt4 = list0.reverse</span><br><span class=\"line\">    <span class=\"comment\">//将list中的元素4个一组，类型为Iterator[List[Int]]</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> it = list0.grouped(<span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将iterator转为list</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list5 = it.toList</span><br><span class=\"line\">    <span class=\"comment\">//输出为：List(List(5, 9, 5, 152), List(85, 41))</span></span><br><span class=\"line\">    <span class=\"comment\">//将多个list压扁</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list6 = list5.flatten</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> lines = <span class=\"type\">List</span>(<span class=\"string\">\"hello dd sdjjs sj wehjh\"</span>, <span class=\"string\">\"hello ddd ws\"</span>, <span class=\"string\">\"sawdxgyua hello jjs\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//先按照空格切分，再压平</span></span><br><span class=\"line\">    <span class=\"comment\">//    val words = lines.map(_.split(\" \"))</span></span><br><span class=\"line\">    <span class=\"comment\">//    val flatten_words = words.flatten 比较费事，可以用flatMap</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> word = lines.flatMap(_.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   tips：系统中有多个任务同时存在可称之为“并发”，系统内有多个任务同时执行可称之为“并行”；</span></span><br><span class=\"line\"><span class=\"comment\">         并发是并行的子集。比如在单核CPU系统上，只可能存在并发而不可能存在并行。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">//并行计算求和</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"comment\">//val res = arr.sum</span></span><br><span class=\"line\">    <span class=\"comment\">//和线程有关，每个线程计算一部分，（1，+2+3+4）+ （5+6+7+8）+（9+10）//</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = arr.par.sum <span class=\"comment\">//par方法实现并行计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//按照特定顺序进行聚合 res2 和 res3</span></span><br><span class=\"line\">    <span class=\"comment\">//    （（（（1 + 2）+ 3） + 4） + 5）   ...</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res2 = arr.reduce(_ + _)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res3 = arr.reduceLeft(_ + _)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res4 = arr.par.reduce(_ + _) <span class=\"comment\">//没有顺序</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//折叠：有初始值（无特定顺序）</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res5 = arr.par.fold(<span class=\"number\">10</span>)(_ + _) <span class=\"comment\">//有初始值时，在每个线程中都会加一次初始值，但是调用有顺序的fold就只计算一次初始值，比如foldLeft</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//折叠：有初始值（有特定顺序）</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res6 = arr.foldLeft(<span class=\"number\">10</span>)(_ + _) <span class=\"comment\">//有初始值时，在每个线程中都会加一次初始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//聚合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list7 = <span class=\"type\">List</span>(<span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), <span class=\"type\">List</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>), <span class=\"type\">List</span>(<span class=\"number\">2</span>), <span class=\"type\">List</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"comment\">//val res7 = list7.flatten.reduce(_+_)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res8 = list7.aggregate(<span class=\"number\">0</span>)(_ + _.sum, _ + _)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> l1 = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> l2 = <span class=\"type\">List</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//并集</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res9 = l1 union l2 <span class=\"comment\">//不会去重</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//交集</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res10 = l1 intersect l2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//差集</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res11 = l1 diff l2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>lazy关键字</p>\n<p>lazy一般在变量前边作为修饰字符，表示该变量是一个<strong>惰性变量</strong>（想想spark里面的转换操作），会实现<strong>延迟加载</strong>，惰性变量只能是<em>不可变变量</em>， 只有在调用惰性变量时才会实例化该变量。</p>\n</li>\n</ul>","more":"<p>  未使用lazy：</p>\n  <figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ScalaLazyDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span></span>(): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"call init()\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> property = init()<span class=\"comment\">//未使用lazy关键字</span></span><br><span class=\"line\">    println(<span class=\"string\">\"after init\"</span>)</span><br><span class=\"line\">    println(property)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output：</span><br><span class=\"line\">call init()</span><br><span class=\"line\">after init</span><br><span class=\"line\">()</span><br></pre></td></tr></table></figure>\n<p>  使用lazy：</p>\n  <figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">ScalaLazyDemo2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span></span>(): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"call init()\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">val</span> property = init()<span class=\"comment\">//使用lazy关键字</span></span><br><span class=\"line\">    println(<span class=\"string\">\"after init\"</span>)<span class=\"comment\">//先执行这一句</span></span><br><span class=\"line\">    println(property)<span class=\"comment\">//到这里才执行init（）</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output：</span><br><span class=\"line\">after init</span><br><span class=\"line\">call init()</span><br><span class=\"line\">()</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>函数式编程连续</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Exercise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个list</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list0 = <span class=\"type\">List</span>(<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">152</span>, <span class=\"number\">85</span>, <span class=\"number\">41</span>)</span><br><span class=\"line\">    <span class=\"comment\">//list中的每个元素乘2</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list1 = list0.map(_ * <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将list中的偶数取出来生成一个新集合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list2 = list0.filter(_ % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将list排序</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list3 = list0.sorted</span><br><span class=\"line\">    <span class=\"comment\">//反转list</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> listt4 = list0.reverse</span><br><span class=\"line\">    <span class=\"comment\">//将list中的元素4个一组，类型为Iterator[List[Int]]</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> it = list0.grouped(<span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将iterator转为list</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list5 = it.toList</span><br><span class=\"line\">    <span class=\"comment\">//输出为：List(List(5, 9, 5, 152), List(85, 41))</span></span><br><span class=\"line\">    <span class=\"comment\">//将多个list压扁</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list6 = list5.flatten</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> lines = <span class=\"type\">List</span>(<span class=\"string\">\"hello dd sdjjs sj wehjh\"</span>, <span class=\"string\">\"hello ddd ws\"</span>, <span class=\"string\">\"sawdxgyua hello jjs\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//先按照空格切分，再压平</span></span><br><span class=\"line\">    <span class=\"comment\">//    val words = lines.map(_.split(\" \"))</span></span><br><span class=\"line\">    <span class=\"comment\">//    val flatten_words = words.flatten 比较费事，可以用flatMap</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> word = lines.flatMap(_.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   tips：系统中有多个任务同时存在可称之为“并发”，系统内有多个任务同时执行可称之为“并行”；</span></span><br><span class=\"line\"><span class=\"comment\">         并发是并行的子集。比如在单核CPU系统上，只可能存在并发而不可能存在并行。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">//并行计算求和</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"comment\">//val res = arr.sum</span></span><br><span class=\"line\">    <span class=\"comment\">//和线程有关，每个线程计算一部分，（1，+2+3+4）+ （5+6+7+8）+（9+10）//</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = arr.par.sum <span class=\"comment\">//par方法实现并行计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//按照特定顺序进行聚合 res2 和 res3</span></span><br><span class=\"line\">    <span class=\"comment\">//    （（（（1 + 2）+ 3） + 4） + 5）   ...</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res2 = arr.reduce(_ + _)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res3 = arr.reduceLeft(_ + _)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res4 = arr.par.reduce(_ + _) <span class=\"comment\">//没有顺序</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//折叠：有初始值（无特定顺序）</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res5 = arr.par.fold(<span class=\"number\">10</span>)(_ + _) <span class=\"comment\">//有初始值时，在每个线程中都会加一次初始值，但是调用有顺序的fold就只计算一次初始值，比如foldLeft</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//折叠：有初始值（有特定顺序）</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res6 = arr.foldLeft(<span class=\"number\">10</span>)(_ + _) <span class=\"comment\">//有初始值时，在每个线程中都会加一次初始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//聚合</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> list7 = <span class=\"type\">List</span>(<span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), <span class=\"type\">List</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>), <span class=\"type\">List</span>(<span class=\"number\">2</span>), <span class=\"type\">List</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"comment\">//val res7 = list7.flatten.reduce(_+_)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res8 = list7.aggregate(<span class=\"number\">0</span>)(_ + _.sum, _ + _)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> l1 = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> l2 = <span class=\"type\">List</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//并集</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res9 = l1 union l2 <span class=\"comment\">//不会去重</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//交集</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res10 = l1 intersect l2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//差集</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> res11 = l1 diff l2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>"},{"title":"hexo系列问题之我们换了电脑怎么办","date":"2018-06-03T16:14:00.000Z","_content":"\n问题\n我们如果换了电脑怎么办？我们把hexo文件从一个电脑cope到另外一个电脑吗?答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理\n\n解决方案\n我们初步的解决方案是把我们的文件提交到git上，利用git来管理它，我是这样解决的： 在现有的XXX.github.io项目上创建一个分支来管理 \n<!-- more--> \n1. 克隆gitHub上的XXX.github.io项目的文件到本地 \n\ngit clone https://github.com/yourname/xxx.github.io.git \n\n2. 删除文件夹里除了.git的其他所有文件 \n3. 把hexo项目文件下的所有文件全部复制过来 \n4. 里面应该有一个叫.gitignore的文件，如果没有就输入 touch .gitignore，创建一个 \n5. .gitignore文件里应该是这些内容 \n\n.DS_Store \nThumbs.db \ndb.json \n*.log \nnode_modules/ \npublic/ \n.deploy*/ \n\n6. 创建一个叫hexo的分支并切换到这个分支上 \n\ngit checkout -b hexo \n\n7. 提交复制过来的文件到暂存区 \n\ngit add --all \n\n8. 提交 \n\ngit commit -m \"新建分支资源文件\" \n\n9. 推送分支到github \n\ngit push --set-upstream origin hexo \n\n到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。 \n10. 今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。 \n克隆分支的操作 \ngit clone -b hexo https://github.com/yourname/xxx.github.io.git \n\n11. 因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。 \n12. 这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。\n","source":"_posts/hexo系列问题之我们换了电脑怎么办.md","raw":"---\ntitle: hexo系列问题之我们换了电脑怎么办\ndate: 2018-06-04 00:14:00\ntags: 随笔\n---\n\n问题\n我们如果换了电脑怎么办？我们把hexo文件从一个电脑cope到另外一个电脑吗?答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理\n\n解决方案\n我们初步的解决方案是把我们的文件提交到git上，利用git来管理它，我是这样解决的： 在现有的XXX.github.io项目上创建一个分支来管理 \n<!-- more--> \n1. 克隆gitHub上的XXX.github.io项目的文件到本地 \n\ngit clone https://github.com/yourname/xxx.github.io.git \n\n2. 删除文件夹里除了.git的其他所有文件 \n3. 把hexo项目文件下的所有文件全部复制过来 \n4. 里面应该有一个叫.gitignore的文件，如果没有就输入 touch .gitignore，创建一个 \n5. .gitignore文件里应该是这些内容 \n\n.DS_Store \nThumbs.db \ndb.json \n*.log \nnode_modules/ \npublic/ \n.deploy*/ \n\n6. 创建一个叫hexo的分支并切换到这个分支上 \n\ngit checkout -b hexo \n\n7. 提交复制过来的文件到暂存区 \n\ngit add --all \n\n8. 提交 \n\ngit commit -m \"新建分支资源文件\" \n\n9. 推送分支到github \n\ngit push --set-upstream origin hexo \n\n到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。 \n10. 今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。 \n克隆分支的操作 \ngit clone -b hexo https://github.com/yourname/xxx.github.io.git \n\n11. 因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。 \n12. 这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。\n","slug":"hexo系列问题之我们换了电脑怎么办","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7o003hcf961z86ske6","content":"<p>问题<br>我们如果换了电脑怎么办？我们把hexo文件从一个电脑cope到另外一个电脑吗?答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理</p>\n<p>解决方案<br>我们初步的解决方案是把我们的文件提交到git上，利用git来管理它，我是这样解决的： 在现有的XXX.github.io项目上创建一个分支来管理<br><a id=\"more\"></a> </p>\n<ol>\n<li>克隆gitHub上的XXX.github.io项目的文件到本地 </li>\n</ol>\n<p>git clone <a href=\"https://github.com/yourname/xxx.github.io.git\" target=\"_blank\" rel=\"noopener\">https://github.com/yourname/xxx.github.io.git</a> </p>\n<ol>\n<li>删除文件夹里除了.git的其他所有文件 </li>\n<li>把hexo项目文件下的所有文件全部复制过来 </li>\n<li>里面应该有一个叫.gitignore的文件，如果没有就输入 touch .gitignore，创建一个 </li>\n<li>.gitignore文件里应该是这些内容 </li>\n</ol>\n<p>.DS_Store<br>Thumbs.db<br>db.json<br><em>.log<br>node_modules/<br>public/<br>.deploy</em>/ </p>\n<ol>\n<li>创建一个叫hexo的分支并切换到这个分支上 </li>\n</ol>\n<p>git checkout -b hexo </p>\n<ol>\n<li>提交复制过来的文件到暂存区 </li>\n</ol>\n<p>git add –all </p>\n<ol>\n<li>提交 </li>\n</ol>\n<p>git commit -m “新建分支资源文件” </p>\n<ol>\n<li>推送分支到github </li>\n</ol>\n<p>git push –set-upstream origin hexo </p>\n<p>到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。 </p>\n<ol>\n<li><p>今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。<br>克隆分支的操作<br>git clone -b hexo <a href=\"https://github.com/yourname/xxx.github.io.git\" target=\"_blank\" rel=\"noopener\">https://github.com/yourname/xxx.github.io.git</a> </p>\n</li>\n<li><p>因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。 </p>\n</li>\n<li>这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>问题<br>我们如果换了电脑怎么办？我们把hexo文件从一个电脑cope到另外一个电脑吗?答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理</p>\n<p>解决方案<br>我们初步的解决方案是把我们的文件提交到git上，利用git来管理它，我是这样解决的： 在现有的XXX.github.io项目上创建一个分支来管理<br>","more":"</p>\n<ol>\n<li>克隆gitHub上的XXX.github.io项目的文件到本地 </li>\n</ol>\n<p>git clone <a href=\"https://github.com/yourname/xxx.github.io.git\" target=\"_blank\" rel=\"noopener\">https://github.com/yourname/xxx.github.io.git</a> </p>\n<ol>\n<li>删除文件夹里除了.git的其他所有文件 </li>\n<li>把hexo项目文件下的所有文件全部复制过来 </li>\n<li>里面应该有一个叫.gitignore的文件，如果没有就输入 touch .gitignore，创建一个 </li>\n<li>.gitignore文件里应该是这些内容 </li>\n</ol>\n<p>.DS_Store<br>Thumbs.db<br>db.json<br><em>.log<br>node_modules/<br>public/<br>.deploy</em>/ </p>\n<ol>\n<li>创建一个叫hexo的分支并切换到这个分支上 </li>\n</ol>\n<p>git checkout -b hexo </p>\n<ol>\n<li>提交复制过来的文件到暂存区 </li>\n</ol>\n<p>git add –all </p>\n<ol>\n<li>提交 </li>\n</ol>\n<p>git commit -m “新建分支资源文件” </p>\n<ol>\n<li>推送分支到github </li>\n</ol>\n<p>git push –set-upstream origin hexo </p>\n<p>到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。 </p>\n<ol>\n<li><p>今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。<br>克隆分支的操作<br>git clone -b hexo <a href=\"https://github.com/yourname/xxx.github.io.git\" target=\"_blank\" rel=\"noopener\">https://github.com/yourname/xxx.github.io.git</a> </p>\n</li>\n<li><p>因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。 </p>\n</li>\n<li>这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。</li>\n</ol>"},{"title":"实习笔记----HTTP方法:GET对比POST","date":"2018-05-09T14:52:42.000Z","_content":"## 什么是 HTTP？\n\n超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。\n\nHTTP 的工作方式是客户机与服务器之间的请求-应答协议。\n\nweb 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。\n<!-- more-->\n举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。\n\n## 两种 HTTP 请求方法：GET 和 POST\n\n在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。\n\n- *GET* - 从指定的资源请求数据。\n- *POST* - 向指定的资源提交要被处理的数据\n\n## GET 方法\n\n请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：\n\n```\n/test/demo_form.asp?name1=value1&name2=value2\n```\n\n有关 GET 请求的其他一些注释：\n\n- GET 请求可被缓存\n- GET 请求保留在浏览器历史记录中\n- GET 请求可被收藏为书签\n- GET 请求不应在处理敏感数据时使用\n- GET 请求有长度限制\n- GET 请求只应当用于取回数据\n\n## POST 方法\n\n请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：\n\n```\nPOST /test/demo_form.asp HTTP/1.1\nHost: xxx.com\nname1=value1&name2=value2\n```\n\n有关 POST 请求的其他一些注释：\n\n- POST 请求不会被缓存\n- POST 请求不会保留在浏览器历史记录中\n- POST 不能被收藏为书签\n- POST 请求对数据长度没有要求\n\n## 比较 GET 与 POST\n\n下面的表格比较了两种 HTTP 方法：GET 和 POST。\n\n|                  | GET                                                          | POST                                                         |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |\n| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |\n| 缓存             | 能被缓存                                                     | 不能缓存                                                     |\n| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |\n| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |\n| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |\n| 对数据类型的限制 | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |\n| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |\n| 可见性           | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |\n\n## 其他 HTTP 请求方法\n\n下面的表格列出了其他一些 HTTP 请求方法：\n\n| 方法    | 描述                                              |\n| ------- | ------------------------------------------------- |\n| HEAD    | 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 |\n| PUT     | 上传指定的 URI 表示。                             |\n| DELETE  | 删除指定资源。                                    |\n| OPTIONS | 返回服务器支持的 HTTP 方法。                      |\n| CONNECT | 把请求连接转换到透明的 TCP/IP 通道。              |\n\n## Java HTTP请求方式：\n\n常用的HTTP库有HttpClient和HttpURLConnection，先来看两个例子再比较两种库。\n\n- HttpURLConnection\n\n  HttpURLConnection一般步骤：创建URL对象 ==》 获取URL的HttpURLConnection对象实例==》设置HTTP请求使用的方法==》设置超时和消息头==》对服务器响应码判断==》获得服务器返回的输入流==》关掉HTTP连接\n\n  **GET请求**\n\n```java\n  URL url = new URL(\"xxx\");\n  //调用URL对象的openConnection( )来获取HttpURLConnection对象实例\n  HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n  //请求方法为GET\n  conn.setRequestMethod(\"GET\");\n  //设置连接超时为5秒\n  conn.setConnectTimeout(5000);\n  //服务器返回东西了，先对响应码判断\n  if (conn.getResponseCode() == 200) {\n      //用getInputStream()方法获得服务器返回的输入流\n      InputStream in = conn.getInputStream();\n      byte[] data = read(in); //流转换为二进制数组，read()自己写的是转换方法\n      String html = new String(data, \"UTF-8\");\n      System.out.println(html);\n      in.close();\n  }\n```\n\n  **POST请求**\n\n  POST请求：POST请求大体和GET一致，只是设置相关参数的时候要注意设置允许输入、输出，还有POST方法不能缓存，要手动设置为false.\n\n```java\n  //创建URL对象,xxx是服务器API\n  URL url = new URL(\"xxx\");\n  //调用URL对象的openConnection( )来获取HttpURLConnection对象实例\n  HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n  //请求方法为GET\n  conn.setRequestMethod(\"POST\");\n  //设置连接超时为5秒\n  conn.setConnectTimeout(5000);\n  //允许输入输出\n  conn.setDoInput(true);\n  conn.setDoOutput(true);\n  //不能缓存\n  conn.setUseCaches(false);\n  //至少要设置的两个请求头\n  conn.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded\");\n  //输出流包含要发送的数据,要注意数据格式编码\n  OutputStream op=conn.getOutputStream();//此时才发送http请求\n  op.write(new String(\"name=zharold\").getBytes());\n  //服务器返回东西了，先对响应码判断\n  if (conn.getResponseCode() == 200) {\n      //用getInputStream()方法获得服务器返回的输入流\n      InputStream in = conn.getInputStream();\n      byte[] data = read(in); //流转换为二进制数组，read()是转换方法\n      String html = new String(data, \"UTF-8\");\n      System.out.println(html);\n      in.close();\n  }\n```\n\n> 说明：\n>\n> > - HttpURLConnection对象不能直接构造，需要通过URL类中的openConnection()方法来获得。\n> > - HttpURLConnection的connect()函数，实际上**只是建立了一个与服务器的TCP连接**，并没有实际发送HTTP请求。HTTP请求实际上直到我们获取服务器响应数据（如调用getInputStream()、getResponseCode()等方法）时才正式发送出去。\n> > - 对HttpURLConnection对象的配置都需要在connect()方法执行之前完成。\n> > - HttpURLConnection是基于HTTP协议的，其底层通过socket通信实现。如果不设置超时（timeout），在网络异常的情况下，可能会导致程序僵死而不继续往下执行。\n> > - HTTP正文的内容是通过OutputStream流写入的， **向流中写入的数据不会立即发送到网络，而是存在于内存缓冲区中，待流关闭时，根据写入的内容生成HTTP正文**。\n> > - 调用getInputStream()方法时，返回一个输入流，用于从中读取服务器对于HTTP请求的返回信息。\n> > - 我们可以使用HttpURLConnection.connect()方法手动的发送一个HTTP请求，但是如果要获取HTTP响应的时候，请求就会自动的发起，比如我们使用HttpURLConnection.getInputStream()方法的时候，所以完全没有必要调用connect()方法。\n\n- HttpClient\n\n  HttpClient的使用步骤：创建HttpClient对象==》创建Http请求对象（GET、POST不同）==》设置请求参数==》执行请求==》获取响应对象==》对响应对象处理==》关闭相应对象==》关闭HttpClient\n\n  **GET请求**\n\n  ```java\n  //构造uri\n  URI uri = new URIBuilder()\n          .setScheme(\"https\")\n          .setHost(\"xxx\")\n          .setPath(\"/xxx\")\n          .setParameter(\"key1\", \"value1\")\n          .setParameter(\"key2\", \"value2\")\n          .build();\n  //创建httpclient对象\n  CloseableHttpClient client = HttpClients.createDefault();\n  //创建GET对象\n  HttpGet httpget = new HttpGet(uri);\n  //执行请求\n  CloseableHttpResponse response = client.execute(httpget);\n  if (response.getStatusLine().getStatusCode() == 200 ) {\n      HttpEntity entity = response.getEntity();\n      String detail = EntityUtils.toString(entity, \"utf-8\");\n      System.out.println(detail);\n\n  }\n  response.close();\n  client.close();\n  ```\n\n  **POST请求**\n\n  POST一般用于提交一些特别的东西，内容多种多样，HttpClient针对不同内容提供了不同的数据容器，如最常见的字符串（StringEntity），字节数组（ByteArrayEntity），输入流（InputStreamEntity），和文件（FileEntity）,请注意`InputStreamEntity`是不可重复的，因为它只能从底层数据流中读取一次。一般建议实现一个自定义`HttpEntity`类，而不是使用泛型`InputStreamEntity`。 \n\n  ```java\n  public String postInfo(String infoType, String aimUrl, String jsonBody) {\n          System.out.println(infoType + \"发送数据\");\n  \t\tString str = \"\";\n  \t\tCloseableHttpClient httpclient = HttpClients.createDefault();\n  \t\tHttpPost httpPost = new HttpPost(aimUrl);\n  \t\t//DES加密\n  \t\tbyte[] encrypt = SecureUtil.des(HexUtil.decodeHex(ZhengzhouData.DES)).encrypt(jsonBody);\n  \t\t//apache.commons.codec.Base64 编码\n  \t\tString data = Base64.encodeBase64String(encrypt);\n  \t\tStringEntity strEntity = new StringEntity(data, \"UTF-8\");\n  \t\thttpPost.setEntity(strEntity);\n  \t\tstrEntity.setContentEncoding(\"UTF-8\");\n  \t\tstrEntity.setContentType(\"application/json\");\n  \t\ttry {\n  \t\t\tCloseableHttpResponse response = httpclient.execute(httpPost);\n  \t\t\tif (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n  \t\t\t\tstr = EntityUtils.toString(response.getEntity(), \"UTF-8\");\n  \t\t\t}else {\n                  throw new Exception(\"发送\" + infoType + \"信息异常 code : \" + response.getStatusLine().getStatusCode());\n              }\n  \t\t\tresponse.close();\n  \t\t} catch (Exception e) {\n  \t\t\te.printStackTrace();\n  \t\t}\n  \t\treturn str;\n      }\n  ```\n\n  ​\n\n 在一般情况下，如果只是需要向Web站点的某个简单页面提交请求并获取服务器响应，HttpURLConnection完全可以胜任。但在绝大部分情况下，Web站点的网页可能没这么简单，这些页面并不是通过一个简单的URL就可访问的，可能需要用户登录而且具有相应的权限才可访问该页面。在这种情况下，就需要涉及Session、Cookie的处理了，如果打算使用HttpURLConnection来处理这些细节，当然也是可能实现的，只是处理起来难度就大了。\n\n为了更好地处理向Web站点请求，包括处理Session、Cookie等细节问题，Apache开源组织提供了一个HttpClient项目，看它的名称就知道，它是一个简单的HTTP客户端（并不是浏览器），可以用于发送HTTP请求，接收HTTP响应。但不会缓存服务器的响应，不能执行HTML页面中嵌入的Javascript代码；也不会对页面内容进行任何解析、处理。\n\n简单来说，HttpClient就是一个增强版的HttpURLConnection，HttpURLConnection可以做的事情HttpClient全部可以做；HttpURLConnection没有提供的有些功能，HttpClient也提供了，但它只是关注于如何发送请求、接收响应，以及管理HTTP连接。\n","source":"_posts/实习笔记-HTTP方法-GET对比POST.md","raw":"---\ntitle: '实习笔记----HTTP方法:GET对比POST'\ndate: 2018-05-09 22:52:42\ntags: [HTTP, 随笔, Java] \n---\n## 什么是 HTTP？\n\n超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。\n\nHTTP 的工作方式是客户机与服务器之间的请求-应答协议。\n\nweb 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。\n<!-- more-->\n举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。\n\n## 两种 HTTP 请求方法：GET 和 POST\n\n在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。\n\n- *GET* - 从指定的资源请求数据。\n- *POST* - 向指定的资源提交要被处理的数据\n\n## GET 方法\n\n请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：\n\n```\n/test/demo_form.asp?name1=value1&name2=value2\n```\n\n有关 GET 请求的其他一些注释：\n\n- GET 请求可被缓存\n- GET 请求保留在浏览器历史记录中\n- GET 请求可被收藏为书签\n- GET 请求不应在处理敏感数据时使用\n- GET 请求有长度限制\n- GET 请求只应当用于取回数据\n\n## POST 方法\n\n请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：\n\n```\nPOST /test/demo_form.asp HTTP/1.1\nHost: xxx.com\nname1=value1&name2=value2\n```\n\n有关 POST 请求的其他一些注释：\n\n- POST 请求不会被缓存\n- POST 请求不会保留在浏览器历史记录中\n- POST 不能被收藏为书签\n- POST 请求对数据长度没有要求\n\n## 比较 GET 与 POST\n\n下面的表格比较了两种 HTTP 方法：GET 和 POST。\n\n|                  | GET                                                          | POST                                                         |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |\n| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |\n| 缓存             | 能被缓存                                                     | 不能缓存                                                     |\n| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |\n| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |\n| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |\n| 对数据类型的限制 | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |\n| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |\n| 可见性           | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |\n\n## 其他 HTTP 请求方法\n\n下面的表格列出了其他一些 HTTP 请求方法：\n\n| 方法    | 描述                                              |\n| ------- | ------------------------------------------------- |\n| HEAD    | 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 |\n| PUT     | 上传指定的 URI 表示。                             |\n| DELETE  | 删除指定资源。                                    |\n| OPTIONS | 返回服务器支持的 HTTP 方法。                      |\n| CONNECT | 把请求连接转换到透明的 TCP/IP 通道。              |\n\n## Java HTTP请求方式：\n\n常用的HTTP库有HttpClient和HttpURLConnection，先来看两个例子再比较两种库。\n\n- HttpURLConnection\n\n  HttpURLConnection一般步骤：创建URL对象 ==》 获取URL的HttpURLConnection对象实例==》设置HTTP请求使用的方法==》设置超时和消息头==》对服务器响应码判断==》获得服务器返回的输入流==》关掉HTTP连接\n\n  **GET请求**\n\n```java\n  URL url = new URL(\"xxx\");\n  //调用URL对象的openConnection( )来获取HttpURLConnection对象实例\n  HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n  //请求方法为GET\n  conn.setRequestMethod(\"GET\");\n  //设置连接超时为5秒\n  conn.setConnectTimeout(5000);\n  //服务器返回东西了，先对响应码判断\n  if (conn.getResponseCode() == 200) {\n      //用getInputStream()方法获得服务器返回的输入流\n      InputStream in = conn.getInputStream();\n      byte[] data = read(in); //流转换为二进制数组，read()自己写的是转换方法\n      String html = new String(data, \"UTF-8\");\n      System.out.println(html);\n      in.close();\n  }\n```\n\n  **POST请求**\n\n  POST请求：POST请求大体和GET一致，只是设置相关参数的时候要注意设置允许输入、输出，还有POST方法不能缓存，要手动设置为false.\n\n```java\n  //创建URL对象,xxx是服务器API\n  URL url = new URL(\"xxx\");\n  //调用URL对象的openConnection( )来获取HttpURLConnection对象实例\n  HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n  //请求方法为GET\n  conn.setRequestMethod(\"POST\");\n  //设置连接超时为5秒\n  conn.setConnectTimeout(5000);\n  //允许输入输出\n  conn.setDoInput(true);\n  conn.setDoOutput(true);\n  //不能缓存\n  conn.setUseCaches(false);\n  //至少要设置的两个请求头\n  conn.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded\");\n  //输出流包含要发送的数据,要注意数据格式编码\n  OutputStream op=conn.getOutputStream();//此时才发送http请求\n  op.write(new String(\"name=zharold\").getBytes());\n  //服务器返回东西了，先对响应码判断\n  if (conn.getResponseCode() == 200) {\n      //用getInputStream()方法获得服务器返回的输入流\n      InputStream in = conn.getInputStream();\n      byte[] data = read(in); //流转换为二进制数组，read()是转换方法\n      String html = new String(data, \"UTF-8\");\n      System.out.println(html);\n      in.close();\n  }\n```\n\n> 说明：\n>\n> > - HttpURLConnection对象不能直接构造，需要通过URL类中的openConnection()方法来获得。\n> > - HttpURLConnection的connect()函数，实际上**只是建立了一个与服务器的TCP连接**，并没有实际发送HTTP请求。HTTP请求实际上直到我们获取服务器响应数据（如调用getInputStream()、getResponseCode()等方法）时才正式发送出去。\n> > - 对HttpURLConnection对象的配置都需要在connect()方法执行之前完成。\n> > - HttpURLConnection是基于HTTP协议的，其底层通过socket通信实现。如果不设置超时（timeout），在网络异常的情况下，可能会导致程序僵死而不继续往下执行。\n> > - HTTP正文的内容是通过OutputStream流写入的， **向流中写入的数据不会立即发送到网络，而是存在于内存缓冲区中，待流关闭时，根据写入的内容生成HTTP正文**。\n> > - 调用getInputStream()方法时，返回一个输入流，用于从中读取服务器对于HTTP请求的返回信息。\n> > - 我们可以使用HttpURLConnection.connect()方法手动的发送一个HTTP请求，但是如果要获取HTTP响应的时候，请求就会自动的发起，比如我们使用HttpURLConnection.getInputStream()方法的时候，所以完全没有必要调用connect()方法。\n\n- HttpClient\n\n  HttpClient的使用步骤：创建HttpClient对象==》创建Http请求对象（GET、POST不同）==》设置请求参数==》执行请求==》获取响应对象==》对响应对象处理==》关闭相应对象==》关闭HttpClient\n\n  **GET请求**\n\n  ```java\n  //构造uri\n  URI uri = new URIBuilder()\n          .setScheme(\"https\")\n          .setHost(\"xxx\")\n          .setPath(\"/xxx\")\n          .setParameter(\"key1\", \"value1\")\n          .setParameter(\"key2\", \"value2\")\n          .build();\n  //创建httpclient对象\n  CloseableHttpClient client = HttpClients.createDefault();\n  //创建GET对象\n  HttpGet httpget = new HttpGet(uri);\n  //执行请求\n  CloseableHttpResponse response = client.execute(httpget);\n  if (response.getStatusLine().getStatusCode() == 200 ) {\n      HttpEntity entity = response.getEntity();\n      String detail = EntityUtils.toString(entity, \"utf-8\");\n      System.out.println(detail);\n\n  }\n  response.close();\n  client.close();\n  ```\n\n  **POST请求**\n\n  POST一般用于提交一些特别的东西，内容多种多样，HttpClient针对不同内容提供了不同的数据容器，如最常见的字符串（StringEntity），字节数组（ByteArrayEntity），输入流（InputStreamEntity），和文件（FileEntity）,请注意`InputStreamEntity`是不可重复的，因为它只能从底层数据流中读取一次。一般建议实现一个自定义`HttpEntity`类，而不是使用泛型`InputStreamEntity`。 \n\n  ```java\n  public String postInfo(String infoType, String aimUrl, String jsonBody) {\n          System.out.println(infoType + \"发送数据\");\n  \t\tString str = \"\";\n  \t\tCloseableHttpClient httpclient = HttpClients.createDefault();\n  \t\tHttpPost httpPost = new HttpPost(aimUrl);\n  \t\t//DES加密\n  \t\tbyte[] encrypt = SecureUtil.des(HexUtil.decodeHex(ZhengzhouData.DES)).encrypt(jsonBody);\n  \t\t//apache.commons.codec.Base64 编码\n  \t\tString data = Base64.encodeBase64String(encrypt);\n  \t\tStringEntity strEntity = new StringEntity(data, \"UTF-8\");\n  \t\thttpPost.setEntity(strEntity);\n  \t\tstrEntity.setContentEncoding(\"UTF-8\");\n  \t\tstrEntity.setContentType(\"application/json\");\n  \t\ttry {\n  \t\t\tCloseableHttpResponse response = httpclient.execute(httpPost);\n  \t\t\tif (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n  \t\t\t\tstr = EntityUtils.toString(response.getEntity(), \"UTF-8\");\n  \t\t\t}else {\n                  throw new Exception(\"发送\" + infoType + \"信息异常 code : \" + response.getStatusLine().getStatusCode());\n              }\n  \t\t\tresponse.close();\n  \t\t} catch (Exception e) {\n  \t\t\te.printStackTrace();\n  \t\t}\n  \t\treturn str;\n      }\n  ```\n\n  ​\n\n 在一般情况下，如果只是需要向Web站点的某个简单页面提交请求并获取服务器响应，HttpURLConnection完全可以胜任。但在绝大部分情况下，Web站点的网页可能没这么简单，这些页面并不是通过一个简单的URL就可访问的，可能需要用户登录而且具有相应的权限才可访问该页面。在这种情况下，就需要涉及Session、Cookie的处理了，如果打算使用HttpURLConnection来处理这些细节，当然也是可能实现的，只是处理起来难度就大了。\n\n为了更好地处理向Web站点请求，包括处理Session、Cookie等细节问题，Apache开源组织提供了一个HttpClient项目，看它的名称就知道，它是一个简单的HTTP客户端（并不是浏览器），可以用于发送HTTP请求，接收HTTP响应。但不会缓存服务器的响应，不能执行HTML页面中嵌入的Javascript代码；也不会对页面内容进行任何解析、处理。\n\n简单来说，HttpClient就是一个增强版的HttpURLConnection，HttpURLConnection可以做的事情HttpClient全部可以做；HttpURLConnection没有提供的有些功能，HttpClient也提供了，但它只是关注于如何发送请求、接收响应，以及管理HTTP连接。\n","slug":"实习笔记-HTTP方法-GET对比POST","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7p003jcf963xsem47s","content":"<h2 id=\"什么是-HTTP？\"><a href=\"#什么是-HTTP？\" class=\"headerlink\" title=\"什么是 HTTP？\"></a>什么是 HTTP？</h2><p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。</p>\n<p>HTTP 的工作方式是客户机与服务器之间的请求-应答协议。</p>\n<p>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。<br><a id=\"more\"></a><br>举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。</p>\n<h2 id=\"两种-HTTP-请求方法：GET-和-POST\"><a href=\"#两种-HTTP-请求方法：GET-和-POST\" class=\"headerlink\" title=\"两种 HTTP 请求方法：GET 和 POST\"></a>两种 HTTP 请求方法：GET 和 POST</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p>\n<ul>\n<li><em>GET</em> - 从指定的资源请求数据。</li>\n<li><em>POST</em> - 向指定的资源提交要被处理的数据</li>\n</ul>\n<h2 id=\"GET-方法\"><a href=\"#GET-方法\" class=\"headerlink\" title=\"GET 方法\"></a>GET 方法</h2><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/test/demo_form.asp?name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>\n<p>有关 GET 请求的其他一些注释：</p>\n<ul>\n<li>GET 请求可被缓存</li>\n<li>GET 请求保留在浏览器历史记录中</li>\n<li>GET 请求可被收藏为书签</li>\n<li>GET 请求不应在处理敏感数据时使用</li>\n<li>GET 请求有长度限制</li>\n<li>GET 请求只应当用于取回数据</li>\n</ul>\n<h2 id=\"POST-方法\"><a href=\"#POST-方法\" class=\"headerlink\" title=\"POST 方法\"></a>POST 方法</h2><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /test/demo_form.asp HTTP/1.1</span><br><span class=\"line\">Host: xxx.com</span><br><span class=\"line\">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>\n<p>有关 POST 请求的其他一些注释：</p>\n<ul>\n<li>POST 请求不会被缓存</li>\n<li>POST 请求不会保留在浏览器历史记录中</li>\n<li>POST 不能被收藏为书签</li>\n<li>POST 请求对数据长度没有要求</li>\n</ul>\n<h2 id=\"比较-GET-与-POST\"><a href=\"#比较-GET-与-POST\" class=\"headerlink\" title=\"比较 GET 与 POST\"></a>比较 GET 与 POST</h2><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>GET</th>\n<th>POST</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>后退按钮/刷新</td>\n<td>无害</td>\n<td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>\n</tr>\n<tr>\n<td>书签</td>\n<td>可收藏为书签</td>\n<td>不可收藏为书签</td>\n</tr>\n<tr>\n<td>缓存</td>\n<td>能被缓存</td>\n<td>不能缓存</td>\n</tr>\n<tr>\n<td>编码类型</td>\n<td>application/x-www-form-urlencoded</td>\n<td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>\n</tr>\n<tr>\n<td>历史</td>\n<td>参数保留在浏览器历史中。</td>\n<td>参数不会保存在浏览器历史中。</td>\n</tr>\n<tr>\n<td>对数据长度的限制</td>\n<td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>\n<td>无限制。</td>\n</tr>\n<tr>\n<td>对数据类型的限制</td>\n<td>只允许 ASCII 字符。</td>\n<td>没有限制。也允许二进制数据。</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td>\n<td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>\n</tr>\n<tr>\n<td>可见性</td>\n<td>数据在 URL 中对所有人都是可见的。</td>\n<td>数据不会显示在 URL 中。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"其他-HTTP-请求方法\"><a href=\"#其他-HTTP-请求方法\" class=\"headerlink\" title=\"其他 HTTP 请求方法\"></a>其他 HTTP 请求方法</h2><p>下面的表格列出了其他一些 HTTP 请求方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HEAD</td>\n<td>与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>上传指定的 URI 表示。</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>删除指定资源。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>返回服务器支持的 HTTP 方法。</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>把请求连接转换到透明的 TCP/IP 通道。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Java-HTTP请求方式：\"><a href=\"#Java-HTTP请求方式：\" class=\"headerlink\" title=\"Java HTTP请求方式：\"></a>Java HTTP请求方式：</h2><p>常用的HTTP库有HttpClient和HttpURLConnection，先来看两个例子再比较两种库。</p>\n<ul>\n<li><p>HttpURLConnection</p>\n<p>HttpURLConnection一般步骤：创建URL对象 ==》 获取URL的HttpURLConnection对象实例==》设置HTTP请求使用的方法==》设置超时和消息头==》对服务器响应码判断==》获得服务器返回的输入流==》关掉HTTP连接</p>\n<p><strong>GET请求</strong></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"xxx\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//调用URL对象的openConnection( )来获取HttpURLConnection对象实例</span></span><br><span class=\"line\">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\"><span class=\"comment\">//请求方法为GET</span></span><br><span class=\"line\">conn.setRequestMethod(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置连接超时为5秒</span></span><br><span class=\"line\">conn.setConnectTimeout(<span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">//服务器返回东西了，先对响应码判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (conn.getResponseCode() == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//用getInputStream()方法获得服务器返回的输入流</span></span><br><span class=\"line\">    InputStream in = conn.getInputStream();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] data = read(in); <span class=\"comment\">//流转换为二进制数组，read()自己写的是转换方法</span></span><br><span class=\"line\">    String html = <span class=\"keyword\">new</span> String(data, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">    System.out.println(html);</span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <strong>POST请求</strong></p>\n<p>  POST请求：POST请求大体和GET一致，只是设置相关参数的时候要注意设置允许输入、输出，还有POST方法不能缓存，要手动设置为false.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建URL对象,xxx是服务器API</span></span><br><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"xxx\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//调用URL对象的openConnection( )来获取HttpURLConnection对象实例</span></span><br><span class=\"line\">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\"><span class=\"comment\">//请求方法为GET</span></span><br><span class=\"line\">conn.setRequestMethod(<span class=\"string\">\"POST\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置连接超时为5秒</span></span><br><span class=\"line\">conn.setConnectTimeout(<span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">//允许输入输出</span></span><br><span class=\"line\">conn.setDoInput(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">conn.setDoOutput(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">//不能缓存</span></span><br><span class=\"line\">conn.setUseCaches(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">//至少要设置的两个请求头</span></span><br><span class=\"line\">conn.setRequestProperty(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//输出流包含要发送的数据,要注意数据格式编码</span></span><br><span class=\"line\">OutputStream op=conn.getOutputStream();<span class=\"comment\">//此时才发送http请求</span></span><br><span class=\"line\">op.write(<span class=\"keyword\">new</span> String(<span class=\"string\">\"name=zharold\"</span>).getBytes());</span><br><span class=\"line\"><span class=\"comment\">//服务器返回东西了，先对响应码判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (conn.getResponseCode() == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//用getInputStream()方法获得服务器返回的输入流</span></span><br><span class=\"line\">    InputStream in = conn.getInputStream();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] data = read(in); <span class=\"comment\">//流转换为二进制数组，read()是转换方法</span></span><br><span class=\"line\">    String html = <span class=\"keyword\">new</span> String(data, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">    System.out.println(html);</span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明：</p>\n<blockquote>\n<ul>\n<li>HttpURLConnection对象不能直接构造，需要通过URL类中的openConnection()方法来获得。</li>\n<li>HttpURLConnection的connect()函数，实际上<strong>只是建立了一个与服务器的TCP连接</strong>，并没有实际发送HTTP请求。HTTP请求实际上直到我们获取服务器响应数据（如调用getInputStream()、getResponseCode()等方法）时才正式发送出去。</li>\n<li>对HttpURLConnection对象的配置都需要在connect()方法执行之前完成。</li>\n<li>HttpURLConnection是基于HTTP协议的，其底层通过socket通信实现。如果不设置超时（timeout），在网络异常的情况下，可能会导致程序僵死而不继续往下执行。</li>\n<li>HTTP正文的内容是通过OutputStream流写入的， <strong>向流中写入的数据不会立即发送到网络，而是存在于内存缓冲区中，待流关闭时，根据写入的内容生成HTTP正文</strong>。</li>\n<li>调用getInputStream()方法时，返回一个输入流，用于从中读取服务器对于HTTP请求的返回信息。</li>\n<li>我们可以使用HttpURLConnection.connect()方法手动的发送一个HTTP请求，但是如果要获取HTTP响应的时候，请求就会自动的发起，比如我们使用HttpURLConnection.getInputStream()方法的时候，所以完全没有必要调用connect()方法。</li>\n</ul>\n</blockquote>\n</blockquote>\n<ul>\n<li><p>HttpClient</p>\n<p>HttpClient的使用步骤：创建HttpClient对象==》创建Http请求对象（GET、POST不同）==》设置请求参数==》执行请求==》获取响应对象==》对响应对象处理==》关闭相应对象==》关闭HttpClient</p>\n<p><strong>GET请求</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造uri</span></span><br><span class=\"line\">URI uri = <span class=\"keyword\">new</span> URIBuilder()</span><br><span class=\"line\">        .setScheme(<span class=\"string\">\"https\"</span>)</span><br><span class=\"line\">        .setHost(<span class=\"string\">\"xxx\"</span>)</span><br><span class=\"line\">        .setPath(<span class=\"string\">\"/xxx\"</span>)</span><br><span class=\"line\">        .setParameter(<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>)</span><br><span class=\"line\">        .setParameter(<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"><span class=\"comment\">//创建httpclient对象</span></span><br><span class=\"line\">CloseableHttpClient client = HttpClients.createDefault();</span><br><span class=\"line\"><span class=\"comment\">//创建GET对象</span></span><br><span class=\"line\">HttpGet httpget = <span class=\"keyword\">new</span> HttpGet(uri);</span><br><span class=\"line\"><span class=\"comment\">//执行请求</span></span><br><span class=\"line\">CloseableHttpResponse response = client.execute(httpget);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (response.getStatusLine().getStatusCode() == <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">    HttpEntity entity = response.getEntity();</span><br><span class=\"line\">    String detail = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">    System.out.println(detail);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">response.close();</span><br><span class=\"line\">client.close();</span><br></pre></td></tr></table></figure>\n<p><strong>POST请求</strong></p>\n<p>POST一般用于提交一些特别的东西，内容多种多样，HttpClient针对不同内容提供了不同的数据容器，如最常见的字符串（StringEntity），字节数组（ByteArrayEntity），输入流（InputStreamEntity），和文件（FileEntity）,请注意<code>InputStreamEntity</code>是不可重复的，因为它只能从底层数据流中读取一次。一般建议实现一个自定义<code>HttpEntity</code>类，而不是使用泛型<code>InputStreamEntity</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">postInfo</span><span class=\"params\">(String infoType, String aimUrl, String jsonBody)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(infoType + <span class=\"string\">\"发送数据\"</span>);</span><br><span class=\"line\">\t\tString str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\tCloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpPost httpPost = <span class=\"keyword\">new</span> HttpPost(aimUrl);</span><br><span class=\"line\">\t\t<span class=\"comment\">//DES加密</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] encrypt = SecureUtil.des(HexUtil.decodeHex(ZhengzhouData.DES)).encrypt(jsonBody);</span><br><span class=\"line\">\t\t<span class=\"comment\">//apache.commons.codec.Base64 编码</span></span><br><span class=\"line\">\t\tString data = Base64.encodeBase64String(encrypt);</span><br><span class=\"line\">\t\tStringEntity strEntity = <span class=\"keyword\">new</span> StringEntity(data, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">\t\thttpPost.setEntity(strEntity);</span><br><span class=\"line\">\t\tstrEntity.setContentEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">\t\tstrEntity.setContentType(<span class=\"string\">\"application/json\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tCloseableHttpResponse response = httpclient.execute(httpPost);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;</span><br><span class=\"line\">\t\t\t\tstr = EntityUtils.toString(response.getEntity(), <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"发送\"</span> + infoType + <span class=\"string\">\"信息异常 code : \"</span> + response.getStatusLine().getStatusCode());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\tresponse.close();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<p>在一般情况下，如果只是需要向Web站点的某个简单页面提交请求并获取服务器响应，HttpURLConnection完全可以胜任。但在绝大部分情况下，Web站点的网页可能没这么简单，这些页面并不是通过一个简单的URL就可访问的，可能需要用户登录而且具有相应的权限才可访问该页面。在这种情况下，就需要涉及Session、Cookie的处理了，如果打算使用HttpURLConnection来处理这些细节，当然也是可能实现的，只是处理起来难度就大了。</p>\n</li>\n</ul>\n<p>为了更好地处理向Web站点请求，包括处理Session、Cookie等细节问题，Apache开源组织提供了一个HttpClient项目，看它的名称就知道，它是一个简单的HTTP客户端（并不是浏览器），可以用于发送HTTP请求，接收HTTP响应。但不会缓存服务器的响应，不能执行HTML页面中嵌入的Javascript代码；也不会对页面内容进行任何解析、处理。</p>\n<p>简单来说，HttpClient就是一个增强版的HttpURLConnection，HttpURLConnection可以做的事情HttpClient全部可以做；HttpURLConnection没有提供的有些功能，HttpClient也提供了，但它只是关注于如何发送请求、接收响应，以及管理HTTP连接。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是-HTTP？\"><a href=\"#什么是-HTTP？\" class=\"headerlink\" title=\"什么是 HTTP？\"></a>什么是 HTTP？</h2><p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。</p>\n<p>HTTP 的工作方式是客户机与服务器之间的请求-应答协议。</p>\n<p>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。<br>","more":"<br>举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。</p>\n<h2 id=\"两种-HTTP-请求方法：GET-和-POST\"><a href=\"#两种-HTTP-请求方法：GET-和-POST\" class=\"headerlink\" title=\"两种 HTTP 请求方法：GET 和 POST\"></a>两种 HTTP 请求方法：GET 和 POST</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p>\n<ul>\n<li><em>GET</em> - 从指定的资源请求数据。</li>\n<li><em>POST</em> - 向指定的资源提交要被处理的数据</li>\n</ul>\n<h2 id=\"GET-方法\"><a href=\"#GET-方法\" class=\"headerlink\" title=\"GET 方法\"></a>GET 方法</h2><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/test/demo_form.asp?name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>\n<p>有关 GET 请求的其他一些注释：</p>\n<ul>\n<li>GET 请求可被缓存</li>\n<li>GET 请求保留在浏览器历史记录中</li>\n<li>GET 请求可被收藏为书签</li>\n<li>GET 请求不应在处理敏感数据时使用</li>\n<li>GET 请求有长度限制</li>\n<li>GET 请求只应当用于取回数据</li>\n</ul>\n<h2 id=\"POST-方法\"><a href=\"#POST-方法\" class=\"headerlink\" title=\"POST 方法\"></a>POST 方法</h2><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /test/demo_form.asp HTTP/1.1</span><br><span class=\"line\">Host: xxx.com</span><br><span class=\"line\">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>\n<p>有关 POST 请求的其他一些注释：</p>\n<ul>\n<li>POST 请求不会被缓存</li>\n<li>POST 请求不会保留在浏览器历史记录中</li>\n<li>POST 不能被收藏为书签</li>\n<li>POST 请求对数据长度没有要求</li>\n</ul>\n<h2 id=\"比较-GET-与-POST\"><a href=\"#比较-GET-与-POST\" class=\"headerlink\" title=\"比较 GET 与 POST\"></a>比较 GET 与 POST</h2><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>GET</th>\n<th>POST</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>后退按钮/刷新</td>\n<td>无害</td>\n<td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>\n</tr>\n<tr>\n<td>书签</td>\n<td>可收藏为书签</td>\n<td>不可收藏为书签</td>\n</tr>\n<tr>\n<td>缓存</td>\n<td>能被缓存</td>\n<td>不能缓存</td>\n</tr>\n<tr>\n<td>编码类型</td>\n<td>application/x-www-form-urlencoded</td>\n<td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>\n</tr>\n<tr>\n<td>历史</td>\n<td>参数保留在浏览器历史中。</td>\n<td>参数不会保存在浏览器历史中。</td>\n</tr>\n<tr>\n<td>对数据长度的限制</td>\n<td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>\n<td>无限制。</td>\n</tr>\n<tr>\n<td>对数据类型的限制</td>\n<td>只允许 ASCII 字符。</td>\n<td>没有限制。也允许二进制数据。</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td>\n<td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>\n</tr>\n<tr>\n<td>可见性</td>\n<td>数据在 URL 中对所有人都是可见的。</td>\n<td>数据不会显示在 URL 中。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"其他-HTTP-请求方法\"><a href=\"#其他-HTTP-请求方法\" class=\"headerlink\" title=\"其他 HTTP 请求方法\"></a>其他 HTTP 请求方法</h2><p>下面的表格列出了其他一些 HTTP 请求方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HEAD</td>\n<td>与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>上传指定的 URI 表示。</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>删除指定资源。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>返回服务器支持的 HTTP 方法。</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>把请求连接转换到透明的 TCP/IP 通道。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Java-HTTP请求方式：\"><a href=\"#Java-HTTP请求方式：\" class=\"headerlink\" title=\"Java HTTP请求方式：\"></a>Java HTTP请求方式：</h2><p>常用的HTTP库有HttpClient和HttpURLConnection，先来看两个例子再比较两种库。</p>\n<ul>\n<li><p>HttpURLConnection</p>\n<p>HttpURLConnection一般步骤：创建URL对象 ==》 获取URL的HttpURLConnection对象实例==》设置HTTP请求使用的方法==》设置超时和消息头==》对服务器响应码判断==》获得服务器返回的输入流==》关掉HTTP连接</p>\n<p><strong>GET请求</strong></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"xxx\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//调用URL对象的openConnection( )来获取HttpURLConnection对象实例</span></span><br><span class=\"line\">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\"><span class=\"comment\">//请求方法为GET</span></span><br><span class=\"line\">conn.setRequestMethod(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置连接超时为5秒</span></span><br><span class=\"line\">conn.setConnectTimeout(<span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">//服务器返回东西了，先对响应码判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (conn.getResponseCode() == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//用getInputStream()方法获得服务器返回的输入流</span></span><br><span class=\"line\">    InputStream in = conn.getInputStream();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] data = read(in); <span class=\"comment\">//流转换为二进制数组，read()自己写的是转换方法</span></span><br><span class=\"line\">    String html = <span class=\"keyword\">new</span> String(data, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">    System.out.println(html);</span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <strong>POST请求</strong></p>\n<p>  POST请求：POST请求大体和GET一致，只是设置相关参数的时候要注意设置允许输入、输出，还有POST方法不能缓存，要手动设置为false.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建URL对象,xxx是服务器API</span></span><br><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"xxx\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//调用URL对象的openConnection( )来获取HttpURLConnection对象实例</span></span><br><span class=\"line\">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\"><span class=\"comment\">//请求方法为GET</span></span><br><span class=\"line\">conn.setRequestMethod(<span class=\"string\">\"POST\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置连接超时为5秒</span></span><br><span class=\"line\">conn.setConnectTimeout(<span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">//允许输入输出</span></span><br><span class=\"line\">conn.setDoInput(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">conn.setDoOutput(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">//不能缓存</span></span><br><span class=\"line\">conn.setUseCaches(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">//至少要设置的两个请求头</span></span><br><span class=\"line\">conn.setRequestProperty(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//输出流包含要发送的数据,要注意数据格式编码</span></span><br><span class=\"line\">OutputStream op=conn.getOutputStream();<span class=\"comment\">//此时才发送http请求</span></span><br><span class=\"line\">op.write(<span class=\"keyword\">new</span> String(<span class=\"string\">\"name=zharold\"</span>).getBytes());</span><br><span class=\"line\"><span class=\"comment\">//服务器返回东西了，先对响应码判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (conn.getResponseCode() == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//用getInputStream()方法获得服务器返回的输入流</span></span><br><span class=\"line\">    InputStream in = conn.getInputStream();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] data = read(in); <span class=\"comment\">//流转换为二进制数组，read()是转换方法</span></span><br><span class=\"line\">    String html = <span class=\"keyword\">new</span> String(data, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">    System.out.println(html);</span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明：</p>\n<blockquote>\n<ul>\n<li>HttpURLConnection对象不能直接构造，需要通过URL类中的openConnection()方法来获得。</li>\n<li>HttpURLConnection的connect()函数，实际上<strong>只是建立了一个与服务器的TCP连接</strong>，并没有实际发送HTTP请求。HTTP请求实际上直到我们获取服务器响应数据（如调用getInputStream()、getResponseCode()等方法）时才正式发送出去。</li>\n<li>对HttpURLConnection对象的配置都需要在connect()方法执行之前完成。</li>\n<li>HttpURLConnection是基于HTTP协议的，其底层通过socket通信实现。如果不设置超时（timeout），在网络异常的情况下，可能会导致程序僵死而不继续往下执行。</li>\n<li>HTTP正文的内容是通过OutputStream流写入的， <strong>向流中写入的数据不会立即发送到网络，而是存在于内存缓冲区中，待流关闭时，根据写入的内容生成HTTP正文</strong>。</li>\n<li>调用getInputStream()方法时，返回一个输入流，用于从中读取服务器对于HTTP请求的返回信息。</li>\n<li>我们可以使用HttpURLConnection.connect()方法手动的发送一个HTTP请求，但是如果要获取HTTP响应的时候，请求就会自动的发起，比如我们使用HttpURLConnection.getInputStream()方法的时候，所以完全没有必要调用connect()方法。</li>\n</ul>\n</blockquote>\n</blockquote>\n<ul>\n<li><p>HttpClient</p>\n<p>HttpClient的使用步骤：创建HttpClient对象==》创建Http请求对象（GET、POST不同）==》设置请求参数==》执行请求==》获取响应对象==》对响应对象处理==》关闭相应对象==》关闭HttpClient</p>\n<p><strong>GET请求</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造uri</span></span><br><span class=\"line\">URI uri = <span class=\"keyword\">new</span> URIBuilder()</span><br><span class=\"line\">        .setScheme(<span class=\"string\">\"https\"</span>)</span><br><span class=\"line\">        .setHost(<span class=\"string\">\"xxx\"</span>)</span><br><span class=\"line\">        .setPath(<span class=\"string\">\"/xxx\"</span>)</span><br><span class=\"line\">        .setParameter(<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>)</span><br><span class=\"line\">        .setParameter(<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"><span class=\"comment\">//创建httpclient对象</span></span><br><span class=\"line\">CloseableHttpClient client = HttpClients.createDefault();</span><br><span class=\"line\"><span class=\"comment\">//创建GET对象</span></span><br><span class=\"line\">HttpGet httpget = <span class=\"keyword\">new</span> HttpGet(uri);</span><br><span class=\"line\"><span class=\"comment\">//执行请求</span></span><br><span class=\"line\">CloseableHttpResponse response = client.execute(httpget);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (response.getStatusLine().getStatusCode() == <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">    HttpEntity entity = response.getEntity();</span><br><span class=\"line\">    String detail = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">    System.out.println(detail);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">response.close();</span><br><span class=\"line\">client.close();</span><br></pre></td></tr></table></figure>\n<p><strong>POST请求</strong></p>\n<p>POST一般用于提交一些特别的东西，内容多种多样，HttpClient针对不同内容提供了不同的数据容器，如最常见的字符串（StringEntity），字节数组（ByteArrayEntity），输入流（InputStreamEntity），和文件（FileEntity）,请注意<code>InputStreamEntity</code>是不可重复的，因为它只能从底层数据流中读取一次。一般建议实现一个自定义<code>HttpEntity</code>类，而不是使用泛型<code>InputStreamEntity</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">postInfo</span><span class=\"params\">(String infoType, String aimUrl, String jsonBody)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(infoType + <span class=\"string\">\"发送数据\"</span>);</span><br><span class=\"line\">\t\tString str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\tCloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpPost httpPost = <span class=\"keyword\">new</span> HttpPost(aimUrl);</span><br><span class=\"line\">\t\t<span class=\"comment\">//DES加密</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] encrypt = SecureUtil.des(HexUtil.decodeHex(ZhengzhouData.DES)).encrypt(jsonBody);</span><br><span class=\"line\">\t\t<span class=\"comment\">//apache.commons.codec.Base64 编码</span></span><br><span class=\"line\">\t\tString data = Base64.encodeBase64String(encrypt);</span><br><span class=\"line\">\t\tStringEntity strEntity = <span class=\"keyword\">new</span> StringEntity(data, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">\t\thttpPost.setEntity(strEntity);</span><br><span class=\"line\">\t\tstrEntity.setContentEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">\t\tstrEntity.setContentType(<span class=\"string\">\"application/json\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tCloseableHttpResponse response = httpclient.execute(httpPost);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;</span><br><span class=\"line\">\t\t\t\tstr = EntityUtils.toString(response.getEntity(), <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"发送\"</span> + infoType + <span class=\"string\">\"信息异常 code : \"</span> + response.getStatusLine().getStatusCode());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\tresponse.close();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<p>在一般情况下，如果只是需要向Web站点的某个简单页面提交请求并获取服务器响应，HttpURLConnection完全可以胜任。但在绝大部分情况下，Web站点的网页可能没这么简单，这些页面并不是通过一个简单的URL就可访问的，可能需要用户登录而且具有相应的权限才可访问该页面。在这种情况下，就需要涉及Session、Cookie的处理了，如果打算使用HttpURLConnection来处理这些细节，当然也是可能实现的，只是处理起来难度就大了。</p>\n</li>\n</ul>\n<p>为了更好地处理向Web站点请求，包括处理Session、Cookie等细节问题，Apache开源组织提供了一个HttpClient项目，看它的名称就知道，它是一个简单的HTTP客户端（并不是浏览器），可以用于发送HTTP请求，接收HTTP响应。但不会缓存服务器的响应，不能执行HTML页面中嵌入的Javascript代码；也不会对页面内容进行任何解析、处理。</p>\n<p>简单来说，HttpClient就是一个增强版的HttpURLConnection，HttpURLConnection可以做的事情HttpClient全部可以做；HttpURLConnection没有提供的有些功能，HttpClient也提供了，但它只是关注于如何发送请求、接收响应，以及管理HTTP连接。</p>"},{"title":"数据算法——Hadoop的二次排序解决方案","date":"2018-06-04T07:58:43.000Z","_content":"#### 一. 二次排序(secondary sort)问题的引出 ####\n\n**1. 二次排序**:\n\n在reduce阶段对与某个键关联的值排序,又称为键值转换;\n\n**2. MR中的排序:**\n\nMapReduce框架会自动对mapper生成的键排序,说明在启动reducer之前,mapper生成的所有中间键值对必然是**按键有序**的.但是传入reducer的值并不是有序的,他们可能有任意的顺序,要想对reducer中的值进行排序,可以用二次排序设计模式实现.\n\n**3. 通过MR的范式分析二次排序**:\n\nmap(key1,value1)--->list(key2,value2)\nreduce(list(key2,value2))--->list(key3,value3)\nlist(key2,value2)作为reducer的输入,list(value2)=(V1,V2,V3...,Vn),其本身是无序的.\n二次排序的目标就是让reducer收到的值有某种顺序.\n<!-- more--> \n**4. 问题引入**\n\n假如我们有一组温度数据,按照'年\\月\\日\\温度'的格式存储, 我们希望输入每一个年月的温度,并且按照升序排序:\n\n```\n2012-01: 5, 10, 25, 30...\n2012-02: 18, 25, 30...\n2012-08: 13, 20, 35...\n```\n\n#### 二. 二次排序问题的解决方案\n\n* 1.让reducer读取和缓存给定键的所有值,然后对这些值完成in-reducer排序,数据量大时可能导致内存溢出\n* 2.使用MapReduce框架对reducer值排序(这样就不需要再对传入reducer的值进行reducer中的排序),这种方法\"会为自然键增加部分或整个值来创建一个组合键以实现排序目标\",不会造成内存溢出\n  * 使用键值转换设计模式:构造一组中间键(K, V1),其中V1是次键,K称为自然键,要在reducer键中注入一个值,只需要创建一个组合键.在本例中,V1就是温度数据\n  * 让MapReduce执行框架完成排序(利用集群的力量)\n  * 保留多个键值对状态来完成处理,可以适当利用mapper的partitioner来实现.\n\n**1.中间键的排序顺序**\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-6-4/84337503.jpg)\n\n要实现二次排序,我们需要控制中间键的排序顺序,以及reducer处理键的顺序,首先要在组合键中注入一个值(temperature),然后控制中间键的排序顺序.\n\n因为希望reducer按照温度排序,所以增加temperature.要用compareTo方法指出如何对DateTemperaturePair对象排序.\n\n>  在Hadoop中,要持久存储定制数据类型,则必须实现Writable接口,要比较定制数据类型,必须实现WritableComparable接口\n\n```java\npublic class DateTemperaturePair implements Writable, WritableComparable<DateTemperaturePair> {\n    private final Text yearMonth = new Text();\n    private final Text day = new Text();\n    private final IntWritable temperature = new IntWritable();\n\n\n    public DateTemperaturePair() {\n    }\n\n    public DateTemperaturePair(String yearMonth, String day, int temperature) {\n        this.yearMonth.set(yearMonth);\n        this.day.set(day);\n        this.temperature.set(temperature);\n    }\n\n    public static DateTemperaturePair read(DataInput in) throws IOException {\n        DateTemperaturePair pair = new DateTemperaturePair();\n        pair.readFields(in);\n        return pair;\n    }\n\n    @Override\n    public void write(DataOutput dataOutput) throws IOException {\n        yearMonth.write(dataOutput);\n        day.write(dataOutput);\n        temperature.write(dataOutput);\n    }\n\n    @Override\n    public void readFields(DataInput in) throws IOException {\n        yearMonth.readFields(in);\n        day.readFields(in);\n        temperature.readFields(in);\n    }\n\n\n    public void setYearMonth(String yearMonthAsString) {\n        yearMonth.set(yearMonthAsString);\n    }\n\n    public void setTemperature(int Temp) {\n        temperature.set(Temp);\n    }\n\n    public void setDay(String dayAsString) {\n        day.set(dayAsString);\n    }\n\n    public Text getYearMonth() {\n        return yearMonth;\n    }\n\n    public Text getDay() {\n        return day;\n    }\n\n    public IntWritable getTemperature() {\n        return temperature;\n    }\n\n    public int compareTo(DateTemperaturePair pair) {\n        int compareValue = this.yearMonth.compareTo(pair.getYearMonth());\n        if (compareValue == 0) {\n            compareValue = temperature.compareTo(pair.getTemperature());\n        }\n        return -1 * compareValue;//降序排序\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DateTemperaturePair that = (DateTemperaturePair) o;\n        if (temperature != null ? !temperature.equals(that.temperature) : that.temperature != null) {\n            return false;\n        }\n        if (yearMonth != null ? !yearMonth.equals(that.yearMonth) : that.yearMonth != yearMonth) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = yearMonth != null ? yearMonth.hashCode() : 0;\n        result = 31 * result + (temperature != null ? temperature.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"DateTemperaturePair{\" +\n                \"yearMonth=\" + yearMonth +\n                \", day=\" + day +\n                \", temperature=\" + temperature +\n                '}';\n    }\n}\n```\n\n2.定制分区器\n\npartitioner会根据mapper输出的键来决定将其输出发送到那个表reducer，为此我们需要：\n\n​\t1.一个定制partitioner控制哪个reducer处理哪些键\n\n​\t2.一个定制比较器对reducer值排序\n\n定制分区器会确保具有相同键（自然键，并非包含temperature的组合键）的所有数据都发送给同一个reducer，定制比较器会完成排序，保证数据一到达reducer就会按自然键对数据分组。\n\n```java\npublic class DateTemperaturePartitioner extends Partitioner<DateTemperaturePair, Text> {\n    @Override\n    public int getPartition(DateTemperaturePair dateTemperaturePair, Text text, int i) {\n        return Math.abs(dateTemperaturePair.getYearMonth().hashCode() % i);\n    }\n}\n```\n\n3.分组比较器\n\n```java\n/**\n * @author lihe\n * @Title:\n * @Description: 分组比较器，控制哪些键分组到一个reduce函数调用\n * @date 2018/6/7上午11:33\n */\npublic class DateTempratureGroupingComparator  extends WritableComparator {\n    public DateTempratureGroupingComparator() {\n        super(DateTemperaturePair.class, true);\n    }\n\n    @Override\n    public int compare(WritableComparable a, WritableComparable b) {\n        DateTemperaturePair pair = (DateTemperaturePair) a;\n        DateTemperaturePair pair2 = (DateTemperaturePair) b;\n        return pair.getYearMonth().compareTo(pair2.getYearMonth());\n    }\n}\n```\n\n#### 三、MAPREDUCER/Hadoop的二次排序解决方案\n\n**输入：**\n\n<year><,><month><,><day><,><temperature>\n\n示例：\n\n2012，01，01，35\n\n2012，12，23，-4\n\n**期望输出：**\n\n<year><-><month>:<temperature><,><temperature><,>...\n\n其中<temperature1> <= <temperature2> <= ...\n\n示例：\n2012-01: 5，10，13，30，...\n\n2012-03: 12，23，31， ...\n\n**map()函数**\n\n```java\n/**\n * @author harold\n * @Title:\n * @Description: map()函数完成解析和词法分析，然后将temperature注入到reducer键中\n * @date 2018/6/7下午1:34\n */\npublic class SecondarySortMapper extends Mapper<LongWritable, Text, DateTemperaturePair, Text> {\n\n    private final Text theTemperature = new Text();\n    private final DateTemperaturePair pair = new DateTemperaturePair();\n\n    @Override\n    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n        String line = value.toString();\n        String [] tokens = line.split(\",\");\n        String yearMonth = tokens[0] + tokens[1];\n        String day = tokens[2];\n        int temperature = Integer.parseInt(tokens[3]);\n\n        pair.setDay(day);\n        pair.setTemperature(temperature);\n        pair.setYearMonth(yearMonth);\n        theTemperature.set(tokens[3]);\n\n        context.write(pair, theTemperature);\n    }\n}\n```\n\n**reduce()函数**\n\n```java\n/**\n * @author lihe\n * @Title:\n * @Description: 连接值\n * @date 2018/6/7下午1:44\n */\npublic class SecondarySortReducer  extends Reducer<DateTemperaturePair, Text, Text, Text> {\n    @Override\n    protected void reduce(DateTemperaturePair key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n        StringBuilder builder = new StringBuilder();\n        for (Text value : values) {\n            builder.append(value.toString());\n            builder.append(\",\");\n        }\n        context.write(key.getYearMonth(), new Text(builder.toString()));\n    }\n}\n```\n\n**驱动函数**\n\n第一个比较器（DateTemperaturePair.compareTo()）方法会控制键的排序顺序，第二个比较器（DateTemperatureGroupingComparator.compare()）方法会控制哪些键分到一个reducer（）。通过这两个比较器，建立作业时就好像定义了值得顺序一样。\n\n```java\n/**\n * @author lihe\n * @Title:\n * @Description: 驱动器\n * @date 2018/6/7下午1:54\n */\npublic class SecondarySortDriver extends Configured implements Tool {\n\n    private static Logger theLogger = Logger.getLogger(SecondarySortDriver.class);\n\n    @Override\n    public int run(String[] args) throws Exception {\n        Configuration conf = getConf();\n        Job job = new Job(conf);\n        job.setJarByClass(SecondarySortDriver.class);\n        job.setJobName(\"SecondarySort\");\n\n        FileInputFormat.setInputPaths(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[1]));\n\n        job.setMapOutputKeyClass(DateTemperaturePair.class);\n        job.setMapOutputValueClass(Text.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setMapperClass(SecondarySortMapper.class);\n        job.setReducerClass(SecondarySortReducer.class);\n        job.setPartitionerClass(DateTemperaturePartitioner.class);\n        job.setGroupingComparatorClass(DateTempratureGroupingComparator.class);\n\n        boolean status = job.waitForCompletion(true);\n        theLogger.info(\"run: status\" + status);\n        return status ? 0 : 1;\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            theLogger.warn(\"SecondarySortDriver <input-dir> <output-dir>\");\n            throw new IllegalArgumentException(\"SecondarySortDriver <input-dir> <output-dir>\");\n        }\n\n        int returnStatus = ToolRunner.run(new SecondarySortDriver(), args);\n        theLogger.info(\"returnStatus=\" + returnStatus);\n        System.exit(returnStatus);\n    }\n}\n```\n","source":"_posts/数据算法-二次排序.md","raw":"---\ntitle: 数据算法——Hadoop的二次排序解决方案\ndate: 2018-06-04 15:58:43\ntags: [分布式算法, 大数据, 机器学习, Hadoop]\n---\n#### 一. 二次排序(secondary sort)问题的引出 ####\n\n**1. 二次排序**:\n\n在reduce阶段对与某个键关联的值排序,又称为键值转换;\n\n**2. MR中的排序:**\n\nMapReduce框架会自动对mapper生成的键排序,说明在启动reducer之前,mapper生成的所有中间键值对必然是**按键有序**的.但是传入reducer的值并不是有序的,他们可能有任意的顺序,要想对reducer中的值进行排序,可以用二次排序设计模式实现.\n\n**3. 通过MR的范式分析二次排序**:\n\nmap(key1,value1)--->list(key2,value2)\nreduce(list(key2,value2))--->list(key3,value3)\nlist(key2,value2)作为reducer的输入,list(value2)=(V1,V2,V3...,Vn),其本身是无序的.\n二次排序的目标就是让reducer收到的值有某种顺序.\n<!-- more--> \n**4. 问题引入**\n\n假如我们有一组温度数据,按照'年\\月\\日\\温度'的格式存储, 我们希望输入每一个年月的温度,并且按照升序排序:\n\n```\n2012-01: 5, 10, 25, 30...\n2012-02: 18, 25, 30...\n2012-08: 13, 20, 35...\n```\n\n#### 二. 二次排序问题的解决方案\n\n* 1.让reducer读取和缓存给定键的所有值,然后对这些值完成in-reducer排序,数据量大时可能导致内存溢出\n* 2.使用MapReduce框架对reducer值排序(这样就不需要再对传入reducer的值进行reducer中的排序),这种方法\"会为自然键增加部分或整个值来创建一个组合键以实现排序目标\",不会造成内存溢出\n  * 使用键值转换设计模式:构造一组中间键(K, V1),其中V1是次键,K称为自然键,要在reducer键中注入一个值,只需要创建一个组合键.在本例中,V1就是温度数据\n  * 让MapReduce执行框架完成排序(利用集群的力量)\n  * 保留多个键值对状态来完成处理,可以适当利用mapper的partitioner来实现.\n\n**1.中间键的排序顺序**\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-6-4/84337503.jpg)\n\n要实现二次排序,我们需要控制中间键的排序顺序,以及reducer处理键的顺序,首先要在组合键中注入一个值(temperature),然后控制中间键的排序顺序.\n\n因为希望reducer按照温度排序,所以增加temperature.要用compareTo方法指出如何对DateTemperaturePair对象排序.\n\n>  在Hadoop中,要持久存储定制数据类型,则必须实现Writable接口,要比较定制数据类型,必须实现WritableComparable接口\n\n```java\npublic class DateTemperaturePair implements Writable, WritableComparable<DateTemperaturePair> {\n    private final Text yearMonth = new Text();\n    private final Text day = new Text();\n    private final IntWritable temperature = new IntWritable();\n\n\n    public DateTemperaturePair() {\n    }\n\n    public DateTemperaturePair(String yearMonth, String day, int temperature) {\n        this.yearMonth.set(yearMonth);\n        this.day.set(day);\n        this.temperature.set(temperature);\n    }\n\n    public static DateTemperaturePair read(DataInput in) throws IOException {\n        DateTemperaturePair pair = new DateTemperaturePair();\n        pair.readFields(in);\n        return pair;\n    }\n\n    @Override\n    public void write(DataOutput dataOutput) throws IOException {\n        yearMonth.write(dataOutput);\n        day.write(dataOutput);\n        temperature.write(dataOutput);\n    }\n\n    @Override\n    public void readFields(DataInput in) throws IOException {\n        yearMonth.readFields(in);\n        day.readFields(in);\n        temperature.readFields(in);\n    }\n\n\n    public void setYearMonth(String yearMonthAsString) {\n        yearMonth.set(yearMonthAsString);\n    }\n\n    public void setTemperature(int Temp) {\n        temperature.set(Temp);\n    }\n\n    public void setDay(String dayAsString) {\n        day.set(dayAsString);\n    }\n\n    public Text getYearMonth() {\n        return yearMonth;\n    }\n\n    public Text getDay() {\n        return day;\n    }\n\n    public IntWritable getTemperature() {\n        return temperature;\n    }\n\n    public int compareTo(DateTemperaturePair pair) {\n        int compareValue = this.yearMonth.compareTo(pair.getYearMonth());\n        if (compareValue == 0) {\n            compareValue = temperature.compareTo(pair.getTemperature());\n        }\n        return -1 * compareValue;//降序排序\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DateTemperaturePair that = (DateTemperaturePair) o;\n        if (temperature != null ? !temperature.equals(that.temperature) : that.temperature != null) {\n            return false;\n        }\n        if (yearMonth != null ? !yearMonth.equals(that.yearMonth) : that.yearMonth != yearMonth) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = yearMonth != null ? yearMonth.hashCode() : 0;\n        result = 31 * result + (temperature != null ? temperature.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"DateTemperaturePair{\" +\n                \"yearMonth=\" + yearMonth +\n                \", day=\" + day +\n                \", temperature=\" + temperature +\n                '}';\n    }\n}\n```\n\n2.定制分区器\n\npartitioner会根据mapper输出的键来决定将其输出发送到那个表reducer，为此我们需要：\n\n​\t1.一个定制partitioner控制哪个reducer处理哪些键\n\n​\t2.一个定制比较器对reducer值排序\n\n定制分区器会确保具有相同键（自然键，并非包含temperature的组合键）的所有数据都发送给同一个reducer，定制比较器会完成排序，保证数据一到达reducer就会按自然键对数据分组。\n\n```java\npublic class DateTemperaturePartitioner extends Partitioner<DateTemperaturePair, Text> {\n    @Override\n    public int getPartition(DateTemperaturePair dateTemperaturePair, Text text, int i) {\n        return Math.abs(dateTemperaturePair.getYearMonth().hashCode() % i);\n    }\n}\n```\n\n3.分组比较器\n\n```java\n/**\n * @author lihe\n * @Title:\n * @Description: 分组比较器，控制哪些键分组到一个reduce函数调用\n * @date 2018/6/7上午11:33\n */\npublic class DateTempratureGroupingComparator  extends WritableComparator {\n    public DateTempratureGroupingComparator() {\n        super(DateTemperaturePair.class, true);\n    }\n\n    @Override\n    public int compare(WritableComparable a, WritableComparable b) {\n        DateTemperaturePair pair = (DateTemperaturePair) a;\n        DateTemperaturePair pair2 = (DateTemperaturePair) b;\n        return pair.getYearMonth().compareTo(pair2.getYearMonth());\n    }\n}\n```\n\n#### 三、MAPREDUCER/Hadoop的二次排序解决方案\n\n**输入：**\n\n<year><,><month><,><day><,><temperature>\n\n示例：\n\n2012，01，01，35\n\n2012，12，23，-4\n\n**期望输出：**\n\n<year><-><month>:<temperature><,><temperature><,>...\n\n其中<temperature1> <= <temperature2> <= ...\n\n示例：\n2012-01: 5，10，13，30，...\n\n2012-03: 12，23，31， ...\n\n**map()函数**\n\n```java\n/**\n * @author harold\n * @Title:\n * @Description: map()函数完成解析和词法分析，然后将temperature注入到reducer键中\n * @date 2018/6/7下午1:34\n */\npublic class SecondarySortMapper extends Mapper<LongWritable, Text, DateTemperaturePair, Text> {\n\n    private final Text theTemperature = new Text();\n    private final DateTemperaturePair pair = new DateTemperaturePair();\n\n    @Override\n    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n        String line = value.toString();\n        String [] tokens = line.split(\",\");\n        String yearMonth = tokens[0] + tokens[1];\n        String day = tokens[2];\n        int temperature = Integer.parseInt(tokens[3]);\n\n        pair.setDay(day);\n        pair.setTemperature(temperature);\n        pair.setYearMonth(yearMonth);\n        theTemperature.set(tokens[3]);\n\n        context.write(pair, theTemperature);\n    }\n}\n```\n\n**reduce()函数**\n\n```java\n/**\n * @author lihe\n * @Title:\n * @Description: 连接值\n * @date 2018/6/7下午1:44\n */\npublic class SecondarySortReducer  extends Reducer<DateTemperaturePair, Text, Text, Text> {\n    @Override\n    protected void reduce(DateTemperaturePair key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n        StringBuilder builder = new StringBuilder();\n        for (Text value : values) {\n            builder.append(value.toString());\n            builder.append(\",\");\n        }\n        context.write(key.getYearMonth(), new Text(builder.toString()));\n    }\n}\n```\n\n**驱动函数**\n\n第一个比较器（DateTemperaturePair.compareTo()）方法会控制键的排序顺序，第二个比较器（DateTemperatureGroupingComparator.compare()）方法会控制哪些键分到一个reducer（）。通过这两个比较器，建立作业时就好像定义了值得顺序一样。\n\n```java\n/**\n * @author lihe\n * @Title:\n * @Description: 驱动器\n * @date 2018/6/7下午1:54\n */\npublic class SecondarySortDriver extends Configured implements Tool {\n\n    private static Logger theLogger = Logger.getLogger(SecondarySortDriver.class);\n\n    @Override\n    public int run(String[] args) throws Exception {\n        Configuration conf = getConf();\n        Job job = new Job(conf);\n        job.setJarByClass(SecondarySortDriver.class);\n        job.setJobName(\"SecondarySort\");\n\n        FileInputFormat.setInputPaths(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[1]));\n\n        job.setMapOutputKeyClass(DateTemperaturePair.class);\n        job.setMapOutputValueClass(Text.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setMapperClass(SecondarySortMapper.class);\n        job.setReducerClass(SecondarySortReducer.class);\n        job.setPartitionerClass(DateTemperaturePartitioner.class);\n        job.setGroupingComparatorClass(DateTempratureGroupingComparator.class);\n\n        boolean status = job.waitForCompletion(true);\n        theLogger.info(\"run: status\" + status);\n        return status ? 0 : 1;\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            theLogger.warn(\"SecondarySortDriver <input-dir> <output-dir>\");\n            throw new IllegalArgumentException(\"SecondarySortDriver <input-dir> <output-dir>\");\n        }\n\n        int returnStatus = ToolRunner.run(new SecondarySortDriver(), args);\n        theLogger.info(\"returnStatus=\" + returnStatus);\n        System.exit(returnStatus);\n    }\n}\n```\n","slug":"数据算法-二次排序","published":1,"updated":"2018-06-07T11:40:45.000Z","_id":"cji4l7i7q003mcf96auoju0ds","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"一-二次排序-secondary-sort-问题的引出\"><a href=\"#一-二次排序-secondary-sort-问题的引出\" class=\"headerlink\" title=\"一. 二次排序(secondary sort)问题的引出\"></a>一. 二次排序(secondary sort)问题的引出</h4><p><strong>1. 二次排序</strong>:</p>\n<p>在reduce阶段对与某个键关联的值排序,又称为键值转换;</p>\n<p><strong>2. MR中的排序:</strong></p>\n<p>MapReduce框架会自动对mapper生成的键排序,说明在启动reducer之前,mapper生成的所有中间键值对必然是<strong>按键有序</strong>的.但是传入reducer的值并不是有序的,他们可能有任意的顺序,要想对reducer中的值进行排序,可以用二次排序设计模式实现.</p>\n<p><strong>3. 通过MR的范式分析二次排序</strong>:</p>\n<p>map(key1,value1)—&gt;list(key2,value2)<br>reduce(list(key2,value2))—&gt;list(key3,value3)<br>list(key2,value2)作为reducer的输入,list(value2)=(V1,V2,V3…,Vn),其本身是无序的.<br>二次排序的目标就是让reducer收到的值有某种顺序.<br><a id=\"more\"></a><br><strong>4. 问题引入</strong></p>\n<p>假如我们有一组温度数据,按照’年\\月\\日\\温度’的格式存储, 我们希望输入每一个年月的温度,并且按照升序排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2012-01: 5, 10, 25, 30...</span><br><span class=\"line\">2012-02: 18, 25, 30...</span><br><span class=\"line\">2012-08: 13, 20, 35...</span><br></pre></td></tr></table></figure>\n<h4 id=\"二-二次排序问题的解决方案\"><a href=\"#二-二次排序问题的解决方案\" class=\"headerlink\" title=\"二. 二次排序问题的解决方案\"></a>二. 二次排序问题的解决方案</h4><ul>\n<li>1.让reducer读取和缓存给定键的所有值,然后对这些值完成in-reducer排序,数据量大时可能导致内存溢出</li>\n<li>2.使用MapReduce框架对reducer值排序(这样就不需要再对传入reducer的值进行reducer中的排序),这种方法”会为自然键增加部分或整个值来创建一个组合键以实现排序目标”,不会造成内存溢出<ul>\n<li>使用键值转换设计模式:构造一组中间键(K, V1),其中V1是次键,K称为自然键,要在reducer键中注入一个值,只需要创建一个组合键.在本例中,V1就是温度数据</li>\n<li>让MapReduce执行框架完成排序(利用集群的力量)</li>\n<li>保留多个键值对状态来完成处理,可以适当利用mapper的partitioner来实现.</li>\n</ul>\n</li>\n</ul>\n<p><strong>1.中间键的排序顺序</strong></p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-6-4/84337503.jpg\" alt=\"\"></p>\n<p>要实现二次排序,我们需要控制中间键的排序顺序,以及reducer处理键的顺序,首先要在组合键中注入一个值(temperature),然后控制中间键的排序顺序.</p>\n<p>因为希望reducer按照温度排序,所以增加temperature.要用compareTo方法指出如何对DateTemperaturePair对象排序.</p>\n<blockquote>\n<p> 在Hadoop中,要持久存储定制数据类型,则必须实现Writable接口,要比较定制数据类型,必须实现WritableComparable接口</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DateTemperaturePair</span> <span class=\"keyword\">implements</span> <span class=\"title\">Writable</span>, <span class=\"title\">WritableComparable</span>&lt;<span class=\"title\">DateTemperaturePair</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Text yearMonth = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Text day = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IntWritable temperature = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DateTemperaturePair</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DateTemperaturePair</span><span class=\"params\">(String yearMonth, String day, <span class=\"keyword\">int</span> temperature)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.yearMonth.set(yearMonth);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.day.set(day);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature.set(temperature);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DateTemperaturePair <span class=\"title\">read</span><span class=\"params\">(DataInput in)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        DateTemperaturePair pair = <span class=\"keyword\">new</span> DateTemperaturePair();</span><br><span class=\"line\">        pair.readFields(in);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pair;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(DataOutput dataOutput)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        yearMonth.write(dataOutput);</span><br><span class=\"line\">        day.write(dataOutput);</span><br><span class=\"line\">        temperature.write(dataOutput);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFields</span><span class=\"params\">(DataInput in)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        yearMonth.readFields(in);</span><br><span class=\"line\">        day.readFields(in);</span><br><span class=\"line\">        temperature.readFields(in);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setYearMonth</span><span class=\"params\">(String yearMonthAsString)</span> </span>&#123;</span><br><span class=\"line\">        yearMonth.set(yearMonthAsString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTemperature</span><span class=\"params\">(<span class=\"keyword\">int</span> Temp)</span> </span>&#123;</span><br><span class=\"line\">        temperature.set(Temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDay</span><span class=\"params\">(String dayAsString)</span> </span>&#123;</span><br><span class=\"line\">        day.set(dayAsString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">getYearMonth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> yearMonth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">getDay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IntWritable <span class=\"title\">getTemperature</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temperature;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(DateTemperaturePair pair)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> compareValue = <span class=\"keyword\">this</span>.yearMonth.compareTo(pair.getYearMonth());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            compareValue = temperature.compareTo(pair.getTemperature());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span> * compareValue;<span class=\"comment\">//降序排序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        DateTemperaturePair that = (DateTemperaturePair) o;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temperature != <span class=\"keyword\">null</span> ? !temperature.equals(that.temperature) : that.temperature != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (yearMonth != <span class=\"keyword\">null</span> ? !yearMonth.equals(that.yearMonth) : that.yearMonth != yearMonth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = yearMonth != <span class=\"keyword\">null</span> ? yearMonth.hashCode() : <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (temperature != <span class=\"keyword\">null</span> ? temperature.hashCode() : <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"DateTemperaturePair&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"yearMonth=\"</span> + yearMonth +</span><br><span class=\"line\">                <span class=\"string\">\", day=\"</span> + day +</span><br><span class=\"line\">                <span class=\"string\">\", temperature=\"</span> + temperature +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.定制分区器</p>\n<p>partitioner会根据mapper输出的键来决定将其输出发送到那个表reducer，为此我们需要：</p>\n<p>​    1.一个定制partitioner控制哪个reducer处理哪些键</p>\n<p>​    2.一个定制比较器对reducer值排序</p>\n<p>定制分区器会确保具有相同键（自然键，并非包含temperature的组合键）的所有数据都发送给同一个reducer，定制比较器会完成排序，保证数据一到达reducer就会按自然键对数据分组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DateTemperaturePartitioner</span> <span class=\"keyword\">extends</span> <span class=\"title\">Partitioner</span>&lt;<span class=\"title\">DateTemperaturePair</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPartition</span><span class=\"params\">(DateTemperaturePair dateTemperaturePair, Text text, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.abs(dateTemperaturePair.getYearMonth().hashCode() % i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.分组比较器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 分组比较器，控制哪些键分组到一个reduce函数调用</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7上午11:33</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DateTempratureGroupingComparator</span>  <span class=\"keyword\">extends</span> <span class=\"title\">WritableComparator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DateTempratureGroupingComparator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(DateTemperaturePair.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(WritableComparable a, WritableComparable b)</span> </span>&#123;</span><br><span class=\"line\">        DateTemperaturePair pair = (DateTemperaturePair) a;</span><br><span class=\"line\">        DateTemperaturePair pair2 = (DateTemperaturePair) b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pair.getYearMonth().compareTo(pair2.getYearMonth());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、MAPREDUCER-Hadoop的二次排序解决方案\"><a href=\"#三、MAPREDUCER-Hadoop的二次排序解决方案\" class=\"headerlink\" title=\"三、MAPREDUCER/Hadoop的二次排序解决方案\"></a>三、MAPREDUCER/Hadoop的二次排序解决方案</h4><p><strong>输入：</strong></p>\n<p><year>&lt;,&gt;<month>&lt;,&gt;<day>&lt;,&gt;<temperature></temperature></day></month></year></p>\n<p>示例：</p>\n<p>2012，01，01，35</p>\n<p>2012，12，23，-4</p>\n<p><strong>期望输出：</strong></p>\n<p><year><-><month>:<temperature>&lt;,&gt;<temperature>&lt;,&gt;…</temperature></temperature></month></-></year></p>\n<p>其中<temperature1> &lt;= <temperature2> &lt;= …</temperature2></temperature1></p>\n<p>示例：<br>2012-01: 5，10，13，30，…</p>\n<p>2012-03: 12，23，31， …</p>\n<p><strong>map()函数</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: map()函数完成解析和词法分析，然后将temperature注入到reducer键中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7下午1:34</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondarySortMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">DateTemperaturePair</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Text theTemperature = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DateTemperaturePair pair = <span class=\"keyword\">new</span> DateTemperaturePair();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String line = value.toString();</span><br><span class=\"line\">        String [] tokens = line.split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">        String yearMonth = tokens[<span class=\"number\">0</span>] + tokens[<span class=\"number\">1</span>];</span><br><span class=\"line\">        String day = tokens[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temperature = Integer.parseInt(tokens[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        pair.setDay(day);</span><br><span class=\"line\">        pair.setTemperature(temperature);</span><br><span class=\"line\">        pair.setYearMonth(yearMonth);</span><br><span class=\"line\">        theTemperature.set(tokens[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        context.write(pair, theTemperature);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>reduce()函数</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 连接值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7下午1:44</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondarySortReducer</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">DateTemperaturePair</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(DateTemperaturePair key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Text value : values) &#123;</span><br><span class=\"line\">            builder.append(value.toString());</span><br><span class=\"line\">            builder.append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.write(key.getYearMonth(), <span class=\"keyword\">new</span> Text(builder.toString()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>驱动函数</strong></p>\n<p>第一个比较器（DateTemperaturePair.compareTo()）方法会控制键的排序顺序，第二个比较器（DateTemperatureGroupingComparator.compare()）方法会控制哪些键分到一个reducer（）。通过这两个比较器，建立作业时就好像定义了值得顺序一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 驱动器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7下午1:54</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondarySortDriver</span> <span class=\"keyword\">extends</span> <span class=\"title\">Configured</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Logger theLogger = Logger.getLogger(SecondarySortDriver.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">run</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Configuration conf = getConf();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf);</span><br><span class=\"line\">        job.setJarByClass(SecondarySortDriver.class);</span><br><span class=\"line\">        job.setJobName(<span class=\"string\">\"SecondarySort\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(args[<span class=\"number\">1</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapOutputKeyClass(DateTemperaturePair.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(SecondarySortMapper.class);</span><br><span class=\"line\">        job.setReducerClass(SecondarySortReducer.class);</span><br><span class=\"line\">        job.setPartitionerClass(DateTemperaturePartitioner.class);</span><br><span class=\"line\">        job.setGroupingComparatorClass(DateTempratureGroupingComparator.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> status = job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        theLogger.info(<span class=\"string\">\"run: status\"</span> + status);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> status ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            theLogger.warn(<span class=\"string\">\"SecondarySortDriver &lt;input-dir&gt; &lt;output-dir&gt;\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"SecondarySortDriver &lt;input-dir&gt; &lt;output-dir&gt;\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> returnStatus = ToolRunner.run(<span class=\"keyword\">new</span> SecondarySortDriver(), args);</span><br><span class=\"line\">        theLogger.info(<span class=\"string\">\"returnStatus=\"</span> + returnStatus);</span><br><span class=\"line\">        System.exit(returnStatus);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"一-二次排序-secondary-sort-问题的引出\"><a href=\"#一-二次排序-secondary-sort-问题的引出\" class=\"headerlink\" title=\"一. 二次排序(secondary sort)问题的引出\"></a>一. 二次排序(secondary sort)问题的引出</h4><p><strong>1. 二次排序</strong>:</p>\n<p>在reduce阶段对与某个键关联的值排序,又称为键值转换;</p>\n<p><strong>2. MR中的排序:</strong></p>\n<p>MapReduce框架会自动对mapper生成的键排序,说明在启动reducer之前,mapper生成的所有中间键值对必然是<strong>按键有序</strong>的.但是传入reducer的值并不是有序的,他们可能有任意的顺序,要想对reducer中的值进行排序,可以用二次排序设计模式实现.</p>\n<p><strong>3. 通过MR的范式分析二次排序</strong>:</p>\n<p>map(key1,value1)—&gt;list(key2,value2)<br>reduce(list(key2,value2))—&gt;list(key3,value3)<br>list(key2,value2)作为reducer的输入,list(value2)=(V1,V2,V3…,Vn),其本身是无序的.<br>二次排序的目标就是让reducer收到的值有某种顺序.<br>","more":"<br><strong>4. 问题引入</strong></p>\n<p>假如我们有一组温度数据,按照’年\\月\\日\\温度’的格式存储, 我们希望输入每一个年月的温度,并且按照升序排序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2012-01: 5, 10, 25, 30...</span><br><span class=\"line\">2012-02: 18, 25, 30...</span><br><span class=\"line\">2012-08: 13, 20, 35...</span><br></pre></td></tr></table></figure>\n<h4 id=\"二-二次排序问题的解决方案\"><a href=\"#二-二次排序问题的解决方案\" class=\"headerlink\" title=\"二. 二次排序问题的解决方案\"></a>二. 二次排序问题的解决方案</h4><ul>\n<li>1.让reducer读取和缓存给定键的所有值,然后对这些值完成in-reducer排序,数据量大时可能导致内存溢出</li>\n<li>2.使用MapReduce框架对reducer值排序(这样就不需要再对传入reducer的值进行reducer中的排序),这种方法”会为自然键增加部分或整个值来创建一个组合键以实现排序目标”,不会造成内存溢出<ul>\n<li>使用键值转换设计模式:构造一组中间键(K, V1),其中V1是次键,K称为自然键,要在reducer键中注入一个值,只需要创建一个组合键.在本例中,V1就是温度数据</li>\n<li>让MapReduce执行框架完成排序(利用集群的力量)</li>\n<li>保留多个键值对状态来完成处理,可以适当利用mapper的partitioner来实现.</li>\n</ul>\n</li>\n</ul>\n<p><strong>1.中间键的排序顺序</strong></p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-6-4/84337503.jpg\" alt=\"\"></p>\n<p>要实现二次排序,我们需要控制中间键的排序顺序,以及reducer处理键的顺序,首先要在组合键中注入一个值(temperature),然后控制中间键的排序顺序.</p>\n<p>因为希望reducer按照温度排序,所以增加temperature.要用compareTo方法指出如何对DateTemperaturePair对象排序.</p>\n<blockquote>\n<p> 在Hadoop中,要持久存储定制数据类型,则必须实现Writable接口,要比较定制数据类型,必须实现WritableComparable接口</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DateTemperaturePair</span> <span class=\"keyword\">implements</span> <span class=\"title\">Writable</span>, <span class=\"title\">WritableComparable</span>&lt;<span class=\"title\">DateTemperaturePair</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Text yearMonth = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Text day = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IntWritable temperature = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DateTemperaturePair</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DateTemperaturePair</span><span class=\"params\">(String yearMonth, String day, <span class=\"keyword\">int</span> temperature)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.yearMonth.set(yearMonth);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.day.set(day);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature.set(temperature);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DateTemperaturePair <span class=\"title\">read</span><span class=\"params\">(DataInput in)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        DateTemperaturePair pair = <span class=\"keyword\">new</span> DateTemperaturePair();</span><br><span class=\"line\">        pair.readFields(in);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pair;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(DataOutput dataOutput)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        yearMonth.write(dataOutput);</span><br><span class=\"line\">        day.write(dataOutput);</span><br><span class=\"line\">        temperature.write(dataOutput);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFields</span><span class=\"params\">(DataInput in)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        yearMonth.readFields(in);</span><br><span class=\"line\">        day.readFields(in);</span><br><span class=\"line\">        temperature.readFields(in);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setYearMonth</span><span class=\"params\">(String yearMonthAsString)</span> </span>&#123;</span><br><span class=\"line\">        yearMonth.set(yearMonthAsString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTemperature</span><span class=\"params\">(<span class=\"keyword\">int</span> Temp)</span> </span>&#123;</span><br><span class=\"line\">        temperature.set(Temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDay</span><span class=\"params\">(String dayAsString)</span> </span>&#123;</span><br><span class=\"line\">        day.set(dayAsString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">getYearMonth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> yearMonth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Text <span class=\"title\">getDay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IntWritable <span class=\"title\">getTemperature</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temperature;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(DateTemperaturePair pair)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> compareValue = <span class=\"keyword\">this</span>.yearMonth.compareTo(pair.getYearMonth());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareValue == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            compareValue = temperature.compareTo(pair.getTemperature());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span> * compareValue;<span class=\"comment\">//降序排序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        DateTemperaturePair that = (DateTemperaturePair) o;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temperature != <span class=\"keyword\">null</span> ? !temperature.equals(that.temperature) : that.temperature != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (yearMonth != <span class=\"keyword\">null</span> ? !yearMonth.equals(that.yearMonth) : that.yearMonth != yearMonth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = yearMonth != <span class=\"keyword\">null</span> ? yearMonth.hashCode() : <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (temperature != <span class=\"keyword\">null</span> ? temperature.hashCode() : <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"DateTemperaturePair&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"yearMonth=\"</span> + yearMonth +</span><br><span class=\"line\">                <span class=\"string\">\", day=\"</span> + day +</span><br><span class=\"line\">                <span class=\"string\">\", temperature=\"</span> + temperature +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.定制分区器</p>\n<p>partitioner会根据mapper输出的键来决定将其输出发送到那个表reducer，为此我们需要：</p>\n<p>​    1.一个定制partitioner控制哪个reducer处理哪些键</p>\n<p>​    2.一个定制比较器对reducer值排序</p>\n<p>定制分区器会确保具有相同键（自然键，并非包含temperature的组合键）的所有数据都发送给同一个reducer，定制比较器会完成排序，保证数据一到达reducer就会按自然键对数据分组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DateTemperaturePartitioner</span> <span class=\"keyword\">extends</span> <span class=\"title\">Partitioner</span>&lt;<span class=\"title\">DateTemperaturePair</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPartition</span><span class=\"params\">(DateTemperaturePair dateTemperaturePair, Text text, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.abs(dateTemperaturePair.getYearMonth().hashCode() % i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.分组比较器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 分组比较器，控制哪些键分组到一个reduce函数调用</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7上午11:33</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DateTempratureGroupingComparator</span>  <span class=\"keyword\">extends</span> <span class=\"title\">WritableComparator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DateTempratureGroupingComparator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(DateTemperaturePair.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(WritableComparable a, WritableComparable b)</span> </span>&#123;</span><br><span class=\"line\">        DateTemperaturePair pair = (DateTemperaturePair) a;</span><br><span class=\"line\">        DateTemperaturePair pair2 = (DateTemperaturePair) b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pair.getYearMonth().compareTo(pair2.getYearMonth());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、MAPREDUCER-Hadoop的二次排序解决方案\"><a href=\"#三、MAPREDUCER-Hadoop的二次排序解决方案\" class=\"headerlink\" title=\"三、MAPREDUCER/Hadoop的二次排序解决方案\"></a>三、MAPREDUCER/Hadoop的二次排序解决方案</h4><p><strong>输入：</strong></p>\n<p><year>&lt;,&gt;<month>&lt;,&gt;<day>&lt;,&gt;<temperature></temperature></day></month></year></p>\n<p>示例：</p>\n<p>2012，01，01，35</p>\n<p>2012，12，23，-4</p>\n<p><strong>期望输出：</strong></p>\n<p><year><-><month>:<temperature>&lt;,&gt;<temperature>&lt;,&gt;…</temperature></temperature></month></-></year></p>\n<p>其中<temperature1> &lt;= <temperature2> &lt;= …</temperature2></temperature1></p>\n<p>示例：<br>2012-01: 5，10，13，30，…</p>\n<p>2012-03: 12，23，31， …</p>\n<p><strong>map()函数</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> harold</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: map()函数完成解析和词法分析，然后将temperature注入到reducer键中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7下午1:34</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondarySortMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">DateTemperaturePair</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Text theTemperature = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DateTemperaturePair pair = <span class=\"keyword\">new</span> DateTemperaturePair();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String line = value.toString();</span><br><span class=\"line\">        String [] tokens = line.split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">        String yearMonth = tokens[<span class=\"number\">0</span>] + tokens[<span class=\"number\">1</span>];</span><br><span class=\"line\">        String day = tokens[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temperature = Integer.parseInt(tokens[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        pair.setDay(day);</span><br><span class=\"line\">        pair.setTemperature(temperature);</span><br><span class=\"line\">        pair.setYearMonth(yearMonth);</span><br><span class=\"line\">        theTemperature.set(tokens[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        context.write(pair, theTemperature);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>reduce()函数</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 连接值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7下午1:44</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondarySortReducer</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">DateTemperaturePair</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(DateTemperaturePair key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Text value : values) &#123;</span><br><span class=\"line\">            builder.append(value.toString());</span><br><span class=\"line\">            builder.append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.write(key.getYearMonth(), <span class=\"keyword\">new</span> Text(builder.toString()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>驱动函数</strong></p>\n<p>第一个比较器（DateTemperaturePair.compareTo()）方法会控制键的排序顺序，第二个比较器（DateTemperatureGroupingComparator.compare()）方法会控制哪些键分到一个reducer（）。通过这两个比较器，建立作业时就好像定义了值得顺序一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lihe</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Title</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 驱动器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/6/7下午1:54</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondarySortDriver</span> <span class=\"keyword\">extends</span> <span class=\"title\">Configured</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Logger theLogger = Logger.getLogger(SecondarySortDriver.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">run</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Configuration conf = getConf();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf);</span><br><span class=\"line\">        job.setJarByClass(SecondarySortDriver.class);</span><br><span class=\"line\">        job.setJobName(<span class=\"string\">\"SecondarySort\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(args[<span class=\"number\">1</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapOutputKeyClass(DateTemperaturePair.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(SecondarySortMapper.class);</span><br><span class=\"line\">        job.setReducerClass(SecondarySortReducer.class);</span><br><span class=\"line\">        job.setPartitionerClass(DateTemperaturePartitioner.class);</span><br><span class=\"line\">        job.setGroupingComparatorClass(DateTempratureGroupingComparator.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> status = job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        theLogger.info(<span class=\"string\">\"run: status\"</span> + status);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> status ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            theLogger.warn(<span class=\"string\">\"SecondarySortDriver &lt;input-dir&gt; &lt;output-dir&gt;\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"SecondarySortDriver &lt;input-dir&gt; &lt;output-dir&gt;\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> returnStatus = ToolRunner.run(<span class=\"keyword\">new</span> SecondarySortDriver(), args);</span><br><span class=\"line\">        theLogger.info(<span class=\"string\">\"returnStatus=\"</span> + returnStatus);</span><br><span class=\"line\">        System.exit(returnStatus);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"特征提取方法:one-hot和TF-IDF","date":"2018-05-26T16:16:19.000Z","_content":"\n【转自https://www.cnblogs.com/lianyingteng/p/7755545.html】\n\none-hot 和 TF-IDF是目前最为常见的用于提取文本特征的方法，本文主要介绍两种方法的思想以及优缺点。\n\n## 1. one-hot\n\n### 1.1 one-hot编码\n\n　　什么是one-hot编码？one-hot编码，又称独热编码、一位有效编码。其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。<!-- more-->举个例子，假设我们有四个样本（行），每个样本有三个特征（列），如图：\n\n　　　　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030163200996-742440926.png)\n\n上图中我们已经对每个特征进行了普通的数字编码：我们的feature_1有两种可能的取值，比如是男/女，这里男用1表示，女用2表示。那么one-hot编码是怎么搞的呢？我们再拿feature_2来说明：\n\n这里feature_2 有4种取值（状态），我们就用4个状态位来表示这个特征，one-hot编码就是保证每个样本中的单个特征只有1位处于状态1，其他的都是0。\n\n　　　　　 ![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030164625793-1703194224.png)\n\n对于2种状态、三种状态、甚至更多状态都是这样表示，所以我们可以得到这些样本特征的新表示：\n\n　　　　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165132480-1341638518.png)\n\none-hot编码将每个状态位都看成一个特征。对于前两个样本我们可以得到它的特征向量分别为\n\n　　　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165731683-1946521226.png)\n\n### 1.2 one-hot在提取文本特征上的应用\n\n　　one hot在特征提取上属于词袋模型（bag of words）。关于如何使用one-hot抽取文本特征向量我们通过以下例子来说明。假设我们的语料库中有三段话：\n\n　　　　我爱中国\n\n　　　　爸爸妈妈爱我\n\n　　　　爸爸妈妈爱中国\n\n我们首先对预料库分离并获取其中所有的词，然后对每个此进行编号：\n\n　　　　1 我； 2 爱； 3 爸爸； 4 妈妈；5 中国\n\n然后使用one hot对每段话提取特征向量：\n\n　![img](https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103420622-1037006116.png)；![img](https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103811778-399990946.png)；![img](https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103938778-1278932628.png)\n\n因此我们得到了最终的特征向量为\n\n　　　　我爱中国 　->　　　1，1，0，0，1\n\n　　　　爸爸妈妈爱我　　->　　1，1，1，1，0\n\n　　　　爸爸妈妈爱中国　　->　　0，1，1，1，1\n\n \n\n### 优缺点分析\n\n**优点：**一是解决了分类器不好处理离散数据的问题，二是在一定程度上也起到了扩充特征的作用（上面样本特征数从3扩展到了9）\n\n**缺点：**在文本特征表示上有些缺点就非常突出了。首先，它是一个词袋模型，不考虑词与词之间的顺序（文本中词的顺序信息也是很重要的）；其次，它假设词与词相互独立（在大多数情况下，词与词是相互影响的）；最后，它得到的特征是离散稀疏的。\n\n### sklearn实现one hot encode\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\nfrom sklearn import preprocessing  \n      \nenc = preprocessing.OneHotEncoder()  # 创建对象\nenc.fit([[0,0,3],[1,1,0],[0,2,1],[1,0,2]])   # 拟合\narray = enc.transform([[0,1,3]]).toarray()  # 转化\nprint(array)\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n \n\n## 2. TF-IDF\n\n　　IF-IDF是信息检索（IR）中最常用的一种文本表示法。算法的思想也很简单，就是统计每个词出现的词频（TF），然后再为其附上一个权值参数（IDF）。举个例子：\n\n　　现在假设我们要统计一篇文档中的前10个关键词，应该怎么下手？首先想到的是统计一下文档中每个词出现的频率（TF），词频越高，这个词就越重要。但是统计完你可能会发现你得到的关键词基本都是“的”、“是”、“为”这样没有实际意义的词（停用词），这个问题怎么解决呢？你可能会想到为每个词都加一个权重，像这种”停用词“就加一个很小的权重（甚至是置为0），这个权重就是IDF。下面再来看看公式：\n\n　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030184644027-2546042.png)![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030185050808-1214386978.png)\n\nIF应该很容易理解就是计算词频，IDF衡量词的常见程度。为了计算IDF我们需要事先准备一个语料库用来模拟语言的使用环境，如果一个词越是常见，那么式子中分母就越大，逆文档频率就越小越接近于0。这里的分母+1是为了避免分母为0的情况出现。TF-IDF的计算公式如下：\n\n　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030194100761-48755487.png)\n\n根据公式很容易看出，TF-IDF的值与该词在文章中出现的频率成正比，与该词在整个语料库中出现的频率成反比，因此可以很好的实现提取文章中关键词的目的。\n\n### 优缺点分析\n\n**优点：**简单快速，结果比较符合实际\n\n**缺点：**单纯考虑词频，忽略了词与词的位置信息以及词与词之间的相互关系。\n\n### sklearn实现tfidf\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\nfrom sklearn.feature_extraction.text import CountVectorizer  \nfrom sklearn.feature_extraction.text import TfidfTransformer\n\ntag_list = ['青年 吃货 唱歌',  \n            '少年 游戏 叛逆',  \n            '少年 吃货 足球'] \n\nvectorizer = CountVectorizer() #将文本中的词语转换为词频矩阵  \nX = vectorizer.fit_transform(tag_list) #计算个词语出现的次数\n\"\"\"\nword_dict = vectorizer.vocabulary_\n{'唱歌': 2, '吃货': 1, '青年': 6, '足球': 5, '叛逆': 0, '少年': 3, '游戏': 4}\n\"\"\"\n\ntransformer = TfidfTransformer()  \ntfidf = transformer.fit_transform(X)  #将词频矩阵X统计成TF-IDF值  \nprint(tfidf.toarray())\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n ","source":"_posts/特征提取方法-one-hot和TF-IDF.md","raw":"---\ntitle: '特征提取方法:one-hot和TF-IDF'\ndate: 2018-05-27 00:16:19\ntags: [机器学习, 大数据]\n---\n\n【转自https://www.cnblogs.com/lianyingteng/p/7755545.html】\n\none-hot 和 TF-IDF是目前最为常见的用于提取文本特征的方法，本文主要介绍两种方法的思想以及优缺点。\n\n## 1. one-hot\n\n### 1.1 one-hot编码\n\n　　什么是one-hot编码？one-hot编码，又称独热编码、一位有效编码。其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。<!-- more-->举个例子，假设我们有四个样本（行），每个样本有三个特征（列），如图：\n\n　　　　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030163200996-742440926.png)\n\n上图中我们已经对每个特征进行了普通的数字编码：我们的feature_1有两种可能的取值，比如是男/女，这里男用1表示，女用2表示。那么one-hot编码是怎么搞的呢？我们再拿feature_2来说明：\n\n这里feature_2 有4种取值（状态），我们就用4个状态位来表示这个特征，one-hot编码就是保证每个样本中的单个特征只有1位处于状态1，其他的都是0。\n\n　　　　　 ![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030164625793-1703194224.png)\n\n对于2种状态、三种状态、甚至更多状态都是这样表示，所以我们可以得到这些样本特征的新表示：\n\n　　　　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165132480-1341638518.png)\n\none-hot编码将每个状态位都看成一个特征。对于前两个样本我们可以得到它的特征向量分别为\n\n　　　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165731683-1946521226.png)\n\n### 1.2 one-hot在提取文本特征上的应用\n\n　　one hot在特征提取上属于词袋模型（bag of words）。关于如何使用one-hot抽取文本特征向量我们通过以下例子来说明。假设我们的语料库中有三段话：\n\n　　　　我爱中国\n\n　　　　爸爸妈妈爱我\n\n　　　　爸爸妈妈爱中国\n\n我们首先对预料库分离并获取其中所有的词，然后对每个此进行编号：\n\n　　　　1 我； 2 爱； 3 爸爸； 4 妈妈；5 中国\n\n然后使用one hot对每段话提取特征向量：\n\n　![img](https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103420622-1037006116.png)；![img](https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103811778-399990946.png)；![img](https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103938778-1278932628.png)\n\n因此我们得到了最终的特征向量为\n\n　　　　我爱中国 　->　　　1，1，0，0，1\n\n　　　　爸爸妈妈爱我　　->　　1，1，1，1，0\n\n　　　　爸爸妈妈爱中国　　->　　0，1，1，1，1\n\n \n\n### 优缺点分析\n\n**优点：**一是解决了分类器不好处理离散数据的问题，二是在一定程度上也起到了扩充特征的作用（上面样本特征数从3扩展到了9）\n\n**缺点：**在文本特征表示上有些缺点就非常突出了。首先，它是一个词袋模型，不考虑词与词之间的顺序（文本中词的顺序信息也是很重要的）；其次，它假设词与词相互独立（在大多数情况下，词与词是相互影响的）；最后，它得到的特征是离散稀疏的。\n\n### sklearn实现one hot encode\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\nfrom sklearn import preprocessing  \n      \nenc = preprocessing.OneHotEncoder()  # 创建对象\nenc.fit([[0,0,3],[1,1,0],[0,2,1],[1,0,2]])   # 拟合\narray = enc.transform([[0,1,3]]).toarray()  # 转化\nprint(array)\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n \n\n## 2. TF-IDF\n\n　　IF-IDF是信息检索（IR）中最常用的一种文本表示法。算法的思想也很简单，就是统计每个词出现的词频（TF），然后再为其附上一个权值参数（IDF）。举个例子：\n\n　　现在假设我们要统计一篇文档中的前10个关键词，应该怎么下手？首先想到的是统计一下文档中每个词出现的频率（TF），词频越高，这个词就越重要。但是统计完你可能会发现你得到的关键词基本都是“的”、“是”、“为”这样没有实际意义的词（停用词），这个问题怎么解决呢？你可能会想到为每个词都加一个权重，像这种”停用词“就加一个很小的权重（甚至是置为0），这个权重就是IDF。下面再来看看公式：\n\n　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030184644027-2546042.png)![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030185050808-1214386978.png)\n\nIF应该很容易理解就是计算词频，IDF衡量词的常见程度。为了计算IDF我们需要事先准备一个语料库用来模拟语言的使用环境，如果一个词越是常见，那么式子中分母就越大，逆文档频率就越小越接近于0。这里的分母+1是为了避免分母为0的情况出现。TF-IDF的计算公式如下：\n\n　　　![img](https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030194100761-48755487.png)\n\n根据公式很容易看出，TF-IDF的值与该词在文章中出现的频率成正比，与该词在整个语料库中出现的频率成反比，因此可以很好的实现提取文章中关键词的目的。\n\n### 优缺点分析\n\n**优点：**简单快速，结果比较符合实际\n\n**缺点：**单纯考虑词频，忽略了词与词的位置信息以及词与词之间的相互关系。\n\n### sklearn实现tfidf\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\nfrom sklearn.feature_extraction.text import CountVectorizer  \nfrom sklearn.feature_extraction.text import TfidfTransformer\n\ntag_list = ['青年 吃货 唱歌',  \n            '少年 游戏 叛逆',  \n            '少年 吃货 足球'] \n\nvectorizer = CountVectorizer() #将文本中的词语转换为词频矩阵  \nX = vectorizer.fit_transform(tag_list) #计算个词语出现的次数\n\"\"\"\nword_dict = vectorizer.vocabulary_\n{'唱歌': 2, '吃货': 1, '青年': 6, '足球': 5, '叛逆': 0, '少年': 3, '游戏': 4}\n\"\"\"\n\ntransformer = TfidfTransformer()  \ntfidf = transformer.fit_transform(X)  #将词频矩阵X统计成TF-IDF值  \nprint(tfidf.toarray())\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n ","slug":"特征提取方法-one-hot和TF-IDF","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7s003pcf967bmharni","content":"<p>【转自<a href=\"https://www.cnblogs.com/lianyingteng/p/7755545.html】\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lianyingteng/p/7755545.html】</a></p>\n<p>one-hot 和 TF-IDF是目前最为常见的用于提取文本特征的方法，本文主要介绍两种方法的思想以及优缺点。</p>\n<h2 id=\"1-one-hot\"><a href=\"#1-one-hot\" class=\"headerlink\" title=\"1. one-hot\"></a>1. one-hot</h2><h3 id=\"1-1-one-hot编码\"><a href=\"#1-1-one-hot编码\" class=\"headerlink\" title=\"1.1 one-hot编码\"></a>1.1 one-hot编码</h3><p>　　什么是one-hot编码？one-hot编码，又称独热编码、一位有效编码。其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。<a id=\"more\"></a>举个例子，假设我们有四个样本（行），每个样本有三个特征（列），如图：</p>\n<p>　　　　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030163200996-742440926.png\" alt=\"img\"></p>\n<p>上图中我们已经对每个特征进行了普通的数字编码：我们的feature_1有两种可能的取值，比如是男/女，这里男用1表示，女用2表示。那么one-hot编码是怎么搞的呢？我们再拿feature_2来说明：</p>\n<p>这里feature_2 有4种取值（状态），我们就用4个状态位来表示这个特征，one-hot编码就是保证每个样本中的单个特征只有1位处于状态1，其他的都是0。</p>\n<p>　　　　　 <img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030164625793-1703194224.png\" alt=\"img\"></p>\n<p>对于2种状态、三种状态、甚至更多状态都是这样表示，所以我们可以得到这些样本特征的新表示：</p>\n<p>　　　　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165132480-1341638518.png\" alt=\"img\"></p>\n<p>one-hot编码将每个状态位都看成一个特征。对于前两个样本我们可以得到它的特征向量分别为</p>\n<p>　　　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165731683-1946521226.png\" alt=\"img\"></p>\n<h3 id=\"1-2-one-hot在提取文本特征上的应用\"><a href=\"#1-2-one-hot在提取文本特征上的应用\" class=\"headerlink\" title=\"1.2 one-hot在提取文本特征上的应用\"></a>1.2 one-hot在提取文本特征上的应用</h3><p>　　one hot在特征提取上属于词袋模型（bag of words）。关于如何使用one-hot抽取文本特征向量我们通过以下例子来说明。假设我们的语料库中有三段话：</p>\n<p>　　　　我爱中国</p>\n<p>　　　　爸爸妈妈爱我</p>\n<p>　　　　爸爸妈妈爱中国</p>\n<p>我们首先对预料库分离并获取其中所有的词，然后对每个此进行编号：</p>\n<p>　　　　1 我； 2 爱； 3 爸爸； 4 妈妈；5 中国</p>\n<p>然后使用one hot对每段话提取特征向量：</p>\n<p>　<img src=\"https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103420622-1037006116.png\" alt=\"img\">；<img src=\"https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103811778-399990946.png\" alt=\"img\">；<img src=\"https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103938778-1278932628.png\" alt=\"img\"></p>\n<p>因此我们得到了最终的特征向量为</p>\n<p>　　　　我爱中国 　-&gt;　　　1，1，0，0，1</p>\n<p>　　　　爸爸妈妈爱我　　-&gt;　　1，1，1，1，0</p>\n<p>　　　　爸爸妈妈爱中国　　-&gt;　　0，1，1，1，1</p>\n<h3 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h3><p><strong>优点：</strong>一是解决了分类器不好处理离散数据的问题，二是在一定程度上也起到了扩充特征的作用（上面样本特征数从3扩展到了9）</p>\n<p><strong>缺点：</strong>在文本特征表示上有些缺点就非常突出了。首先，它是一个词袋模型，不考虑词与词之间的顺序（文本中词的顺序信息也是很重要的）；其次，它假设词与词相互独立（在大多数情况下，词与词是相互影响的）；最后，它得到的特征是离散稀疏的。</p>\n<h3 id=\"sklearn实现one-hot-encode\"><a href=\"#sklearn实现one-hot-encode\" class=\"headerlink\" title=\"sklearn实现one hot encode\"></a>sklearn实现one hot encode</h3><p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sklearn import preprocessing  </span><br><span class=\"line\">      </span><br><span class=\"line\">enc = preprocessing.OneHotEncoder()  # 创建对象</span><br><span class=\"line\">enc.fit([[0,0,3],[1,1,0],[0,2,1],[1,0,2]])   # 拟合</span><br><span class=\"line\">array = enc.transform([[0,1,3]]).toarray()  # 转化</span><br><span class=\"line\">print(array)</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<h2 id=\"2-TF-IDF\"><a href=\"#2-TF-IDF\" class=\"headerlink\" title=\"2. TF-IDF\"></a>2. TF-IDF</h2><p>　　IF-IDF是信息检索（IR）中最常用的一种文本表示法。算法的思想也很简单，就是统计每个词出现的词频（TF），然后再为其附上一个权值参数（IDF）。举个例子：</p>\n<p>　　现在假设我们要统计一篇文档中的前10个关键词，应该怎么下手？首先想到的是统计一下文档中每个词出现的频率（TF），词频越高，这个词就越重要。但是统计完你可能会发现你得到的关键词基本都是“的”、“是”、“为”这样没有实际意义的词（停用词），这个问题怎么解决呢？你可能会想到为每个词都加一个权重，像这种”停用词“就加一个很小的权重（甚至是置为0），这个权重就是IDF。下面再来看看公式：</p>\n<p>　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030184644027-2546042.png\" alt=\"img\"><img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030185050808-1214386978.png\" alt=\"img\"></p>\n<p>IF应该很容易理解就是计算词频，IDF衡量词的常见程度。为了计算IDF我们需要事先准备一个语料库用来模拟语言的使用环境，如果一个词越是常见，那么式子中分母就越大，逆文档频率就越小越接近于0。这里的分母+1是为了避免分母为0的情况出现。TF-IDF的计算公式如下：</p>\n<p>　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030194100761-48755487.png\" alt=\"img\"></p>\n<p>根据公式很容易看出，TF-IDF的值与该词在文章中出现的频率成正比，与该词在整个语料库中出现的频率成反比，因此可以很好的实现提取文章中关键词的目的。</p>\n<h3 id=\"优缺点分析-1\"><a href=\"#优缺点分析-1\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h3><p><strong>优点：</strong>简单快速，结果比较符合实际</p>\n<p><strong>缺点：</strong>单纯考虑词频，忽略了词与词的位置信息以及词与词之间的相互关系。</p>\n<h3 id=\"sklearn实现tfidf\"><a href=\"#sklearn实现tfidf\" class=\"headerlink\" title=\"sklearn实现tfidf\"></a>sklearn实现tfidf</h3><p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sklearn.feature_extraction.text import CountVectorizer  </span><br><span class=\"line\">from sklearn.feature_extraction.text import TfidfTransformer</span><br><span class=\"line\"></span><br><span class=\"line\">tag_list = [&apos;青年 吃货 唱歌&apos;,  </span><br><span class=\"line\">            &apos;少年 游戏 叛逆&apos;,  </span><br><span class=\"line\">            &apos;少年 吃货 足球&apos;] </span><br><span class=\"line\"></span><br><span class=\"line\">vectorizer = CountVectorizer() #将文本中的词语转换为词频矩阵  </span><br><span class=\"line\">X = vectorizer.fit_transform(tag_list) #计算个词语出现的次数</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">word_dict = vectorizer.vocabulary_</span><br><span class=\"line\">&#123;&apos;唱歌&apos;: 2, &apos;吃货&apos;: 1, &apos;青年&apos;: 6, &apos;足球&apos;: 5, &apos;叛逆&apos;: 0, &apos;少年&apos;: 3, &apos;游戏&apos;: 4&#125;</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">transformer = TfidfTransformer()  </span><br><span class=\"line\">tfidf = transformer.fit_transform(X)  #将词频矩阵X统计成TF-IDF值  </span><br><span class=\"line\">print(tfidf.toarray())</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n","site":{"data":{}},"excerpt":"<p>【转自<a href=\"https://www.cnblogs.com/lianyingteng/p/7755545.html】\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lianyingteng/p/7755545.html】</a></p>\n<p>one-hot 和 TF-IDF是目前最为常见的用于提取文本特征的方法，本文主要介绍两种方法的思想以及优缺点。</p>\n<h2 id=\"1-one-hot\"><a href=\"#1-one-hot\" class=\"headerlink\" title=\"1. one-hot\"></a>1. one-hot</h2><h3 id=\"1-1-one-hot编码\"><a href=\"#1-1-one-hot编码\" class=\"headerlink\" title=\"1.1 one-hot编码\"></a>1.1 one-hot编码</h3><p>　　什么是one-hot编码？one-hot编码，又称独热编码、一位有效编码。其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。","more":"举个例子，假设我们有四个样本（行），每个样本有三个特征（列），如图：</p>\n<p>　　　　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030163200996-742440926.png\" alt=\"img\"></p>\n<p>上图中我们已经对每个特征进行了普通的数字编码：我们的feature_1有两种可能的取值，比如是男/女，这里男用1表示，女用2表示。那么one-hot编码是怎么搞的呢？我们再拿feature_2来说明：</p>\n<p>这里feature_2 有4种取值（状态），我们就用4个状态位来表示这个特征，one-hot编码就是保证每个样本中的单个特征只有1位处于状态1，其他的都是0。</p>\n<p>　　　　　 <img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030164625793-1703194224.png\" alt=\"img\"></p>\n<p>对于2种状态、三种状态、甚至更多状态都是这样表示，所以我们可以得到这些样本特征的新表示：</p>\n<p>　　　　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165132480-1341638518.png\" alt=\"img\"></p>\n<p>one-hot编码将每个状态位都看成一个特征。对于前两个样本我们可以得到它的特征向量分别为</p>\n<p>　　　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030165731683-1946521226.png\" alt=\"img\"></p>\n<h3 id=\"1-2-one-hot在提取文本特征上的应用\"><a href=\"#1-2-one-hot在提取文本特征上的应用\" class=\"headerlink\" title=\"1.2 one-hot在提取文本特征上的应用\"></a>1.2 one-hot在提取文本特征上的应用</h3><p>　　one hot在特征提取上属于词袋模型（bag of words）。关于如何使用one-hot抽取文本特征向量我们通过以下例子来说明。假设我们的语料库中有三段话：</p>\n<p>　　　　我爱中国</p>\n<p>　　　　爸爸妈妈爱我</p>\n<p>　　　　爸爸妈妈爱中国</p>\n<p>我们首先对预料库分离并获取其中所有的词，然后对每个此进行编号：</p>\n<p>　　　　1 我； 2 爱； 3 爸爸； 4 妈妈；5 中国</p>\n<p>然后使用one hot对每段话提取特征向量：</p>\n<p>　<img src=\"https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103420622-1037006116.png\" alt=\"img\">；<img src=\"https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103811778-399990946.png\" alt=\"img\">；<img src=\"https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106103938778-1278932628.png\" alt=\"img\"></p>\n<p>因此我们得到了最终的特征向量为</p>\n<p>　　　　我爱中国 　-&gt;　　　1，1，0，0，1</p>\n<p>　　　　爸爸妈妈爱我　　-&gt;　　1，1，1，1，0</p>\n<p>　　　　爸爸妈妈爱中国　　-&gt;　　0，1，1，1，1</p>\n<h3 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h3><p><strong>优点：</strong>一是解决了分类器不好处理离散数据的问题，二是在一定程度上也起到了扩充特征的作用（上面样本特征数从3扩展到了9）</p>\n<p><strong>缺点：</strong>在文本特征表示上有些缺点就非常突出了。首先，它是一个词袋模型，不考虑词与词之间的顺序（文本中词的顺序信息也是很重要的）；其次，它假设词与词相互独立（在大多数情况下，词与词是相互影响的）；最后，它得到的特征是离散稀疏的。</p>\n<h3 id=\"sklearn实现one-hot-encode\"><a href=\"#sklearn实现one-hot-encode\" class=\"headerlink\" title=\"sklearn实现one hot encode\"></a>sklearn实现one hot encode</h3><p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sklearn import preprocessing  </span><br><span class=\"line\">      </span><br><span class=\"line\">enc = preprocessing.OneHotEncoder()  # 创建对象</span><br><span class=\"line\">enc.fit([[0,0,3],[1,1,0],[0,2,1],[1,0,2]])   # 拟合</span><br><span class=\"line\">array = enc.transform([[0,1,3]]).toarray()  # 转化</span><br><span class=\"line\">print(array)</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<h2 id=\"2-TF-IDF\"><a href=\"#2-TF-IDF\" class=\"headerlink\" title=\"2. TF-IDF\"></a>2. TF-IDF</h2><p>　　IF-IDF是信息检索（IR）中最常用的一种文本表示法。算法的思想也很简单，就是统计每个词出现的词频（TF），然后再为其附上一个权值参数（IDF）。举个例子：</p>\n<p>　　现在假设我们要统计一篇文档中的前10个关键词，应该怎么下手？首先想到的是统计一下文档中每个词出现的频率（TF），词频越高，这个词就越重要。但是统计完你可能会发现你得到的关键词基本都是“的”、“是”、“为”这样没有实际意义的词（停用词），这个问题怎么解决呢？你可能会想到为每个词都加一个权重，像这种”停用词“就加一个很小的权重（甚至是置为0），这个权重就是IDF。下面再来看看公式：</p>\n<p>　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030184644027-2546042.png\" alt=\"img\"><img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030185050808-1214386978.png\" alt=\"img\"></p>\n<p>IF应该很容易理解就是计算词频，IDF衡量词的常见程度。为了计算IDF我们需要事先准备一个语料库用来模拟语言的使用环境，如果一个词越是常见，那么式子中分母就越大，逆文档频率就越小越接近于0。这里的分母+1是为了避免分母为0的情况出现。TF-IDF的计算公式如下：</p>\n<p>　　　<img src=\"https://images2017.cnblogs.com/blog/1251096/201710/1251096-20171030194100761-48755487.png\" alt=\"img\"></p>\n<p>根据公式很容易看出，TF-IDF的值与该词在文章中出现的频率成正比，与该词在整个语料库中出现的频率成反比，因此可以很好的实现提取文章中关键词的目的。</p>\n<h3 id=\"优缺点分析-1\"><a href=\"#优缺点分析-1\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h3><p><strong>优点：</strong>简单快速，结果比较符合实际</p>\n<p><strong>缺点：</strong>单纯考虑词频，忽略了词与词的位置信息以及词与词之间的相互关系。</p>\n<h3 id=\"sklearn实现tfidf\"><a href=\"#sklearn实现tfidf\" class=\"headerlink\" title=\"sklearn实现tfidf\"></a>sklearn实现tfidf</h3><p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sklearn.feature_extraction.text import CountVectorizer  </span><br><span class=\"line\">from sklearn.feature_extraction.text import TfidfTransformer</span><br><span class=\"line\"></span><br><span class=\"line\">tag_list = [&apos;青年 吃货 唱歌&apos;,  </span><br><span class=\"line\">            &apos;少年 游戏 叛逆&apos;,  </span><br><span class=\"line\">            &apos;少年 吃货 足球&apos;] </span><br><span class=\"line\"></span><br><span class=\"line\">vectorizer = CountVectorizer() #将文本中的词语转换为词频矩阵  </span><br><span class=\"line\">X = vectorizer.fit_transform(tag_list) #计算个词语出现的次数</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">word_dict = vectorizer.vocabulary_</span><br><span class=\"line\">&#123;&apos;唱歌&apos;: 2, &apos;吃货&apos;: 1, &apos;青年&apos;: 6, &apos;足球&apos;: 5, &apos;叛逆&apos;: 0, &apos;少年&apos;: 3, &apos;游戏&apos;: 4&#125;</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">transformer = TfidfTransformer()  </span><br><span class=\"line\">tfidf = transformer.fit_transform(X)  #将词频矩阵X统计成TF-IDF值  </span><br><span class=\"line\">print(tfidf.toarray())</span><br></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>"},{"title":"用Mahout编写一个基本推荐系统","date":"2018-04-10T01:44:25.000Z","_content":"\nMahout是一个机器学习Java类库的集合用于完成各种任务，如分类、评价性的聚类和模式挖掘等。相对于Weka和RapidMIner等库，Mahout真正是为大规模数据集设计的，它的算法用Hadoop环境。\n我们将使用Slope On推荐算法，它基于协同过滤方法，因为在Mahout0.9之后已经没有此方法，因此需要在pom文件中指定0.8版本。\n<!-- more-->\n**准备工作**\n数据集：GroupLens\n下载方式：`wget http://www.grouplens.org/system/files/ml-1m.zip`\n下载后有四个文件：\n> user.dat:包含6000个用户\n> movies.dat:包含电影名字\n> ratings.dat: 包含用户和电影的关系，一个数字表示用户对电影的喜爱程度\n> README： 说明文件格式\n\n**实现过程**\n1.将GroupLens格式的rating.转换成CSV格式，将1::1193::5::978300760转为1,1193形式\n2.创建一个Model类来处理将要使用的新文件rating.csv的文件格式\n3.在该模型上创建一个简单的推荐系统\n4.从文件rating.csv中提取整个用户列表需要花费一段时间，之后，在标题上将会看到每个用户的推荐\n\n```java\npackage com.manhoutcookbook.recommendsys;\nimport org.apache.mahout.cf.taste.common.TasteException;\nimport org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;\nimport org.apache.mahout.cf.taste.impl.model.file.FileDataModel;\nimport org.apache.mahout.cf.taste.impl.recommender.CachingRecommender;\nimport org.apache.mahout.cf.taste.impl.recommender.slopeone.SlopeOneRecommender;\nimport org.apache.mahout.cf.taste.model.DataModel;\nimport org.apache.mahout.cf.taste.recommender.RecommendedItem;\n\nimport java.io.*;\nimport java.util.List;\n\npublic class App {\n    static final String  inputFile = \"ml-1m/ratings.dat\";\n    static final String outputFile = \"ml-1m/ratings.csv\";\n\n    public static void main(String[] args) throws IOException, TasteException {\n        CreateCvsRatingFile();//修改文件格式\n        //基于CSV文件建立模型\n        File  ratingsFile = new File(outputFile);\n        DataModel model;\n        model = new FileDataModel(ratingsFile);\n        //创建SlopeRecommender\n        CachingRecommender cachingRecommender = new CachingRecommender(new SlopeOneRecommender(model));\n        for (LongPrimitiveIterator it = model.getUserIDs(); it.hasNext(); ) {\n            long userId = it.nextLong();\n            //显示推荐结果\n            List<RecommendedItem> recommendations = cachingRecommender.recommend(userId, 10);\n            if (recommendations.size() == 0) {\n                System.out.println(\"User \");\n                System.out.println(userId);\n                System.out.println(\": no recommendations\");\n            }\n\n            for(RecommendedItem recommendedItem : recommendations) {\n                System.out.println(\"User \");\n                System.out.println(userId);\n                System.out.println(recommendedItem);\n            }\n        }\n    }\n\n    private static void CreateCvsRatingFile() throws IOException {\n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));\n        String line = null;\n        String line2write = null;\n        String [] temp;\n        int i = 0;\n        //仅转换1000条，避免单机运行堆异常\n        while((line  = reader.readLine()) != null && i<10000) {\n            i++;\n            temp = line.split(\"::\");\n            line2write = temp[0] + \",\" + temp[1];\n            writer.write(line2write);\n            writer.newLine();\n            writer.flush();\n        }\n        reader.close();\n        writer.close();\n    }\n}```\n运行结果：\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-10/23573009.jpg)\nSlope One推荐算法：使用线性函数结合用户和条目来估计接近程度，计算简单快速，对新用户推荐效果不错\n\n","source":"_posts/用Mahout编写一个基本推荐系统.md","raw":"---\ntitle: 用Mahout编写一个基本推荐系统\ndate: 2018-04-10 09:44:25\ntags: [大数据,  推荐系统,  Mahout,  Hadoop]\n---\n\nMahout是一个机器学习Java类库的集合用于完成各种任务，如分类、评价性的聚类和模式挖掘等。相对于Weka和RapidMIner等库，Mahout真正是为大规模数据集设计的，它的算法用Hadoop环境。\n我们将使用Slope On推荐算法，它基于协同过滤方法，因为在Mahout0.9之后已经没有此方法，因此需要在pom文件中指定0.8版本。\n<!-- more-->\n**准备工作**\n数据集：GroupLens\n下载方式：`wget http://www.grouplens.org/system/files/ml-1m.zip`\n下载后有四个文件：\n> user.dat:包含6000个用户\n> movies.dat:包含电影名字\n> ratings.dat: 包含用户和电影的关系，一个数字表示用户对电影的喜爱程度\n> README： 说明文件格式\n\n**实现过程**\n1.将GroupLens格式的rating.转换成CSV格式，将1::1193::5::978300760转为1,1193形式\n2.创建一个Model类来处理将要使用的新文件rating.csv的文件格式\n3.在该模型上创建一个简单的推荐系统\n4.从文件rating.csv中提取整个用户列表需要花费一段时间，之后，在标题上将会看到每个用户的推荐\n\n```java\npackage com.manhoutcookbook.recommendsys;\nimport org.apache.mahout.cf.taste.common.TasteException;\nimport org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;\nimport org.apache.mahout.cf.taste.impl.model.file.FileDataModel;\nimport org.apache.mahout.cf.taste.impl.recommender.CachingRecommender;\nimport org.apache.mahout.cf.taste.impl.recommender.slopeone.SlopeOneRecommender;\nimport org.apache.mahout.cf.taste.model.DataModel;\nimport org.apache.mahout.cf.taste.recommender.RecommendedItem;\n\nimport java.io.*;\nimport java.util.List;\n\npublic class App {\n    static final String  inputFile = \"ml-1m/ratings.dat\";\n    static final String outputFile = \"ml-1m/ratings.csv\";\n\n    public static void main(String[] args) throws IOException, TasteException {\n        CreateCvsRatingFile();//修改文件格式\n        //基于CSV文件建立模型\n        File  ratingsFile = new File(outputFile);\n        DataModel model;\n        model = new FileDataModel(ratingsFile);\n        //创建SlopeRecommender\n        CachingRecommender cachingRecommender = new CachingRecommender(new SlopeOneRecommender(model));\n        for (LongPrimitiveIterator it = model.getUserIDs(); it.hasNext(); ) {\n            long userId = it.nextLong();\n            //显示推荐结果\n            List<RecommendedItem> recommendations = cachingRecommender.recommend(userId, 10);\n            if (recommendations.size() == 0) {\n                System.out.println(\"User \");\n                System.out.println(userId);\n                System.out.println(\": no recommendations\");\n            }\n\n            for(RecommendedItem recommendedItem : recommendations) {\n                System.out.println(\"User \");\n                System.out.println(userId);\n                System.out.println(recommendedItem);\n            }\n        }\n    }\n\n    private static void CreateCvsRatingFile() throws IOException {\n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));\n        String line = null;\n        String line2write = null;\n        String [] temp;\n        int i = 0;\n        //仅转换1000条，避免单机运行堆异常\n        while((line  = reader.readLine()) != null && i<10000) {\n            i++;\n            temp = line.split(\"::\");\n            line2write = temp[0] + \",\" + temp[1];\n            writer.write(line2write);\n            writer.newLine();\n            writer.flush();\n        }\n        reader.close();\n        writer.close();\n    }\n}```\n运行结果：\n![](http://p5s7d12ls.bkt.clouddn.com/18-4-10/23573009.jpg)\nSlope One推荐算法：使用线性函数结合用户和条目来估计接近程度，计算简单快速，对新用户推荐效果不错\n\n","slug":"用Mahout编写一个基本推荐系统","published":1,"updated":"2018-06-07T13:35:07.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7u003scf96ni1xhxkx","content":"<p>Mahout是一个机器学习Java类库的集合用于完成各种任务，如分类、评价性的聚类和模式挖掘等。相对于Weka和RapidMIner等库，Mahout真正是为大规模数据集设计的，它的算法用Hadoop环境。<br>我们将使用Slope On推荐算法，它基于协同过滤方法，因为在Mahout0.9之后已经没有此方法，因此需要在pom文件中指定0.8版本。<br><a id=\"more\"></a><br><strong>准备工作</strong><br>数据集：GroupLens<br>下载方式：<code>wget http://www.grouplens.org/system/files/ml-1m.zip</code><br>下载后有四个文件：</p>\n<blockquote>\n<p>user.dat:包含6000个用户<br>movies.dat:包含电影名字<br>ratings.dat: 包含用户和电影的关系，一个数字表示用户对电影的喜爱程度<br>README： 说明文件格式</p>\n</blockquote>\n<p><strong>实现过程</strong><br>1.将GroupLens格式的rating.转换成CSV格式，将1::1193::5::978300760转为1,1193形式<br>2.创建一个Model类来处理将要使用的新文件rating.csv的文件格式<br>3.在该模型上创建一个简单的推荐系统<br>4.从文件rating.csv中提取整个用户列表需要花费一段时间，之后，在标题上将会看到每个用户的推荐</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.manhoutcookbook.recommendsys;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.common.TasteException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.model.file.FileDataModel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.recommender.CachingRecommender;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.recommender.slopeone.SlopeOneRecommender;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.model.DataModel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.recommender.RecommendedItem;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String  inputFile = <span class=\"string\">\"ml-1m/ratings.dat\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String outputFile = <span class=\"string\">\"ml-1m/ratings.csv\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, TasteException </span>&#123;</span><br><span class=\"line\">        CreateCvsRatingFile();<span class=\"comment\">//修改文件格式</span></span><br><span class=\"line\">        <span class=\"comment\">//基于CSV文件建立模型</span></span><br><span class=\"line\">        File  ratingsFile = <span class=\"keyword\">new</span> File(outputFile);</span><br><span class=\"line\">        DataModel model;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> FileDataModel(ratingsFile);</span><br><span class=\"line\">        <span class=\"comment\">//创建SlopeRecommender</span></span><br><span class=\"line\">        CachingRecommender cachingRecommender = <span class=\"keyword\">new</span> CachingRecommender(<span class=\"keyword\">new</span> SlopeOneRecommender(model));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LongPrimitiveIterator it = model.getUserIDs(); it.hasNext(); ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> userId = it.nextLong();</span><br><span class=\"line\">            <span class=\"comment\">//显示推荐结果</span></span><br><span class=\"line\">            List&lt;RecommendedItem&gt; recommendations = cachingRecommender.recommend(userId, <span class=\"number\">10</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (recommendations.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"User \"</span>);</span><br><span class=\"line\">                System.out.println(userId);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\": no recommendations\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(RecommendedItem recommendedItem : recommendations) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"User \"</span>);</span><br><span class=\"line\">                System.out.println(userId);</span><br><span class=\"line\">                System.out.println(recommendedItem);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">CreateCvsRatingFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(inputFile));</span><br><span class=\"line\">        BufferedWriter writer = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(outputFile));</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        String line2write = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        String [] temp;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//仅转换1000条，避免单机运行堆异常</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>((line  = reader.readLine()) != <span class=\"keyword\">null</span> &amp;&amp; i&lt;<span class=\"number\">10000</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            temp = line.split(<span class=\"string\">\"::\"</span>);</span><br><span class=\"line\">            line2write = temp[<span class=\"number\">0</span>] + <span class=\"string\">\",\"</span> + temp[<span class=\"number\">1</span>];</span><br><span class=\"line\">            writer.write(line2write);</span><br><span class=\"line\">            writer.newLine();</span><br><span class=\"line\">            writer.flush();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.close();</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-10/23573009.jpg\" alt=\"\"><br>Slope One推荐算法：使用线性函数结合用户和条目来估计接近程度，计算简单快速，对新用户推荐效果不错</p>\n","site":{"data":{}},"excerpt":"<p>Mahout是一个机器学习Java类库的集合用于完成各种任务，如分类、评价性的聚类和模式挖掘等。相对于Weka和RapidMIner等库，Mahout真正是为大规模数据集设计的，它的算法用Hadoop环境。<br>我们将使用Slope On推荐算法，它基于协同过滤方法，因为在Mahout0.9之后已经没有此方法，因此需要在pom文件中指定0.8版本。<br>","more":"<br><strong>准备工作</strong><br>数据集：GroupLens<br>下载方式：<code>wget http://www.grouplens.org/system/files/ml-1m.zip</code><br>下载后有四个文件：</p>\n<blockquote>\n<p>user.dat:包含6000个用户<br>movies.dat:包含电影名字<br>ratings.dat: 包含用户和电影的关系，一个数字表示用户对电影的喜爱程度<br>README： 说明文件格式</p>\n</blockquote>\n<p><strong>实现过程</strong><br>1.将GroupLens格式的rating.转换成CSV格式，将1::1193::5::978300760转为1,1193形式<br>2.创建一个Model类来处理将要使用的新文件rating.csv的文件格式<br>3.在该模型上创建一个简单的推荐系统<br>4.从文件rating.csv中提取整个用户列表需要花费一段时间，之后，在标题上将会看到每个用户的推荐</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.manhoutcookbook.recommendsys;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.common.TasteException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.model.file.FileDataModel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.recommender.CachingRecommender;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.impl.recommender.slopeone.SlopeOneRecommender;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.model.DataModel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.mahout.cf.taste.recommender.RecommendedItem;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String  inputFile = <span class=\"string\">\"ml-1m/ratings.dat\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String outputFile = <span class=\"string\">\"ml-1m/ratings.csv\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, TasteException </span>&#123;</span><br><span class=\"line\">        CreateCvsRatingFile();<span class=\"comment\">//修改文件格式</span></span><br><span class=\"line\">        <span class=\"comment\">//基于CSV文件建立模型</span></span><br><span class=\"line\">        File  ratingsFile = <span class=\"keyword\">new</span> File(outputFile);</span><br><span class=\"line\">        DataModel model;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> FileDataModel(ratingsFile);</span><br><span class=\"line\">        <span class=\"comment\">//创建SlopeRecommender</span></span><br><span class=\"line\">        CachingRecommender cachingRecommender = <span class=\"keyword\">new</span> CachingRecommender(<span class=\"keyword\">new</span> SlopeOneRecommender(model));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LongPrimitiveIterator it = model.getUserIDs(); it.hasNext(); ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> userId = it.nextLong();</span><br><span class=\"line\">            <span class=\"comment\">//显示推荐结果</span></span><br><span class=\"line\">            List&lt;RecommendedItem&gt; recommendations = cachingRecommender.recommend(userId, <span class=\"number\">10</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (recommendations.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"User \"</span>);</span><br><span class=\"line\">                System.out.println(userId);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\": no recommendations\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(RecommendedItem recommendedItem : recommendations) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"User \"</span>);</span><br><span class=\"line\">                System.out.println(userId);</span><br><span class=\"line\">                System.out.println(recommendedItem);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">CreateCvsRatingFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(inputFile));</span><br><span class=\"line\">        BufferedWriter writer = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(outputFile));</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        String line2write = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        String [] temp;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//仅转换1000条，避免单机运行堆异常</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>((line  = reader.readLine()) != <span class=\"keyword\">null</span> &amp;&amp; i&lt;<span class=\"number\">10000</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            temp = line.split(<span class=\"string\">\"::\"</span>);</span><br><span class=\"line\">            line2write = temp[<span class=\"number\">0</span>] + <span class=\"string\">\",\"</span> + temp[<span class=\"number\">1</span>];</span><br><span class=\"line\">            writer.write(line2write);</span><br><span class=\"line\">            writer.newLine();</span><br><span class=\"line\">            writer.flush();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.close();</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-4-10/23573009.jpg\" alt=\"\"><br>Slope One推荐算法：使用线性函数结合用户和条目来估计接近程度，计算简单快速，对新用户推荐效果不错</p>"},{"title":"线程的生命周期","date":"2018-06-03T16:12:09.000Z","_content":"\n\n  当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运\n\n行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。\n<!-- more--> \n1. 新建和就绪状态\n\n  当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量\n\n值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。\n\n  当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该\n\n线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。\n2. 运行和阻塞状态\n\n  如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态。\n\n当发生如下情况下，线程将会进入阻塞状态：\n\n    线程调用sleep方法主动放弃所占用的处理器资源。\n\n    线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。\n\n    线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。关于同步监视器的知识将在后面有更深入的介绍。\n\n    线程在等待某个通知(notify)。\n\n    程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。\n\n  当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是\n\n说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。\n\n针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：\n\n    调用sleep方法的线程经过了指定时间。\n\n    线程调用的阻塞式IO方法已经返回。\n\n    线程成功地获得了试图取得同步监视器。\n\n    线程正在等待某个通知时，其他线程发出了一个通知。\n\n    处于挂起状态的线程被调用了resume恢复方法。\n\n线程状态转换图：\n![](https://img-blog.csdn.net/20160602105419074)\n3. 线程死亡\n\n线程会以以下三种方式之一结束，结束后就处于死亡状态：\n\n    run()方法执行完成，线程正常结束。\n\n    线程抛出一个未捕获的Exception或Error。\n\n    直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。\n\n","source":"_posts/线程的生命周期.md","raw":"---\ntitle: 线程的生命周期\ndate: 2018-06-04 00:12:09\ntags: [Java, 多线程, 并发]\n---\n\n\n  当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运\n\n行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。\n<!-- more--> \n1. 新建和就绪状态\n\n  当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量\n\n值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。\n\n  当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该\n\n线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。\n2. 运行和阻塞状态\n\n  如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态。\n\n当发生如下情况下，线程将会进入阻塞状态：\n\n    线程调用sleep方法主动放弃所占用的处理器资源。\n\n    线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。\n\n    线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。关于同步监视器的知识将在后面有更深入的介绍。\n\n    线程在等待某个通知(notify)。\n\n    程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。\n\n  当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是\n\n说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。\n\n针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：\n\n    调用sleep方法的线程经过了指定时间。\n\n    线程调用的阻塞式IO方法已经返回。\n\n    线程成功地获得了试图取得同步监视器。\n\n    线程正在等待某个通知时，其他线程发出了一个通知。\n\n    处于挂起状态的线程被调用了resume恢复方法。\n\n线程状态转换图：\n![](https://img-blog.csdn.net/20160602105419074)\n3. 线程死亡\n\n线程会以以下三种方式之一结束，结束后就处于死亡状态：\n\n    run()方法执行完成，线程正常结束。\n\n    线程抛出一个未捕获的Exception或Error。\n\n    直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。\n\n","slug":"线程的生命周期","published":1,"updated":"2018-06-07T13:35:07.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7v003ucf96dqg7q1v7","content":"<p>  当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运</p>\n<p>行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。<br><a id=\"more\"></a> </p>\n<ol>\n<li>新建和就绪状态</li>\n</ol>\n<p>  当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量</p>\n<p>值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。</p>\n<p>  当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该</p>\n<p>线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。</p>\n<ol>\n<li>运行和阻塞状态</li>\n</ol>\n<p>  如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态。</p>\n<p>当发生如下情况下，线程将会进入阻塞状态：</p>\n<pre><code>线程调用sleep方法主动放弃所占用的处理器资源。\n\n线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。\n\n线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。关于同步监视器的知识将在后面有更深入的介绍。\n\n线程在等待某个通知(notify)。\n\n程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。\n</code></pre><p>  当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是</p>\n<p>说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。</p>\n<p>针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：</p>\n<pre><code>调用sleep方法的线程经过了指定时间。\n\n线程调用的阻塞式IO方法已经返回。\n\n线程成功地获得了试图取得同步监视器。\n\n线程正在等待某个通知时，其他线程发出了一个通知。\n\n处于挂起状态的线程被调用了resume恢复方法。\n</code></pre><p>线程状态转换图：<br><img src=\"https://img-blog.csdn.net/20160602105419074\" alt=\"\"></p>\n<ol>\n<li>线程死亡</li>\n</ol>\n<p>线程会以以下三种方式之一结束，结束后就处于死亡状态：</p>\n<pre><code>run()方法执行完成，线程正常结束。\n\n线程抛出一个未捕获的Exception或Error。\n\n直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。\n</code></pre>","site":{"data":{}},"excerpt":"<p>  当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运</p>\n<p>行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。<br>","more":"</p>\n<ol>\n<li>新建和就绪状态</li>\n</ol>\n<p>  当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量</p>\n<p>值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。</p>\n<p>  当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该</p>\n<p>线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。</p>\n<ol>\n<li>运行和阻塞状态</li>\n</ol>\n<p>  如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态。</p>\n<p>当发生如下情况下，线程将会进入阻塞状态：</p>\n<pre><code>线程调用sleep方法主动放弃所占用的处理器资源。\n\n线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。\n\n线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。关于同步监视器的知识将在后面有更深入的介绍。\n\n线程在等待某个通知(notify)。\n\n程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。\n</code></pre><p>  当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是</p>\n<p>说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。</p>\n<p>针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：</p>\n<pre><code>调用sleep方法的线程经过了指定时间。\n\n线程调用的阻塞式IO方法已经返回。\n\n线程成功地获得了试图取得同步监视器。\n\n线程正在等待某个通知时，其他线程发出了一个通知。\n\n处于挂起状态的线程被调用了resume恢复方法。\n</code></pre><p>线程状态转换图：<br><img src=\"https://img-blog.csdn.net/20160602105419074\" alt=\"\"></p>\n<ol>\n<li>线程死亡</li>\n</ol>\n<p>线程会以以下三种方式之一结束，结束后就处于死亡状态：</p>\n<pre><code>run()方法执行完成，线程正常结束。\n\n线程抛出一个未捕获的Exception或Error。\n\n直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。\n</code></pre>"},{"title":"记录一道笔试算法题","date":"2018-03-22T14:54:41.000Z","_content":"\n今天师兄笔试的时候遇到一道算法题,一开始直接看结果没有想明白,后来才觉得原来这么简单,但是还是比较考验思维,做个记录,留着以后看:\n\n题目:在一个圆上画n个点,将这个圆n等分,每次连两个点,问最多可以画出多少条线段使得这些线段不相交.\n\n思路:首先将所有的点顺接起来构成一个n边形,再从中取一个点和其他所有的点连起来,这样就又有n-1条边,且互不相交,但是n-1条边里和出发点相邻的两点连成的边已经在第一次的n条边里算进去了,因此要减去2,再多花的话都会相交,因此最终结果是n+n-1-2=2*n-3\n","source":"_posts/记录一道笔试算法题.md","raw":"---\ntitle: 记录一道笔试算法题\ndate: 2018-03-22 22:54:41\ntags: 算法\n---\n\n今天师兄笔试的时候遇到一道算法题,一开始直接看结果没有想明白,后来才觉得原来这么简单,但是还是比较考验思维,做个记录,留着以后看:\n\n题目:在一个圆上画n个点,将这个圆n等分,每次连两个点,问最多可以画出多少条线段使得这些线段不相交.\n\n思路:首先将所有的点顺接起来构成一个n边形,再从中取一个点和其他所有的点连起来,这样就又有n-1条边,且互不相交,但是n-1条边里和出发点相邻的两点连成的边已经在第一次的n条边里算进去了,因此要减去2,再多花的话都会相交,因此最终结果是n+n-1-2=2*n-3\n","slug":"记录一道笔试算法题","published":1,"updated":"2018-06-07T13:35:07.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i7w003xcf96vfmj3k1v","content":"<p>今天师兄笔试的时候遇到一道算法题,一开始直接看结果没有想明白,后来才觉得原来这么简单,但是还是比较考验思维,做个记录,留着以后看:</p>\n<p>题目:在一个圆上画n个点,将这个圆n等分,每次连两个点,问最多可以画出多少条线段使得这些线段不相交.</p>\n<p>思路:首先将所有的点顺接起来构成一个n边形,再从中取一个点和其他所有的点连起来,这样就又有n-1条边,且互不相交,但是n-1条边里和出发点相邻的两点连成的边已经在第一次的n条边里算进去了,因此要减去2,再多花的话都会相交,因此最终结果是n+n-1-2=2*n-3</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天师兄笔试的时候遇到一道算法题,一开始直接看结果没有想明白,后来才觉得原来这么简单,但是还是比较考验思维,做个记录,留着以后看:</p>\n<p>题目:在一个圆上画n个点,将这个圆n等分,每次连两个点,问最多可以画出多少条线段使得这些线段不相交.</p>\n<p>思路:首先将所有的点顺接起来构成一个n边形,再从中取一个点和其他所有的点连起来,这样就又有n-1条边,且互不相交,但是n-1条边里和出发点相邻的两点连成的边已经在第一次的n条边里算进去了,因此要减去2,再多花的话都会相交,因此最终结果是n+n-1-2=2*n-3</p>\n"},{"title":"用hadoop构建豆瓣图书推荐系统","date":"2018-03-28T15:33:49.000Z","_content":"\n《Hadoop权威指南》已经通读一遍，对于分布式数据处理大致有一些概念，从网上找一个合适的项目练练手，此博客记录了我基于[张丹大神的电影推荐系统](http://blog.fens.me/hadoop-mapreduce-recommend/)手搓的豆瓣图书推荐系统，Hadoop版本为2.8.0，爬虫用python scrapy框架来写。\n\n**一、推荐系统概述**\n\n互联网已经普及到了今天，更加上机器学习和大数据的浪潮火爆，几乎我们接触的所有网站、App等都会用到推荐系统，比如淘宝的猜你喜欢，头条的新闻推送等等。\n<!-- more-->\n常见的推荐原理有：\n> *基于用户基本信息的推荐* : 例如可以根据用户的性别、职业、 年龄、 所在地等信息向他推荐感兴趣或者相关的内容\n> *基于物品/内容基本信息推荐* ： 根据物品的类型、来源、主题等信息推荐\n> *协同推荐* ： 协同过滤算法通过计算用户之间或者物品之间的相关性来进行推荐\n\n协同过滤算法的实现分为两个步骤：\n1.计算物品之间的相关度\n2.根据物品的相似度和用户的历史行为给用户生成推荐列表\n**二、算法模型**\n这里我们用分步式基于物品的协同过滤算法实现为豆瓣用户推荐图书的系统。测试数据仍然用张丹大神原系统中的small.csv\n```data\n1,101,5.0\n1,102,3.0\n1,103,2.5\n2,101,2.0\n2,102,2.5\n2,103,5.0\n2,104,2.0\n3,101,2.0\n3,104,4.0\n3,105,4.5\n3,107,5.0\n4,101,5.0\n4,103,3.0\n4,104,4.5\n4,106,4.0\n5,101,4.0\n5,102,3.0\n5,103,2.0\n5,104,4.0\n5,105,3.5\n5,106,4.0\n```\n每行3个字段，依次代表用户ID，图书ID，用户对图书的评分(0-5分）。\n本推荐系统执行的思路：\n1. 建立物品的同现矩阵： 同现矩阵的值代表了某两本书同时出现在用户的评价列表中的次数\n```data\n      [101] [102] [103] [104] [105] [106] [107]\n[101]   5     3     4     4     2     2     1\n[102]   3     3     3     2     1     1     0\n[103]   4     3     4     3     1     2     0\n[104]   4     2     3     4     2     2     1\n[105]   2     1     1     2     2     1     1\n[106]   2     1     2     2     1     2     0\n[107]   1     0     0     1     1     0     1```\n2. 建立用户对物品的评分矩阵： 有多少个用户就有多少个评分矩阵\n​```data\n       U3\n[101] 2.0\n[102] 0.0\n[103] 0.0\n[104] 4.0\n[105] 4.5\n[106] 0.0\n[107] 5.0```\n3. 矩阵计算推荐结果： 同现矩阵*评分矩阵 = 推荐结果\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/78005679.jpg)\n\n**三、系统架构**\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/71568403.jpg)\n\n上图左边是Application业务系统，右边是本博客要实现的HDFS，MapReduce\n1.业务系统记录了用户行为和用户对物品的打分（这里我们用爬取到的数据代替）\n2.设置系统定时器CRON，隔一段时间增量向HDFS导入数据，即本系统需要的userId，itemId，value，time\n3.完成导入后，设置系统定时器，启动MapReduce程序，运行推荐算法。\n4.完成计算后，设置系统定时器，从HDFS导出推荐结果数据到数据库，方便以后的及时查询。\n\n**四 程序开发：MapReduce程序的实现**\n开发环境：Ubuntu 16.04, IntelliJ IDEA， 和Hadoop2.8.0\n新建类：\n    Recommend.java，主任务启动程序\n    Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵\n    Step2.java，对物品组合列表进行计数，建立物品的同现矩阵\n    Step3.java，对同现矩阵和评分矩阵转型\n    *Step4.java，计算推荐结果列表，结果会出问题，最终不用这个类\n    Step4_Update.java, 计算部分评分\n    Step4_Update2.java, 计算最终评分，得到推荐结果\n    HdfsDAO.java，HDFS操作工具类\n\n*1）.Recommend.java,任务驱动程序*\n​```java\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\npublic class Recommend {\n    public static final Pattern DELIMITER = Pattern.compile(\"[\\t,]\");\n    public static final String HDFS = \"hdfs://localhost/\";\n\n    public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {\n        Map<String, String> path = new HashMap<String, String>();\n        path.put(\"data\", \"resources/small.csv\");\n        path.put(\"Step1Input\", HDFS + \"/user/hdfs/recommend\");\n        path.put(\"Step1Output\", path.get(\"Step1Input\") + \"/step1\");\n        path.put(\"Step2Input\", path.get(\"Step1Output\"));\n        path.put(\"Step2Output\", path.get(\"Step1Input\") + \"/step2\");\n        path.put(\"Step3Input1\", path.get(\"Step1Output\"));\n        path.put(\"Step3Output1\", path.get(\"Step1Input\") + \"/step3_1\");\n        path.put(\"Step3Input2\", path.get(\"Step2Output\"));\n        path.put(\"Step3Output2\", path.get(\"Step1Input\") + \"/step3_2\");\n\n        path.put(\"Step4Input1\", path.get(\"Step3Output1\"));\n        path.put(\"Step4Input2\", path.get(\"Step3Output2\"));\n        path.put(\"Step4Output\", path.get(\"Step1Input\") + \"/step4\");\n\n        path.put(\"Step5Input1\", path.get(\"Step3Output1\"));\n        path.put(\"Step5Input2\", path.get(\"Step3Output2\"));\n        path.put(\"Step5Output\", path.get(\"Step1Input\") + \"/step5\");\n\n        path.put(\"Step6Input\", path.get(\"Step5Output\"));\n        path.put(\"Step6Output\", path.get(\"Step1Input\") + \"/step6\");\n\n        Step1.run(path);\n        Step2.run(path);\n        Step3.run(path);\n        Step3.run2(path);\n        Step4.run(path);//NullPointerException,可能不会先构造同现矩阵\n//        Step4_Update.run(path);\n        Step4_Update2.run(path);\n\n        System.exit(0);\n    }\n}\n```\n*2). Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵*\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step1 {\n\n    public static class Step1_ToItemPreMapper extends Mapper<Object, Text, IntWritable, Text> {\n\n        @Override\n        protected void map(Object key, Text value, Context context) throws IOException, InterruptedException {\n            String tokens[] = Recommend.DELIMITER.split(value.toString());\n            int userId = Integer.parseInt(tokens[0]);\n            String itemId = tokens[1];\n            String pref = tokens[2];\n            context.write(new IntWritable(userId), new Text(itemId + \":\" + pref));\n        }\n    }\n\n    public static class Step1_ToUserVectorReducer extends Reducer<IntWritable, Text, IntWritable, Text> {\n        @Override\n        protected void reduce(IntWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            StringBuilder sb = new StringBuilder();\n            Iterator<Text> iter = values.iterator();\n            while (iter.hasNext()) {\n                sb.append(\",\" + iter.next());\n            }\n            context.write(key, new Text(sb.toString().replaceFirst(\",\", \"\")));\n        }\n    }\n\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        String input = path.get(\"Step1Input\");\n        String output = path.get(\"Step1Output\");\n\n        Configuration conf = new Configuration();\n//        conf.set(\"mapreduce.task.io.sort.mb\",\"1024\");//任务内部排序缓冲区大小,默认为100\n\n        Job job = new Job(conf, \"Step1\");\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(input);\n        hdfs.mkdirs(input);\n        hdfs.copyFile(path.get(\"data\"), input);\n\n        job.setJarByClass(Step1.class);\n        job.setMapOutputKeyClass(IntWritable.class);\n        job.setMapOutputValueClass(Text.class);\n\n        job.setOutputKeyClass(IntWritable.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        job.setMapperClass(Step1_ToItemPreMapper.class);\n        job.setReducerClass(Step1_ToUserVectorReducer.class);\n        job.setCombinerClass(Step1_ToUserVectorReducer.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}```\nmap阶段：用正则表达式分割输入数据，以userId为键，图书id和打分组合成字符串itemId：pref传递给Reducer\nreduce阶段：此时传进来的key已经按照userId分好块，于是我们可以得到每个用户的评分矩阵\nStep1的输出为：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/97798258.jpg)\n\n*3). Step2.java，对物品组合列表进行计数，建立物品的同现矩阵*\n​```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step2 {\n    public static class Step2_UserVectorToCooccurrenceMapper extends Mapper<LongWritable, Text, Text, IntWritable> {\n        private final static Text k = new Text();\n        private final static IntWritable v = new IntWritable(1);\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            for (int i = 1; i < tokens.length; i++) {\n                String itemId = tokens[i].split(\":\")[0];\n                for (int j = 1; j < tokens.length; j++) {\n                    String itemId2 = tokens[j].split(\":\")[0];\n                    context.write(new Text(itemId + \":\" + itemId2), v);\n                }\n            }\n        }\n    }\n\n    public static class Step2_UserVectorToCooccurrenceReducer extends Reducer<Text, IntWritable, Text, IntWritable> {\n        @Override\n        protected void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n            int sum = 0;\n            Iterator<IntWritable> iter = values.iterator();\n            while (iter.hasNext()) {\n                sum += iter.next().get();\n            }\n            context.write(key, new IntWritable(sum));\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"Step2\");\n\n        String input = path.get(\"Step2Input\");\n        String output = path.get(\"Step2Output\");\n        System.out.println(output);\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n\n        job.setJarByClass(Step2.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(IntWritable.class);\n\n        job.setMapperClass(Step2_UserVectorToCooccurrenceMapper.class);\n        job.setCombinerClass(Step2_UserVectorToCooccurrenceReducer.class);\n        job.setReducerClass(Step2_UserVectorToCooccurrenceReducer.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n\n    }\n}\n```\nStep2的输入是Step1的输出，\nmap阶段：用正则表达式分割每行，利用双重循环构造每行中任意两个itemsId的组合作为键，用数字1作为值输出到Reducer\nreduce阶段：Mapper传来的数据已经按键分块，累加每种键下的值即可得到item1和item2出现在同一个评分列表中的次数，即得到图书的同现矩阵\nStep2的输出为：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/19253791.jpg)\n\n*4). Step3.java，合并同现矩阵和评分矩阵*\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class Step3 {\n    public static class Step31_UserVectorSplitterMapper extends Mapper<LongWritable, Text, IntWritable, Text> {\n        private IntWritable k = new IntWritable();\n        private Text v = new Text();\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            for (int i = 1; i < tokens.length; i++) {\n                String[] vector = tokens[i].split(\":\");\n                int itemId = Integer.parseInt(vector[0]);\n                String pref = vector[1];\n                k.set(itemId);\n                v.set(tokens[0] + \":\" + pref);\n                context.write(k, v);\n            }\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"step31_spliteUserVector\");\n        String input = path.get(\"Step3Input1\");\n        String output = path.get(\"Step3Output1\");\n\n        HdfsDAO hdfs = new HdfsDAO(conf);\n        hdfs.rmr(output);\n        job.setJarByClass(Step3.class);\n        job.setMapOutputKeyClass(IntWritable.class);\n        job.setMapOutputValueClass(Text.class);\n\n        job.setMapperClass(Step31_UserVectorSplitterMapper.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.setNumReduceTasks(0);\n        job.waitForCompletion(true);\n    }\n\n    public static class Step32_CooccurreceColumWrapperMapper extends Mapper<LongWritable, Text, Text, IntWritable> {\n        private final static Text k = new Text();\n        private final static IntWritable v = new IntWritable();\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String tokens[] = Recommend.DELIMITER.split(value.toString());\n            k.set(tokens[0]);\n            v.set(Integer.parseInt(tokens[1])); //这里和step2的输出有什么区别????\n            context.write(k, v);\n        }\n    }\n\n    public static void run2(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"step32_cooccurreceMap\");\n        String input = path.get(\"Step3Input2\");\n        String output = path.get(\"Step3Output2\");\n        job.setJarByClass(Step3.class);\n        HdfsDAO hdfs = new HdfsDAO(conf);\n        hdfs.rmr(output);\n\n        job.setMapOutputKeyClass(Text.class);\n        job.setMapOutputValueClass(IntWritable.class);\n\n        job.setMapperClass(Step32_CooccurreceColumWrapperMapper.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.setNumReduceTasks(0);\n        job.waitForCompletion(true);\n    }\n}\n```\nStep3_1将用户评分矩阵拆分为itemId\tuserId:pref的形式输出，为了方便之后的计算\nStep3_2看起来输出结果与Step2相同\nStep3_1输出：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/9400783.jpg)\nStep3_1输出：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/22519877.jpg)\n\n*5). Step4.java，计算推荐结果列表*\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.*;\n\npublic class Step4 {\n    public static class Step4_PartialMultiplyMapper extends Mapper<LongWritable, Text, IntWritable, Text> {\n        private final static IntWritable k = new IntWritable();\n        private final static Text v = new Text();\n        private final static Map<Integer, List<Cooccurrence>> cooccurrenceMatrix = new HashMap<Integer, List<Cooccurrence>>();\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n\n            String[] v1 = tokens[0].split(\":\");\n            String[] v2 = tokens[1].split(\":\");\n\n            if (v1.length > 1) {// cooccurrence\n                int itemID1 = Integer.parseInt(v1[0]);\n                int itemID2 = Integer.parseInt(v1[1]);\n                int num = Integer.parseInt(tokens[1]);\n\n                List<Cooccurrence> list = null;\n                if (!cooccurrenceMatrix.containsKey(itemID1)) {\n                    list = new ArrayList<Cooccurrence>();\n                } else {\n                    list = cooccurrenceMatrix.get(itemID1);\n                }\n                list.add(new Cooccurrence(itemID1, itemID2, num));\n                cooccurrenceMatrix.put(itemID1, list);\n            }\n\n            if (v2.length > 1) {// userVector\n                int itemID = Integer.parseInt(tokens[0]);\n                int userID = Integer.parseInt(v2[0]);\n                double pref = Double.parseDouble(v2[1]);\n                k.set(userID);\n                for (Cooccurrence co : cooccurrenceMatrix.get(itemID)) {\n                    v.set(co.getItemID2() + \",\" + pref * co.getNum());\n                    context.write(k, v);\n                }\n            }\n        }\n    }\n\n    public static class Step4_AggregateAndRecommendReducer extends Reducer<IntWritable, Text, IntWritable, Text> {\n        private final static Text v = new Text();\n\n        @Override\n        protected void reduce(IntWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            Map<String, Double> result = new HashMap<String, Double>();\n            Iterator<Text> iter = values.iterator();\n            while (iter.hasNext()) {\n                String[] str = iter.next().toString().split(\",\");\n                if (result.containsKey(str[0])) {\n                    result.put(str[0], result.get(str[0]) + Double.parseDouble(str[1]));\n                } else {\n                    result.put(str[0], Double.parseDouble(str[1]));\n                }\n            }\n            Iterator<String> iter2 = result.keySet().iterator();\n            while (iter.hasNext()) {\n                String itemID = iter2.next();\n                double score = result.get(itemID);\n                v.set(itemID + \",\" + score);\n                context.write(key, v);\n            }\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        String input1 = path.get(\"Step4Input1\");\n        String input2 = path.get(\"Step4Input2\");\n        String output = path.get(\"Step4Output\");\n\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"Step4\");\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n        job.setJarByClass(Step4.class);\n\n        job.setOutputKeyClass(IntWritable.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        job.setMapperClass(Step4_PartialMultiplyMapper.class);\n        job.setReducerClass(Step4_AggregateAndRecommendReducer.class);\n        job.setCombinerClass(Step4_AggregateAndRecommendReducer.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input1), new Path(input2));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}\n\nclass Cooccurrence {\n    private int itemID1;\n    private int itemID2;\n    private int num;\n\n    public Cooccurrence(int itemID1, int itemID2, int num) {\n        super();\n        this.itemID1 = itemID1;\n        this.itemID2 = itemID2;\n        this.num = num;\n    }\n\n    public int getItemID1() {\n        return itemID1;\n    }\n\n    public int getItemID2() {\n        return itemID2;\n    }\n\n    public int getNum() {\n        return num;\n    }\n\n    public void setItemID1(int itemID1) {\n        this.itemID1 = itemID1;\n    }\n\n    public void setItemID2(int itemID2) {\n        this.itemID2 = itemID2;\n    }\n\n    public void setNum(int num) {\n        this.num = num;\n    }\n}```\nStep4的输入来自两个路径，分别是step3_1和step3_2的输出，\nmap阶段：对输入的值进行分割，如果是同现矩阵其将被分割为`[101:102,3]`的形式，如果是评分矩阵将被分割为`[102,5:30]`的形式，然后以“：”为分隔符分别分割数组tokens中的元素，以此来判别输入是什么类型的矩阵。如果是同现矩阵，获取itemID1和itemID2以及num，在初始化时创建的静态map中填充以每一个itemID1为键，以List<Cooccurence>对象为值的数据，最后得到的map形象的表示为下图所示的方式：\n```\n{101：[cooccurence(101,101,5),cooccurence(101,102,3),...],\n...\n106:[cooccurence(106,101,2),cooccurence(106,101,1),...],\n107:[cooccurence(107,101,1)}\n```\n如果输入来自用户评分矩阵，会先得到itemID，userID和评分pref，然后将userID设为键，利用itemID从上面的map中得到其对应的list，从list中可以得到*同现item*（通过`co.getItemID2()`）和*同现次数num*，对list中的每项都能得到一个输出，将输出值设为组合字符串“同现item，pref*同现num”，我将通过下图来解释第二项的意义，请读者自行体会。\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/60596269.jpg)\n\nreduce阶段逻辑比较简单，将每个item对应的值加起来就是用户对这个item的推荐的程度。\nStep4在执行的时候会报错：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/51842026.jpg)\n\n原因在于当输入是用户评分矩阵时，同现map并不是随时就绪的，可能不会先构造同现矩阵。因为hadoop从hdfs上读取小文件时，会先读占用空间大的文件，这样就不难保证先生成coocurenceMatrix了，所以Step4.java这个类不能使用，我们把矩阵乘法进行分开计算，先进行对于位置相乘Step4_Updata.java，最后进行加法Step4_Updata2.java\n \n**5). Step4_Update.java，计算推荐结果列表**\n\n​```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.FileSplit;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step4_Update {\n\n\n    public static class Step4_PartialMultiplyMapper extends Mapper<LongWritable, Text, Text, Text> {\n        private String flag;//A同现矩阵,B用户评分矩阵\n\n        @Override\n        protected void setup(Context context) throws IOException, InterruptedException {\n            FileSplit split = (FileSplit) context.getInputSplit();\n            flag = split.getPath().getParent().getName();\n        }\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            if (flag.equals(\"step3_2\")) {\n                String[] v1 = tokens[0].split(\":\");\n                String itemID1 = v1[0];\n                String itemID2 = v1[1];\n                String num = tokens[1];\n\n                Text k = new Text(itemID1);\n                Text v = new Text(\"A:\" + itemID2 + \",\" + num);\n                context.write(k, v);\n            } else if (flag.equals(\"step3_1\")) {\n                String[] v2 = tokens[1].split(\":\");\n                String itemID = tokens[0];\n                String userID = v2[0];\n                String pref = v2[1];\n                Text k = new Text(itemID);\n                Text v = new Text(\"B:\" + userID + \",\" + pref);\n                context.write(k, v);\n            }\n        }\n    }\n\n    public static class Step4_AggregateReducer extends Reducer<Text, Text, Text, Text> {\n        @Override\n        protected void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            //System.out.println(key.toString() + \":\");\n            Map<String, String> mapA = new HashMap<String, String>();\n            Map<String, String> mapB = new HashMap<String, String>();\n            for (Text line : values) {\n                String val = line.toString();\n                //System.out.println(val);\n\n                if (val.startsWith(\"A:\")) {\n                    String[] kv = Recommend.DELIMITER.split(val.substring(2));\n                    mapA.put(kv[0], kv[1]);\n                } else if (val.startsWith(\"B:\")) {\n                    String[] kv = Recommend.DELIMITER.split(val.substring(2));\n                    mapB.put(kv[0], kv[1]);\n                }\n            }\n\n            double result = 0;\n            Iterator<String> iter = mapA.keySet().iterator();\n            while (iter.hasNext()) {\n                String mapk = iter.next();//itemID2\n                int num = Integer.parseInt(mapA.get(mapk));\n                Iterator<String> iterb = mapB.keySet().iterator();//userID\n                while (iterb.hasNext()) {\n                    String mapkb = iterb.next();\n\n                    double pref = Double.parseDouble(mapB.get(mapkb));\n                    result = num * pref;\n                    Text k = new Text(mapkb);\n                    Text v = new Text(mapk + \",\" + result);\n                    context.write(k, v);\n                }\n            }\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf);\n        String input1 = path.get(\"Step5Input1\");\n        String input2 = path.get(\"Step5Input2\");\n        String output = path.get(\"Step5Output\");\n\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n\n        job.setJarByClass(Step4_Update.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setMapperClass(Step4_Update.Step4_PartialMultiplyMapper.class);\n        job.setReducerClass(Step4_Update.Step4_AggregateReducer.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input1), new Path(input2));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}\n```\n在Mapper的setup阶段，通过`split.getPath().getParent().getName()`来确定输入来自那个文件，如果来自用户评分矩阵，则输出以A：打头的值，否则以B：打头，键均为itemID\nredece阶段：键为item1，创建mapA和mapB，mapA的内容为（item2,num），mapB的值为(userId，pref),对于mapA中的每个item2和num，为每个user计算num*pref，输出的值为（userId，“itemID2,num*pref”）\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/27264349.jpg)\n\nstep4_update.java输出是：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/96688878.jpg) \n\n**6).Step4_Update2.java:计算推荐结果**\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step4_Update2 {\n    public static class Step4_RecommendMapper extends Mapper<LongWritable, Text, Text, Text> {\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            Text k = new Text(tokens[0]);\n            Text v = new Text(tokens[1] + \",\" + tokens[2]);\n            context.write(k,v);\n        }\n    }\n\n    public static class Step4_RecommendReducer extends Reducer<Text,Text, Text, Text> {\n        @Override\n        protected void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            System.out.println(key.toString());\n            Map<String, Double> map = new HashMap<String, Double>();\n            for (Text line : values) {\n                System.out.println(line.toString());\n                String [] tokens = Recommend.DELIMITER.split(line.toString());\n                String itemID = tokens[0];\n                Double score = Double.parseDouble(tokens[1]);\n\n                if (map.containsKey(itemID)) {\n                    map.put(itemID, map.get(itemID) + score);\n                } else {\n                    map.put(itemID, score);\n                }\n            }\n\n            Iterator<String> iter = map.keySet().iterator();\n            while (iter.hasNext()) {\n                String itemID = iter.next();\n                double score = map.get(itemID);\n                Text v = new Text(itemID + \",\" + score);\n                context.write(key,v);\n            }\n        }\n    }\n    public static void run(Map<String, String> path) throws InterruptedException, IOException, ClassNotFoundException {\n        Configuration conf = new Configuration();\n\n        String input = path.get(\"Step6Input\");\n        String output = path.get(\"Step6Output\");\n\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n        Job job = new Job(conf);\n        job.setJarByClass(Step4_Update2.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setMapperClass(Step4_Update2.Step4_RecommendMapper.class);\n        job.setReducerClass(Step4_Update2.Step4_RecommendReducer.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}\n```\n较为简单，求和即可，结果如下：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/61332065.jpg)\n五、程序开发：爬虫的编写\n本爬虫爬取图书的信息，未整理完毕，可以根据需求更改\nitem.py\n```python\nimport scrapy\n\n\nclass DoubanbooksItem(scrapy.Item):\n    book_name = scrapy.Field()  # 图书名\n    book_star = scrapy.Field()  # 图书评分\n    book_pl = scrapy.Field()  # 图书评论数\n    book_author = scrapy.Field()  # 图书作者\n    book_publish = scrapy.Field()  # 出版社\n    book_date = scrapy.Field()  # 出版日期\n    book_price = scrapy.Field()  # 图书价格\n    book_tag = scrapy.Field()\n    book_desc = scrapy.Field()\n    book_id = scrapy.Field()```\nbookspider.py\n​```python\n# -*- coding: utf-8 -*-\nimport urllib\n\nimport scrapy\nfrom PIL import Image\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import CrawlSpider, Rule\nfrom scrapy.selector import Selector\nfrom doubanBooks.items import DoubanbooksItem\n\n\nclass BookspiderSpider(CrawlSpider):\n    name = 'bookspider'\n    allowed_domains = ['douban.com']\n    start_urls = [\"https://book.douban.com/tag/\"]\n    rules = (\n        Rule(LinkExtractor(allow=r'tag/.{2,4}'), callback='parse_item', follow=False),\n        Rule(LinkExtractor(allow=r'https://book.douban.com/tag/.+/?start=\\d+&type=T'), callback='parse_item2', follow=True),\n        # Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d+/'), callback='parse_item2',follow=False),\n        # Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d/reviews'), callback='parse_item3', follow=False),\n    )\n\n\n\n\n    # def start_requests(self):\n    #     '''\n    #     重写start_requests，请求登录页面\n    #     '''\n    #     return [scrapy.FormRequest(\"https://accounts.douban.com/login\", meta={\"cookiejar\": 1},\n    #                                callback=self.parse_before_login)]\n    #\n\n\n    def parse_item0(self, response):\n        sel = Selector(response);\n        # item['book_tag'] = sel.xpath('/html/body/div[3]/div[1]/h1/text()').extract()[0].split(':')[1].strip()\n\n    def parse_item(self, response):\n        pass\n       # print(response)\n\n    def parse_item2(self, response):\n        sel = Selector(response)\n        item = DoubanbooksItem()\n        item['book_tag'] = sel.xpath('/html/body/div[3]/div[1]/h1/text()').extract()[0].strip().split(':')[1]\n        book_list = sel.css('#subject_list > ul > li')\n        for book in book_list:\n\n            try:\n                # strip() 方法用于移除字符串头尾指定的字符（默认为空格）\n                item['book_name'] = book.xpath('div[@class=\"info\"]/h2/a/text()').extract()[0].strip()\n                item['book_star'] = book.xpath(\"div[@class='info']/div[2]/span[@class='rating_nums']/text()\").extract()[0].strip()\n                item['book_pl'] = book.xpath(\"div[@class='info']/div[2]/span[@class='pl']/text()\").extract()[0].strip()\n                item['book_desc'] = book.xpath(\"div[2]/p/text()\").extract()[0]\n                item['book_id'] = book.xpath('div[@class=\"info\"]/h2[@class=\"\"]/a/@href').extract()[0].strip().split('/')[-2]\n                pub = book.xpath('div[@class=\"info\"]/div[@class=\"pub\"]/text()').extract()[0].strip().split('/')\n                item['book_price'] = pub.pop()\n                item['book_date'] = pub.pop()\n                item['book_publish'] = pub.pop()\n                item['book_author'] = '/'.join(pub)\n\n                yield item\n            except:\n                pass\n\n# def parse_item4(self, response):\n#         sel = Selector(response);\n#         item = DoubanbooksItem()\n#         item['user_name'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()\n#         item['user_score'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()\n#         yield item\n\n    def parse_before_login(self, response):\n        print(\"登录前表单填充\")\n        captcha_id = response.xpath('//input[@name=\"captcha-id\"]/@value').extract_first()\n        captcha_image_url = response.xpath('//img[@id=\"captcha_image\"]/@src').extract_first()\n        if captcha_image_url is None:\n            print(\"登录时无验证码\")\n            formdata = {\n                \"form_email\": \"18911341910\",\n                # 请填写你的密码\n                \"form_password\": \"lh1994114\",\n                \"login\": \"登录\",\n                \"redir\": \"https://www.douban.com/\",\n                \"source\": \"index_nav\",\n            }\n        else:\n            print(\"登录时有验证码\")\n            save_image_path = \"/media/harold/SpareDisk/pythonProject/captcha.jpeg\"\n            # 将图片验证码下载到本地\n            urllib.request.urlretrieve(captcha_image_url, save_image_path)\n            # 打开图片，以便我们识别图中验证码\n            try:\n                im = Image.open(save_image_path)\n                im.show()\n            except:\n                pass\n            # 手动输入验证码\n            captcha_solution = input('根据打开的图片输入验证码:')\n            formdata = {\n                \"source\": \"None\",\n                \"redir\": \"https://www.douban.com/\",\n                \"form_email\": \"13227708059@163.com\",\n                # 此处请填写密码\n                \"form_password\": \"*******\",\n                \"captcha-solution\": captcha_solution,\n                \"captcha-id\": captcha_id,\n                \"login\": \"登录\",\n            }\n\n        print(\"登录中\")\n        # 提交表单\n        return scrapy.FormRequest.from_response(response, meta={\"cookiejar\": response.meta[\"cookiejar\"]},\n                                                formdata=formdata,\n                                                callback=self.parse_after_login)\n\n\n    def parse_after_login(self, response):\n        '''\n        验证登录是否成功\n        '''\n        account = response.xpath('/html/body/div[1]/div/div[1]/ul/li[2]/a/span[1]').extract_first()\n        print(account)\n        if account is None:\n            print(\"登录失败\")\n        else:\n            print(u\"登录成功,当前账户为 %s\" % account)\n            yield self.make_requests_from_url(\"https://book.douban.com/tag/\")\n\n```\npipeline.py 输出到csv\n```python\nfrom scrapy import signals\nfrom scrapy.contrib.exporter import CsvItemExporter\n\n\nclass BookPipeline(object):\n    @classmethod\n    def from_crawler(cls, crawler):\n        pipeline = cls()\n        crawler.signals.connect(pipeline.spider_opened, signals.spider_opened)\n        crawler.signals.connect(pipeline.spider_closed, signals.spider_closed)\n        return pipeline\n\n    def spider_opened(self, spider):\n        self.file = open('output.csv', 'w+b')\n        self.exporter = CsvItemExporter(self.file)\n        self.exporter.start_exporting()\n\n    def spider_closed(self, spider):\n        self.exporter.finish_exporting()\n        self.file.close()\n\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item```\n\n部分结果\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/51973032.jpg)\n\ngithub地址：\n爬虫：https://github.com/Harold1994/doubanBooks\n推荐系统：https://github.com/Harold1994/HadoopFileRecommendation\n\n```","source":"_posts/用hadoop构建豆瓣图书推荐系统.md","raw":"---\ntitle: 用hadoop构建豆瓣图书推荐系统\ndate: 2018-03-28 23:33:49\ntags: [大数据, Hadoop, 推荐系统, 协同过滤]\n---\n\n《Hadoop权威指南》已经通读一遍，对于分布式数据处理大致有一些概念，从网上找一个合适的项目练练手，此博客记录了我基于[张丹大神的电影推荐系统](http://blog.fens.me/hadoop-mapreduce-recommend/)手搓的豆瓣图书推荐系统，Hadoop版本为2.8.0，爬虫用python scrapy框架来写。\n\n**一、推荐系统概述**\n\n互联网已经普及到了今天，更加上机器学习和大数据的浪潮火爆，几乎我们接触的所有网站、App等都会用到推荐系统，比如淘宝的猜你喜欢，头条的新闻推送等等。\n<!-- more-->\n常见的推荐原理有：\n> *基于用户基本信息的推荐* : 例如可以根据用户的性别、职业、 年龄、 所在地等信息向他推荐感兴趣或者相关的内容\n> *基于物品/内容基本信息推荐* ： 根据物品的类型、来源、主题等信息推荐\n> *协同推荐* ： 协同过滤算法通过计算用户之间或者物品之间的相关性来进行推荐\n\n协同过滤算法的实现分为两个步骤：\n1.计算物品之间的相关度\n2.根据物品的相似度和用户的历史行为给用户生成推荐列表\n**二、算法模型**\n这里我们用分步式基于物品的协同过滤算法实现为豆瓣用户推荐图书的系统。测试数据仍然用张丹大神原系统中的small.csv\n```data\n1,101,5.0\n1,102,3.0\n1,103,2.5\n2,101,2.0\n2,102,2.5\n2,103,5.0\n2,104,2.0\n3,101,2.0\n3,104,4.0\n3,105,4.5\n3,107,5.0\n4,101,5.0\n4,103,3.0\n4,104,4.5\n4,106,4.0\n5,101,4.0\n5,102,3.0\n5,103,2.0\n5,104,4.0\n5,105,3.5\n5,106,4.0\n```\n每行3个字段，依次代表用户ID，图书ID，用户对图书的评分(0-5分）。\n本推荐系统执行的思路：\n1. 建立物品的同现矩阵： 同现矩阵的值代表了某两本书同时出现在用户的评价列表中的次数\n```data\n      [101] [102] [103] [104] [105] [106] [107]\n[101]   5     3     4     4     2     2     1\n[102]   3     3     3     2     1     1     0\n[103]   4     3     4     3     1     2     0\n[104]   4     2     3     4     2     2     1\n[105]   2     1     1     2     2     1     1\n[106]   2     1     2     2     1     2     0\n[107]   1     0     0     1     1     0     1```\n2. 建立用户对物品的评分矩阵： 有多少个用户就有多少个评分矩阵\n​```data\n       U3\n[101] 2.0\n[102] 0.0\n[103] 0.0\n[104] 4.0\n[105] 4.5\n[106] 0.0\n[107] 5.0```\n3. 矩阵计算推荐结果： 同现矩阵*评分矩阵 = 推荐结果\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/78005679.jpg)\n\n**三、系统架构**\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/71568403.jpg)\n\n上图左边是Application业务系统，右边是本博客要实现的HDFS，MapReduce\n1.业务系统记录了用户行为和用户对物品的打分（这里我们用爬取到的数据代替）\n2.设置系统定时器CRON，隔一段时间增量向HDFS导入数据，即本系统需要的userId，itemId，value，time\n3.完成导入后，设置系统定时器，启动MapReduce程序，运行推荐算法。\n4.完成计算后，设置系统定时器，从HDFS导出推荐结果数据到数据库，方便以后的及时查询。\n\n**四 程序开发：MapReduce程序的实现**\n开发环境：Ubuntu 16.04, IntelliJ IDEA， 和Hadoop2.8.0\n新建类：\n    Recommend.java，主任务启动程序\n    Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵\n    Step2.java，对物品组合列表进行计数，建立物品的同现矩阵\n    Step3.java，对同现矩阵和评分矩阵转型\n    *Step4.java，计算推荐结果列表，结果会出问题，最终不用这个类\n    Step4_Update.java, 计算部分评分\n    Step4_Update2.java, 计算最终评分，得到推荐结果\n    HdfsDAO.java，HDFS操作工具类\n\n*1）.Recommend.java,任务驱动程序*\n​```java\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\npublic class Recommend {\n    public static final Pattern DELIMITER = Pattern.compile(\"[\\t,]\");\n    public static final String HDFS = \"hdfs://localhost/\";\n\n    public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {\n        Map<String, String> path = new HashMap<String, String>();\n        path.put(\"data\", \"resources/small.csv\");\n        path.put(\"Step1Input\", HDFS + \"/user/hdfs/recommend\");\n        path.put(\"Step1Output\", path.get(\"Step1Input\") + \"/step1\");\n        path.put(\"Step2Input\", path.get(\"Step1Output\"));\n        path.put(\"Step2Output\", path.get(\"Step1Input\") + \"/step2\");\n        path.put(\"Step3Input1\", path.get(\"Step1Output\"));\n        path.put(\"Step3Output1\", path.get(\"Step1Input\") + \"/step3_1\");\n        path.put(\"Step3Input2\", path.get(\"Step2Output\"));\n        path.put(\"Step3Output2\", path.get(\"Step1Input\") + \"/step3_2\");\n\n        path.put(\"Step4Input1\", path.get(\"Step3Output1\"));\n        path.put(\"Step4Input2\", path.get(\"Step3Output2\"));\n        path.put(\"Step4Output\", path.get(\"Step1Input\") + \"/step4\");\n\n        path.put(\"Step5Input1\", path.get(\"Step3Output1\"));\n        path.put(\"Step5Input2\", path.get(\"Step3Output2\"));\n        path.put(\"Step5Output\", path.get(\"Step1Input\") + \"/step5\");\n\n        path.put(\"Step6Input\", path.get(\"Step5Output\"));\n        path.put(\"Step6Output\", path.get(\"Step1Input\") + \"/step6\");\n\n        Step1.run(path);\n        Step2.run(path);\n        Step3.run(path);\n        Step3.run2(path);\n        Step4.run(path);//NullPointerException,可能不会先构造同现矩阵\n//        Step4_Update.run(path);\n        Step4_Update2.run(path);\n\n        System.exit(0);\n    }\n}\n```\n*2). Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵*\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step1 {\n\n    public static class Step1_ToItemPreMapper extends Mapper<Object, Text, IntWritable, Text> {\n\n        @Override\n        protected void map(Object key, Text value, Context context) throws IOException, InterruptedException {\n            String tokens[] = Recommend.DELIMITER.split(value.toString());\n            int userId = Integer.parseInt(tokens[0]);\n            String itemId = tokens[1];\n            String pref = tokens[2];\n            context.write(new IntWritable(userId), new Text(itemId + \":\" + pref));\n        }\n    }\n\n    public static class Step1_ToUserVectorReducer extends Reducer<IntWritable, Text, IntWritable, Text> {\n        @Override\n        protected void reduce(IntWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            StringBuilder sb = new StringBuilder();\n            Iterator<Text> iter = values.iterator();\n            while (iter.hasNext()) {\n                sb.append(\",\" + iter.next());\n            }\n            context.write(key, new Text(sb.toString().replaceFirst(\",\", \"\")));\n        }\n    }\n\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        String input = path.get(\"Step1Input\");\n        String output = path.get(\"Step1Output\");\n\n        Configuration conf = new Configuration();\n//        conf.set(\"mapreduce.task.io.sort.mb\",\"1024\");//任务内部排序缓冲区大小,默认为100\n\n        Job job = new Job(conf, \"Step1\");\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(input);\n        hdfs.mkdirs(input);\n        hdfs.copyFile(path.get(\"data\"), input);\n\n        job.setJarByClass(Step1.class);\n        job.setMapOutputKeyClass(IntWritable.class);\n        job.setMapOutputValueClass(Text.class);\n\n        job.setOutputKeyClass(IntWritable.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        job.setMapperClass(Step1_ToItemPreMapper.class);\n        job.setReducerClass(Step1_ToUserVectorReducer.class);\n        job.setCombinerClass(Step1_ToUserVectorReducer.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}```\nmap阶段：用正则表达式分割输入数据，以userId为键，图书id和打分组合成字符串itemId：pref传递给Reducer\nreduce阶段：此时传进来的key已经按照userId分好块，于是我们可以得到每个用户的评分矩阵\nStep1的输出为：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/97798258.jpg)\n\n*3). Step2.java，对物品组合列表进行计数，建立物品的同现矩阵*\n​```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step2 {\n    public static class Step2_UserVectorToCooccurrenceMapper extends Mapper<LongWritable, Text, Text, IntWritable> {\n        private final static Text k = new Text();\n        private final static IntWritable v = new IntWritable(1);\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            for (int i = 1; i < tokens.length; i++) {\n                String itemId = tokens[i].split(\":\")[0];\n                for (int j = 1; j < tokens.length; j++) {\n                    String itemId2 = tokens[j].split(\":\")[0];\n                    context.write(new Text(itemId + \":\" + itemId2), v);\n                }\n            }\n        }\n    }\n\n    public static class Step2_UserVectorToCooccurrenceReducer extends Reducer<Text, IntWritable, Text, IntWritable> {\n        @Override\n        protected void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n            int sum = 0;\n            Iterator<IntWritable> iter = values.iterator();\n            while (iter.hasNext()) {\n                sum += iter.next().get();\n            }\n            context.write(key, new IntWritable(sum));\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"Step2\");\n\n        String input = path.get(\"Step2Input\");\n        String output = path.get(\"Step2Output\");\n        System.out.println(output);\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n\n        job.setJarByClass(Step2.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(IntWritable.class);\n\n        job.setMapperClass(Step2_UserVectorToCooccurrenceMapper.class);\n        job.setCombinerClass(Step2_UserVectorToCooccurrenceReducer.class);\n        job.setReducerClass(Step2_UserVectorToCooccurrenceReducer.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n\n    }\n}\n```\nStep2的输入是Step1的输出，\nmap阶段：用正则表达式分割每行，利用双重循环构造每行中任意两个itemsId的组合作为键，用数字1作为值输出到Reducer\nreduce阶段：Mapper传来的数据已经按键分块，累加每种键下的值即可得到item1和item2出现在同一个评分列表中的次数，即得到图书的同现矩阵\nStep2的输出为：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/19253791.jpg)\n\n*4). Step3.java，合并同现矩阵和评分矩阵*\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class Step3 {\n    public static class Step31_UserVectorSplitterMapper extends Mapper<LongWritable, Text, IntWritable, Text> {\n        private IntWritable k = new IntWritable();\n        private Text v = new Text();\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            for (int i = 1; i < tokens.length; i++) {\n                String[] vector = tokens[i].split(\":\");\n                int itemId = Integer.parseInt(vector[0]);\n                String pref = vector[1];\n                k.set(itemId);\n                v.set(tokens[0] + \":\" + pref);\n                context.write(k, v);\n            }\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"step31_spliteUserVector\");\n        String input = path.get(\"Step3Input1\");\n        String output = path.get(\"Step3Output1\");\n\n        HdfsDAO hdfs = new HdfsDAO(conf);\n        hdfs.rmr(output);\n        job.setJarByClass(Step3.class);\n        job.setMapOutputKeyClass(IntWritable.class);\n        job.setMapOutputValueClass(Text.class);\n\n        job.setMapperClass(Step31_UserVectorSplitterMapper.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.setNumReduceTasks(0);\n        job.waitForCompletion(true);\n    }\n\n    public static class Step32_CooccurreceColumWrapperMapper extends Mapper<LongWritable, Text, Text, IntWritable> {\n        private final static Text k = new Text();\n        private final static IntWritable v = new IntWritable();\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String tokens[] = Recommend.DELIMITER.split(value.toString());\n            k.set(tokens[0]);\n            v.set(Integer.parseInt(tokens[1])); //这里和step2的输出有什么区别????\n            context.write(k, v);\n        }\n    }\n\n    public static void run2(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"step32_cooccurreceMap\");\n        String input = path.get(\"Step3Input2\");\n        String output = path.get(\"Step3Output2\");\n        job.setJarByClass(Step3.class);\n        HdfsDAO hdfs = new HdfsDAO(conf);\n        hdfs.rmr(output);\n\n        job.setMapOutputKeyClass(Text.class);\n        job.setMapOutputValueClass(IntWritable.class);\n\n        job.setMapperClass(Step32_CooccurreceColumWrapperMapper.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.setNumReduceTasks(0);\n        job.waitForCompletion(true);\n    }\n}\n```\nStep3_1将用户评分矩阵拆分为itemId\tuserId:pref的形式输出，为了方便之后的计算\nStep3_2看起来输出结果与Step2相同\nStep3_1输出：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/9400783.jpg)\nStep3_1输出：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/22519877.jpg)\n\n*5). Step4.java，计算推荐结果列表*\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.*;\n\npublic class Step4 {\n    public static class Step4_PartialMultiplyMapper extends Mapper<LongWritable, Text, IntWritable, Text> {\n        private final static IntWritable k = new IntWritable();\n        private final static Text v = new Text();\n        private final static Map<Integer, List<Cooccurrence>> cooccurrenceMatrix = new HashMap<Integer, List<Cooccurrence>>();\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n\n            String[] v1 = tokens[0].split(\":\");\n            String[] v2 = tokens[1].split(\":\");\n\n            if (v1.length > 1) {// cooccurrence\n                int itemID1 = Integer.parseInt(v1[0]);\n                int itemID2 = Integer.parseInt(v1[1]);\n                int num = Integer.parseInt(tokens[1]);\n\n                List<Cooccurrence> list = null;\n                if (!cooccurrenceMatrix.containsKey(itemID1)) {\n                    list = new ArrayList<Cooccurrence>();\n                } else {\n                    list = cooccurrenceMatrix.get(itemID1);\n                }\n                list.add(new Cooccurrence(itemID1, itemID2, num));\n                cooccurrenceMatrix.put(itemID1, list);\n            }\n\n            if (v2.length > 1) {// userVector\n                int itemID = Integer.parseInt(tokens[0]);\n                int userID = Integer.parseInt(v2[0]);\n                double pref = Double.parseDouble(v2[1]);\n                k.set(userID);\n                for (Cooccurrence co : cooccurrenceMatrix.get(itemID)) {\n                    v.set(co.getItemID2() + \",\" + pref * co.getNum());\n                    context.write(k, v);\n                }\n            }\n        }\n    }\n\n    public static class Step4_AggregateAndRecommendReducer extends Reducer<IntWritable, Text, IntWritable, Text> {\n        private final static Text v = new Text();\n\n        @Override\n        protected void reduce(IntWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            Map<String, Double> result = new HashMap<String, Double>();\n            Iterator<Text> iter = values.iterator();\n            while (iter.hasNext()) {\n                String[] str = iter.next().toString().split(\",\");\n                if (result.containsKey(str[0])) {\n                    result.put(str[0], result.get(str[0]) + Double.parseDouble(str[1]));\n                } else {\n                    result.put(str[0], Double.parseDouble(str[1]));\n                }\n            }\n            Iterator<String> iter2 = result.keySet().iterator();\n            while (iter.hasNext()) {\n                String itemID = iter2.next();\n                double score = result.get(itemID);\n                v.set(itemID + \",\" + score);\n                context.write(key, v);\n            }\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        String input1 = path.get(\"Step4Input1\");\n        String input2 = path.get(\"Step4Input2\");\n        String output = path.get(\"Step4Output\");\n\n        Configuration conf = new Configuration();\n        Job job = new Job(conf, \"Step4\");\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n        job.setJarByClass(Step4.class);\n\n        job.setOutputKeyClass(IntWritable.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        job.setMapperClass(Step4_PartialMultiplyMapper.class);\n        job.setReducerClass(Step4_AggregateAndRecommendReducer.class);\n        job.setCombinerClass(Step4_AggregateAndRecommendReducer.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input1), new Path(input2));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}\n\nclass Cooccurrence {\n    private int itemID1;\n    private int itemID2;\n    private int num;\n\n    public Cooccurrence(int itemID1, int itemID2, int num) {\n        super();\n        this.itemID1 = itemID1;\n        this.itemID2 = itemID2;\n        this.num = num;\n    }\n\n    public int getItemID1() {\n        return itemID1;\n    }\n\n    public int getItemID2() {\n        return itemID2;\n    }\n\n    public int getNum() {\n        return num;\n    }\n\n    public void setItemID1(int itemID1) {\n        this.itemID1 = itemID1;\n    }\n\n    public void setItemID2(int itemID2) {\n        this.itemID2 = itemID2;\n    }\n\n    public void setNum(int num) {\n        this.num = num;\n    }\n}```\nStep4的输入来自两个路径，分别是step3_1和step3_2的输出，\nmap阶段：对输入的值进行分割，如果是同现矩阵其将被分割为`[101:102,3]`的形式，如果是评分矩阵将被分割为`[102,5:30]`的形式，然后以“：”为分隔符分别分割数组tokens中的元素，以此来判别输入是什么类型的矩阵。如果是同现矩阵，获取itemID1和itemID2以及num，在初始化时创建的静态map中填充以每一个itemID1为键，以List<Cooccurence>对象为值的数据，最后得到的map形象的表示为下图所示的方式：\n```\n{101：[cooccurence(101,101,5),cooccurence(101,102,3),...],\n...\n106:[cooccurence(106,101,2),cooccurence(106,101,1),...],\n107:[cooccurence(107,101,1)}\n```\n如果输入来自用户评分矩阵，会先得到itemID，userID和评分pref，然后将userID设为键，利用itemID从上面的map中得到其对应的list，从list中可以得到*同现item*（通过`co.getItemID2()`）和*同现次数num*，对list中的每项都能得到一个输出，将输出值设为组合字符串“同现item，pref*同现num”，我将通过下图来解释第二项的意义，请读者自行体会。\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/60596269.jpg)\n\nreduce阶段逻辑比较简单，将每个item对应的值加起来就是用户对这个item的推荐的程度。\nStep4在执行的时候会报错：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/51842026.jpg)\n\n原因在于当输入是用户评分矩阵时，同现map并不是随时就绪的，可能不会先构造同现矩阵。因为hadoop从hdfs上读取小文件时，会先读占用空间大的文件，这样就不难保证先生成coocurenceMatrix了，所以Step4.java这个类不能使用，我们把矩阵乘法进行分开计算，先进行对于位置相乘Step4_Updata.java，最后进行加法Step4_Updata2.java\n \n**5). Step4_Update.java，计算推荐结果列表**\n\n​```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.FileSplit;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step4_Update {\n\n\n    public static class Step4_PartialMultiplyMapper extends Mapper<LongWritable, Text, Text, Text> {\n        private String flag;//A同现矩阵,B用户评分矩阵\n\n        @Override\n        protected void setup(Context context) throws IOException, InterruptedException {\n            FileSplit split = (FileSplit) context.getInputSplit();\n            flag = split.getPath().getParent().getName();\n        }\n\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            if (flag.equals(\"step3_2\")) {\n                String[] v1 = tokens[0].split(\":\");\n                String itemID1 = v1[0];\n                String itemID2 = v1[1];\n                String num = tokens[1];\n\n                Text k = new Text(itemID1);\n                Text v = new Text(\"A:\" + itemID2 + \",\" + num);\n                context.write(k, v);\n            } else if (flag.equals(\"step3_1\")) {\n                String[] v2 = tokens[1].split(\":\");\n                String itemID = tokens[0];\n                String userID = v2[0];\n                String pref = v2[1];\n                Text k = new Text(itemID);\n                Text v = new Text(\"B:\" + userID + \",\" + pref);\n                context.write(k, v);\n            }\n        }\n    }\n\n    public static class Step4_AggregateReducer extends Reducer<Text, Text, Text, Text> {\n        @Override\n        protected void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            //System.out.println(key.toString() + \":\");\n            Map<String, String> mapA = new HashMap<String, String>();\n            Map<String, String> mapB = new HashMap<String, String>();\n            for (Text line : values) {\n                String val = line.toString();\n                //System.out.println(val);\n\n                if (val.startsWith(\"A:\")) {\n                    String[] kv = Recommend.DELIMITER.split(val.substring(2));\n                    mapA.put(kv[0], kv[1]);\n                } else if (val.startsWith(\"B:\")) {\n                    String[] kv = Recommend.DELIMITER.split(val.substring(2));\n                    mapB.put(kv[0], kv[1]);\n                }\n            }\n\n            double result = 0;\n            Iterator<String> iter = mapA.keySet().iterator();\n            while (iter.hasNext()) {\n                String mapk = iter.next();//itemID2\n                int num = Integer.parseInt(mapA.get(mapk));\n                Iterator<String> iterb = mapB.keySet().iterator();//userID\n                while (iterb.hasNext()) {\n                    String mapkb = iterb.next();\n\n                    double pref = Double.parseDouble(mapB.get(mapkb));\n                    result = num * pref;\n                    Text k = new Text(mapkb);\n                    Text v = new Text(mapk + \",\" + result);\n                    context.write(k, v);\n                }\n            }\n        }\n    }\n\n    public static void run(Map<String, String> path) throws IOException, ClassNotFoundException, InterruptedException {\n        Configuration conf = new Configuration();\n        Job job = new Job(conf);\n        String input1 = path.get(\"Step5Input1\");\n        String input2 = path.get(\"Step5Input2\");\n        String output = path.get(\"Step5Output\");\n\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n\n        job.setJarByClass(Step4_Update.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setMapperClass(Step4_Update.Step4_PartialMultiplyMapper.class);\n        job.setReducerClass(Step4_Update.Step4_AggregateReducer.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input1), new Path(input2));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}\n```\n在Mapper的setup阶段，通过`split.getPath().getParent().getName()`来确定输入来自那个文件，如果来自用户评分矩阵，则输出以A：打头的值，否则以B：打头，键均为itemID\nredece阶段：键为item1，创建mapA和mapB，mapA的内容为（item2,num），mapB的值为(userId，pref),对于mapA中的每个item2和num，为每个user计算num*pref，输出的值为（userId，“itemID2,num*pref”）\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/27264349.jpg)\n\nstep4_update.java输出是：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/96688878.jpg) \n\n**6).Step4_Update2.java:计算推荐结果**\n```java\nimport hdfs.HdfsDAO;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.TextInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Step4_Update2 {\n    public static class Step4_RecommendMapper extends Mapper<LongWritable, Text, Text, Text> {\n        @Override\n        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {\n            String[] tokens = Recommend.DELIMITER.split(value.toString());\n            Text k = new Text(tokens[0]);\n            Text v = new Text(tokens[1] + \",\" + tokens[2]);\n            context.write(k,v);\n        }\n    }\n\n    public static class Step4_RecommendReducer extends Reducer<Text,Text, Text, Text> {\n        @Override\n        protected void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n            System.out.println(key.toString());\n            Map<String, Double> map = new HashMap<String, Double>();\n            for (Text line : values) {\n                System.out.println(line.toString());\n                String [] tokens = Recommend.DELIMITER.split(line.toString());\n                String itemID = tokens[0];\n                Double score = Double.parseDouble(tokens[1]);\n\n                if (map.containsKey(itemID)) {\n                    map.put(itemID, map.get(itemID) + score);\n                } else {\n                    map.put(itemID, score);\n                }\n            }\n\n            Iterator<String> iter = map.keySet().iterator();\n            while (iter.hasNext()) {\n                String itemID = iter.next();\n                double score = map.get(itemID);\n                Text v = new Text(itemID + \",\" + score);\n                context.write(key,v);\n            }\n        }\n    }\n    public static void run(Map<String, String> path) throws InterruptedException, IOException, ClassNotFoundException {\n        Configuration conf = new Configuration();\n\n        String input = path.get(\"Step6Input\");\n        String output = path.get(\"Step6Output\");\n\n        HdfsDAO hdfs = new HdfsDAO(Recommend.HDFS, conf);\n        hdfs.rmr(output);\n        Job job = new Job(conf);\n        job.setJarByClass(Step4_Update2.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(Text.class);\n\n        job.setMapperClass(Step4_Update2.Step4_RecommendMapper.class);\n        job.setReducerClass(Step4_Update2.Step4_RecommendReducer.class);\n\n        job.setInputFormatClass(TextInputFormat.class);\n        job.setOutputFormatClass(TextOutputFormat.class);\n\n        FileInputFormat.setInputPaths(job, new Path(input));\n        FileOutputFormat.setOutputPath(job, new Path(output));\n\n        job.waitForCompletion(true);\n    }\n}\n```\n较为简单，求和即可，结果如下：\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/61332065.jpg)\n五、程序开发：爬虫的编写\n本爬虫爬取图书的信息，未整理完毕，可以根据需求更改\nitem.py\n```python\nimport scrapy\n\n\nclass DoubanbooksItem(scrapy.Item):\n    book_name = scrapy.Field()  # 图书名\n    book_star = scrapy.Field()  # 图书评分\n    book_pl = scrapy.Field()  # 图书评论数\n    book_author = scrapy.Field()  # 图书作者\n    book_publish = scrapy.Field()  # 出版社\n    book_date = scrapy.Field()  # 出版日期\n    book_price = scrapy.Field()  # 图书价格\n    book_tag = scrapy.Field()\n    book_desc = scrapy.Field()\n    book_id = scrapy.Field()```\nbookspider.py\n​```python\n# -*- coding: utf-8 -*-\nimport urllib\n\nimport scrapy\nfrom PIL import Image\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import CrawlSpider, Rule\nfrom scrapy.selector import Selector\nfrom doubanBooks.items import DoubanbooksItem\n\n\nclass BookspiderSpider(CrawlSpider):\n    name = 'bookspider'\n    allowed_domains = ['douban.com']\n    start_urls = [\"https://book.douban.com/tag/\"]\n    rules = (\n        Rule(LinkExtractor(allow=r'tag/.{2,4}'), callback='parse_item', follow=False),\n        Rule(LinkExtractor(allow=r'https://book.douban.com/tag/.+/?start=\\d+&type=T'), callback='parse_item2', follow=True),\n        # Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d+/'), callback='parse_item2',follow=False),\n        # Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d/reviews'), callback='parse_item3', follow=False),\n    )\n\n\n\n\n    # def start_requests(self):\n    #     '''\n    #     重写start_requests，请求登录页面\n    #     '''\n    #     return [scrapy.FormRequest(\"https://accounts.douban.com/login\", meta={\"cookiejar\": 1},\n    #                                callback=self.parse_before_login)]\n    #\n\n\n    def parse_item0(self, response):\n        sel = Selector(response);\n        # item['book_tag'] = sel.xpath('/html/body/div[3]/div[1]/h1/text()').extract()[0].split(':')[1].strip()\n\n    def parse_item(self, response):\n        pass\n       # print(response)\n\n    def parse_item2(self, response):\n        sel = Selector(response)\n        item = DoubanbooksItem()\n        item['book_tag'] = sel.xpath('/html/body/div[3]/div[1]/h1/text()').extract()[0].strip().split(':')[1]\n        book_list = sel.css('#subject_list > ul > li')\n        for book in book_list:\n\n            try:\n                # strip() 方法用于移除字符串头尾指定的字符（默认为空格）\n                item['book_name'] = book.xpath('div[@class=\"info\"]/h2/a/text()').extract()[0].strip()\n                item['book_star'] = book.xpath(\"div[@class='info']/div[2]/span[@class='rating_nums']/text()\").extract()[0].strip()\n                item['book_pl'] = book.xpath(\"div[@class='info']/div[2]/span[@class='pl']/text()\").extract()[0].strip()\n                item['book_desc'] = book.xpath(\"div[2]/p/text()\").extract()[0]\n                item['book_id'] = book.xpath('div[@class=\"info\"]/h2[@class=\"\"]/a/@href').extract()[0].strip().split('/')[-2]\n                pub = book.xpath('div[@class=\"info\"]/div[@class=\"pub\"]/text()').extract()[0].strip().split('/')\n                item['book_price'] = pub.pop()\n                item['book_date'] = pub.pop()\n                item['book_publish'] = pub.pop()\n                item['book_author'] = '/'.join(pub)\n\n                yield item\n            except:\n                pass\n\n# def parse_item4(self, response):\n#         sel = Selector(response);\n#         item = DoubanbooksItem()\n#         item['user_name'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()\n#         item['user_score'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()\n#         yield item\n\n    def parse_before_login(self, response):\n        print(\"登录前表单填充\")\n        captcha_id = response.xpath('//input[@name=\"captcha-id\"]/@value').extract_first()\n        captcha_image_url = response.xpath('//img[@id=\"captcha_image\"]/@src').extract_first()\n        if captcha_image_url is None:\n            print(\"登录时无验证码\")\n            formdata = {\n                \"form_email\": \"18911341910\",\n                # 请填写你的密码\n                \"form_password\": \"lh1994114\",\n                \"login\": \"登录\",\n                \"redir\": \"https://www.douban.com/\",\n                \"source\": \"index_nav\",\n            }\n        else:\n            print(\"登录时有验证码\")\n            save_image_path = \"/media/harold/SpareDisk/pythonProject/captcha.jpeg\"\n            # 将图片验证码下载到本地\n            urllib.request.urlretrieve(captcha_image_url, save_image_path)\n            # 打开图片，以便我们识别图中验证码\n            try:\n                im = Image.open(save_image_path)\n                im.show()\n            except:\n                pass\n            # 手动输入验证码\n            captcha_solution = input('根据打开的图片输入验证码:')\n            formdata = {\n                \"source\": \"None\",\n                \"redir\": \"https://www.douban.com/\",\n                \"form_email\": \"13227708059@163.com\",\n                # 此处请填写密码\n                \"form_password\": \"*******\",\n                \"captcha-solution\": captcha_solution,\n                \"captcha-id\": captcha_id,\n                \"login\": \"登录\",\n            }\n\n        print(\"登录中\")\n        # 提交表单\n        return scrapy.FormRequest.from_response(response, meta={\"cookiejar\": response.meta[\"cookiejar\"]},\n                                                formdata=formdata,\n                                                callback=self.parse_after_login)\n\n\n    def parse_after_login(self, response):\n        '''\n        验证登录是否成功\n        '''\n        account = response.xpath('/html/body/div[1]/div/div[1]/ul/li[2]/a/span[1]').extract_first()\n        print(account)\n        if account is None:\n            print(\"登录失败\")\n        else:\n            print(u\"登录成功,当前账户为 %s\" % account)\n            yield self.make_requests_from_url(\"https://book.douban.com/tag/\")\n\n```\npipeline.py 输出到csv\n```python\nfrom scrapy import signals\nfrom scrapy.contrib.exporter import CsvItemExporter\n\n\nclass BookPipeline(object):\n    @classmethod\n    def from_crawler(cls, crawler):\n        pipeline = cls()\n        crawler.signals.connect(pipeline.spider_opened, signals.spider_opened)\n        crawler.signals.connect(pipeline.spider_closed, signals.spider_closed)\n        return pipeline\n\n    def spider_opened(self, spider):\n        self.file = open('output.csv', 'w+b')\n        self.exporter = CsvItemExporter(self.file)\n        self.exporter.start_exporting()\n\n    def spider_closed(self, spider):\n        self.exporter.finish_exporting()\n        self.file.close()\n\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item```\n\n部分结果\n\n![](http://p5s7d12ls.bkt.clouddn.com/18-3-28/51973032.jpg)\n\ngithub地址：\n爬虫：https://github.com/Harold1994/doubanBooks\n推荐系统：https://github.com/Harold1994/HadoopFileRecommendation\n\n```","slug":"用hadoop构建豆瓣图书推荐系统","published":1,"updated":"2018-06-07T13:35:07.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i86004mcf96vfj74old","content":"<p>《Hadoop权威指南》已经通读一遍，对于分布式数据处理大致有一些概念，从网上找一个合适的项目练练手，此博客记录了我基于<a href=\"http://blog.fens.me/hadoop-mapreduce-recommend/\" target=\"_blank\" rel=\"noopener\">张丹大神的电影推荐系统</a>手搓的豆瓣图书推荐系统，Hadoop版本为2.8.0，爬虫用python scrapy框架来写。</p>\n<p><strong>一、推荐系统概述</strong></p>\n<p>互联网已经普及到了今天，更加上机器学习和大数据的浪潮火爆，几乎我们接触的所有网站、App等都会用到推荐系统，比如淘宝的猜你喜欢，头条的新闻推送等等。<br><a id=\"more\"></a><br>常见的推荐原理有：</p>\n<blockquote>\n<p><em>基于用户基本信息的推荐</em> : 例如可以根据用户的性别、职业、 年龄、 所在地等信息向他推荐感兴趣或者相关的内容<br><em>基于物品/内容基本信息推荐</em> ： 根据物品的类型、来源、主题等信息推荐<br><em>协同推荐</em> ： 协同过滤算法通过计算用户之间或者物品之间的相关性来进行推荐</p>\n</blockquote>\n<p>协同过滤算法的实现分为两个步骤：<br>1.计算物品之间的相关度<br>2.根据物品的相似度和用户的历史行为给用户生成推荐列表<br><strong>二、算法模型</strong><br>这里我们用分步式基于物品的协同过滤算法实现为豆瓣用户推荐图书的系统。测试数据仍然用张丹大神原系统中的small.csv<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1,101,5.0</span><br><span class=\"line\">1,102,3.0</span><br><span class=\"line\">1,103,2.5</span><br><span class=\"line\">2,101,2.0</span><br><span class=\"line\">2,102,2.5</span><br><span class=\"line\">2,103,5.0</span><br><span class=\"line\">2,104,2.0</span><br><span class=\"line\">3,101,2.0</span><br><span class=\"line\">3,104,4.0</span><br><span class=\"line\">3,105,4.5</span><br><span class=\"line\">3,107,5.0</span><br><span class=\"line\">4,101,5.0</span><br><span class=\"line\">4,103,3.0</span><br><span class=\"line\">4,104,4.5</span><br><span class=\"line\">4,106,4.0</span><br><span class=\"line\">5,101,4.0</span><br><span class=\"line\">5,102,3.0</span><br><span class=\"line\">5,103,2.0</span><br><span class=\"line\">5,104,4.0</span><br><span class=\"line\">5,105,3.5</span><br><span class=\"line\">5,106,4.0</span><br></pre></td></tr></table></figure></p>\n<p>每行3个字段，依次代表用户ID，图书ID，用户对图书的评分(0-5分）。<br>本推荐系统执行的思路：</p>\n<ol>\n<li><p>建立物品的同现矩阵： 同现矩阵的值代表了某两本书同时出现在用户的评价列表中的次数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      [101] [102] [103] [104] [105] [106] [107]</span><br><span class=\"line\">[101]   5     3     4     4     2     2     1</span><br><span class=\"line\">[102]   3     3     3     2     1     1     0</span><br><span class=\"line\">[103]   4     3     4     3     1     2     0</span><br><span class=\"line\">[104]   4     2     3     4     2     2     1</span><br><span class=\"line\">[105]   2     1     1     2     2     1     1</span><br><span class=\"line\">[106]   2     1     2     2     1     2     0</span><br><span class=\"line\">[107]   1     0     0     1     1     0     1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>建立用户对物品的评分矩阵： 有多少个用户就有多少个评分矩阵<br>​<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       U3</span><br><span class=\"line\">[101] 2.0</span><br><span class=\"line\">[102] 0.0</span><br><span class=\"line\">[103] 0.0</span><br><span class=\"line\">[104] 4.0</span><br><span class=\"line\">[105] 4.5</span><br><span class=\"line\">[106] 0.0</span><br><span class=\"line\">[107] 5.0</span><br></pre></td></tr></table></figure></p>\n</li>\n<li><p>矩阵计算推荐结果： 同现矩阵*评分矩阵 = 推荐结果<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/78005679.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p><strong>三、系统架构</strong><br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/71568403.jpg\" alt=\"\"></p>\n<p>上图左边是Application业务系统，右边是本博客要实现的HDFS，MapReduce<br>1.业务系统记录了用户行为和用户对物品的打分（这里我们用爬取到的数据代替）<br>2.设置系统定时器CRON，隔一段时间增量向HDFS导入数据，即本系统需要的userId，itemId，value，time<br>3.完成导入后，设置系统定时器，启动MapReduce程序，运行推荐算法。<br>4.完成计算后，设置系统定时器，从HDFS导出推荐结果数据到数据库，方便以后的及时查询。</p>\n<p><strong>四 程序开发：MapReduce程序的实现</strong><br>开发环境：Ubuntu 16.04, IntelliJ IDEA， 和Hadoop2.8.0<br>新建类：<br>    Recommend.java，主任务启动程序<br>    Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵<br>    Step2.java，对物品组合列表进行计数，建立物品的同现矩阵<br>    Step3.java，对同现矩阵和评分矩阵转型<br>    *Step4.java，计算推荐结果列表，结果会出问题，最终不用这个类<br>    Step4_Update.java, 计算部分评分<br>    Step4_Update2.java, 计算最终评分，得到推荐结果<br>    HdfsDAO.java，HDFS操作工具类</p>\n<p><em>1）.Recommend.java,任务驱动程序</em><br>​<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Recommend</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Pattern DELIMITER = Pattern.compile(<span class=\"string\">\"[\\t,]\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String HDFS = <span class=\"string\">\"hdfs://localhost/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        Map&lt;String, String&gt; path = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">        path.put(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"resources/small.csv\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step1Input\"</span>, HDFS + <span class=\"string\">\"/user/hdfs/recommend\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step1Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step1\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step2Input\"</span>, path.get(<span class=\"string\">\"Step1Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step2Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step2\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Input1\"</span>, path.get(<span class=\"string\">\"Step1Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Output1\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step3_1\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Input2\"</span>, path.get(<span class=\"string\">\"Step2Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Output2\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step3_2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step4Input1\"</span>, path.get(<span class=\"string\">\"Step3Output1\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step4Input2\"</span>, path.get(<span class=\"string\">\"Step3Output2\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step4Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step4\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step5Input1\"</span>, path.get(<span class=\"string\">\"Step3Output1\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step5Input2\"</span>, path.get(<span class=\"string\">\"Step3Output2\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step5Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step5\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step6Input\"</span>, path.get(<span class=\"string\">\"Step5Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step6Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step6\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Step1.run(path);</span><br><span class=\"line\">        Step2.run(path);</span><br><span class=\"line\">        Step3.run(path);</span><br><span class=\"line\">        Step3.run2(path);</span><br><span class=\"line\">        Step4.run(path);<span class=\"comment\">//NullPointerException,可能不会先构造同现矩阵</span></span><br><span class=\"line\"><span class=\"comment\">//        Step4_Update.run(path);</span></span><br><span class=\"line\">        Step4_Update2.run(path);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>2). Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step1_ToItemPreMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">Object</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(Object key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String tokens[] = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">int</span> userId = Integer.parseInt(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            String itemId = tokens[<span class=\"number\">1</span>];</span><br><span class=\"line\">            String pref = tokens[<span class=\"number\">2</span>];</span><br><span class=\"line\">            context.write(<span class=\"keyword\">new</span> IntWritable(userId), <span class=\"keyword\">new</span> Text(itemId + <span class=\"string\">\":\"</span> + pref));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step1_ToUserVectorReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(IntWritable key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            Iterator&lt;Text&gt; iter = values.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                sb.append(<span class=\"string\">\",\"</span> + iter.next());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context.write(key, <span class=\"keyword\">new</span> Text(sb.toString().replaceFirst(<span class=\"string\">\",\"</span>, <span class=\"string\">\"\"</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step1Input\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step1Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\"><span class=\"comment\">//        conf.set(\"mapreduce.task.io.sort.mb\",\"1024\");//任务内部排序缓冲区大小,默认为100</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"Step1\"</span>);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(input);</span><br><span class=\"line\">        hdfs.mkdirs(input);</span><br><span class=\"line\">        hdfs.copyFile(path.get(<span class=\"string\">\"data\"</span>), input);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setJarByClass(Step1.class);</span><br><span class=\"line\">        job.setMapOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step1_ToItemPreMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step1_ToUserVectorReducer.class);</span><br><span class=\"line\">        job.setCombinerClass(Step1_ToUserVectorReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>map阶段：用正则表达式分割输入数据，以userId为键，图书id和打分组合成字符串itemId：pref传递给Reducer<br>reduce阶段：此时传进来的key已经按照userId分好块，于是我们可以得到每个用户的评分矩阵<br>Step1的输出为：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/97798258.jpg\" alt=\"\"></p>\n<p><em>3). Step2.java，对物品组合列表进行计数，建立物品的同现矩阵</em><br>​<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step2_UserVectorToCooccurrenceMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text k = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> IntWritable v = <span class=\"keyword\">new</span> IntWritable(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; tokens.length; i++) &#123;</span><br><span class=\"line\">                String itemId = tokens[i].split(<span class=\"string\">\":\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; tokens.length; j++) &#123;</span><br><span class=\"line\">                    String itemId2 = tokens[j].split(<span class=\"string\">\":\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    context.write(<span class=\"keyword\">new</span> Text(itemId + <span class=\"string\">\":\"</span> + itemId2), v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step2_UserVectorToCooccurrenceReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Iterator&lt;IntWritable&gt; iter = values.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                sum += iter.next().get();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context.write(key, <span class=\"keyword\">new</span> IntWritable(sum));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"Step2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step2Input\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step2Output\"</span>);</span><br><span class=\"line\">        System.out.println(output);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setJarByClass(Step2.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(IntWritable.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step2_UserVectorToCooccurrenceMapper.class);</span><br><span class=\"line\">        job.setCombinerClass(Step2_UserVectorToCooccurrenceReducer.class);</span><br><span class=\"line\">        job.setReducerClass(Step2_UserVectorToCooccurrenceReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Step2的输入是Step1的输出，<br>map阶段：用正则表达式分割每行，利用双重循环构造每行中任意两个itemsId的组合作为键，用数字1作为值输出到Reducer<br>reduce阶段：Mapper传来的数据已经按键分块，累加每种键下的值即可得到item1和item2出现在同一个评分列表中的次数，即得到图书的同现矩阵<br>Step2的输出为：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/19253791.jpg\" alt=\"\"></p>\n<p><em>4). Step3.java，合并同现矩阵和评分矩阵</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step31_UserVectorSplitterMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> IntWritable k = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Text v = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; tokens.length; i++) &#123;</span><br><span class=\"line\">                String[] vector = tokens[i].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemId = Integer.parseInt(vector[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                String pref = vector[<span class=\"number\">1</span>];</span><br><span class=\"line\">                k.set(itemId);</span><br><span class=\"line\">                v.set(tokens[<span class=\"number\">0</span>] + <span class=\"string\">\":\"</span> + pref);</span><br><span class=\"line\">                context.write(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"step31_spliteUserVector\"</span>);</span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step3Input1\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step3Output1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\">        job.setJarByClass(Step3.class);</span><br><span class=\"line\">        job.setMapOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step31_UserVectorSplitterMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step32_CooccurreceColumWrapperMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text k = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> IntWritable v = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String tokens[] = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            k.set(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            v.set(Integer.parseInt(tokens[<span class=\"number\">1</span>])); <span class=\"comment\">//这里和step2的输出有什么区别????</span></span><br><span class=\"line\">            context.write(k, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run2</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"step32_cooccurreceMap\"</span>);</span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step3Input2\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step3Output2\"</span>);</span><br><span class=\"line\">        job.setJarByClass(Step3.class);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step32_CooccurreceColumWrapperMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Step3_1将用户评分矩阵拆分为itemId    userId:pref的形式输出，为了方便之后的计算<br>Step3_2看起来输出结果与Step2相同<br>Step3_1输出：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/9400783.jpg\" alt=\"\"><br>Step3_1输出：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/22519877.jpg\" alt=\"\"></p>\n<p><em>5). Step4.java，计算推荐结果列表</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_PartialMultiplyMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> IntWritable k = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text v = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;Integer, List&lt;Cooccurrence&gt;&gt; cooccurrenceMatrix = <span class=\"keyword\">new</span> HashMap&lt;Integer, List&lt;Cooccurrence&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">            String[] v1 = tokens[<span class=\"number\">0</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">            String[] v2 = tokens[<span class=\"number\">1</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v1.length &gt; <span class=\"number\">1</span>) &#123;<span class=\"comment\">// cooccurrence</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemID1 = Integer.parseInt(v1[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemID2 = Integer.parseInt(v1[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> num = Integer.parseInt(tokens[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">                List&lt;Cooccurrence&gt; list = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cooccurrenceMatrix.containsKey(itemID1)) &#123;</span><br><span class=\"line\">                    list = <span class=\"keyword\">new</span> ArrayList&lt;Cooccurrence&gt;();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    list = cooccurrenceMatrix.get(itemID1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                list.add(<span class=\"keyword\">new</span> Cooccurrence(itemID1, itemID2, num));</span><br><span class=\"line\">                cooccurrenceMatrix.put(itemID1, list);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v2.length &gt; <span class=\"number\">1</span>) &#123;<span class=\"comment\">// userVector</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemID = Integer.parseInt(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> userID = Integer.parseInt(v2[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">double</span> pref = Double.parseDouble(v2[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                k.set(userID);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Cooccurrence co : cooccurrenceMatrix.get(itemID)) &#123;</span><br><span class=\"line\">                    v.set(co.getItemID2() + <span class=\"string\">\",\"</span> + pref * co.getNum());</span><br><span class=\"line\">                    context.write(k, v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_AggregateAndRecommendReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text v = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(IntWritable key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            Map&lt;String, Double&gt; result = <span class=\"keyword\">new</span> HashMap&lt;String, Double&gt;();</span><br><span class=\"line\">            Iterator&lt;Text&gt; iter = values.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String[] str = iter.next().toString().split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result.containsKey(str[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">                    result.put(str[<span class=\"number\">0</span>], result.get(str[<span class=\"number\">0</span>]) + Double.parseDouble(str[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    result.put(str[<span class=\"number\">0</span>], Double.parseDouble(str[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Iterator&lt;String&gt; iter2 = result.keySet().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String itemID = iter2.next();</span><br><span class=\"line\">                <span class=\"keyword\">double</span> score = result.get(itemID);</span><br><span class=\"line\">                v.set(itemID + <span class=\"string\">\",\"</span> + score);</span><br><span class=\"line\">                context.write(key, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String input1 = path.get(<span class=\"string\">\"Step4Input1\"</span>);</span><br><span class=\"line\">        String input2 = path.get(<span class=\"string\">\"Step4Input2\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step4Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"Step4\"</span>);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\">        job.setJarByClass(Step4.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step4_PartialMultiplyMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step4_AggregateAndRecommendReducer.class);</span><br><span class=\"line\">        job.setCombinerClass(Step4_AggregateAndRecommendReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input1), <span class=\"keyword\">new</span> Path(input2));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cooccurrence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> itemID1;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> itemID2;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cooccurrence</span><span class=\"params\">(<span class=\"keyword\">int</span> itemID1, <span class=\"keyword\">int</span> itemID2, <span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID1 = itemID1;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID2 = itemID2;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemID1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> itemID1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemID2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> itemID2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setItemID1</span><span class=\"params\">(<span class=\"keyword\">int</span> itemID1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID1 = itemID1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setItemID2</span><span class=\"params\">(<span class=\"keyword\">int</span> itemID2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID2 = itemID2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Step4的输入来自两个路径，分别是step3_1和step3_2的输出，<br>map阶段：对输入的值进行分割，如果是同现矩阵其将被分割为<code>[101:102,3]</code>的形式，如果是评分矩阵将被分割为<code>[102,5:30]</code>的形式，然后以“：”为分隔符分别分割数组tokens中的元素，以此来判别输入是什么类型的矩阵。如果是同现矩阵，获取itemID1和itemID2以及num，在初始化时创建的静态map中填充以每一个itemID1为键，以List<cooccurence>对象为值的数据，最后得到的map形象的表示为下图所示的方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;101：[cooccurence(101,101,5),cooccurence(101,102,3),...],</span><br><span class=\"line\">...</span><br><span class=\"line\">106:[cooccurence(106,101,2),cooccurence(106,101,1),...],</span><br><span class=\"line\">107:[cooccurence(107,101,1)&#125;</span><br></pre></td></tr></table></figure></cooccurence></p>\n<p>如果输入来自用户评分矩阵，会先得到itemID，userID和评分pref，然后将userID设为键，利用itemID从上面的map中得到其对应的list，从list中可以得到<em>同现item</em>（通过<code>co.getItemID2()</code>）和<em>同现次数num</em>，对list中的每项都能得到一个输出，将输出值设为组合字符串“同现item，pref*同现num”，我将通过下图来解释第二项的意义，请读者自行体会。</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/60596269.jpg\" alt=\"\"></p>\n<p>reduce阶段逻辑比较简单，将每个item对应的值加起来就是用户对这个item的推荐的程度。<br>Step4在执行的时候会报错：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/51842026.jpg\" alt=\"\"></p>\n<p>原因在于当输入是用户评分矩阵时，同现map并不是随时就绪的，可能不会先构造同现矩阵。因为hadoop从hdfs上读取小文件时，会先读占用空间大的文件，这样就不难保证先生成coocurenceMatrix了，所以Step4.java这个类不能使用，我们把矩阵乘法进行分开计算，先进行对于位置相乘Step4_Updata.java，最后进行加法Step4_Updata2.java</p>\n<p><strong>5). Step4_Update.java，计算推荐结果列表</strong></p>\n<p>​<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileSplit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_Update</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_PartialMultiplyMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String flag;<span class=\"comment\">//A同现矩阵,B用户评分矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">(Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            FileSplit split = (FileSplit) context.getInputSplit();</span><br><span class=\"line\">            flag = split.getPath().getParent().getName();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag.equals(<span class=\"string\">\"step3_2\"</span>)) &#123;</span><br><span class=\"line\">                String[] v1 = tokens[<span class=\"number\">0</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">                String itemID1 = v1[<span class=\"number\">0</span>];</span><br><span class=\"line\">                String itemID2 = v1[<span class=\"number\">1</span>];</span><br><span class=\"line\">                String num = tokens[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                Text k = <span class=\"keyword\">new</span> Text(itemID1);</span><br><span class=\"line\">                Text v = <span class=\"keyword\">new</span> Text(<span class=\"string\">\"A:\"</span> + itemID2 + <span class=\"string\">\",\"</span> + num);</span><br><span class=\"line\">                context.write(k, v);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag.equals(<span class=\"string\">\"step3_1\"</span>)) &#123;</span><br><span class=\"line\">                String[] v2 = tokens[<span class=\"number\">1</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">                String itemID = tokens[<span class=\"number\">0</span>];</span><br><span class=\"line\">                String userID = v2[<span class=\"number\">0</span>];</span><br><span class=\"line\">                String pref = v2[<span class=\"number\">1</span>];</span><br><span class=\"line\">                Text k = <span class=\"keyword\">new</span> Text(itemID);</span><br><span class=\"line\">                Text v = <span class=\"keyword\">new</span> Text(<span class=\"string\">\"B:\"</span> + userID + <span class=\"string\">\",\"</span> + pref);</span><br><span class=\"line\">                context.write(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_AggregateReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(key.toString() + \":\");</span></span><br><span class=\"line\">            Map&lt;String, String&gt; mapA = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">            Map&lt;String, String&gt; mapB = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Text line : values) &#123;</span><br><span class=\"line\">                String val = line.toString();</span><br><span class=\"line\">                <span class=\"comment\">//System.out.println(val);</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val.startsWith(<span class=\"string\">\"A:\"</span>)) &#123;</span><br><span class=\"line\">                    String[] kv = Recommend.DELIMITER.split(val.substring(<span class=\"number\">2</span>));</span><br><span class=\"line\">                    mapA.put(kv[<span class=\"number\">0</span>], kv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val.startsWith(<span class=\"string\">\"B:\"</span>)) &#123;</span><br><span class=\"line\">                    String[] kv = Recommend.DELIMITER.split(val.substring(<span class=\"number\">2</span>));</span><br><span class=\"line\">                    mapB.put(kv[<span class=\"number\">0</span>], kv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">double</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Iterator&lt;String&gt; iter = mapA.keySet().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String mapk = iter.next();<span class=\"comment\">//itemID2</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> num = Integer.parseInt(mapA.get(mapk));</span><br><span class=\"line\">                Iterator&lt;String&gt; iterb = mapB.keySet().iterator();<span class=\"comment\">//userID</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iterb.hasNext()) &#123;</span><br><span class=\"line\">                    String mapkb = iterb.next();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">double</span> pref = Double.parseDouble(mapB.get(mapkb));</span><br><span class=\"line\">                    result = num * pref;</span><br><span class=\"line\">                    Text k = <span class=\"keyword\">new</span> Text(mapkb);</span><br><span class=\"line\">                    Text v = <span class=\"keyword\">new</span> Text(mapk + <span class=\"string\">\",\"</span> + result);</span><br><span class=\"line\">                    context.write(k, v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf);</span><br><span class=\"line\">        String input1 = path.get(<span class=\"string\">\"Step5Input1\"</span>);</span><br><span class=\"line\">        String input2 = path.get(<span class=\"string\">\"Step5Input2\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step5Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setJarByClass(Step4_Update.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step4_Update.Step4_PartialMultiplyMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step4_Update.Step4_AggregateReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input1), <span class=\"keyword\">new</span> Path(input2));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Mapper的setup阶段，通过<code>split.getPath().getParent().getName()</code>来确定输入来自那个文件，如果来自用户评分矩阵，则输出以A：打头的值，否则以B：打头，键均为itemID<br>redece阶段：键为item1，创建mapA和mapB，mapA的内容为（item2,num），mapB的值为(userId，pref),对于mapA中的每个item2和num，为每个user计算num<em>pref，输出的值为（userId，“itemID2,num</em>pref”）<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/27264349.jpg\" alt=\"\"></p>\n<p>step4_update.java输出是：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/96688878.jpg\" alt=\"\"> </p>\n<p><strong>6).Step4_Update2.java:计算推荐结果</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_Update2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_RecommendMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            Text k = <span class=\"keyword\">new</span> Text(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            Text v = <span class=\"keyword\">new</span> Text(tokens[<span class=\"number\">1</span>] + <span class=\"string\">\",\"</span> + tokens[<span class=\"number\">2</span>]);</span><br><span class=\"line\">            context.write(k,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_RecommendReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>,<span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            System.out.println(key.toString());</span><br><span class=\"line\">            Map&lt;String, Double&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, Double&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Text line : values) &#123;</span><br><span class=\"line\">                System.out.println(line.toString());</span><br><span class=\"line\">                String [] tokens = Recommend.DELIMITER.split(line.toString());</span><br><span class=\"line\">                String itemID = tokens[<span class=\"number\">0</span>];</span><br><span class=\"line\">                Double score = Double.parseDouble(tokens[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.containsKey(itemID)) &#123;</span><br><span class=\"line\">                    map.put(itemID, map.get(itemID) + score);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    map.put(itemID, score);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Iterator&lt;String&gt; iter = map.keySet().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String itemID = iter.next();</span><br><span class=\"line\">                <span class=\"keyword\">double</span> score = map.get(itemID);</span><br><span class=\"line\">                Text v = <span class=\"keyword\">new</span> Text(itemID + <span class=\"string\">\",\"</span> + score);</span><br><span class=\"line\">                context.write(key,v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step6Input\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step6Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf);</span><br><span class=\"line\">        job.setJarByClass(Step4_Update2.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step4_Update2.Step4_RecommendMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step4_Update2.Step4_RecommendReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>较为简单，求和即可，结果如下：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/61332065.jpg\" alt=\"\"><br>五、程序开发：爬虫的编写<br>本爬虫爬取图书的信息，未整理完毕，可以根据需求更改<br>item.py<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubanbooksItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    book_name = scrapy.Field()  <span class=\"comment\"># 图书名</span></span><br><span class=\"line\">    book_star = scrapy.Field()  <span class=\"comment\"># 图书评分</span></span><br><span class=\"line\">    book_pl = scrapy.Field()  <span class=\"comment\"># 图书评论数</span></span><br><span class=\"line\">    book_author = scrapy.Field()  <span class=\"comment\"># 图书作者</span></span><br><span class=\"line\">    book_publish = scrapy.Field()  <span class=\"comment\"># 出版社</span></span><br><span class=\"line\">    book_date = scrapy.Field()  <span class=\"comment\"># 出版日期</span></span><br><span class=\"line\">    book_price = scrapy.Field()  <span class=\"comment\"># 图书价格</span></span><br><span class=\"line\">    book_tag = scrapy.Field()</span><br><span class=\"line\">    book_desc = scrapy.Field()</span><br><span class=\"line\">    book_id = scrapy.Field()</span><br></pre></td></tr></table></figure></p>\n<p>bookspider.py<br>​<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.linkextractors <span class=\"keyword\">import</span> LinkExtractor</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.spiders <span class=\"keyword\">import</span> CrawlSpider, Rule</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.selector <span class=\"keyword\">import</span> Selector</span><br><span class=\"line\"><span class=\"keyword\">from</span> doubanBooks.items <span class=\"keyword\">import</span> DoubanbooksItem</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookspiderSpider</span><span class=\"params\">(CrawlSpider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'bookspider'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'douban.com'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">\"https://book.douban.com/tag/\"</span>]</span><br><span class=\"line\">    rules = (</span><br><span class=\"line\">        Rule(LinkExtractor(allow=<span class=\"string\">r'tag/.&#123;2,4&#125;'</span>), callback=<span class=\"string\">'parse_item'</span>, follow=<span class=\"keyword\">False</span>),</span><br><span class=\"line\">        Rule(LinkExtractor(allow=<span class=\"string\">r'https://book.douban.com/tag/.+/?start=\\d+&amp;type=T'</span>), callback=<span class=\"string\">'parse_item2'</span>, follow=<span class=\"keyword\">True</span>),</span><br><span class=\"line\">        <span class=\"comment\"># Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d+/'), callback='parse_item2',follow=False),</span></span><br><span class=\"line\">        <span class=\"comment\"># Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d/reviews'), callback='parse_item3', follow=False),</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># def start_requests(self):</span></span><br><span class=\"line\">    <span class=\"comment\">#     '''</span></span><br><span class=\"line\">    <span class=\"comment\">#     重写start_requests，请求登录页面</span></span><br><span class=\"line\">    <span class=\"comment\">#     '''</span></span><br><span class=\"line\">    <span class=\"comment\">#     return [scrapy.FormRequest(\"https://accounts.douban.com/login\", meta=&#123;\"cookiejar\": 1&#125;,</span></span><br><span class=\"line\">    <span class=\"comment\">#                                callback=self.parse_before_login)]</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_item0</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        sel = Selector(response);</span><br><span class=\"line\">        <span class=\"comment\"># item['book_tag'] = sel.xpath('/html/body/div[3]/div[1]/h1/text()').extract()[0].split(':')[1].strip()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_item</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">       <span class=\"comment\"># print(response)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_item2</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        sel = Selector(response)</span><br><span class=\"line\">        item = DoubanbooksItem()</span><br><span class=\"line\">        item[<span class=\"string\">'book_tag'</span>] = sel.xpath(<span class=\"string\">'/html/body/div[3]/div[1]/h1/text()'</span>).extract()[<span class=\"number\">0</span>].strip().split(<span class=\"string\">':'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">        book_list = sel.css(<span class=\"string\">'#subject_list &gt; ul &gt; li'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> book_list:</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"comment\"># strip() 方法用于移除字符串头尾指定的字符（默认为空格）</span></span><br><span class=\"line\">                item[<span class=\"string\">'book_name'</span>] = book.xpath(<span class=\"string\">'div[@class=\"info\"]/h2/a/text()'</span>).extract()[<span class=\"number\">0</span>].strip()</span><br><span class=\"line\">                item[<span class=\"string\">'book_star'</span>] = book.xpath(<span class=\"string\">\"div[@class='info']/div[2]/span[@class='rating_nums']/text()\"</span>).extract()[<span class=\"number\">0</span>].strip()</span><br><span class=\"line\">                item[<span class=\"string\">'book_pl'</span>] = book.xpath(<span class=\"string\">\"div[@class='info']/div[2]/span[@class='pl']/text()\"</span>).extract()[<span class=\"number\">0</span>].strip()</span><br><span class=\"line\">                item[<span class=\"string\">'book_desc'</span>] = book.xpath(<span class=\"string\">\"div[2]/p/text()\"</span>).extract()[<span class=\"number\">0</span>]</span><br><span class=\"line\">                item[<span class=\"string\">'book_id'</span>] = book.xpath(<span class=\"string\">'div[@class=\"info\"]/h2[@class=\"\"]/a/@href'</span>).extract()[<span class=\"number\">0</span>].strip().split(<span class=\"string\">'/'</span>)[<span class=\"number\">-2</span>]</span><br><span class=\"line\">                pub = book.xpath(<span class=\"string\">'div[@class=\"info\"]/div[@class=\"pub\"]/text()'</span>).extract()[<span class=\"number\">0</span>].strip().split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">                item[<span class=\"string\">'book_price'</span>] = pub.pop()</span><br><span class=\"line\">                item[<span class=\"string\">'book_date'</span>] = pub.pop()</span><br><span class=\"line\">                item[<span class=\"string\">'book_publish'</span>] = pub.pop()</span><br><span class=\"line\">                item[<span class=\"string\">'book_author'</span>] = <span class=\"string\">'/'</span>.join(pub)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">yield</span> item</span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># def parse_item4(self, response):</span></span><br><span class=\"line\"><span class=\"comment\">#         sel = Selector(response);</span></span><br><span class=\"line\"><span class=\"comment\">#         item = DoubanbooksItem()</span></span><br><span class=\"line\"><span class=\"comment\">#         item['user_name'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()</span></span><br><span class=\"line\"><span class=\"comment\">#         item['user_score'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()</span></span><br><span class=\"line\"><span class=\"comment\">#         yield item</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_before_login</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"登录前表单填充\"</span>)</span><br><span class=\"line\">        captcha_id = response.xpath(<span class=\"string\">'//input[@name=\"captcha-id\"]/@value'</span>).extract_first()</span><br><span class=\"line\">        captcha_image_url = response.xpath(<span class=\"string\">'//img[@id=\"captcha_image\"]/@src'</span>).extract_first()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> captcha_image_url <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"登录时无验证码\"</span>)</span><br><span class=\"line\">            formdata = &#123;</span><br><span class=\"line\">                <span class=\"string\">\"form_email\"</span>: <span class=\"string\">\"18911341910\"</span>,</span><br><span class=\"line\">                <span class=\"comment\"># 请填写你的密码</span></span><br><span class=\"line\">                <span class=\"string\">\"form_password\"</span>: <span class=\"string\">\"lh1994114\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"login\"</span>: <span class=\"string\">\"登录\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"redir\"</span>: <span class=\"string\">\"https://www.douban.com/\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"source\"</span>: <span class=\"string\">\"index_nav\"</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"登录时有验证码\"</span>)</span><br><span class=\"line\">            save_image_path = <span class=\"string\">\"/media/harold/SpareDisk/pythonProject/captcha.jpeg\"</span></span><br><span class=\"line\">            <span class=\"comment\"># 将图片验证码下载到本地</span></span><br><span class=\"line\">            urllib.request.urlretrieve(captcha_image_url, save_image_path)</span><br><span class=\"line\">            <span class=\"comment\"># 打开图片，以便我们识别图中验证码</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                im = Image.open(save_image_path)</span><br><span class=\"line\">                im.show()</span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"comment\"># 手动输入验证码</span></span><br><span class=\"line\">            captcha_solution = input(<span class=\"string\">'根据打开的图片输入验证码:'</span>)</span><br><span class=\"line\">            formdata = &#123;</span><br><span class=\"line\">                <span class=\"string\">\"source\"</span>: <span class=\"string\">\"None\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"redir\"</span>: <span class=\"string\">\"https://www.douban.com/\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"form_email\"</span>: <span class=\"string\">\"13227708059@163.com\"</span>,</span><br><span class=\"line\">                <span class=\"comment\"># 此处请填写密码</span></span><br><span class=\"line\">                <span class=\"string\">\"form_password\"</span>: <span class=\"string\">\"*******\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"captcha-solution\"</span>: captcha_solution,</span><br><span class=\"line\">                <span class=\"string\">\"captcha-id\"</span>: captcha_id,</span><br><span class=\"line\">                <span class=\"string\">\"login\"</span>: <span class=\"string\">\"登录\"</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        print(<span class=\"string\">\"登录中\"</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 提交表单</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> scrapy.FormRequest.from_response(response, meta=&#123;<span class=\"string\">\"cookiejar\"</span>: response.meta[<span class=\"string\">\"cookiejar\"</span>]&#125;,</span><br><span class=\"line\">                                                formdata=formdata,</span><br><span class=\"line\">                                                callback=self.parse_after_login)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_after_login</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        验证登录是否成功</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        account = response.xpath(<span class=\"string\">'/html/body/div[1]/div/div[1]/ul/li[2]/a/span[1]'</span>).extract_first()</span><br><span class=\"line\">        print(account)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> account <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"登录失败\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">u\"登录成功,当前账户为 %s\"</span> % account)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> self.make_requests_from_url(<span class=\"string\">\"https://book.douban.com/tag/\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>pipeline.py 输出到csv<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy <span class=\"keyword\">import</span> signals</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.contrib.exporter <span class=\"keyword\">import</span> CsvItemExporter</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span><span class=\"params\">(cls, crawler)</span>:</span></span><br><span class=\"line\">        pipeline = cls()</span><br><span class=\"line\">        crawler.signals.connect(pipeline.spider_opened, signals.spider_opened)</span><br><span class=\"line\">        crawler.signals.connect(pipeline.spider_closed, signals.spider_closed)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipeline</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spider_opened</span><span class=\"params\">(self, spider)</span>:</span></span><br><span class=\"line\">        self.file = open(<span class=\"string\">'output.csv'</span>, <span class=\"string\">'w+b'</span>)</span><br><span class=\"line\">        self.exporter = CsvItemExporter(self.file)</span><br><span class=\"line\">        self.exporter.start_exporting()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spider_closed</span><span class=\"params\">(self, spider)</span>:</span></span><br><span class=\"line\">        self.exporter.finish_exporting()</span><br><span class=\"line\">        self.file.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        self.exporter.export_item(item)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure></p>\n<p>部分结果</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/51973032.jpg\" alt=\"\"></p>\n<p>github地址：<br>爬虫：<a href=\"https://github.com/Harold1994/doubanBooks\" target=\"_blank\" rel=\"noopener\">https://github.com/Harold1994/doubanBooks</a><br>推荐系统：<a href=\"https://github.com/Harold1994/HadoopFileRecommendation\" target=\"_blank\" rel=\"noopener\">https://github.com/Harold1994/HadoopFileRecommendation</a></p>\n<p><code>`</code></p>\n","site":{"data":{}},"excerpt":"<p>《Hadoop权威指南》已经通读一遍，对于分布式数据处理大致有一些概念，从网上找一个合适的项目练练手，此博客记录了我基于<a href=\"http://blog.fens.me/hadoop-mapreduce-recommend/\" target=\"_blank\" rel=\"noopener\">张丹大神的电影推荐系统</a>手搓的豆瓣图书推荐系统，Hadoop版本为2.8.0，爬虫用python scrapy框架来写。</p>\n<p><strong>一、推荐系统概述</strong></p>\n<p>互联网已经普及到了今天，更加上机器学习和大数据的浪潮火爆，几乎我们接触的所有网站、App等都会用到推荐系统，比如淘宝的猜你喜欢，头条的新闻推送等等。<br>","more":"<br>常见的推荐原理有：</p>\n<blockquote>\n<p><em>基于用户基本信息的推荐</em> : 例如可以根据用户的性别、职业、 年龄、 所在地等信息向他推荐感兴趣或者相关的内容<br><em>基于物品/内容基本信息推荐</em> ： 根据物品的类型、来源、主题等信息推荐<br><em>协同推荐</em> ： 协同过滤算法通过计算用户之间或者物品之间的相关性来进行推荐</p>\n</blockquote>\n<p>协同过滤算法的实现分为两个步骤：<br>1.计算物品之间的相关度<br>2.根据物品的相似度和用户的历史行为给用户生成推荐列表<br><strong>二、算法模型</strong><br>这里我们用分步式基于物品的协同过滤算法实现为豆瓣用户推荐图书的系统。测试数据仍然用张丹大神原系统中的small.csv<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1,101,5.0</span><br><span class=\"line\">1,102,3.0</span><br><span class=\"line\">1,103,2.5</span><br><span class=\"line\">2,101,2.0</span><br><span class=\"line\">2,102,2.5</span><br><span class=\"line\">2,103,5.0</span><br><span class=\"line\">2,104,2.0</span><br><span class=\"line\">3,101,2.0</span><br><span class=\"line\">3,104,4.0</span><br><span class=\"line\">3,105,4.5</span><br><span class=\"line\">3,107,5.0</span><br><span class=\"line\">4,101,5.0</span><br><span class=\"line\">4,103,3.0</span><br><span class=\"line\">4,104,4.5</span><br><span class=\"line\">4,106,4.0</span><br><span class=\"line\">5,101,4.0</span><br><span class=\"line\">5,102,3.0</span><br><span class=\"line\">5,103,2.0</span><br><span class=\"line\">5,104,4.0</span><br><span class=\"line\">5,105,3.5</span><br><span class=\"line\">5,106,4.0</span><br></pre></td></tr></table></figure></p>\n<p>每行3个字段，依次代表用户ID，图书ID，用户对图书的评分(0-5分）。<br>本推荐系统执行的思路：</p>\n<ol>\n<li><p>建立物品的同现矩阵： 同现矩阵的值代表了某两本书同时出现在用户的评价列表中的次数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      [101] [102] [103] [104] [105] [106] [107]</span><br><span class=\"line\">[101]   5     3     4     4     2     2     1</span><br><span class=\"line\">[102]   3     3     3     2     1     1     0</span><br><span class=\"line\">[103]   4     3     4     3     1     2     0</span><br><span class=\"line\">[104]   4     2     3     4     2     2     1</span><br><span class=\"line\">[105]   2     1     1     2     2     1     1</span><br><span class=\"line\">[106]   2     1     2     2     1     2     0</span><br><span class=\"line\">[107]   1     0     0     1     1     0     1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>建立用户对物品的评分矩阵： 有多少个用户就有多少个评分矩阵<br>​<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       U3</span><br><span class=\"line\">[101] 2.0</span><br><span class=\"line\">[102] 0.0</span><br><span class=\"line\">[103] 0.0</span><br><span class=\"line\">[104] 4.0</span><br><span class=\"line\">[105] 4.5</span><br><span class=\"line\">[106] 0.0</span><br><span class=\"line\">[107] 5.0</span><br></pre></td></tr></table></figure></p>\n</li>\n<li><p>矩阵计算推荐结果： 同现矩阵*评分矩阵 = 推荐结果<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/78005679.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p><strong>三、系统架构</strong><br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/71568403.jpg\" alt=\"\"></p>\n<p>上图左边是Application业务系统，右边是本博客要实现的HDFS，MapReduce<br>1.业务系统记录了用户行为和用户对物品的打分（这里我们用爬取到的数据代替）<br>2.设置系统定时器CRON，隔一段时间增量向HDFS导入数据，即本系统需要的userId，itemId，value，time<br>3.完成导入后，设置系统定时器，启动MapReduce程序，运行推荐算法。<br>4.完成计算后，设置系统定时器，从HDFS导出推荐结果数据到数据库，方便以后的及时查询。</p>\n<p><strong>四 程序开发：MapReduce程序的实现</strong><br>开发环境：Ubuntu 16.04, IntelliJ IDEA， 和Hadoop2.8.0<br>新建类：<br>    Recommend.java，主任务启动程序<br>    Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵<br>    Step2.java，对物品组合列表进行计数，建立物品的同现矩阵<br>    Step3.java，对同现矩阵和评分矩阵转型<br>    *Step4.java，计算推荐结果列表，结果会出问题，最终不用这个类<br>    Step4_Update.java, 计算部分评分<br>    Step4_Update2.java, 计算最终评分，得到推荐结果<br>    HdfsDAO.java，HDFS操作工具类</p>\n<p><em>1）.Recommend.java,任务驱动程序</em><br>​<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Recommend</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Pattern DELIMITER = Pattern.compile(<span class=\"string\">\"[\\t,]\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String HDFS = <span class=\"string\">\"hdfs://localhost/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        Map&lt;String, String&gt; path = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">        path.put(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"resources/small.csv\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step1Input\"</span>, HDFS + <span class=\"string\">\"/user/hdfs/recommend\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step1Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step1\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step2Input\"</span>, path.get(<span class=\"string\">\"Step1Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step2Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step2\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Input1\"</span>, path.get(<span class=\"string\">\"Step1Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Output1\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step3_1\"</span>);</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Input2\"</span>, path.get(<span class=\"string\">\"Step2Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step3Output2\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step3_2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step4Input1\"</span>, path.get(<span class=\"string\">\"Step3Output1\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step4Input2\"</span>, path.get(<span class=\"string\">\"Step3Output2\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step4Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step4\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step5Input1\"</span>, path.get(<span class=\"string\">\"Step3Output1\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step5Input2\"</span>, path.get(<span class=\"string\">\"Step3Output2\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step5Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step5\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step6Input\"</span>, path.get(<span class=\"string\">\"Step5Output\"</span>));</span><br><span class=\"line\">        path.put(<span class=\"string\">\"Step6Output\"</span>, path.get(<span class=\"string\">\"Step1Input\"</span>) + <span class=\"string\">\"/step6\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Step1.run(path);</span><br><span class=\"line\">        Step2.run(path);</span><br><span class=\"line\">        Step3.run(path);</span><br><span class=\"line\">        Step3.run2(path);</span><br><span class=\"line\">        Step4.run(path);<span class=\"comment\">//NullPointerException,可能不会先构造同现矩阵</span></span><br><span class=\"line\"><span class=\"comment\">//        Step4_Update.run(path);</span></span><br><span class=\"line\">        Step4_Update2.run(path);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>2). Step1.java，按用户分组，计算所有物品出现的组合列表，得到用户对物品的评分矩阵</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step1_ToItemPreMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">Object</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(Object key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String tokens[] = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">int</span> userId = Integer.parseInt(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            String itemId = tokens[<span class=\"number\">1</span>];</span><br><span class=\"line\">            String pref = tokens[<span class=\"number\">2</span>];</span><br><span class=\"line\">            context.write(<span class=\"keyword\">new</span> IntWritable(userId), <span class=\"keyword\">new</span> Text(itemId + <span class=\"string\">\":\"</span> + pref));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step1_ToUserVectorReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(IntWritable key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            Iterator&lt;Text&gt; iter = values.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                sb.append(<span class=\"string\">\",\"</span> + iter.next());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context.write(key, <span class=\"keyword\">new</span> Text(sb.toString().replaceFirst(<span class=\"string\">\",\"</span>, <span class=\"string\">\"\"</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step1Input\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step1Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\"><span class=\"comment\">//        conf.set(\"mapreduce.task.io.sort.mb\",\"1024\");//任务内部排序缓冲区大小,默认为100</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"Step1\"</span>);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(input);</span><br><span class=\"line\">        hdfs.mkdirs(input);</span><br><span class=\"line\">        hdfs.copyFile(path.get(<span class=\"string\">\"data\"</span>), input);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setJarByClass(Step1.class);</span><br><span class=\"line\">        job.setMapOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step1_ToItemPreMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step1_ToUserVectorReducer.class);</span><br><span class=\"line\">        job.setCombinerClass(Step1_ToUserVectorReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>map阶段：用正则表达式分割输入数据，以userId为键，图书id和打分组合成字符串itemId：pref传递给Reducer<br>reduce阶段：此时传进来的key已经按照userId分好块，于是我们可以得到每个用户的评分矩阵<br>Step1的输出为：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/97798258.jpg\" alt=\"\"></p>\n<p><em>3). Step2.java，对物品组合列表进行计数，建立物品的同现矩阵</em><br>​<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step2_UserVectorToCooccurrenceMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text k = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> IntWritable v = <span class=\"keyword\">new</span> IntWritable(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; tokens.length; i++) &#123;</span><br><span class=\"line\">                String itemId = tokens[i].split(<span class=\"string\">\":\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; tokens.length; j++) &#123;</span><br><span class=\"line\">                    String itemId2 = tokens[j].split(<span class=\"string\">\":\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    context.write(<span class=\"keyword\">new</span> Text(itemId + <span class=\"string\">\":\"</span> + itemId2), v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step2_UserVectorToCooccurrenceReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Iterator&lt;IntWritable&gt; iter = values.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                sum += iter.next().get();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context.write(key, <span class=\"keyword\">new</span> IntWritable(sum));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"Step2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step2Input\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step2Output\"</span>);</span><br><span class=\"line\">        System.out.println(output);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setJarByClass(Step2.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(IntWritable.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step2_UserVectorToCooccurrenceMapper.class);</span><br><span class=\"line\">        job.setCombinerClass(Step2_UserVectorToCooccurrenceReducer.class);</span><br><span class=\"line\">        job.setReducerClass(Step2_UserVectorToCooccurrenceReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Step2的输入是Step1的输出，<br>map阶段：用正则表达式分割每行，利用双重循环构造每行中任意两个itemsId的组合作为键，用数字1作为值输出到Reducer<br>reduce阶段：Mapper传来的数据已经按键分块，累加每种键下的值即可得到item1和item2出现在同一个评分列表中的次数，即得到图书的同现矩阵<br>Step2的输出为：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/19253791.jpg\" alt=\"\"></p>\n<p><em>4). Step3.java，合并同现矩阵和评分矩阵</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step31_UserVectorSplitterMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> IntWritable k = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Text v = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; tokens.length; i++) &#123;</span><br><span class=\"line\">                String[] vector = tokens[i].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemId = Integer.parseInt(vector[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                String pref = vector[<span class=\"number\">1</span>];</span><br><span class=\"line\">                k.set(itemId);</span><br><span class=\"line\">                v.set(tokens[<span class=\"number\">0</span>] + <span class=\"string\">\":\"</span> + pref);</span><br><span class=\"line\">                context.write(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"step31_spliteUserVector\"</span>);</span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step3Input1\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step3Output1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\">        job.setJarByClass(Step3.class);</span><br><span class=\"line\">        job.setMapOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step31_UserVectorSplitterMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step32_CooccurreceColumWrapperMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text k = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> IntWritable v = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String tokens[] = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            k.set(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            v.set(Integer.parseInt(tokens[<span class=\"number\">1</span>])); <span class=\"comment\">//这里和step2的输出有什么区别????</span></span><br><span class=\"line\">            context.write(k, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run2</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"step32_cooccurreceMap\"</span>);</span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step3Input2\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step3Output2\"</span>);</span><br><span class=\"line\">        job.setJarByClass(Step3.class);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step32_CooccurreceColumWrapperMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setNumReduceTasks(<span class=\"number\">0</span>);</span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Step3_1将用户评分矩阵拆分为itemId    userId:pref的形式输出，为了方便之后的计算<br>Step3_2看起来输出结果与Step2相同<br>Step3_1输出：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/9400783.jpg\" alt=\"\"><br>Step3_1输出：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/22519877.jpg\" alt=\"\"></p>\n<p><em>5). Step4.java，计算推荐结果列表</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_PartialMultiplyMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> IntWritable k = <span class=\"keyword\">new</span> IntWritable();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text v = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;Integer, List&lt;Cooccurrence&gt;&gt; cooccurrenceMatrix = <span class=\"keyword\">new</span> HashMap&lt;Integer, List&lt;Cooccurrence&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">            String[] v1 = tokens[<span class=\"number\">0</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">            String[] v2 = tokens[<span class=\"number\">1</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v1.length &gt; <span class=\"number\">1</span>) &#123;<span class=\"comment\">// cooccurrence</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemID1 = Integer.parseInt(v1[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemID2 = Integer.parseInt(v1[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> num = Integer.parseInt(tokens[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">                List&lt;Cooccurrence&gt; list = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cooccurrenceMatrix.containsKey(itemID1)) &#123;</span><br><span class=\"line\">                    list = <span class=\"keyword\">new</span> ArrayList&lt;Cooccurrence&gt;();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    list = cooccurrenceMatrix.get(itemID1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                list.add(<span class=\"keyword\">new</span> Cooccurrence(itemID1, itemID2, num));</span><br><span class=\"line\">                cooccurrenceMatrix.put(itemID1, list);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v2.length &gt; <span class=\"number\">1</span>) &#123;<span class=\"comment\">// userVector</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> itemID = Integer.parseInt(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> userID = Integer.parseInt(v2[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">double</span> pref = Double.parseDouble(v2[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                k.set(userID);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Cooccurrence co : cooccurrenceMatrix.get(itemID)) &#123;</span><br><span class=\"line\">                    v.set(co.getItemID2() + <span class=\"string\">\",\"</span> + pref * co.getNum());</span><br><span class=\"line\">                    context.write(k, v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_AggregateAndRecommendReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">IntWritable</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Text v = <span class=\"keyword\">new</span> Text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(IntWritable key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            Map&lt;String, Double&gt; result = <span class=\"keyword\">new</span> HashMap&lt;String, Double&gt;();</span><br><span class=\"line\">            Iterator&lt;Text&gt; iter = values.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String[] str = iter.next().toString().split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result.containsKey(str[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">                    result.put(str[<span class=\"number\">0</span>], result.get(str[<span class=\"number\">0</span>]) + Double.parseDouble(str[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    result.put(str[<span class=\"number\">0</span>], Double.parseDouble(str[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Iterator&lt;String&gt; iter2 = result.keySet().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String itemID = iter2.next();</span><br><span class=\"line\">                <span class=\"keyword\">double</span> score = result.get(itemID);</span><br><span class=\"line\">                v.set(itemID + <span class=\"string\">\",\"</span> + score);</span><br><span class=\"line\">                context.write(key, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String input1 = path.get(<span class=\"string\">\"Step4Input1\"</span>);</span><br><span class=\"line\">        String input2 = path.get(<span class=\"string\">\"Step4Input2\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step4Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf, <span class=\"string\">\"Step4\"</span>);</span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\">        job.setJarByClass(Step4.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(IntWritable.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step4_PartialMultiplyMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step4_AggregateAndRecommendReducer.class);</span><br><span class=\"line\">        job.setCombinerClass(Step4_AggregateAndRecommendReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input1), <span class=\"keyword\">new</span> Path(input2));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cooccurrence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> itemID1;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> itemID2;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cooccurrence</span><span class=\"params\">(<span class=\"keyword\">int</span> itemID1, <span class=\"keyword\">int</span> itemID2, <span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID1 = itemID1;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID2 = itemID2;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemID1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> itemID1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemID2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> itemID2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setItemID1</span><span class=\"params\">(<span class=\"keyword\">int</span> itemID1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID1 = itemID1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setItemID2</span><span class=\"params\">(<span class=\"keyword\">int</span> itemID2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.itemID2 = itemID2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Step4的输入来自两个路径，分别是step3_1和step3_2的输出，<br>map阶段：对输入的值进行分割，如果是同现矩阵其将被分割为<code>[101:102,3]</code>的形式，如果是评分矩阵将被分割为<code>[102,5:30]</code>的形式，然后以“：”为分隔符分别分割数组tokens中的元素，以此来判别输入是什么类型的矩阵。如果是同现矩阵，获取itemID1和itemID2以及num，在初始化时创建的静态map中填充以每一个itemID1为键，以List<cooccurence>对象为值的数据，最后得到的map形象的表示为下图所示的方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;101：[cooccurence(101,101,5),cooccurence(101,102,3),...],</span><br><span class=\"line\">...</span><br><span class=\"line\">106:[cooccurence(106,101,2),cooccurence(106,101,1),...],</span><br><span class=\"line\">107:[cooccurence(107,101,1)&#125;</span><br></pre></td></tr></table></figure></cooccurence></p>\n<p>如果输入来自用户评分矩阵，会先得到itemID，userID和评分pref，然后将userID设为键，利用itemID从上面的map中得到其对应的list，从list中可以得到<em>同现item</em>（通过<code>co.getItemID2()</code>）和<em>同现次数num</em>，对list中的每项都能得到一个输出，将输出值设为组合字符串“同现item，pref*同现num”，我将通过下图来解释第二项的意义，请读者自行体会。</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/60596269.jpg\" alt=\"\"></p>\n<p>reduce阶段逻辑比较简单，将每个item对应的值加起来就是用户对这个item的推荐的程度。<br>Step4在执行的时候会报错：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/51842026.jpg\" alt=\"\"></p>\n<p>原因在于当输入是用户评分矩阵时，同现map并不是随时就绪的，可能不会先构造同现矩阵。因为hadoop从hdfs上读取小文件时，会先读占用空间大的文件，这样就不难保证先生成coocurenceMatrix了，所以Step4.java这个类不能使用，我们把矩阵乘法进行分开计算，先进行对于位置相乘Step4_Updata.java，最后进行加法Step4_Updata2.java</p>\n<p><strong>5). Step4_Update.java，计算推荐结果列表</strong></p>\n<p>​<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileSplit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_Update</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_PartialMultiplyMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String flag;<span class=\"comment\">//A同现矩阵,B用户评分矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">(Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            FileSplit split = (FileSplit) context.getInputSplit();</span><br><span class=\"line\">            flag = split.getPath().getParent().getName();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag.equals(<span class=\"string\">\"step3_2\"</span>)) &#123;</span><br><span class=\"line\">                String[] v1 = tokens[<span class=\"number\">0</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">                String itemID1 = v1[<span class=\"number\">0</span>];</span><br><span class=\"line\">                String itemID2 = v1[<span class=\"number\">1</span>];</span><br><span class=\"line\">                String num = tokens[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                Text k = <span class=\"keyword\">new</span> Text(itemID1);</span><br><span class=\"line\">                Text v = <span class=\"keyword\">new</span> Text(<span class=\"string\">\"A:\"</span> + itemID2 + <span class=\"string\">\",\"</span> + num);</span><br><span class=\"line\">                context.write(k, v);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag.equals(<span class=\"string\">\"step3_1\"</span>)) &#123;</span><br><span class=\"line\">                String[] v2 = tokens[<span class=\"number\">1</span>].split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">                String itemID = tokens[<span class=\"number\">0</span>];</span><br><span class=\"line\">                String userID = v2[<span class=\"number\">0</span>];</span><br><span class=\"line\">                String pref = v2[<span class=\"number\">1</span>];</span><br><span class=\"line\">                Text k = <span class=\"keyword\">new</span> Text(itemID);</span><br><span class=\"line\">                Text v = <span class=\"keyword\">new</span> Text(<span class=\"string\">\"B:\"</span> + userID + <span class=\"string\">\",\"</span> + pref);</span><br><span class=\"line\">                context.write(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_AggregateReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(key.toString() + \":\");</span></span><br><span class=\"line\">            Map&lt;String, String&gt; mapA = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">            Map&lt;String, String&gt; mapB = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Text line : values) &#123;</span><br><span class=\"line\">                String val = line.toString();</span><br><span class=\"line\">                <span class=\"comment\">//System.out.println(val);</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val.startsWith(<span class=\"string\">\"A:\"</span>)) &#123;</span><br><span class=\"line\">                    String[] kv = Recommend.DELIMITER.split(val.substring(<span class=\"number\">2</span>));</span><br><span class=\"line\">                    mapA.put(kv[<span class=\"number\">0</span>], kv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val.startsWith(<span class=\"string\">\"B:\"</span>)) &#123;</span><br><span class=\"line\">                    String[] kv = Recommend.DELIMITER.split(val.substring(<span class=\"number\">2</span>));</span><br><span class=\"line\">                    mapB.put(kv[<span class=\"number\">0</span>], kv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">double</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Iterator&lt;String&gt; iter = mapA.keySet().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String mapk = iter.next();<span class=\"comment\">//itemID2</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> num = Integer.parseInt(mapA.get(mapk));</span><br><span class=\"line\">                Iterator&lt;String&gt; iterb = mapB.keySet().iterator();<span class=\"comment\">//userID</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iterb.hasNext()) &#123;</span><br><span class=\"line\">                    String mapkb = iterb.next();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">double</span> pref = Double.parseDouble(mapB.get(mapkb));</span><br><span class=\"line\">                    result = num * pref;</span><br><span class=\"line\">                    Text k = <span class=\"keyword\">new</span> Text(mapkb);</span><br><span class=\"line\">                    Text v = <span class=\"keyword\">new</span> Text(mapk + <span class=\"string\">\",\"</span> + result);</span><br><span class=\"line\">                    context.write(k, v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf);</span><br><span class=\"line\">        String input1 = path.get(<span class=\"string\">\"Step5Input1\"</span>);</span><br><span class=\"line\">        String input2 = path.get(<span class=\"string\">\"Step5Input2\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step5Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setJarByClass(Step4_Update.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step4_Update.Step4_PartialMultiplyMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step4_Update.Step4_AggregateReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input1), <span class=\"keyword\">new</span> Path(input2));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Mapper的setup阶段，通过<code>split.getPath().getParent().getName()</code>来确定输入来自那个文件，如果来自用户评分矩阵，则输出以A：打头的值，否则以B：打头，键均为itemID<br>redece阶段：键为item1，创建mapA和mapB，mapA的内容为（item2,num），mapB的值为(userId，pref),对于mapA中的每个item2和num，为每个user计算num<em>pref，输出的值为（userId，“itemID2,num</em>pref”）<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/27264349.jpg\" alt=\"\"></p>\n<p>step4_update.java输出是：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/96688878.jpg\" alt=\"\"> </p>\n<p><strong>6).Step4_Update2.java:计算推荐结果</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hdfs.HdfsDAO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.fs.Path;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.io.Text;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_Update2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_RecommendMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mapper</span>&lt;<span class=\"title\">LongWritable</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(LongWritable key, Text value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            String[] tokens = Recommend.DELIMITER.split(value.toString());</span><br><span class=\"line\">            Text k = <span class=\"keyword\">new</span> Text(tokens[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            Text v = <span class=\"keyword\">new</span> Text(tokens[<span class=\"number\">1</span>] + <span class=\"string\">\",\"</span> + tokens[<span class=\"number\">2</span>]);</span><br><span class=\"line\">            context.write(k,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Step4_RecommendReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>,<span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">            System.out.println(key.toString());</span><br><span class=\"line\">            Map&lt;String, Double&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, Double&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Text line : values) &#123;</span><br><span class=\"line\">                System.out.println(line.toString());</span><br><span class=\"line\">                String [] tokens = Recommend.DELIMITER.split(line.toString());</span><br><span class=\"line\">                String itemID = tokens[<span class=\"number\">0</span>];</span><br><span class=\"line\">                Double score = Double.parseDouble(tokens[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.containsKey(itemID)) &#123;</span><br><span class=\"line\">                    map.put(itemID, map.get(itemID) + score);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    map.put(itemID, score);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Iterator&lt;String&gt; iter = map.keySet().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                String itemID = iter.next();</span><br><span class=\"line\">                <span class=\"keyword\">double</span> score = map.get(itemID);</span><br><span class=\"line\">                Text v = <span class=\"keyword\">new</span> Text(itemID + <span class=\"string\">\",\"</span> + score);</span><br><span class=\"line\">                context.write(key,v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Map&lt;String, String&gt; path)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        Configuration conf = <span class=\"keyword\">new</span> Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">        String input = path.get(<span class=\"string\">\"Step6Input\"</span>);</span><br><span class=\"line\">        String output = path.get(<span class=\"string\">\"Step6Output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HdfsDAO hdfs = <span class=\"keyword\">new</span> HdfsDAO(Recommend.HDFS, conf);</span><br><span class=\"line\">        hdfs.rmr(output);</span><br><span class=\"line\">        Job job = <span class=\"keyword\">new</span> Job(conf);</span><br><span class=\"line\">        job.setJarByClass(Step4_Update2.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);</span><br><span class=\"line\">        job.setOutputValueClass(Text.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setMapperClass(Step4_Update2.Step4_RecommendMapper.class);</span><br><span class=\"line\">        job.setReducerClass(Step4_Update2.Step4_RecommendReducer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class=\"line\">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        FileInputFormat.setInputPaths(job, <span class=\"keyword\">new</span> Path(input));</span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(output));</span><br><span class=\"line\"></span><br><span class=\"line\">        job.waitForCompletion(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>较为简单，求和即可，结果如下：<br><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/61332065.jpg\" alt=\"\"><br>五、程序开发：爬虫的编写<br>本爬虫爬取图书的信息，未整理完毕，可以根据需求更改<br>item.py<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubanbooksItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    book_name = scrapy.Field()  <span class=\"comment\"># 图书名</span></span><br><span class=\"line\">    book_star = scrapy.Field()  <span class=\"comment\"># 图书评分</span></span><br><span class=\"line\">    book_pl = scrapy.Field()  <span class=\"comment\"># 图书评论数</span></span><br><span class=\"line\">    book_author = scrapy.Field()  <span class=\"comment\"># 图书作者</span></span><br><span class=\"line\">    book_publish = scrapy.Field()  <span class=\"comment\"># 出版社</span></span><br><span class=\"line\">    book_date = scrapy.Field()  <span class=\"comment\"># 出版日期</span></span><br><span class=\"line\">    book_price = scrapy.Field()  <span class=\"comment\"># 图书价格</span></span><br><span class=\"line\">    book_tag = scrapy.Field()</span><br><span class=\"line\">    book_desc = scrapy.Field()</span><br><span class=\"line\">    book_id = scrapy.Field()</span><br></pre></td></tr></table></figure></p>\n<p>bookspider.py<br>​<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.linkextractors <span class=\"keyword\">import</span> LinkExtractor</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.spiders <span class=\"keyword\">import</span> CrawlSpider, Rule</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.selector <span class=\"keyword\">import</span> Selector</span><br><span class=\"line\"><span class=\"keyword\">from</span> doubanBooks.items <span class=\"keyword\">import</span> DoubanbooksItem</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookspiderSpider</span><span class=\"params\">(CrawlSpider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'bookspider'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'douban.com'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">\"https://book.douban.com/tag/\"</span>]</span><br><span class=\"line\">    rules = (</span><br><span class=\"line\">        Rule(LinkExtractor(allow=<span class=\"string\">r'tag/.&#123;2,4&#125;'</span>), callback=<span class=\"string\">'parse_item'</span>, follow=<span class=\"keyword\">False</span>),</span><br><span class=\"line\">        Rule(LinkExtractor(allow=<span class=\"string\">r'https://book.douban.com/tag/.+/?start=\\d+&amp;type=T'</span>), callback=<span class=\"string\">'parse_item2'</span>, follow=<span class=\"keyword\">True</span>),</span><br><span class=\"line\">        <span class=\"comment\"># Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d+/'), callback='parse_item2',follow=False),</span></span><br><span class=\"line\">        <span class=\"comment\"># Rule(LinkExtractor(allow=r'https://book.douban.com/subject/\\d/reviews'), callback='parse_item3', follow=False),</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># def start_requests(self):</span></span><br><span class=\"line\">    <span class=\"comment\">#     '''</span></span><br><span class=\"line\">    <span class=\"comment\">#     重写start_requests，请求登录页面</span></span><br><span class=\"line\">    <span class=\"comment\">#     '''</span></span><br><span class=\"line\">    <span class=\"comment\">#     return [scrapy.FormRequest(\"https://accounts.douban.com/login\", meta=&#123;\"cookiejar\": 1&#125;,</span></span><br><span class=\"line\">    <span class=\"comment\">#                                callback=self.parse_before_login)]</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_item0</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        sel = Selector(response);</span><br><span class=\"line\">        <span class=\"comment\"># item['book_tag'] = sel.xpath('/html/body/div[3]/div[1]/h1/text()').extract()[0].split(':')[1].strip()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_item</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">       <span class=\"comment\"># print(response)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_item2</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        sel = Selector(response)</span><br><span class=\"line\">        item = DoubanbooksItem()</span><br><span class=\"line\">        item[<span class=\"string\">'book_tag'</span>] = sel.xpath(<span class=\"string\">'/html/body/div[3]/div[1]/h1/text()'</span>).extract()[<span class=\"number\">0</span>].strip().split(<span class=\"string\">':'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">        book_list = sel.css(<span class=\"string\">'#subject_list &gt; ul &gt; li'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> book_list:</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"comment\"># strip() 方法用于移除字符串头尾指定的字符（默认为空格）</span></span><br><span class=\"line\">                item[<span class=\"string\">'book_name'</span>] = book.xpath(<span class=\"string\">'div[@class=\"info\"]/h2/a/text()'</span>).extract()[<span class=\"number\">0</span>].strip()</span><br><span class=\"line\">                item[<span class=\"string\">'book_star'</span>] = book.xpath(<span class=\"string\">\"div[@class='info']/div[2]/span[@class='rating_nums']/text()\"</span>).extract()[<span class=\"number\">0</span>].strip()</span><br><span class=\"line\">                item[<span class=\"string\">'book_pl'</span>] = book.xpath(<span class=\"string\">\"div[@class='info']/div[2]/span[@class='pl']/text()\"</span>).extract()[<span class=\"number\">0</span>].strip()</span><br><span class=\"line\">                item[<span class=\"string\">'book_desc'</span>] = book.xpath(<span class=\"string\">\"div[2]/p/text()\"</span>).extract()[<span class=\"number\">0</span>]</span><br><span class=\"line\">                item[<span class=\"string\">'book_id'</span>] = book.xpath(<span class=\"string\">'div[@class=\"info\"]/h2[@class=\"\"]/a/@href'</span>).extract()[<span class=\"number\">0</span>].strip().split(<span class=\"string\">'/'</span>)[<span class=\"number\">-2</span>]</span><br><span class=\"line\">                pub = book.xpath(<span class=\"string\">'div[@class=\"info\"]/div[@class=\"pub\"]/text()'</span>).extract()[<span class=\"number\">0</span>].strip().split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">                item[<span class=\"string\">'book_price'</span>] = pub.pop()</span><br><span class=\"line\">                item[<span class=\"string\">'book_date'</span>] = pub.pop()</span><br><span class=\"line\">                item[<span class=\"string\">'book_publish'</span>] = pub.pop()</span><br><span class=\"line\">                item[<span class=\"string\">'book_author'</span>] = <span class=\"string\">'/'</span>.join(pub)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">yield</span> item</span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># def parse_item4(self, response):</span></span><br><span class=\"line\"><span class=\"comment\">#         sel = Selector(response);</span></span><br><span class=\"line\"><span class=\"comment\">#         item = DoubanbooksItem()</span></span><br><span class=\"line\"><span class=\"comment\">#         item['user_name'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()</span></span><br><span class=\"line\"><span class=\"comment\">#         item['user_score'] = sel.xpath('div[@class=\"aside\"]/div[@class=\"sidebar-info-wrapper\"]/div[2]/a/text()').extract()[0].strip()</span></span><br><span class=\"line\"><span class=\"comment\">#         yield item</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_before_login</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"登录前表单填充\"</span>)</span><br><span class=\"line\">        captcha_id = response.xpath(<span class=\"string\">'//input[@name=\"captcha-id\"]/@value'</span>).extract_first()</span><br><span class=\"line\">        captcha_image_url = response.xpath(<span class=\"string\">'//img[@id=\"captcha_image\"]/@src'</span>).extract_first()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> captcha_image_url <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"登录时无验证码\"</span>)</span><br><span class=\"line\">            formdata = &#123;</span><br><span class=\"line\">                <span class=\"string\">\"form_email\"</span>: <span class=\"string\">\"18911341910\"</span>,</span><br><span class=\"line\">                <span class=\"comment\"># 请填写你的密码</span></span><br><span class=\"line\">                <span class=\"string\">\"form_password\"</span>: <span class=\"string\">\"lh1994114\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"login\"</span>: <span class=\"string\">\"登录\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"redir\"</span>: <span class=\"string\">\"https://www.douban.com/\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"source\"</span>: <span class=\"string\">\"index_nav\"</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"登录时有验证码\"</span>)</span><br><span class=\"line\">            save_image_path = <span class=\"string\">\"/media/harold/SpareDisk/pythonProject/captcha.jpeg\"</span></span><br><span class=\"line\">            <span class=\"comment\"># 将图片验证码下载到本地</span></span><br><span class=\"line\">            urllib.request.urlretrieve(captcha_image_url, save_image_path)</span><br><span class=\"line\">            <span class=\"comment\"># 打开图片，以便我们识别图中验证码</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                im = Image.open(save_image_path)</span><br><span class=\"line\">                im.show()</span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"comment\"># 手动输入验证码</span></span><br><span class=\"line\">            captcha_solution = input(<span class=\"string\">'根据打开的图片输入验证码:'</span>)</span><br><span class=\"line\">            formdata = &#123;</span><br><span class=\"line\">                <span class=\"string\">\"source\"</span>: <span class=\"string\">\"None\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"redir\"</span>: <span class=\"string\">\"https://www.douban.com/\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"form_email\"</span>: <span class=\"string\">\"13227708059@163.com\"</span>,</span><br><span class=\"line\">                <span class=\"comment\"># 此处请填写密码</span></span><br><span class=\"line\">                <span class=\"string\">\"form_password\"</span>: <span class=\"string\">\"*******\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"captcha-solution\"</span>: captcha_solution,</span><br><span class=\"line\">                <span class=\"string\">\"captcha-id\"</span>: captcha_id,</span><br><span class=\"line\">                <span class=\"string\">\"login\"</span>: <span class=\"string\">\"登录\"</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        print(<span class=\"string\">\"登录中\"</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 提交表单</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> scrapy.FormRequest.from_response(response, meta=&#123;<span class=\"string\">\"cookiejar\"</span>: response.meta[<span class=\"string\">\"cookiejar\"</span>]&#125;,</span><br><span class=\"line\">                                                formdata=formdata,</span><br><span class=\"line\">                                                callback=self.parse_after_login)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_after_login</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        验证登录是否成功</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        account = response.xpath(<span class=\"string\">'/html/body/div[1]/div/div[1]/ul/li[2]/a/span[1]'</span>).extract_first()</span><br><span class=\"line\">        print(account)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> account <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"登录失败\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">u\"登录成功,当前账户为 %s\"</span> % account)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> self.make_requests_from_url(<span class=\"string\">\"https://book.douban.com/tag/\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>pipeline.py 输出到csv<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy <span class=\"keyword\">import</span> signals</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.contrib.exporter <span class=\"keyword\">import</span> CsvItemExporter</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span><span class=\"params\">(cls, crawler)</span>:</span></span><br><span class=\"line\">        pipeline = cls()</span><br><span class=\"line\">        crawler.signals.connect(pipeline.spider_opened, signals.spider_opened)</span><br><span class=\"line\">        crawler.signals.connect(pipeline.spider_closed, signals.spider_closed)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipeline</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spider_opened</span><span class=\"params\">(self, spider)</span>:</span></span><br><span class=\"line\">        self.file = open(<span class=\"string\">'output.csv'</span>, <span class=\"string\">'w+b'</span>)</span><br><span class=\"line\">        self.exporter = CsvItemExporter(self.file)</span><br><span class=\"line\">        self.exporter.start_exporting()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spider_closed</span><span class=\"params\">(self, spider)</span>:</span></span><br><span class=\"line\">        self.exporter.finish_exporting()</span><br><span class=\"line\">        self.file.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        self.exporter.export_item(item)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure></p>\n<p>部分结果</p>\n<p><img src=\"http://p5s7d12ls.bkt.clouddn.com/18-3-28/51973032.jpg\" alt=\"\"></p>\n<p>github地址：<br>爬虫：<a href=\"https://github.com/Harold1994/doubanBooks\" target=\"_blank\" rel=\"noopener\">https://github.com/Harold1994/doubanBooks</a><br>推荐系统：<a href=\"https://github.com/Harold1994/HadoopFileRecommendation\" target=\"_blank\" rel=\"noopener\">https://github.com/Harold1994/HadoopFileRecommendation</a></p>\n<p><code>`</code></p>"},{"title":"数据库中：维度表和事实表","date":"2018-06-03T16:13:13.000Z","_content":"\n a) 事实表   \n\n i.              事实表是维度模型的基本表，存放有大量的业务性能度量值。\n\n ii.              事实表的一行对应一个度量值，一个度量值就是事实表的一行，事实表的所有度量值必须具有相同的粒度\n\n iii.              事实表中最有用的事实是数字类型和可加形型事实\n<!-- more--> \n iv.              在维度模型中，事实表表示维度见多对多的关系\n\nb)        维度表\n\ni.              维度表包含业务的文字描述，维度表倾向于将列数做相当少。\n\nii.              位数表是进入事实表的入口，丰富的维度属性给出了丰富的分析切割能力，维度给用户提供了使用数据仓库的借口\n\nc)         事实与维度的融合\n\ni.              由数字类型度量值组成的事实表连接到一组填满描述属性的维度表上，这个星型结构特征通常叫做星星连接方案\n\nii.              维度模型的简明性也带来了性能上的好处，数据库优化器可以更加高效的出吃这些连接关系较少的简单方案。数据库引擎可采取非常强劲的做法是：首先集中对建立了充足的索引的维度进行约束处理，然后用满足条件的维度表关节子的笛卡尔乘积一次性处理全部的事实表。\n\niii.              维度模型的可预订框架能够经受住无法预见的用户行为带来的考验\n\n一个典型的例子是，把逻辑业务比作一个立方体，产品维、时间维、地点维分别作为不同的坐标轴，而坐标轴的交点就是一个具体的事实。也就是说事实表是多个维度表的一个交点。而维度表是分析事实的一个窗口。 \n\n首先介绍下数据库结构中的星型结构，该结构在位于结构中心的单个事实数据表中维护数据，其它维度数据存储在维度表中。每个维度表与事实数据表直接相关，且通常通过一个键联接到事实数据表中。星型架构是数据仓库比较流向的一种架构。\n\n事实表是数据仓库结构中的中央表，它包含联系事实与维度表的数字度量值和键。事实数据表包含描述业务（例如产品销售）内特定事件的数据。\n\n维度表是维度属性的集合。是分析问题的一个窗口。是人们观察数据的特定角度，是考虑问题时的一类属性，属性的集合构成一个维。\n\n* 二者的区别：\n\n    - 维度表的冗余很大，主要是因为维度一般不大(相对于事实表来说的)，而维度表的冗余可以使事实表节省很多空间。\n    \n   - 事实表一般都很大，如果以普通方式查询的话，得到结果一般发的时间都不是我们可以接受的。所以它一般要进行一些特殊处理。如SQL Server 2005就会对事实表进行如预生成处理等。\n    \n    - 事实表一般是没有主键的，数据的质量完全由业务系统来把握。\n","source":"_posts/数据库中：维度表和事实表.md","raw":"---\ntitle: 数据库中：维度表和事实表\ndate: 2018-06-04 00:13:13\ntags: 数据库\n---\n\n a) 事实表   \n\n i.              事实表是维度模型的基本表，存放有大量的业务性能度量值。\n\n ii.              事实表的一行对应一个度量值，一个度量值就是事实表的一行，事实表的所有度量值必须具有相同的粒度\n\n iii.              事实表中最有用的事实是数字类型和可加形型事实\n<!-- more--> \n iv.              在维度模型中，事实表表示维度见多对多的关系\n\nb)        维度表\n\ni.              维度表包含业务的文字描述，维度表倾向于将列数做相当少。\n\nii.              位数表是进入事实表的入口，丰富的维度属性给出了丰富的分析切割能力，维度给用户提供了使用数据仓库的借口\n\nc)         事实与维度的融合\n\ni.              由数字类型度量值组成的事实表连接到一组填满描述属性的维度表上，这个星型结构特征通常叫做星星连接方案\n\nii.              维度模型的简明性也带来了性能上的好处，数据库优化器可以更加高效的出吃这些连接关系较少的简单方案。数据库引擎可采取非常强劲的做法是：首先集中对建立了充足的索引的维度进行约束处理，然后用满足条件的维度表关节子的笛卡尔乘积一次性处理全部的事实表。\n\niii.              维度模型的可预订框架能够经受住无法预见的用户行为带来的考验\n\n一个典型的例子是，把逻辑业务比作一个立方体，产品维、时间维、地点维分别作为不同的坐标轴，而坐标轴的交点就是一个具体的事实。也就是说事实表是多个维度表的一个交点。而维度表是分析事实的一个窗口。 \n\n首先介绍下数据库结构中的星型结构，该结构在位于结构中心的单个事实数据表中维护数据，其它维度数据存储在维度表中。每个维度表与事实数据表直接相关，且通常通过一个键联接到事实数据表中。星型架构是数据仓库比较流向的一种架构。\n\n事实表是数据仓库结构中的中央表，它包含联系事实与维度表的数字度量值和键。事实数据表包含描述业务（例如产品销售）内特定事件的数据。\n\n维度表是维度属性的集合。是分析问题的一个窗口。是人们观察数据的特定角度，是考虑问题时的一类属性，属性的集合构成一个维。\n\n* 二者的区别：\n\n    - 维度表的冗余很大，主要是因为维度一般不大(相对于事实表来说的)，而维度表的冗余可以使事实表节省很多空间。\n    \n   - 事实表一般都很大，如果以普通方式查询的话，得到结果一般发的时间都不是我们可以接受的。所以它一般要进行一些特殊处理。如SQL Server 2005就会对事实表进行如预生成处理等。\n    \n    - 事实表一般是没有主键的，数据的质量完全由业务系统来把握。\n","slug":"数据库中：维度表和事实表","published":1,"updated":"2018-06-07T13:35:07.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji4l7i87004ncf963o149z2i","content":"<p> a) 事实表   </p>\n<p> i.              事实表是维度模型的基本表，存放有大量的业务性能度量值。</p>\n<p> ii.              事实表的一行对应一个度量值，一个度量值就是事实表的一行，事实表的所有度量值必须具有相同的粒度</p>\n<p> iii.              事实表中最有用的事实是数字类型和可加形型事实<br><a id=\"more\"></a><br> iv.              在维度模型中，事实表表示维度见多对多的关系</p>\n<p>b)        维度表</p>\n<p>i.              维度表包含业务的文字描述，维度表倾向于将列数做相当少。</p>\n<p>ii.              位数表是进入事实表的入口，丰富的维度属性给出了丰富的分析切割能力，维度给用户提供了使用数据仓库的借口</p>\n<p>c)         事实与维度的融合</p>\n<p>i.              由数字类型度量值组成的事实表连接到一组填满描述属性的维度表上，这个星型结构特征通常叫做星星连接方案</p>\n<p>ii.              维度模型的简明性也带来了性能上的好处，数据库优化器可以更加高效的出吃这些连接关系较少的简单方案。数据库引擎可采取非常强劲的做法是：首先集中对建立了充足的索引的维度进行约束处理，然后用满足条件的维度表关节子的笛卡尔乘积一次性处理全部的事实表。</p>\n<p>iii.              维度模型的可预订框架能够经受住无法预见的用户行为带来的考验</p>\n<p>一个典型的例子是，把逻辑业务比作一个立方体，产品维、时间维、地点维分别作为不同的坐标轴，而坐标轴的交点就是一个具体的事实。也就是说事实表是多个维度表的一个交点。而维度表是分析事实的一个窗口。 </p>\n<p>首先介绍下数据库结构中的星型结构，该结构在位于结构中心的单个事实数据表中维护数据，其它维度数据存储在维度表中。每个维度表与事实数据表直接相关，且通常通过一个键联接到事实数据表中。星型架构是数据仓库比较流向的一种架构。</p>\n<p>事实表是数据仓库结构中的中央表，它包含联系事实与维度表的数字度量值和键。事实数据表包含描述业务（例如产品销售）内特定事件的数据。</p>\n<p>维度表是维度属性的集合。是分析问题的一个窗口。是人们观察数据的特定角度，是考虑问题时的一类属性，属性的集合构成一个维。</p>\n<ul>\n<li><p>二者的区别：</p>\n<ul>\n<li><p>维度表的冗余很大，主要是因为维度一般不大(相对于事实表来说的)，而维度表的冗余可以使事实表节省很多空间。</p>\n<ul>\n<li>事实表一般都很大，如果以普通方式查询的话，得到结果一般发的时间都不是我们可以接受的。所以它一般要进行一些特殊处理。如SQL Server 2005就会对事实表进行如预生成处理等。</li>\n</ul>\n</li>\n<li><p>事实表一般是没有主键的，数据的质量完全由业务系统来把握。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p> a) 事实表   </p>\n<p> i.              事实表是维度模型的基本表，存放有大量的业务性能度量值。</p>\n<p> ii.              事实表的一行对应一个度量值，一个度量值就是事实表的一行，事实表的所有度量值必须具有相同的粒度</p>\n<p> iii.              事实表中最有用的事实是数字类型和可加形型事实<br>","more":"<br> iv.              在维度模型中，事实表表示维度见多对多的关系</p>\n<p>b)        维度表</p>\n<p>i.              维度表包含业务的文字描述，维度表倾向于将列数做相当少。</p>\n<p>ii.              位数表是进入事实表的入口，丰富的维度属性给出了丰富的分析切割能力，维度给用户提供了使用数据仓库的借口</p>\n<p>c)         事实与维度的融合</p>\n<p>i.              由数字类型度量值组成的事实表连接到一组填满描述属性的维度表上，这个星型结构特征通常叫做星星连接方案</p>\n<p>ii.              维度模型的简明性也带来了性能上的好处，数据库优化器可以更加高效的出吃这些连接关系较少的简单方案。数据库引擎可采取非常强劲的做法是：首先集中对建立了充足的索引的维度进行约束处理，然后用满足条件的维度表关节子的笛卡尔乘积一次性处理全部的事实表。</p>\n<p>iii.              维度模型的可预订框架能够经受住无法预见的用户行为带来的考验</p>\n<p>一个典型的例子是，把逻辑业务比作一个立方体，产品维、时间维、地点维分别作为不同的坐标轴，而坐标轴的交点就是一个具体的事实。也就是说事实表是多个维度表的一个交点。而维度表是分析事实的一个窗口。 </p>\n<p>首先介绍下数据库结构中的星型结构，该结构在位于结构中心的单个事实数据表中维护数据，其它维度数据存储在维度表中。每个维度表与事实数据表直接相关，且通常通过一个键联接到事实数据表中。星型架构是数据仓库比较流向的一种架构。</p>\n<p>事实表是数据仓库结构中的中央表，它包含联系事实与维度表的数字度量值和键。事实数据表包含描述业务（例如产品销售）内特定事件的数据。</p>\n<p>维度表是维度属性的集合。是分析问题的一个窗口。是人们观察数据的特定角度，是考虑问题时的一类属性，属性的集合构成一个维。</p>\n<ul>\n<li><p>二者的区别：</p>\n<ul>\n<li><p>维度表的冗余很大，主要是因为维度一般不大(相对于事实表来说的)，而维度表的冗余可以使事实表节省很多空间。</p>\n<ul>\n<li>事实表一般都很大，如果以普通方式查询的话，得到结果一般发的时间都不是我们可以接受的。所以它一般要进行一些特殊处理。如SQL Server 2005就会对事实表进行如预生成处理等。</li>\n</ul>\n</li>\n<li><p>事实表一般是没有主键的，数据的质量完全由业务系统来把握。</p>\n</li>\n</ul>\n</li>\n</ul>"},{"layout":"posts","title":"数据算法——Spark的二次排序解决方案","date":"2018-06-07T07:41:50.000Z","_content":"\n在Saprk中解决二次排序问题，又以下两种解决方案：\n\n* 方案一：\n\n  将一个给定的键的所有值读取并缓存到一个List数组，对数组中得值完成归约器排序，如果每个归约器键的值集很小，则本方案适用\n\n* 方案二：\n\n  使用Spark框架对归约器值排序，这种方法“会为自然键增加部分或者整个值来创建一个组合键以实现排序目标”，本方法可伸缩，不受内存限制。\n<!-- more-->\n**时间序列作为输入**：\n\n输入格式：\n\n```\n<key><,><time><,><value>\n```\n\n示例：\n\n```\np,4,40\np,6,20\nx,2,9\ny,2,5\nx,1,3\ny,1,7\ny,3,1\nx,3,6\nz,1,4\nz,2,8\nz,3,7\nz,4,0\np,1,10\np,3,60\n```\n\n**期望输出：**\n\n```\n(z,{1=4, 2=8, 3=7, 4=0})\n(p,{1=10, 3=60, 4=40, 6=20})\n(x,{1=3, 2=9, 3=6})\n(y,{1=7, 2=5, 3=1})\n```\n\n#### 一、方案一：内存中实现二次排序\n\n算法：\n\n>1.导入所需Java/Spark类\n>\n>2.将输入数据作为参数传入并验证\n>\n>3.创建sparkcontext对象，连接到Spark master,用来创建新的RDD\n>\n>4.使用sc对象为输入文件创建一个RDD\n>\n>5.从一个RDD<String>创建键值对，键是name，值是（time，value）对，得到PairRDD<String,Tuple2<String, String>>\n>\n>6.验证第五步，打印PairRDD所有值\n>\n>7.按键分组，使用GroupByKey()方法， 得到PairRDD<String, Iterable<Tuple2<String, String>>>\n>\n>* 注意：Iterable<Tuple2<String, String>>并不是有序的，一般处于性能考虑，更优先使用reduceByKey(),而不是GroupByKey(),不过此处只能用GroupByKey()，因为reduceByKey()不允许对给定键的值原地排序。\n>\n>8.验证第七步，打印PairRDD<String, Iterable<Tuple2<String, String>>>中所有值\n>\n>9.对reducer排序来得到最终输出\n>\n>10.打印所有值\n\n```scala\nobject SecondarySort_InMemory {\n  def main(args: Array[String]): Unit = {\n    if (args.length != 2) {\n      println(\"Usage <input-path> <output-path>\")\n      sys.exit(1)\n    }\n\n    val inpath = args(0)\n    val outpath = args(1)\n    //    val inpath = \"/Users/harold-mac/Documents/data-algorithms/input\"\n    //    val outpath = \"./out\"\n    val config = new SparkConf()\n      .setAppName(\"SecondarySort_InMemory\")\n      .setMaster(\"local\")\n    val sc = new SparkContext(config)\n    val input = sc.textFile(inpath)\n    val tmp = input.map(line => {\n      val x = line.split(\",\")\n      (x(0), (x(1).toInt, x(2).toInt))\n    })\n    val output = tmp.groupByKey().mapValues(x => x.toList.sortWith((x, y) => x._1 > y._1))\n    //或者\n    //    val output = tmp.groupByKey().map {\n    //      case (name, iter) => iter.toList.sortWith((x, y) => x._1 > y._1)\n    //    }\n    output.saveAsTextFile(outpath)\n  }\n}\n```\n\n\n\n#### 二、方案二：使用Spark框架实现二次排序\n\n按照(name, time)排序，写一个分区器。\n\n```scala\nobject SecondarySort {\n  def main(args: Array[String]): Unit = {\n    if (args.length != 3) {\n      println(\"Usage <number-of-partitions> <input-path> <output-path>\")\n      sys.exit(1)\n    }\n\n    val partitions = args(0).toInt\n    val inputPath = args(1)\n    val outputPath = args(2)\n\n    val config = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"SecondarySort\")\n\n    val sc = new SparkContext(config)\n    val input = sc.textFile(inputPath)\n    val valueToKey = input.map(x => {\n      val line = x.split(\",\")\n      ((line(0) + \"-\" + line(1) , line(2).toInt), line(2).toInt)\n    }\n    )\n    //隐式变换，按照（name，time）方式排序\n    implicit def tupleOrderingDesc = new Ordering[Tuple2[String, Int]] {\n      override def compare(x: Tuple2[String, Int], y: Tuple2[String, Int]): Int = {\n        if (y._1.compareTo(x._1) == 0)\n          y._2.compareTo(x._2)\n        else y._1.compareTo(x._1)\n      }\n    }\n\n    val sorted = valueToKey.repartitionAndSortWithinPartitions(new CustomPartitioner(partitions))\n    val result = sorted.map {\n      case (k,v) => (k._1, v)\n    }\n    result.saveAsTextFile(outputPath)\n    sc.stop()\n  }\n}\n```\n\n```scala\n//分区器\nclass CustomPartitioner(partitons :Int) extends Partitioner{\n  require(partitons >0, s\"Number of partitons ($partitons) cannot be negative.\")\n  override def numPartitions: Int = partitons\n\n  override def getPartition(key: Any): Int = key match {\n    case (k:String, v:Int) => math.abs(k.hashCode % numPartitions)\n    case null => 0\n    case _ => math.abs(key.hashCode() % numPartitions)\n  }\n\n  override def equals(obj: scala.Any): Boolean = obj match {\n    case h:CustomPartitioner => h.numPartitions == numPartitions\n    case _ => false\n  }\n\n  override def hashCode(): Int = numPartitions\n}\n```\n","source":"_posts/数据算法——Spark的二次排序解决方案.md","raw":"---\nlayout: posts\ntitle: 数据算法——Spark的二次排序解决方案\ndate: 2018-06-07 15:41:50\ntags: [分布式算法, 大数据, 机器学习, Spark]\n---\n\n在Saprk中解决二次排序问题，又以下两种解决方案：\n\n* 方案一：\n\n  将一个给定的键的所有值读取并缓存到一个List数组，对数组中得值完成归约器排序，如果每个归约器键的值集很小，则本方案适用\n\n* 方案二：\n\n  使用Spark框架对归约器值排序，这种方法“会为自然键增加部分或者整个值来创建一个组合键以实现排序目标”，本方法可伸缩，不受内存限制。\n<!-- more-->\n**时间序列作为输入**：\n\n输入格式：\n\n```\n<key><,><time><,><value>\n```\n\n示例：\n\n```\np,4,40\np,6,20\nx,2,9\ny,2,5\nx,1,3\ny,1,7\ny,3,1\nx,3,6\nz,1,4\nz,2,8\nz,3,7\nz,4,0\np,1,10\np,3,60\n```\n\n**期望输出：**\n\n```\n(z,{1=4, 2=8, 3=7, 4=0})\n(p,{1=10, 3=60, 4=40, 6=20})\n(x,{1=3, 2=9, 3=6})\n(y,{1=7, 2=5, 3=1})\n```\n\n#### 一、方案一：内存中实现二次排序\n\n算法：\n\n>1.导入所需Java/Spark类\n>\n>2.将输入数据作为参数传入并验证\n>\n>3.创建sparkcontext对象，连接到Spark master,用来创建新的RDD\n>\n>4.使用sc对象为输入文件创建一个RDD\n>\n>5.从一个RDD<String>创建键值对，键是name，值是（time，value）对，得到PairRDD<String,Tuple2<String, String>>\n>\n>6.验证第五步，打印PairRDD所有值\n>\n>7.按键分组，使用GroupByKey()方法， 得到PairRDD<String, Iterable<Tuple2<String, String>>>\n>\n>* 注意：Iterable<Tuple2<String, String>>并不是有序的，一般处于性能考虑，更优先使用reduceByKey(),而不是GroupByKey(),不过此处只能用GroupByKey()，因为reduceByKey()不允许对给定键的值原地排序。\n>\n>8.验证第七步，打印PairRDD<String, Iterable<Tuple2<String, String>>>中所有值\n>\n>9.对reducer排序来得到最终输出\n>\n>10.打印所有值\n\n```scala\nobject SecondarySort_InMemory {\n  def main(args: Array[String]): Unit = {\n    if (args.length != 2) {\n      println(\"Usage <input-path> <output-path>\")\n      sys.exit(1)\n    }\n\n    val inpath = args(0)\n    val outpath = args(1)\n    //    val inpath = \"/Users/harold-mac/Documents/data-algorithms/input\"\n    //    val outpath = \"./out\"\n    val config = new SparkConf()\n      .setAppName(\"SecondarySort_InMemory\")\n      .setMaster(\"local\")\n    val sc = new SparkContext(config)\n    val input = sc.textFile(inpath)\n    val tmp = input.map(line => {\n      val x = line.split(\",\")\n      (x(0), (x(1).toInt, x(2).toInt))\n    })\n    val output = tmp.groupByKey().mapValues(x => x.toList.sortWith((x, y) => x._1 > y._1))\n    //或者\n    //    val output = tmp.groupByKey().map {\n    //      case (name, iter) => iter.toList.sortWith((x, y) => x._1 > y._1)\n    //    }\n    output.saveAsTextFile(outpath)\n  }\n}\n```\n\n\n\n#### 二、方案二：使用Spark框架实现二次排序\n\n按照(name, time)排序，写一个分区器。\n\n```scala\nobject SecondarySort {\n  def main(args: Array[String]): Unit = {\n    if (args.length != 3) {\n      println(\"Usage <number-of-partitions> <input-path> <output-path>\")\n      sys.exit(1)\n    }\n\n    val partitions = args(0).toInt\n    val inputPath = args(1)\n    val outputPath = args(2)\n\n    val config = new SparkConf()\n      .setMaster(\"local\")\n      .setAppName(\"SecondarySort\")\n\n    val sc = new SparkContext(config)\n    val input = sc.textFile(inputPath)\n    val valueToKey = input.map(x => {\n      val line = x.split(\",\")\n      ((line(0) + \"-\" + line(1) , line(2).toInt), line(2).toInt)\n    }\n    )\n    //隐式变换，按照（name，time）方式排序\n    implicit def tupleOrderingDesc = new Ordering[Tuple2[String, Int]] {\n      override def compare(x: Tuple2[String, Int], y: Tuple2[String, Int]): Int = {\n        if (y._1.compareTo(x._1) == 0)\n          y._2.compareTo(x._2)\n        else y._1.compareTo(x._1)\n      }\n    }\n\n    val sorted = valueToKey.repartitionAndSortWithinPartitions(new CustomPartitioner(partitions))\n    val result = sorted.map {\n      case (k,v) => (k._1, v)\n    }\n    result.saveAsTextFile(outputPath)\n    sc.stop()\n  }\n}\n```\n\n```scala\n//分区器\nclass CustomPartitioner(partitons :Int) extends Partitioner{\n  require(partitons >0, s\"Number of partitons ($partitons) cannot be negative.\")\n  override def numPartitions: Int = partitons\n\n  override def getPartition(key: Any): Int = key match {\n    case (k:String, v:Int) => math.abs(k.hashCode % numPartitions)\n    case null => 0\n    case _ => math.abs(key.hashCode() % numPartitions)\n  }\n\n  override def equals(obj: scala.Any): Boolean = obj match {\n    case h:CustomPartitioner => h.numPartitions == numPartitions\n    case _ => false\n  }\n\n  override def hashCode(): Int = numPartitions\n}\n```\n","slug":"数据算法——Spark的二次排序解决方案","published":1,"updated":"2018-06-07T11:40:45.000Z","comments":1,"photos":[],"link":"","_id":"cji4m0lti0000nr96ylr00024","content":"<p>在Saprk中解决二次排序问题，又以下两种解决方案：</p>\n<ul>\n<li><p>方案一：</p>\n<p>将一个给定的键的所有值读取并缓存到一个List数组，对数组中得值完成归约器排序，如果每个归约器键的值集很小，则本方案适用</p>\n</li>\n<li><p>方案二：</p>\n<p>使用Spark框架对归约器值排序，这种方法“会为自然键增加部分或者整个值来创建一个组合键以实现排序目标”，本方法可伸缩，不受内存限制。</p>\n<a id=\"more\"></a>\n<p><strong>时间序列作为输入</strong>：</p>\n</li>\n</ul>\n<p>输入格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;&lt;,&gt;&lt;time&gt;&lt;,&gt;&lt;value&gt;</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p,4,40</span><br><span class=\"line\">p,6,20</span><br><span class=\"line\">x,2,9</span><br><span class=\"line\">y,2,5</span><br><span class=\"line\">x,1,3</span><br><span class=\"line\">y,1,7</span><br><span class=\"line\">y,3,1</span><br><span class=\"line\">x,3,6</span><br><span class=\"line\">z,1,4</span><br><span class=\"line\">z,2,8</span><br><span class=\"line\">z,3,7</span><br><span class=\"line\">z,4,0</span><br><span class=\"line\">p,1,10</span><br><span class=\"line\">p,3,60</span><br></pre></td></tr></table></figure>\n<p><strong>期望输出：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(z,&#123;1=4, 2=8, 3=7, 4=0&#125;)</span><br><span class=\"line\">(p,&#123;1=10, 3=60, 4=40, 6=20&#125;)</span><br><span class=\"line\">(x,&#123;1=3, 2=9, 3=6&#125;)</span><br><span class=\"line\">(y,&#123;1=7, 2=5, 3=1&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"一、方案一：内存中实现二次排序\"><a href=\"#一、方案一：内存中实现二次排序\" class=\"headerlink\" title=\"一、方案一：内存中实现二次排序\"></a>一、方案一：内存中实现二次排序</h4><p>算法：</p>\n<blockquote>\n<p>1.导入所需Java/Spark类</p>\n<p>2.将输入数据作为参数传入并验证</p>\n<p>3.创建sparkcontext对象，连接到Spark master,用来创建新的RDD</p>\n<p>4.使用sc对象为输入文件创建一个RDD</p>\n<p>5.从一个RDD<string>创建键值对，键是name，值是（time，value）对，得到PairRDD&lt;String,Tuple2&lt;String, String&gt;&gt;</string></p>\n<p>6.验证第五步，打印PairRDD所有值</p>\n<p>7.按键分组，使用GroupByKey()方法， 得到PairRDD&lt;String, Iterable&lt;Tuple2&lt;String, String&gt;&gt;&gt;</p>\n<ul>\n<li>注意：Iterable&lt;Tuple2&lt;String, String&gt;&gt;并不是有序的，一般处于性能考虑，更优先使用reduceByKey(),而不是GroupByKey(),不过此处只能用GroupByKey()，因为reduceByKey()不允许对给定键的值原地排序。</li>\n</ul>\n<p>8.验证第七步，打印PairRDD&lt;String, Iterable&lt;Tuple2&lt;String, String&gt;&gt;&gt;中所有值</p>\n<p>9.对reducer排序来得到最终输出</p>\n<p>10.打印所有值</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SecondarySort_InMemory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"Usage &lt;input-path&gt; &lt;output-path&gt;\"</span>)</span><br><span class=\"line\">      sys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> inpath = args(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> outpath = args(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">//    val inpath = \"/Users/harold-mac/Documents/data-algorithms/input\"</span></span><br><span class=\"line\">    <span class=\"comment\">//    val outpath = \"./out\"</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> config = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"SecondarySort_InMemory\"</span>)</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(config)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> input = sc.textFile(inpath)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> tmp = input.map(line =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> x = line.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">      (x(<span class=\"number\">0</span>), (x(<span class=\"number\">1</span>).toInt, x(<span class=\"number\">2</span>).toInt))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> output = tmp.groupByKey().mapValues(x =&gt; x.toList.sortWith((x, y) =&gt; x._1 &gt; y._1))</span><br><span class=\"line\">    <span class=\"comment\">//或者</span></span><br><span class=\"line\">    <span class=\"comment\">//    val output = tmp.groupByKey().map &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      case (name, iter) =&gt; iter.toList.sortWith((x, y) =&gt; x._1 &gt; y._1)</span></span><br><span class=\"line\">    <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">    output.saveAsTextFile(outpath)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二、方案二：使用Spark框架实现二次排序\"><a href=\"#二、方案二：使用Spark框架实现二次排序\" class=\"headerlink\" title=\"二、方案二：使用Spark框架实现二次排序\"></a>二、方案二：使用Spark框架实现二次排序</h4><p>按照(name, time)排序，写一个分区器。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SecondarySort</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length != <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"Usage &lt;number-of-partitions&gt; &lt;input-path&gt; &lt;output-path&gt;\"</span>)</span><br><span class=\"line\">      sys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> partitions = args(<span class=\"number\">0</span>).toInt</span><br><span class=\"line\">    <span class=\"keyword\">val</span> inputPath = args(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> outputPath = args(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> config = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"SecondarySort\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(config)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> input = sc.textFile(inputPath)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> valueToKey = input.map(x =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> line = x.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">      ((line(<span class=\"number\">0</span>) + <span class=\"string\">\"-\"</span> + line(<span class=\"number\">1</span>) , line(<span class=\"number\">2</span>).toInt), line(<span class=\"number\">2</span>).toInt)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//隐式变换，按照（name，time）方式排序</span></span><br><span class=\"line\">    <span class=\"keyword\">implicit</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tupleOrderingDesc</span> </span>= <span class=\"keyword\">new</span> <span class=\"type\">Ordering</span>[<span class=\"type\">Tuple2</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare</span></span>(x: <span class=\"type\">Tuple2</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>], y: <span class=\"type\">Tuple2</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y._1.compareTo(x._1) == <span class=\"number\">0</span>)</span><br><span class=\"line\">          y._2.compareTo(x._2)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> y._1.compareTo(x._1)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sorted = valueToKey.repartitionAndSortWithinPartitions(<span class=\"keyword\">new</span> <span class=\"type\">CustomPartitioner</span>(partitions))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = sorted.map &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> (k,v) =&gt; (k._1, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result.saveAsTextFile(outputPath)</span><br><span class=\"line\">    sc.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分区器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomPartitioner</span>(<span class=\"params\">partitons :<span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Partitioner</span></span>&#123;</span><br><span class=\"line\">  require(partitons &gt;<span class=\"number\">0</span>, <span class=\"string\">s\"Number of partitons (<span class=\"subst\">$partitons</span>) cannot be negative.\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numPartitions</span></span>: <span class=\"type\">Int</span> = partitons</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPartition</span></span>(key: <span class=\"type\">Any</span>): <span class=\"type\">Int</span> = key <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> (k:<span class=\"type\">String</span>, v:<span class=\"type\">Int</span>) =&gt; math.abs(k.hashCode % numPartitions)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"literal\">null</span> =&gt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; math.abs(key.hashCode() % numPartitions)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">equals</span></span>(obj: scala.<span class=\"type\">Any</span>): <span class=\"type\">Boolean</span> = obj <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> h:<span class=\"type\">CustomPartitioner</span> =&gt; h.numPartitions == numPartitions</span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hashCode</span></span>(): <span class=\"type\">Int</span> = numPartitions</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在Saprk中解决二次排序问题，又以下两种解决方案：</p>\n<ul>\n<li><p>方案一：</p>\n<p>将一个给定的键的所有值读取并缓存到一个List数组，对数组中得值完成归约器排序，如果每个归约器键的值集很小，则本方案适用</p>\n</li>\n<li><p>方案二：</p>\n<p>使用Spark框架对归约器值排序，这种方法“会为自然键增加部分或者整个值来创建一个组合键以实现排序目标”，本方法可伸缩，不受内存限制。</p>","more":"<p><strong>时间序列作为输入</strong>：</p>\n</li>\n</ul>\n<p>输入格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;&lt;,&gt;&lt;time&gt;&lt;,&gt;&lt;value&gt;</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p,4,40</span><br><span class=\"line\">p,6,20</span><br><span class=\"line\">x,2,9</span><br><span class=\"line\">y,2,5</span><br><span class=\"line\">x,1,3</span><br><span class=\"line\">y,1,7</span><br><span class=\"line\">y,3,1</span><br><span class=\"line\">x,3,6</span><br><span class=\"line\">z,1,4</span><br><span class=\"line\">z,2,8</span><br><span class=\"line\">z,3,7</span><br><span class=\"line\">z,4,0</span><br><span class=\"line\">p,1,10</span><br><span class=\"line\">p,3,60</span><br></pre></td></tr></table></figure>\n<p><strong>期望输出：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(z,&#123;1=4, 2=8, 3=7, 4=0&#125;)</span><br><span class=\"line\">(p,&#123;1=10, 3=60, 4=40, 6=20&#125;)</span><br><span class=\"line\">(x,&#123;1=3, 2=9, 3=6&#125;)</span><br><span class=\"line\">(y,&#123;1=7, 2=5, 3=1&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"一、方案一：内存中实现二次排序\"><a href=\"#一、方案一：内存中实现二次排序\" class=\"headerlink\" title=\"一、方案一：内存中实现二次排序\"></a>一、方案一：内存中实现二次排序</h4><p>算法：</p>\n<blockquote>\n<p>1.导入所需Java/Spark类</p>\n<p>2.将输入数据作为参数传入并验证</p>\n<p>3.创建sparkcontext对象，连接到Spark master,用来创建新的RDD</p>\n<p>4.使用sc对象为输入文件创建一个RDD</p>\n<p>5.从一个RDD<string>创建键值对，键是name，值是（time，value）对，得到PairRDD&lt;String,Tuple2&lt;String, String&gt;&gt;</string></p>\n<p>6.验证第五步，打印PairRDD所有值</p>\n<p>7.按键分组，使用GroupByKey()方法， 得到PairRDD&lt;String, Iterable&lt;Tuple2&lt;String, String&gt;&gt;&gt;</p>\n<ul>\n<li>注意：Iterable&lt;Tuple2&lt;String, String&gt;&gt;并不是有序的，一般处于性能考虑，更优先使用reduceByKey(),而不是GroupByKey(),不过此处只能用GroupByKey()，因为reduceByKey()不允许对给定键的值原地排序。</li>\n</ul>\n<p>8.验证第七步，打印PairRDD&lt;String, Iterable&lt;Tuple2&lt;String, String&gt;&gt;&gt;中所有值</p>\n<p>9.对reducer排序来得到最终输出</p>\n<p>10.打印所有值</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SecondarySort_InMemory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"Usage &lt;input-path&gt; &lt;output-path&gt;\"</span>)</span><br><span class=\"line\">      sys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> inpath = args(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> outpath = args(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">//    val inpath = \"/Users/harold-mac/Documents/data-algorithms/input\"</span></span><br><span class=\"line\">    <span class=\"comment\">//    val outpath = \"./out\"</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> config = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"SecondarySort_InMemory\"</span>)</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(config)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> input = sc.textFile(inpath)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> tmp = input.map(line =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> x = line.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">      (x(<span class=\"number\">0</span>), (x(<span class=\"number\">1</span>).toInt, x(<span class=\"number\">2</span>).toInt))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> output = tmp.groupByKey().mapValues(x =&gt; x.toList.sortWith((x, y) =&gt; x._1 &gt; y._1))</span><br><span class=\"line\">    <span class=\"comment\">//或者</span></span><br><span class=\"line\">    <span class=\"comment\">//    val output = tmp.groupByKey().map &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      case (name, iter) =&gt; iter.toList.sortWith((x, y) =&gt; x._1 &gt; y._1)</span></span><br><span class=\"line\">    <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">    output.saveAsTextFile(outpath)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二、方案二：使用Spark框架实现二次排序\"><a href=\"#二、方案二：使用Spark框架实现二次排序\" class=\"headerlink\" title=\"二、方案二：使用Spark框架实现二次排序\"></a>二、方案二：使用Spark框架实现二次排序</h4><p>按照(name, time)排序，写一个分区器。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SecondarySort</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length != <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"Usage &lt;number-of-partitions&gt; &lt;input-path&gt; &lt;output-path&gt;\"</span>)</span><br><span class=\"line\">      sys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> partitions = args(<span class=\"number\">0</span>).toInt</span><br><span class=\"line\">    <span class=\"keyword\">val</span> inputPath = args(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> outputPath = args(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> config = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"SecondarySort\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(config)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> input = sc.textFile(inputPath)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> valueToKey = input.map(x =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> line = x.split(<span class=\"string\">\",\"</span>)</span><br><span class=\"line\">      ((line(<span class=\"number\">0</span>) + <span class=\"string\">\"-\"</span> + line(<span class=\"number\">1</span>) , line(<span class=\"number\">2</span>).toInt), line(<span class=\"number\">2</span>).toInt)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">//隐式变换，按照（name，time）方式排序</span></span><br><span class=\"line\">    <span class=\"keyword\">implicit</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tupleOrderingDesc</span> </span>= <span class=\"keyword\">new</span> <span class=\"type\">Ordering</span>[<span class=\"type\">Tuple2</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare</span></span>(x: <span class=\"type\">Tuple2</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>], y: <span class=\"type\">Tuple2</span>[<span class=\"type\">String</span>, <span class=\"type\">Int</span>]): <span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y._1.compareTo(x._1) == <span class=\"number\">0</span>)</span><br><span class=\"line\">          y._2.compareTo(x._2)</span><br><span class=\"line\">        <span class=\"keyword\">else</span> y._1.compareTo(x._1)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> sorted = valueToKey.repartitionAndSortWithinPartitions(<span class=\"keyword\">new</span> <span class=\"type\">CustomPartitioner</span>(partitions))</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = sorted.map &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> (k,v) =&gt; (k._1, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result.saveAsTextFile(outputPath)</span><br><span class=\"line\">    sc.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分区器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomPartitioner</span>(<span class=\"params\">partitons :<span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Partitioner</span></span>&#123;</span><br><span class=\"line\">  require(partitons &gt;<span class=\"number\">0</span>, <span class=\"string\">s\"Number of partitons (<span class=\"subst\">$partitons</span>) cannot be negative.\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numPartitions</span></span>: <span class=\"type\">Int</span> = partitons</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPartition</span></span>(key: <span class=\"type\">Any</span>): <span class=\"type\">Int</span> = key <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> (k:<span class=\"type\">String</span>, v:<span class=\"type\">Int</span>) =&gt; math.abs(k.hashCode % numPartitions)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"literal\">null</span> =&gt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; math.abs(key.hashCode() % numPartitions)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">equals</span></span>(obj: scala.<span class=\"type\">Any</span>): <span class=\"type\">Boolean</span> = obj <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> h:<span class=\"type\">CustomPartitioner</span> =&gt; h.numPartitions == numPartitions</span><br><span class=\"line\">    <span class=\"keyword\">case</span> _ =&gt; <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hashCode</span></span>(): <span class=\"type\">Int</span> = numPartitions</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cji4l7i5u0000cf96r69nhl0x","tag_id":"cji4l7i610002cf96llrt1e2e","_id":"cji4l7i690007cf96ospivkst"},{"post_id":"cji4l7i5z0001cf96px32hdz0","tag_id":"cji4l7i690006cf96hcyudmpm","_id":"cji4l7i6h000fcf96du7mfxiw"},{"post_id":"cji4l7i5z0001cf96px32hdz0","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i6j000hcf96yf0wluqo"},{"post_id":"cji4l7i660003cf96eu5iifg5","tag_id":"cji4l7i6g000dcf96jmq2ynkz","_id":"cji4l7i6l000kcf96liob9kdv"},{"post_id":"cji4l7i6j000jcf96m56lq1w7","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i6m000mcf96jwpti48a"},{"post_id":"cji4l7i670004cf963nv0m60w","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i6s000wcf96cnkxeww5"},{"post_id":"cji4l7i670004cf963nv0m60w","tag_id":"cji4l7i6m000ncf96ehygbv7o","_id":"cji4l7i6t000ycf96laydsusy"},{"post_id":"cji4l7i670004cf963nv0m60w","tag_id":"cji4l7i6p000rcf960oftbykn","_id":"cji4l7i6u0011cf9681pjqof7"},{"post_id":"cji4l7i6r000vcf96j63n8iie","tag_id":"cji4l7i610002cf96llrt1e2e","_id":"cji4l7i6u0013cf96qbebu18j"},{"post_id":"cji4l7i680005cf96uhxkdzjw","tag_id":"cji4l7i6r000ucf96pwj8n1su","_id":"cji4l7i6w0016cf960xhk5xiv"},{"post_id":"cji4l7i680005cf96uhxkdzjw","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i6x0018cf967j9i6g4v"},{"post_id":"cji4l7i6u0012cf96lyh19wwk","tag_id":"cji4l7i6g000dcf96jmq2ynkz","_id":"cji4l7i6y001bcf96c148ie3j"},{"post_id":"cji4l7i690008cf969sm1fouv","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i6z001ecf96s4s41dl6"},{"post_id":"cji4l7i690008cf969sm1fouv","tag_id":"cji4l7i6x0019cf96ur0xqem1","_id":"cji4l7i6z001fcf9657r83qpu"},{"post_id":"cji4l7i690008cf969sm1fouv","tag_id":"cji4l7i6z001ccf96flqe4pc3","_id":"cji4l7i70001hcf96zg7236cv"},{"post_id":"cji4l7i6c0009cf968b2zqxpb","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i71001kcf96nbgwynzx"},{"post_id":"cji4l7i6c0009cf968b2zqxpb","tag_id":"cji4l7i6x0019cf96ur0xqem1","_id":"cji4l7i71001lcf967tn1bbsg"},{"post_id":"cji4l7i6c0009cf968b2zqxpb","tag_id":"cji4l7i6z001ccf96flqe4pc3","_id":"cji4l7i71001ncf96prxdcwpg"},{"post_id":"cji4l7i6e000bcf96zkvg9446","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i72001qcf96tss3o248"},{"post_id":"cji4l7i6e000bcf96zkvg9446","tag_id":"cji4l7i6x0019cf96ur0xqem1","_id":"cji4l7i73001rcf96mp1b5spo"},{"post_id":"cji4l7i6e000bcf96zkvg9446","tag_id":"cji4l7i6z001ccf96flqe4pc3","_id":"cji4l7i73001tcf96epwlplvm"},{"post_id":"cji4l7i6f000ccf96qjinvj5e","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i74001wcf96bmtega95"},{"post_id":"cji4l7i6f000ccf96qjinvj5e","tag_id":"cji4l7i6x0019cf96ur0xqem1","_id":"cji4l7i74001xcf96m91ps1jx"},{"post_id":"cji4l7i6f000ccf96qjinvj5e","tag_id":"cji4l7i6z001ccf96flqe4pc3","_id":"cji4l7i75001zcf9646l91hl8"},{"post_id":"cji4l7i6g000ecf96i5ex4dn1","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i760022cf96gpqjgmr9"},{"post_id":"cji4l7i6g000ecf96i5ex4dn1","tag_id":"cji4l7i6x0019cf96ur0xqem1","_id":"cji4l7i760023cf96f9h33khx"},{"post_id":"cji4l7i6g000ecf96i5ex4dn1","tag_id":"cji4l7i6z001ccf96flqe4pc3","_id":"cji4l7i760025cf96znp1fvm2"},{"post_id":"cji4l7i6i000gcf960bpdaodu","tag_id":"cji4l7i750021cf965ywa7dum","_id":"cji4l7i760027cf96hqtv9ff9"},{"post_id":"cji4l7i6i000gcf960bpdaodu","tag_id":"cji4l7i760024cf96udeu43p7","_id":"cji4l7i760028cf965me39zd7"},{"post_id":"cji4l7i6l000lcf96b93ido9a","tag_id":"cji4l7i760026cf962xn80psy","_id":"cji4l7i77002bcf9634i0scwx"},{"post_id":"cji4l7i6l000lcf96b93ido9a","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i77002ccf96l1dv1h6o"},{"post_id":"cji4l7i6l000lcf96b93ido9a","tag_id":"cji4l7i610002cf96llrt1e2e","_id":"cji4l7i77002ecf96wir8i2k3"},{"post_id":"cji4l7i6l000lcf96b93ido9a","tag_id":"cji4l7i770029cf96qilg0pkc","_id":"cji4l7i78002fcf96gup9ngtb"},{"post_id":"cji4l7i6m000ocf96r10sz6ze","tag_id":"cji4l7i77002acf96s94zd5w0","_id":"cji4l7i78002hcf96uku65ql1"},{"post_id":"cji4l7i6m000ocf96r10sz6ze","tag_id":"cji4l7i77002dcf96cp6byqf9","_id":"cji4l7i78002icf96q0qqc16y"},{"post_id":"cji4l7i6o000pcf96a08e6okm","tag_id":"cji4l7i77002acf96s94zd5w0","_id":"cji4l7i79002lcf960hx69wnp"},{"post_id":"cji4l7i6o000pcf96a08e6okm","tag_id":"cji4l7i77002dcf96cp6byqf9","_id":"cji4l7i79002mcf96mex3lq1b"},{"post_id":"cji4l7i6o000qcf962wgadp8s","tag_id":"cji4l7i77002acf96s94zd5w0","_id":"cji4l7i7a002pcf96s2d9gfun"},{"post_id":"cji4l7i6o000qcf962wgadp8s","tag_id":"cji4l7i77002dcf96cp6byqf9","_id":"cji4l7i7a002qcf96sc1l0p62"},{"post_id":"cji4l7i6p000scf96v30uniqk","tag_id":"cji4l7i7a002ocf968ly46eif","_id":"cji4l7i7b002scf96uklradbj"},{"post_id":"cji4l7i6p000scf96v30uniqk","tag_id":"cji4l7i610002cf96llrt1e2e","_id":"cji4l7i7b002tcf967xxgjk6b"},{"post_id":"cji4l7i6p000scf96v30uniqk","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i7c002vcf96b3k6migi"},{"post_id":"cji4l7i6q000tcf96jv6auoqc","tag_id":"cji4l7i7a002rcf96l3u8n6cc","_id":"cji4l7i7c002wcf96e8huube5"},{"post_id":"cji4l7i6s000xcf96ea3vd6nk","tag_id":"cji4l7i7a002rcf96l3u8n6cc","_id":"cji4l7i7d002ycf96w2vc1ga2"},{"post_id":"cji4l7i6t0010cf96eaj78hef","tag_id":"cji4l7i7a002rcf96l3u8n6cc","_id":"cji4l7i7d0030cf9606olrvu3"},{"post_id":"cji4l7i6v0015cf96h8drtgv8","tag_id":"cji4l7i750021cf965ywa7dum","_id":"cji4l7i7e0032cf9685pjr7i6"},{"post_id":"cji4l7i6w0017cf966mlfjki3","tag_id":"cji4l7i6p000rcf960oftbykn","_id":"cji4l7i7e0034cf96s1rx4zw7"},{"post_id":"cji4l7i6w0017cf966mlfjki3","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i7e0035cf9692ev8sie"},{"post_id":"cji4l7i6w0017cf966mlfjki3","tag_id":"cji4l7i7d0031cf969bdirqxp","_id":"cji4l7i7f0036cf96n2mqhp51"},{"post_id":"cji4l7i6x001acf96p8y61fzy","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i7f0037cf969m2i9e88"},{"post_id":"cji4l7i6x001acf96p8y61fzy","tag_id":"cji4l7i6p000rcf960oftbykn","_id":"cji4l7i7f0038cf962od8vps4"},{"post_id":"cji4l7i6x001acf96p8y61fzy","tag_id":"cji4l7i7e0033cf96lkk1nodb","_id":"cji4l7i7f0039cf96wkvlv5ze"},{"post_id":"cji4l7i7i003acf96g2fq1gez","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i7k003ccf96px36mgrg"},{"post_id":"cji4l7i7i003acf96g2fq1gez","tag_id":"cji4l7i6m000ncf96ehygbv7o","_id":"cji4l7i7m003ecf96v88sxxl1"},{"post_id":"cji4l7i7i003acf96g2fq1gez","tag_id":"cji4l7i6p000rcf960oftbykn","_id":"cji4l7i7n003gcf96ppkif063"},{"post_id":"cji4l7i7j003bcf96qkey09h5","tag_id":"cji4l7i750021cf965ywa7dum","_id":"cji4l7i7p003icf96s2islnc1"},{"post_id":"cji4l7i7l003dcf96nmunr7iz","tag_id":"cji4l7i7a002rcf96l3u8n6cc","_id":"cji4l7i7q003lcf966x3p6jir"},{"post_id":"cji4l7i7m003fcf96fz23gwzg","tag_id":"cji4l7i7a002rcf96l3u8n6cc","_id":"cji4l7i7r003ncf96as6c2ftp"},{"post_id":"cji4l7i7o003hcf961z86ske6","tag_id":"cji4l7i7q003kcf963jfguxya","_id":"cji4l7i7u003rcf96leajcrr6"},{"post_id":"cji4l7i7s003pcf967bmharni","tag_id":"cji4l7i610002cf96llrt1e2e","_id":"cji4l7i7v003tcf96d23bku6p"},{"post_id":"cji4l7i7s003pcf967bmharni","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i7w003wcf96efwrwu42"},{"post_id":"cji4l7i7v003ucf96dqg7q1v7","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i7y003ycf96h1y60gqh"},{"post_id":"cji4l7i7v003ucf96dqg7q1v7","tag_id":"cji4l7i6x0019cf96ur0xqem1","_id":"cji4l7i7y0040cf96bnqi4rpu"},{"post_id":"cji4l7i7v003ucf96dqg7q1v7","tag_id":"cji4l7i6z001ccf96flqe4pc3","_id":"cji4l7i7y0041cf96x5l9xz8q"},{"post_id":"cji4l7i7w003xcf96vfmj3k1v","tag_id":"cji4l7i750021cf965ywa7dum","_id":"cji4l7i7z0043cf96vwut3vr6"},{"post_id":"cji4l7i7p003jcf963xsem47s","tag_id":"cji4l7i7t003qcf960myw5a9v","_id":"cji4l7i7z0044cf96784kdwf3"},{"post_id":"cji4l7i7p003jcf963xsem47s","tag_id":"cji4l7i7q003kcf963jfguxya","_id":"cji4l7i800046cf963e7t65ac"},{"post_id":"cji4l7i7p003jcf963xsem47s","tag_id":"cji4l7i6t000zcf96qvgg57cc","_id":"cji4l7i800047cf964hc9xqr1"},{"post_id":"cji4l7i7q003mcf96auoju0ds","tag_id":"cji4l7i7y003zcf96giskac7c","_id":"cji4l7i810049cf96c6ulvn43"},{"post_id":"cji4l7i7q003mcf96auoju0ds","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i82004acf96dqb1gb2h"},{"post_id":"cji4l7i7q003mcf96auoju0ds","tag_id":"cji4l7i610002cf96llrt1e2e","_id":"cji4l7i82004bcf967ssyh5mn"},{"post_id":"cji4l7i7u003scf96ni1xhxkx","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i84004icf96equb446n"},{"post_id":"cji4l7i7u003scf96ni1xhxkx","tag_id":"cji4l7i800048cf96mv6rauxe","_id":"cji4l7i84004jcf96uhrtckr1"},{"post_id":"cji4l7i7u003scf96ni1xhxkx","tag_id":"cji4l7i82004ccf96guyq5cii","_id":"cji4l7i84004kcf96qr3lxe8t"},{"post_id":"cji4l7i7u003scf96ni1xhxkx","tag_id":"cji4l7i6p000rcf960oftbykn","_id":"cji4l7i84004lcf96w4fowoy7"},{"post_id":"cji4l7i86004mcf96vfj74old","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4l7i89004ocf96e4fapawa"},{"post_id":"cji4l7i86004mcf96vfj74old","tag_id":"cji4l7i6p000rcf960oftbykn","_id":"cji4l7i89004pcf9659vcy5py"},{"post_id":"cji4l7i86004mcf96vfj74old","tag_id":"cji4l7i800048cf96mv6rauxe","_id":"cji4l7i89004qcf96o3pkpm7x"},{"post_id":"cji4l7i86004mcf96vfj74old","tag_id":"cji4l7i770029cf96qilg0pkc","_id":"cji4l7i89004rcf96vw8kbd97"},{"post_id":"cji4l7i87004ncf963o149z2i","tag_id":"cji4l7i77002acf96s94zd5w0","_id":"cji4l7i89004scf962fpv1wf0"},{"post_id":"cji4m0lti0000nr96ylr00024","tag_id":"cji4l7i7y003zcf96giskac7c","_id":"cji4m0ltp0001nr96jihytraf"},{"post_id":"cji4m0lti0000nr96ylr00024","tag_id":"cji4l7i6d000acf96huud8czy","_id":"cji4m0ltq0002nr96g0mzktxl"},{"post_id":"cji4m0lti0000nr96ylr00024","tag_id":"cji4l7i610002cf96llrt1e2e","_id":"cji4m0ltq0003nr96rrck1vdf"},{"post_id":"cji4m0lti0000nr96ylr00024","tag_id":"cji4l7i800045cf9623v7uu1r","_id":"cji4m0ltr0004nr96qq3ujqa7"},{"post_id":"cji4l7i7q003mcf96auoju0ds","tag_id":"cji4l7i6p000rcf960oftbykn","_id":"cji4m0ltr0005nr96fegjmuhq"}],"Tag":[{"name":"机器学习","_id":"cji4l7i610002cf96llrt1e2e"},{"name":"ElasticSearch","_id":"cji4l7i690006cf96hcyudmpm"},{"name":"大数据","_id":"cji4l7i6d000acf96huud8czy"},{"name":"区块链","_id":"cji4l7i6g000dcf96jmq2ynkz"},{"name":"Hive","_id":"cji4l7i6m000ncf96ehygbv7o"},{"name":"Hadoop","_id":"cji4l7i6p000rcf960oftbykn"},{"name":"JVM","_id":"cji4l7i6r000ucf96pwj8n1su"},{"name":"Java","_id":"cji4l7i6t000zcf96qvgg57cc"},{"name":"多线程","_id":"cji4l7i6x0019cf96ur0xqem1"},{"name":"并发","_id":"cji4l7i6z001ccf96flqe4pc3"},{"name":"算法","_id":"cji4l7i750021cf965ywa7dum"},{"name":"字符串匹配","_id":"cji4l7i760024cf96udeu43p7"},{"name":"MLib","_id":"cji4l7i760026cf962xn80psy"},{"name":"协同过滤","_id":"cji4l7i770029cf96qilg0pkc"},{"name":"数据库","_id":"cji4l7i77002acf96s94zd5w0"},{"name":"MySQL","_id":"cji4l7i77002dcf96cp6byqf9"},{"name":"MLlib","_id":"cji4l7i7a002ocf968ly46eif"},{"name":"scala","_id":"cji4l7i7a002rcf96l3u8n6cc"},{"name":"Crunch","_id":"cji4l7i7d0031cf969bdirqxp"},{"name":"HBase","_id":"cji4l7i7e0033cf96lkk1nodb"},{"name":"随笔","_id":"cji4l7i7q003kcf963jfguxya"},{"name":"HTTP","_id":"cji4l7i7t003qcf960myw5a9v"},{"name":"分布式算法","_id":"cji4l7i7y003zcf96giskac7c"},{"name":"Spark","_id":"cji4l7i800045cf9623v7uu1r"},{"name":"推荐系统","_id":"cji4l7i800048cf96mv6rauxe"},{"name":"Mahout","_id":"cji4l7i82004ccf96guyq5cii"}]}}