---
title: 数据算法——移动平均
date: 2018-06-14 11:02:07
tags: [分布式算法, 大数据, 机器学习, 时间序列, Hadoop]
---

#### 一、移动平均的基本概念

​	时间序列数据表示一个变量在一段时间内的值，可以将时间序列数据形式化表示为三元组序列：(k,t,v)

这里k是键(如股票代码)，t是时间（小时、分钟或秒），v是关联的值（如一只股票在t的值）。

​	一般的，只要在一段时间内记录相同的度量值，就会得到时间序列数据。多个连续周期的时间序列数据平均值（按相同时间间隔得到的观察值）称为移动平均。之所以称为“移动”，是因为随着新时间序列数据的到来，要不断重新计算这个平均值，由于会删除最早的值的同时增加最新的值，这个平均值会相应的“移动”。
<!-- more-->
**形式定义：**

令A为一组有序对象的序列：
$A = (a_1,a_2,a_3,…,a_N)$

可以把A表示为：$\lbrace a_i\rbrace_{i=1}^N $

n移动平均序列是由$a_i$定义的一个新序列

$\lbrace S_i\rbrace_{i=1}^{N-n+1} $

这是通过计算n项子序列的算术平均值来得到的：
$s_i = \frac 1n\sum_{j=i}^{i+n-1}a_j$

所以n移动平均序列$S_n$计算如下：

$S_2 = \frac12[(a_1+a_2),(a_2+a_3),…,(a_{n-1}+a_n)]$

$S_3 = \frac13[(a_1+a_2+a_3),(a_2+a_3+a_4),…,(a_{n-2}+a_{n-1}+a_n)]$

$S_4 = \frac14[(a_1+a_2+a_3+a_4),(a_2+a_3+a_4+a_5)…$

#### 二、POJO移动平均解决方案

我们可以将窗口实现为一个队列数据结构，以一种先进先出的方式填入时间序列数据点，直至其中包含N个数据点（这N个点的均值就是移动平均数）。这里提供两个方案：

* 使用java.util.queue
* 使用数组模拟队列

**1.使用队列**

```java
/**
 * @author lihe
 * @Title:
 * @Description: 使用队列求移动均值
 * @date 2018/6/14上午11:51
 */
public class SimpleMovingAverage {
    private double sum = 0.0;
    private final int period;
    private final Queue<Double> window = new LinkedList<Double>();

    public SimpleMovingAverage(int period) {
        if (period < 1) {
            throw new IllegalArgumentException("period must be >0");
        }
        this.period = period;
    }

    public void addNewNumber(Double number) {
        sum += number;
        window.add(number);
        if (window.size() > period)
            sum -= window.remove();
    }

    public double getMovingAverage() {
        if (window.isEmpty())
            throw new IllegalArgumentException("average is undefined");
        return sum/window.size();
    }
}
```

**2.使用数组**

```java
/**
 * @author lihe
 * @Title:
 * @Description: 使用数组算MovingAverage
 * @date 2018/6/14上午11:58
 */
public class SimpleMovingAverageUsingArray {
    private double sum = 0;
    private final int period;
    private double[] window = null;
    private int pointer;
    private int size = 0;

    public SimpleMovingAverageUsingArray(int period) {
        if (period < 1)
            throw new IllegalArgumentException("period must be > 0");
        this.period = period;
        window = new double[period];
    }

    public void addNewNumber(double number) {
        sum += number;
        if (size < period) {
            window[pointer++] = number;
            size++;
        } else {
            pointer = pointer % period;
            sum -= window[pointer];
            window[pointer++] = number;
        }
    }

    public double getMovingAverage() {
        if (size == 0) {
            throw new IllegalArgumentException("average is undefined");
        }
        return sum / size;
    }
}
```

**3.测试POJO移动平均**

```java
/**
 * @author lihe
 * @Title:
 * @Description: 测试移动平均
 * @date 2018/6/14下午1:45
 */
public class TestSimpleMovingAverage {
    private static final Logger THE_LOGGER = Logger.getLogger(TestSimpleMovingAverage.class);

    public static void main(String[] args) {
        double[] testData = {10, 18, 20, 30, 24, 33, 27};
        int[] allWindowSizes = {3, 4};
        for (int windowSize : allWindowSizes) {
            SimpleMovingAverage sma = new SimpleMovingAverage(windowSize);
            THE_LOGGER.info("windowSize:" + windowSize);
            for (double x : testData) {
                sma.addNewNumber(x);
                THE_LOGGER.info("Next Number = " + x + ", SMA = " + sma.getMovingAverage());
            }
            THE_LOGGER.info("---");
        }
    }
}
```

#### 三、Mapreduce/Hadoop移动平均解决方案

移动平均框架的计算由reduce()函数处理，这里可以得到一个特定时间序列的所有所需数据。

**输入：**

<name-as-string><,><date-as-string><,><value-as-double>

```
GOOG,2004-11-04,184.70
GOOG,2004-11-03,191.67
GOOG,2004-11-02,194.87
AAPL,2013-10-09,486.59
AAPL,2013-10-08,480.94
AAPL,2013-10-07,487.75
AAPL,2013-10-04,483.03
AAPL,2013-10-03,483.41
IBM,2013-09-30,185.18
IBM,2013-09-27,186.92
IBM,2013-09-26,190.22
IBM,2013-09-25,189.47
GOOG,2013-07-19,896.60
GOOG,2013-07-18,910.68
GOOG,2013-07-17,918.55
```

以上数据代表三个公司的股价，第一列是公司，第二列是时间，第三列是当天的以调整收盘价。

**输出：**

<name-as-string><,><date-as-string><,><movig-average-as-double>

计算移动平均数，只需要根据股票代码对数据分组，然后按时间对这些值排序，最后运用移动平均算法。对时间序列排序的方法可以有以下两种方法：

* 1.在内存中排序
* 2.利用Mapreduce框架在时间序列数据的排序

由于之前的博客中已经详细介绍过二次排序的问题，本博客仅展示在内存中排序的部分代码：

Mapper接受一个格式为<name-as-string><,><date-as-string><,><value-as-double>的输入行，然后发出键值对，其中键是：<name-as-string>，值是：<date-as-string><,><value-as-double>，reducer会接受键值对，然后完成内存中排序。

**时间序列数据：**时间序列数据表示为一个TimeSeriesData对象，因为对象会在Hadoop中持久存储，并完成内存中的排序，因此这个类实现了WritableComparable<TimeSeriesData>.

```java
/**
 * @author lihe
 * @Title:
 * @Description: 时间序列存储格式
 * @date 2018/6/14下午3:13
 */
public class TimeSeriesData implements WritableComparable<TimeSeriesData> {
    private long timestamp;
    private double value;

    public TimeSeriesData(long timestamp, double value) {
        set(timestamp, value);
    }

    public TimeSeriesData() {
    }

    public void set(long timestamp, double value) {
        this.timestamp = timestamp;
        this.value = value;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public double getValue() {
        return value;
    }

    public TimeSeriesData clone() {
        return new TimeSeriesData(timestamp, value);
    }

    public String getDate() {
        return DateUtil.getDateAsString(timestamp);
    }

    @Override
    public int compareTo(TimeSeriesData o) {
        if (this.timestamp < o.timestamp)
            return -1;
        else if (this.timestamp > o.timestamp)
            return 1;
        else
            return 0;
    }

    @Override
    public void write(DataOutput dataOutput) throws IOException {
        dataOutput.writeLong(timestamp);
        dataOutput.writeDouble(value);
    }

    @Override
    public void readFields(DataInput dataInput) throws IOException {
        this.timestamp = dataInput.readLong();
        this.value = dataInput.readDouble();
    }

    @Override
    public String toString() {
        return "(" + timestamp + "," + value + ")";
    }
}
```

**Mapper:**

```java
/**
 * @author lihe
 * @Title:
 * @Description:
 * @date 2018/6/14下午3:28
 */
public class SortInMemory_MovingAverageMapper extends Mapper<LongWritable, Text, Text, TimeSeriesData> {
    private final Text reduceKey = new Text();
    private final TimeSeriesData reducerValue = new TimeSeriesData();

    @Override
    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
        String record = value.toString();
        if ((record == null) || (record.length() == 0)) {
            return;
        }
        String[] tokens = StringUtils.split(record, ',');
        if (tokens.length == 3) {
            Date date = DateUtil.getDate(tokens[1]);
            if (date == null) {
                return;
            }
            reduceKey.set(tokens[0]);
            reducerValue.set(date.getTime(), Double.parseDouble(tokens[2]));
            context.write(reduceKey, reducerValue);
        } else {
            //log as error, not enough tokens
        }
    }
}
```

**reducer:**

```java
public class SortInMemory_MovingAverageReducer extends Reducer<Text, TimeSeriesData, Text, Text> {
    int windowSize = 5;//默认窗口大小

    @Override
    protected void setup(Context context) throws IOException, InterruptedException {
        this.windowSize = context.getConfiguration().getInt("moving.average.window.size", 5);
        System.out.println("setup(): key=" + windowSize);
    }

    @Override
    protected void reduce(Text key, Iterable<TimeSeriesData> values, Context context) throws IOException, InterruptedException {
        List<TimeSeriesData> timeSeries = new ArrayList<TimeSeriesData>();
        for (TimeSeriesData tsData : values) {
            TimeSeriesData copy = tsData.clone();
            timeSeries.add(copy);
        }

        Collections.sort(timeSeries);
        System.out.println("reduce(): timeseries=" + timeSeries.toString());

        //计算前缀和
        double sum = 0;
        for (int i = 0; i < windowSize; i++) {
            sum += timeSeries.get(i).getValue();
        }

        Text outputValue = new Text();
        for (int i = windowSize; i < timeSeries.size(); i++) {
            sum += timeSeries.get(i).getValue();
            double movingAverage = sum / windowSize;
            long timestamp = timeSeries.get(i).getTimestamp();
            outputValue.set(DateUtil.getDateAsString(timestamp) + "," + movingAverage);
            context.write(key, outputValue);
            sum -= timeSeries.get(i - windowSize + 1).getValue();
        }
    }
}
```

**Driver:**

```java
public class SortInMemory_MovingAverageDriver {

    public static void main(String[] args) throws Exception {
       Configuration conf = new Configuration();
       String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
       if (otherArgs.length != 3) {
          System.err.println("Usage: SortInMemory_MovingAverageDriver <window_size> <input> <output>");
          System.exit(1);
       }
       System.out.println("args[0]: <window_size>="+otherArgs[0]);
       System.out.println("args[1]: <input>="+otherArgs[1]);
       System.out.println("args[2]: <output>="+otherArgs[2]);

       Job job = new Job(conf, "SortInMemory_MovingAverageDriver");

       // add jars to distributed cache
       HadoopUtil.addJarsToDistributedCache(job, "/lib/");

       // set mapper/reducer
       job.setMapperClass(SortInMemory_MovingAverageMapper.class);
       job.setReducerClass(SortInMemory_MovingAverageReducer.class);

       // define mapper's output key-value
       job.setMapOutputKeyClass(Text.class);
       job.setMapOutputValueClass(TimeSeriesData.class);

       // define reducer's output key-value
       job.setOutputKeyClass(Text.class);
       job.setOutputValueClass(Text.class);

       // set window size for moving average calculation
       int windowSize = Integer.parseInt(otherArgs[0]);
       job.getConfiguration().setInt("moving.average.window.size", windowSize);      

       // define I/O
       FileInputFormat.addInputPath(job, new Path(otherArgs[1]));
       FileOutputFormat.setOutputPath(job, new Path(otherArgs[2]));

       job.setInputFormatClass(TextInputFormat.class);
       job.setOutputFormatClass(TextOutputFormat.class);

       System.exit(job.waitForCompletion(true) ? 0 : 1);
    }

}
```
