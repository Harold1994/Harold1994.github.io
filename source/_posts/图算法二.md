---
title: 图算法（二）：图的高级问题
date: 2018-09-18 22:24:50
tags: [算法]
---

关于图的基本概念笔者在之前的[博客](https://harold1994.github.io/2018/07/03/图算法/)中已经介绍过，这篇博客介绍图算法比较高级的知识。包括最短路径问题，最小生成子图问题和拓扑排序等问题。

#### 一、最短路径问题

​	图的最短路径问题主要分为两类,单源最短路径问题和全对最短路径问题。单源最短路径问题指给点单个源点,求其到所有其它顶点之间的最短距离。而全对最短路径问题指所有顶点之间的最短路径问题。此外对于单对最短路径问题,从渐进意义上来看,目前还没有比最好的单元算法更快的算法来解决这一问题。

先解决一些基本概念的问题：

对于有向图$G=(V,E)$,权值函数$W: E→R$（即每条边的权值都为一个实数）

**路径：**$p\rightarrow v_1 \rightarrow v_2  ...  \rightarrow v_k$ 表示从$v_1$到$v_k$的一条路径，它的权值是：        					 $w(p)=\sum_{i}^{k-1}w(v_i,v_{i+1})$

**最短路径：**从u到v的一条路径，使w(p)最小

**最短路径权值：**$\delta(u,v)=min  \{ w(p)\}, p为从u到v的路径 $

**最优子结构性质**：最短路径满足最优子结构性质——最短路径的子路径是最短路径

##### 1.单源最短路径问题

​	单源最短路径描述：给定带权有向图$G=(V,E)$,其中每条边的权是非负实数。另外，还给定V中的一个顶点，称之为源(origin)。现在要计算从源到其他各顶点的最短路径的长度。这里的路径长度指的是到达路径各边权值之和。

* BFS算法求无权图的最短路径

  我们已经知道可以利用BFS算法求是否存在一个节点到另一个节点的路径，也可以打印连通图上的节点。通过增加一个数组edgeTo[],就可以解决最短路径问题。

  $edgeTo[w] = v$表示节点w在节点v之后被遍历到，具体的实现在之前的博客已经提及，这里仅将代码复制到此处：

  ```java
  public class BroadFirstSearch {
      private boolean[] marked;
      private int[] edgeTo;
      private int s;
  
      public BroadFirstSearch(Graph G, int s) {
          marked = new boolean[G.V()];
          this.edgeTo = new int[G.V()];
          this.s = s;
          BFS(G, s);
      }
  
      public void BFS(Graph G, int s) {
          Deque<Integer> deque = new ArrayDeque<>();
          marked[s] = true;
          deque.addFirst(s);
          while (!deque.isEmpty()) {
              s = deque.removeLast();
              for (int temp : G.adj(s)){
                  if (!marked[temp]) {
                      deque.push(temp);
                      marked[temp] = true;
                      edgeTo[temp] = s;//记录temp的上一个节点是s
                  }
              }
          }
      }
  
      public boolean hasPathTo(int v) {
          return marked[v];
      }
  
      public List<Integer> pathTo(int v) {//查找从源点到v的最短路径
          if (!hasPathTo(v)) {
              return null;
          }
          List<Integer> list = new ArrayList<>();
          v = edgeTo[v];
          while (v != s) {
              list.add(v);
              v = edgeTo[v];
          }
          return list;
      }
  }
  ```

  如下图所示，以2为源点开始广度优先遍历图，数组edgeTo[]可以用来回溯bfs的路径。

  ![](http://p5s7d12ls.bkt.clouddn.com/18-9-19/26047827.jpg)


* Dijkstra算法求有向加权图的最短路径问题

  - 算法特点：

    迪科斯彻算法使用了**广度优先搜索**解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。

  - 算法的思路

    Dijkstra算法采用的是一种**贪心**的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 
    然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 
    然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。  
    然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。

    我们用一个例子来具体说明迪杰斯特拉算法的流程。

    ![](http://p5s7d12ls.bkt.clouddn.com/18-9-19/53167220.jpg)

    定义源点为0，`dist[i]`为源点0到顶点i的最短路径。其过程描述如下：

    | 步骤  | dist[1] | dist[2] | dist[3] | dist[4] | 已找到的集合   |
    | ----- | ------- | ------- | ------- | ------- | -------------- |
    | 第1步 | 8       | 1       | 2       | +∞      | { 2 }          |
    | 第2步 | 8       | ×       | 2       | 4       | { 2, 3 }       |
    | 第3步 | 5       | ×       | ×       | 4       | { 2, 3, 4 }    |
    | 第4步 | 5       | ×       | ×       | ×       | { 2, 3, 4, 1 } |
    | 第5步 | ×       | ×       | ×       | ×       | { 2, 3, 4, 1 } |

    第1步：从源点0开始，找到与其邻接的点：1，2，3，更新`dist[]`数组，因0不与4邻接，故`dist[4]`为正无穷。在`dist[]`中找到最小值，其顶点为2，即此时已找到0到2的最短路。

    第2步：从2开始，继续更新`dist[]`数组：2与1不邻接，不更新；2与3邻接，因`0→2→3`比`dist[3]`大，故不更新`dist[3]` ；2与4邻接，因`0→2→4`比`dist[4]`小，故更新`dist[4]`为4。在`dist[]`中找到最小值，其顶点为3，即此时又找到0到3的最短路。

    第3步：从3开始，继续更新`dist[]`数组：3与1邻接，因`0→3→1`比`dist[1]`小，更新`dist[1]`为5；3与4邻接，因`0→3→4`比`dist[4]`大，故不更新。在`dist[]`中找到最小值，其顶点为4，即此时又找到0到4的最短路。

    第4步：从4开始，继续更新`dist[]`数组：4与1不邻接，不更新。在`dist[]`中找到最小值，其顶点为1，即此时又找到0到1的最短路。

    第5步：所有点都已找到，停止。

    对于上述步骤，你可能存在以下的疑问：

    ​	   若A作为源点，与其邻接的只有B，C，D三点，其`dist[]`最小时顶点为C，即就可以确定`A→C`为A到C的最短路。但是我们存在疑问的是：**是否还存在另一条路径使A到C的距离更小？** 用反证法证明。

    假设存在如上图的红色虚线路径，使`A→D→C`的距离更小，那么`A→D`作为`A→D→C`的子路径，其距离也比`A→C`小，这与前面所述“`dist[]`最小时顶点为C”矛盾，故假设不成立。因此这个疑问不存在。

    根据上面的证明，我们可以推断出，**Dijkstra每次循环都可以确定一个顶点的最短路径，故程序需要循环n-1次。**

![](http://p5s7d12ls.bkt.clouddn.com/18-9-19/65387848.jpg)
```java
public class Dijstra {
    public static  int [][] matrix;//邻接矩阵
    public static boolean [] visited;
    public static int [] dist;//记录源点到各顶点的最短路径
    public static int [] path;//记录最短路的路径
    public static int source; //源点
    public static int vertex_num;//节点数
    public static int edge_num; //边数

    public static void shortestPath(int source) {
        visited = new boolean [100];
        visited[source] = true;
        for (int i = 0; i<vertex_num; i++) {
            dist[i] = matrix[source][i];
            path[i] = source;
        }

        int min_cost;//权值最小
        int min_cost_index = 0;//权值最小的下标

        for (int i =1; i<vertex_num; i++){
            min_cost = Integer.MAX_VALUE;
            for (int j = 0; j<vertex_num; j++) {
                if (visited[j] == false && dist[j]<min_cost){
                    min_cost = dist[j];
                    min_cost_index = j;
                }
            }

            visited[min_cost_index] = true;
            for (int j = 0; j<vertex_num; j++) {
                if (visited[j] == false && matrix[min_cost_index][j] != Integer.MAX_VALUE
                        && matrix[min_cost_index][j] + min_cost < dist[j]) {
                    dist[j] = matrix[min_cost_index][j] + min_cost;
                    path[j] = min_cost_index;
                }
            }
        }
    }

    public static void main(String[] args) {
        vertex_num = 5;
        edge_num = 7;
        matrix = new int [vertex_num][vertex_num];
        dist = new int [vertex_num];
        path = new int [vertex_num];
        for (int i = 0; i<vertex_num; i++)
            for (int j = 0; j< vertex_num; j++)
                matrix[i][j] = (i != j) ? Integer.MAX_VALUE : 0;

        matrix[0][1] = 3;
        matrix[0][2] = 1;
        matrix[0][3] = 2;
        matrix[1][3] = 3;
        matrix[2][3] = 2;
        matrix[3][4] = 3;
        matrix[2][4] = 3;

        source = 0;
        Dijstra.shortestPath(source);
        for (int i = 0; i<vertex_num; i++) {
            if (i != source) {
                System.out.print(source + " to " + i + ": " + dist[i] + ", path is " + i);
                int t = path[i];
                while (t != source) {
                    System.out.print("--" + t);
                    t = path[t];
                }
                System.out.println("--" + source);
            }
        }
    }
}
```
- 时间复杂度
