---
title: 图算法（二）：图的高级问题
date: 2018-09-18 22:24:50
tags: [算法]
---

关于图的基本概念笔者在之前的[博客](https://harold1994.github.io/2018/07/03/图算法/)中已经介绍过，这篇博客介绍图算法比较高级的知识。包括最短路径问题，最小生成子图问题和拓扑排序等问题。

#### 一、最短路径问题

​	图的最短路径问题主要分为两类,单源最短路径问题和全对最短路径问题。单源最短路径问题指给点单个源点,求其到所有其它顶点之间的最短距离。而全对最短路径问题指所有顶点之间的最短路径问题。此外对于单对最短路径问题,从渐进意义上来看,目前还没有比最好的单元算法更快的算法来解决这一问题。

<!-- more--> 	

先解决一些基本概念的问题：

对于有向图$G=(V,E)$,权值函数$W: E→R$（即每条边的权值都为一个实数）

**路径：**$p\rightarrow v_1 \rightarrow v_2  ...  \rightarrow v_k$ 表示从$v_1$到$v_k$的一条路径，它的权值是：        					 $w(p)=\sum_{i}^{k-1}w(v_i,v_{i+1})$

**最短路径：**从u到v的一条路径，使w(p)最小

**最短路径权值：**$\delta(u,v)=min  \{ w(p)\}, p为从u到v的路径 $

**最优子结构性质**：最短路径满足最优子结构性质——最短路径的子路径是最短路径

**负权重的边：**如果从结点s到v的某条路径上存在权重为负值的环路，则定义$\delta(u,v)=-\infin$

**环路：**最短路径也不能包含权值为正值的环路， 因为只要将环路从路径上删除就可以得到一条源节点和终节电与原来路径相同的权重更小的路径。

> 最短路径不一定是唯一的，最短路径树也不一定是唯一的

##### 1.单源最短路径问题

​	单源最短路径描述：给定带权有向图$G=(V,E)$,其中每条边的权是非负实数。另外，还给定V中的一个顶点，称之为源(origin)。现在要计算从源到其他各顶点的最短路径的长度。这里的路径长度指的是到达路径各边权值之和。

* BFS算法求无权图的最短路径

  我们已经知道可以利用BFS算法求是否存在一个节点到另一个节点的路径，也可以打印连通图上的节点。通过增加一个数组edgeTo[],就可以解决**无权重**最短路径问题。

  $edgeTo[w] = v$表示节点w在节点v之后被遍历到，具体的实现在之前的博客已经提及，这里仅将代码复制到此处：

  ```java
  public class BroadFirstSearch {
      private boolean[] marked;
      private int[] edgeTo;
      private int s;
  
      public BroadFirstSearch(Graph G, int s) {
          marked = new boolean[G.V()];
          this.edgeTo = new int[G.V()];
          this.s = s;
          BFS(G, s);
      }
  
      public void BFS(Graph G, int s) {
          Deque<Integer> deque = new ArrayDeque<>();
          marked[s] = true;
          deque.addFirst(s);
          while (!deque.isEmpty()) {
              s = deque.removeLast();
              for (int temp : G.adj(s)){
                  if (!marked[temp]) {
                      deque.push(temp);
                      marked[temp] = true;
                      edgeTo[temp] = s;//记录temp的上一个节点是s
                  }
              }
          }
      }
  
      public boolean hasPathTo(int v) {
          return marked[v];
      }
  
      public List<Integer> pathTo(int v) {//查找从源点到v的最短路径
          if (!hasPathTo(v)) {
              return null;
          }
          List<Integer> list = new ArrayList<>();
          v = edgeTo[v];
          while (v != s) {
              list.add(v);
              v = edgeTo[v];
          }
          return list;
      }
  }
  ```

  如下图所示，以2为源点开始广度优先遍历图，数组edgeTo[]可以用来回溯bfs的路径。

  ![](http://p5s7d12ls.bkt.clouddn.com/18-9-19/26047827.jpg)


* Dijkstra算法求有向加权图的最短路径问题

  - 算法特点：

    迪科斯彻算法使用了**广度优先搜索**解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。

  - 算法的思路

    Dijkstra算法采用的是一种**贪心**的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 
    然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 
    然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。  
    然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。

    我们用一个例子来具体说明迪杰斯特拉算法的流程。

    ![](http://p5s7d12ls.bkt.clouddn.com/18-9-19/53167220.jpg)

    定义源点为0，`dist[i]`为源点0到顶点i的最短路径。其过程描述如下：

    | 步骤  | dist[1] | dist[2] | dist[3] | dist[4] | 已找到的集合   |
    | ----- | ------- | ------- | ------- | ------- | -------------- |
    | 第1步 | 8       | 1       | 2       | +∞      | { 2 }          |
    | 第2步 | 8       | ×       | 2       | 4       | { 2, 3 }       |
    | 第3步 | 5       | ×       | ×       | 4       | { 2, 3, 4 }    |
    | 第4步 | 5       | ×       | ×       | ×       | { 2, 3, 4, 1 } |
    | 第5步 | ×       | ×       | ×       | ×       | { 2, 3, 4, 1 } |

    第1步：从源点0开始，找到与其邻接的点：1，2，3，更新`dist[]`数组，因0不与4邻接，故`dist[4]`为正无穷。在`dist[]`中找到最小值，其顶点为2，即此时已找到0到2的最短路。

    第2步：从2开始，继续更新`dist[]`数组：2与1不邻接，不更新；2与3邻接，因`0→2→3`比`dist[3]`大，故不更新`dist[3]` ；2与4邻接，因`0→2→4`比`dist[4]`小，故更新`dist[4]`为4。在`dist[]`中找到最小值，其顶点为3，即此时又找到0到3的最短路。

    第3步：从3开始，继续更新`dist[]`数组：3与1邻接，因`0→3→1`比`dist[1]`小，更新`dist[1]`为5；3与4邻接，因`0→3→4`比`dist[4]`大，故不更新。在`dist[]`中找到最小值，其顶点为4，即此时又找到0到4的最短路。

    第4步：从4开始，继续更新`dist[]`数组：4与1不邻接，不更新。在`dist[]`中找到最小值，其顶点为1，即此时又找到0到1的最短路。

    第5步：所有点都已找到，停止。

    对于上述步骤，你可能存在以下的疑问：

    ​	   若A作为源点，与其邻接的只有B，C，D三点，其`dist[]`最小时顶点为C，即就可以确定`A→C`为A到C的最短路。但是我们存在疑问的是：**是否还存在另一条路径使A到C的距离更小？** 用反证法证明。

    假设存在如上图的红色虚线路径，使`A→D→C`的距离更小，那么`A→D`作为`A→D→C`的子路径，其距离也比`A→C`小，这与前面所述“`dist[]`最小时顶点为C”矛盾，故假设不成立。因此这个疑问不存在。

    根据上面的证明，我们可以推断出，**Dijkstra每次循环都可以确定一个顶点的最短路径，故程序需要循环n-1次。**

    ![](http://p5s7d12ls.bkt.clouddn.com/18-9-19/65387848.jpg)

    ```java
    public class Dijkstra {
        public static  int [][] matrix;//邻接矩阵
        public static boolean [] visited;
        public static int [] dist;//记录源点到各顶点的最短路径
        public static int [] path;//记录最短路的路径
        public static int source; //源点
        public static int vertex_num;//节点数
        public static int edge_num; //边数
    
        public static void shortestPath(int source) {
            visited = new boolean [100];
            visited[source] = true;
            for (int i = 0; i<vertex_num; i++) {
                dist[i] = matrix[source][i];
                path[i] = source;
            }
    
            int min_cost;//权值最小
            int min_cost_index = 0;//权值最小的下标
    
            for (int i =1; i<vertex_num; i++){
                min_cost = Integer.MAX_VALUE;
                for (int j = 0; j<vertex_num; j++) {
                    if (visited[j] == false && dist[j]<min_cost){
                        min_cost = dist[j];
                        min_cost_index = j;
                    }
                }
    
                visited[min_cost_index] = true;
                for (int j = 0; j<vertex_num; j++) {
                    //松弛操作, Dijkstra算法对每条边仅松弛一次
                    if (visited[j] == false && matrix[min_cost_index][j] != Integer.MAX_VALUE
                            && matrix[min_cost_index][j] + min_cost < dist[j]) {
                        dist[j] = matrix[min_cost_index][j] + min_cost;
                        path[j] = min_cost_index;
                    }
                }
            }
        }
    
        public static void main(String[] args) {
            vertex_num = 5;
            edge_num = 7;
            matrix = new int [vertex_num][vertex_num];
            dist = new int [vertex_num];
            path = new int [vertex_num];
            for (int i = 0; i<vertex_num; i++)
                for (int j = 0; j< vertex_num; j++)
                    matrix[i][j] = (i != j) ? Integer.MAX_VALUE : 0;
    
            matrix[0][1] = 3;
            matrix[0][2] = 1;
            matrix[0][3] = 2;
            matrix[1][3] = 3;
            matrix[2][3] = 2;
            matrix[3][4] = 3;
            matrix[2][4] = 3;
    
            source = 0;
            Dijstra.shortestPath(source);
            for (int i = 0; i<vertex_num; i++) {
                if (i != source) {
                    System.out.print(source + " to " + i + ": " + dist[i] + ", path is " + i);
                    int t = path[i];
                    while (t != source) {
                        System.out.print("--" + t);
                        t = path[t];
                    }
                    System.out.println("--" + source);
                }
            }
        }
    }
    ```

* Bellman-Ford算法

  Bellman-Ford算法解决的是一般情况下的单源最短路径问题，边的权值可以为负。Bellman-Ford算法返回一个布尔值，表明是否存在从源点到终结点权值为负的环路，若为负，不存在解决方案，否则给出最短路径和权重。

  Bellman-Ford通过对边进行松弛操作来渐进的降低从源节点s到每个节点v的最短路径的估计值v.d,直到与实际的最短路径权重相同为止。

  **那么在算法的处理过程中需要进行多少次松弛操作呢？**

  考虑从任意从源结点s可以到达的结点v，设$p=[v_0,v_1,v_2,v_3,…,v_k]$为源节点s到结点v之间的一条最短路径，这里$v_0=s,v_k=v$.因为最短路径是简单路径，因此p最多包涵$|V|-1$条边（|V|是图中所有结点的总条数），故$k<=|V|-1$.

  在这里引入一个定理： 

  > 设$G=(V,E)$是一个带权重的有向图，权重函数$w：E->R$。设s为源结点，$s—>u->v$是图中的一条最短路径，假设图已经进行了一系列的松弛操作，包括对边$（u,v）$的松弛操作。如果对边$(u,v)$进行松弛操作之前的任意时刻有$u.d=dist(s,u)$（即$u.d$为源结点到u结点最短路径，而不再是最短路径估计），那么在该松弛操作之后的所有时刻$v.d=dist(s,v)$. 

  > **证明：** 
  > 如果在对边(u,v)进行松弛操作前的某时刻有$u.d=dist(s,u)$，则该等式在松弛操作之后也成立。特别的，在对边(u,v)进行松弛后，有$v.d<=u.d+w(u,v)=dist(s,u)+w(u,v)$,又由于最短路径的子路径也是最短路径，即$w(u,v)$是u到v的最短路径距离，则$v.d<=u.d+w(u,v)=dist(s,u)+w(u,v)=dist(s,v)$,又v.d是最短路径估计，有v.d>=dist(s,v),因此$v.d=dist(s,v)$.

  由上面的引理可知，已知$u.d=dist(s,u)$，我们只要一次松弛操作就能够使得$v.d=dist(s,v)$.最短路径最多只有$|V|$个结点，所以最多只有$|V|-1$条边，因此我们最多只要|V|-1个松弛操作就能得到最短路径。 
  （可以这样理解：设图中一定存在最短路径，假设是$[v_0,v_1,v_2,v_3,…,v_k]$，那么初始只知道$v_0$,第一次松弛操作，肯定可以找到v1,因为v1直接与v0相连接，那么下一次松弛操作会找到v2，。。。）

  **算法步骤**

  1. 初始化：将除源点外的所有顶点的最短距离估计值$dist[v] ← +∞, dist[s] ←0;$
  2. 迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行$|v|-1$次） 
  3. 检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在 dist[v]中。

  ​        之所以需要第三部分的原因，是因为，如果存在从源点可达的权为负的回路。则因为无法收敛而导致不能求出最短路径。 

  ```java
  public class BelfmanFord {
      final static private int MAXN = 0x3f3f3f3f;
      private int dis[];
      private int pre[];
  
      public void initializeSource(Weightedgraph.Graph g, int s) {
          for (int v = 0; v < g.getVertices(); v++) {
              dis[v] = MAXN;
          }
          dis[s] = 0;
      }
  
      public void relax(int source, int target, int w) {
          if (dis[target] > dis[source] + w) {
              dis[target] = dis[source] + w;
              pre[target] = source;
          }
      }
  
      void bellmanFord(Weightedgraph.Graph graph, int s) {
          int V = graph.getVertices();
          dis = new int[V];
          pre = new int[V];
          //第一步
          initializeSource(graph, s);
          //第二步
          for (int i = 1; i < V; i++) {
              for (int j = 0; j < V; j++) {
                  for (Weightedgraph.Edge edge : graph.adj[j]) {
                      relax(edge.source, edge.target, edge.weight);
                  }
              }
          }
          //第三步
          for (int j = 0; j < V; j++) {
              for (Weightedgraph.Edge edge : graph.adj[j]) {
                  if (dis[edge.target] > dis[edge.source] + edge.weight) {
                      System.out.println("Graph contains negative weight cycle");
                      return;
                  }
              }
          }
          printArr(dis, V);
      }
  
      void printArr(int dist[], int V) {
          System.out.println("Vertex Distance from Source");
          for (int i = 0; i < V; ++i)
              System.out.println(i + "\t\t" + dist[i]);
      }
  
      public static void main(String[] args) {
          Weightedgraph.Graph graph = new Weightedgraph.Graph(5);
          graph.addEdge(0, 1, -1);
          graph.addEdge(0, 2, 4);
          graph.addEdge(1, 2, 3);
          graph.addEdge(1, 3, 2);
          graph.addEdge(1, 4, 2);
          graph.addEdge(3, 2, 5);
          graph.addEdge(3, 1, 1);
          graph.addEdge(4, 3, -3);
          graph.printGraph();
          BelfmanFord ford = new BelfmanFord();
          ford.bellmanFord(graph, 0);
      }
  }
  ```

  ​	Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改的仅仅是源点到T集合中各顶点的最短路径长度。

  ​	Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。

* SPFA算法

  Bellman-Ford算法的时间复杂度较高，O(V^3)或者O(EV)，原因在于算法要递推V次，且每次递推要扫描所有的边，并且在这个过程中很多遍是多余的.SPFA就是利用队列减少不必要的冗余判断。 

  SPFA（Shortest Path Faster Algorithm）（队列优化）算法是求单源最短路径的一种算法，它还有一个重要的功能是判负环（在差分约束系统中会得以体现），在Bellman-ford算法的基础上加上一个队列优化，减少了冗余的松弛操作，是一种高效的最短路算法。

  **算法步骤：**

  用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止

  > 关于上面松弛成功，就代表着dis[v]变小了，所以所有通过顶点v的路径都可以变小，它具备了更新其他顶点的“资格”。而没有变小的顶点，去更新了也没有用，是冗余的。这样就去掉了冗余项了。	

  我们知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：

  1. 开始算法前，调用拓扑排序进行判断（一般不采用，浪费时间）
  2. 如果某个点进入队列的次数超过V次则存在负环（N为图的顶点数）

  ```java
  public class SPFA {
      final static private int MAXN = 0x3f3f3f3f;
      private int dis[];
      static int V;
      private boolean [] used;
      private int [] times;//进入队列的次数
      ArrayList<Integer> list;
  
      public void initializeSource(Weightedgraph.Graph g, int s) {
          for (int v = 0; v < g.getVertices(); v++) {
              dis[v] = MAXN;
          }
          dis[s] = 0;
          used[s] = true;
          list.add(s);
          times[s] += 1;
      }
  
      public boolean relax(int source, int target, int w) {
          if (dis[target] > dis[source] + w) {
              dis[target] = dis[source] + w;
              if (!used[target]) {
                  list.add(target);
                  times[target] += 1;
                  if (times[target]>V)
                      return false;
                  used[target] = true;
              }
          }
          return true;
      }
  
      public void spfa(Weightedgraph.Graph graph, int src) {
          V = graph.getVertices();
          dis = new int [V];
          used = new boolean [V];
          times = new int [V];
          list = new ArrayList<Integer>();
          initializeSource(graph, src);
          while (!list.isEmpty()) {
              int a = list.get(0);
              list.remove(0);
              for (Weightedgraph.Edge edge : graph.adj[a]) {
                  boolean res = relax(edge.source, edge.target, edge.weight);
                  if (!res) {
                      System.out.println("存在权值为负的环路");
                      return;
                  }
                  used[a] = false;
              }
          }
          printArr(dis, V);
      }
      void printArr(int dist[], int V) {
          System.out.println("Vertex Distance from Source");
          for (int i = 0; i < V; ++i)
              System.out.println(i + "\t\t" + dist[i]);
      }
  }
  ```

* 弗洛伊德（Floyd）算法