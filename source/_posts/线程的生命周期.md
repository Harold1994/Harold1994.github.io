---
title: 线程的生命周期
date: 2018-06-04 00:12:09
tags: [Java, 多线程, 并发]
---

  当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。
<!-- more--> 

1. 新建和就绪状态

  当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。

  当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。

2. 运行和阻塞状态

  如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态。

当发生如下情况下，线程将会进入阻塞状态：

> 1. 线程调用sleep方法主动放弃所占用的处理器资源。
>
> 2. 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。
>
> 3. 线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。关于同步监视器的知识将在后面有更深入的介绍。
>
> 4. 线程在等待某个通知(notify)。
>
> 5. 程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。

  当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。

针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：

> 调用sleep方法的线程经过了指定时间。
>
> 线程调用的阻塞式IO方法已经返回。
>
> 线程成功地获得了试图取得同步监视器。
>
> 线程正在等待某个通知时，其他线程发出了一个通知。
>
> 处于挂起状态的线程被调用了resume恢复方法。

![屏幕快照 2018-10-12 上午12.09.37.png](https://i.loli.net/2018/10/12/5bbff40525562.png)

3. 线程死亡

线程会以以下三种方式之一结束，结束后就处于死亡状态：

* run()方法执行完成，线程正常结束。

* 线程抛出一个未捕获的Exception或Error。

* 直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。

  

