---
title: 图算法
date: 2018-07-03 22:43:24
tags: [算法]
---

其他基础的数据结构之前都已经线下整理过了,但是图这块出于畏难心理一直没有看,最近面试被问到了,答不上来好尴尬,所以说欠的债总是要还的.

图的搜索指系统化地跟随图中的边来访问图中每个结点。

#### 一.图的表示

> 无向图:图是由一组顶点和一组能够将两个顶点相连的边组成的

一般用0至V-1表示一张含有V个顶点的图中的各个顶点.

<!-- more--> 

**特殊的图**:

* 自环:一条连接一个顶点和其自身的边
* 平行边:连接同一对顶点的两条边称为平行边

**1.术语表**

相邻:两个顶点通过一条边相连时,称两顶点相连,并称这条边**依附于**这两个顶点

顶点的度数:依附于它的边的总个数

子图:由一幅图的所有边的一个子集和他们所依附的所有节点组成的子图

> 在图中,**路径**是由边顺序连接的一系列顶点.**简单路径**是一条没有重复顶点的路径.**环**是一条至少含有一条边且起点和终点相同的路径.**简单环**是一条(除起点和终点必须相同外)不含有重复顶点和边的环.路径和环的长度为其所有包含的边数.

连通:当两个顶点之间存在一条连接双方的路径时,称两个顶点是连接的

连通图:如果从任意一个顶点都存在一条路径到达另一个任意顶点,称这幅图是连通图.一幅非连通图由若干连通的部分组成,他们都是其极大连通子图.

一般来说要处理一张图就要一个个处理她得连通分量.

> 树是一幅无环连通图，互不相连的树的集合称为森林。连通图的生成树是它的一幅子图，它含有图中所有节点且是一棵树。图的生成森林是它的所有连通子图的生成树的集合。

当且仅当一幅含有V个节点的图G满足下列5个条件之一时，他就是一棵树：

* G有V-1条边且不含环
* G有V-1条边且是连通的
* G是连通的，但删除任意一条边都使他不再连通
* G是无环图，但添加任意一条边都会使它产生一条环
* G中任意一对顶点间仅存在一条简单路径

图的**密度**：已经连接的顶点对占有所有可能被连接顶点对的比例。在**稀疏图中**，被连接的顶点对很少；而在**稠密图**中，只有少部分顶点对之间没有边连接

**二分图**：能够将所有结点分为两部分的图，其中每条边所连接的两个结点都属于不同的部分。

**2.图的表示**

图G=(V,E),可以用两种方式表示，邻接表和邻接矩阵。他们都可以有向图和无向图，邻接链表因为在表示稀疏图（|E|远远小于$|V|^2$的图）时非常紧凑而成为通常的选择。不过在稠密图的情况下，倾向于使用邻接矩阵。

![屏幕快照 2018-10-12 上午12.05.59.png](https://i.loli.net/2018/10/12/5bbff3187ff28.png)

对于图G=(V,E),其邻接链表表示由一个包含|V|条链表的数组Adj组成,每个节点有一条链表。Adj[u]包含图G中所有与u邻接的结点。

如果G是一个有向图，对于边（u,v）来说，结点v将出现在链表Adj[u]中，因此所有邻接链表的长度之和为|E|.如果G是一个无向图，对于边（u,v）来说，结点v将出现在链表Adj[u]中，结点u将出现在链表Adj[v]中，因此所有邻接链表的长度之和为2|E|.

对邻接表稍加修改，就可以用来表示权重图，权重图是没调表都带一个相关权重的图。

邻接链表的缺陷是无法快速判断一条边（u,v）是否是图中的一条边，唯一办法是在邻接链表Adj[u]中搜索结点v.邻接矩阵克服了这个困难，不过付出了更大的存储空间消耗。

无向图的邻接矩阵是一个对称矩阵，它本身就是自己的转置，在一些应用中，只需要存放对角线以上这部分邻接矩阵。在图规模比较小时，更倾向于使用邻接矩阵表示法，而且邻接矩阵每个记录只需要1位的空间。

无向图的两种表示方法：

```java
public class Graph {
    private int V;//结点数目
    private int E;//边数
    private List<Integer>[] adj ;//邻接表
    private int [][] a;//邻接矩阵

    public Graph(int V) {
        this.V = V;
        E = 0;
        a = new int[V][V];
        adj = new ArrayList[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new ArrayList<Integer>();
        }
    }

    public int V(){return V;}//返回节点数
    public int E(){return E;};//返回边数

    public void addEdge(int v,int w) {
        a[v][w] = 1;
        a[w][v] = 1;
        adj[v].add(w);
        adj[w].add(v);
        E++;
    }

    //返回结点v的所有邻接结点
    public Iterable<Integer> adj(int v) {
//        return adj[v];本句为邻接表的方法，下面是邻接矩阵的方法
        List<Integer> t= new ArrayList<Integer>();
        for (int i = 0; i<V; i++) {
            if (a[v][i]>0)
              t.add(i);
        }
        return t;
    }

    public String toString() {
        String s = V + "个顶点，" + E + "条边";
        for (int i = 0; i<V; i ++) {
            s += i + ": ";
            for (Integer node : adj[i])
                s += node + " ";
        }
        s += "\n";
        return s;
    }
}
```

#### 二. 图的遍历

给定图G=(V,E)和一个可以识别的源节点s，广度优先搜索对图G中的边进行系统性的探索来发现可以从源节点s到达的所有结点。

在广度优先搜索树里从结点s到v的简单路径所对应的就是图G中从节点s到v的“最短路径”,既包含最少边数的路径。

它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。

**2.1 无向图的广度优先搜索**

下面以"无向图"为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。

![TU.jpg](https://i.loli.net/2018/10/12/5bbff363e8088.jpg)

**第1步**：访问A。 
**第2步**：依次访问C,D,F。 
​    在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在"D和F"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 
**第3步**：依次访问B,G。 
​    在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 
**第4步**：访问E。 
​    在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。

因此访问顺序是：**A -> C -> D -> F -> B -> G -> E**

**2.2 有向图的广度优先搜索**

下面以"有向图"为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。

![屏幕快照 2018-10-12 上午12.08.21.png](https://i.loli.net/2018/10/12/5bbff3b2897fb.png)

**第1步**：访问A。 
**第2步**：访问B。 
**第3步**：依次访问C,E,F。 
​    在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 
**第4步**：依次访问D,G。 
​    在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。

因此访问顺序是：**A -> B -> C -> E -> F -> D -> G**

```java
public class BroadFirstSearch {
    private boolean[] marked;
    private int[] edgeTo;
    private int s;

    public BroadFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        this.edgeTo = new int[G.V()];
        this.s = s;
        BFS(G, s);
    }

    public void BFS(Graph G, int s) {
        Deque<Integer> deque = new ArrayDeque<>();
        marked[s] = true;
        deque.addFirst(s);
        while (!deque.isEmpty()) {
            s = deque.removeLast();
            for (int temp : G.adj(s)){
                if (!marked[temp]) {
                    deque.push(temp);
                    marked[temp] = true;
                    edgeTo[temp] = s;
                }
            }
        }
    }

    public boolean hasPathTo(int v) {
        return marked[v];
    }

    public List<Integer> pathTo(int v) {
        if (!hasPathTo(v)) {
            return null;
        }
        List<Integer> list = new ArrayList<>();
        v = edgeTo[v];
        while (v != s) {
            list.add(v);
            v = edgeTo[v];
        }
        return list;
    }
}
```

**2.2 无向图的深度优先搜索**

下面以”无向图”为例，来对深度优先搜索进行演示。

![](http://p5s7d12ls.bkt.clouddn.com/18-7-4/91548031.jpg)

对上面的图G1进行深度优先遍历，从顶点A开始。

![](http://p5s7d12ls.bkt.clouddn.com/18-7-4/22023778.jpg)

**第1步**：访问A。 
**第2步**：访问(A的邻接点)C。 
在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 
**第3步**：访问(C的邻接点)B。 
在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 
**第4步**：访问(C的邻接点)D。 
在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 
**第5步**：访问(A的邻接点)F。 
前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 
**第6步**：访问(F的邻接点)G。 
**第7步**：访问(G的邻接点)E。

因此访问顺序是：A -> C -> B -> D -> F -> G -> E

```java
public class DepthFirstSearch {
    private boolean[] isMarked;
    private int begin;
    private int count;
    private Integer [] edgeTo;

    public DepthFirstSearch(Graph g, int begin) {
        isMarked = new boolean[g.V()];
        edgeTo = new Integer[g.V()];
        count = 0;
        this.begin = begin;
        dfs(g,begin);
    }

    //递归算法
    private void dfs(Graph g, int begin) {
        isMarked[begin] = true;
        for (int i : g.adj(begin)) {
            if (!isMarked[i]) {
                edgeTo[i] = begin;
                count++;
                dfs(g,i);
            }
        }
    }
    
    //非递归
    private void dfs2 (Graph g, int begin) {
        isMarked[begin] = true;
        Stack<Integer> stack = new Stack<>();
        stack.push(begin);
        while (!stack.isEmpty()) {
            boolean is_push = false;
            int v = stack.peek();
            for (int i : g.adj(v)) {
                if (!isMarked[i]) {
                    isMarked[i] = true;
                    stack.push(i);
                    edgeTo[i] = v;
                    is_push = true;
                    break;
                }
            }
            if (!is_push){
                stack.pop();
            }
        }
    }

    public boolean hasPath(int s) {
        return isMarked[s];
    }

    public int count() {
        return count;
    }

    public String pathTo(int v) {
        if (!hasPath(v))
            return "";
        Stack<Integer> stack = new Stack<>();
        stack.push(v);
        for (int i = v; i!=begin; i=edgeTo[i])
            stack.push(edgeTo[i]);
    return stack.toString();
    }
}
```