---
title: 数据算法——Hadoop的二次排序解决方案
date: 2018-06-04 15:58:43
tags: [分布式算法, 大数据, 机器学习, Hadoop]
---
#### 一. 二次排序(secondary sort)问题的引出 ####

**1. 二次排序**:

在reduce阶段对与某个键关联的值排序,又称为键值转换;

**2. MR中的排序:**

MapReduce框架会自动对mapper生成的键排序,说明在启动reducer之前,mapper生成的所有中间键值对必然是**按键有序**的.但是传入reducer的值并不是有序的,他们可能有任意的顺序,要想对reducer中的值进行排序,可以用二次排序设计模式实现.

**3. 通过MR的范式分析二次排序**:

map(key1,value1)--->list(key2,value2)
reduce(list(key2,value2))--->list(key3,value3)
list(key2,value2)作为reducer的输入,list(value2)=(V1,V2,V3...,Vn),其本身是无序的.
二次排序的目标就是让reducer收到的值有某种顺序.
<!-- more--> 
**4. 问题引入**

假如我们有一组温度数据,按照'年\月\日\温度'的格式存储, 我们希望输入每一个年月的温度,并且按照升序排序:

```
2012-01: 5, 10, 25, 30...
2012-02: 18, 25, 30...
2012-08: 13, 20, 35...
```

#### 二. 二次排序问题的解决方案

* 1.让reducer读取和缓存给定键的所有值,然后对这些值完成in-reducer排序,数据量大时可能导致内存溢出
* 2.使用MapReduce框架对reducer值排序(这样就不需要再对传入reducer的值进行reducer中的排序),这种方法"会为自然键增加部分或整个值来创建一个组合键以实现排序目标",不会造成内存溢出
  * 使用键值转换设计模式:构造一组中间键(K, V1),其中V1是次键,K称为自然键,要在reducer键中注入一个值,只需要创建一个组合键.在本例中,V1就是温度数据
  * 让MapReduce执行框架完成排序(利用集群的力量)
  * 保留多个键值对状态来完成处理,可以适当利用mapper的partitioner来实现.

**1.中间键的排序顺序**

![](http://p5s7d12ls.bkt.clouddn.com/18-6-4/84337503.jpg)

要实现二次排序,我们需要控制中间键的排序顺序,以及reducer处理键的顺序,首先要在组合键中注入一个值(temperature),然后控制中间键的排序顺序.

因为希望reducer按照温度排序,所以增加temperature.要用compareTo方法指出如何对DateTemperaturePair对象排序.

>  在Hadoop中,要持久存储定制数据类型,则必须实现Writable接口,要比较定制数据类型,必须实现WritableComparable接口

```java
public class DateTemperaturePair implements Writable, WritableComparable<DateTemperaturePair> {
    private final Text yearMonth = new Text();
    private final Text day = new Text();
    private final IntWritable temperature = new IntWritable();


    public DateTemperaturePair() {
    }

    public DateTemperaturePair(String yearMonth, String day, int temperature) {
        this.yearMonth.set(yearMonth);
        this.day.set(day);
        this.temperature.set(temperature);
    }

    public static DateTemperaturePair read(DataInput in) throws IOException {
        DateTemperaturePair pair = new DateTemperaturePair();
        pair.readFields(in);
        return pair;
    }

    @Override
    public void write(DataOutput dataOutput) throws IOException {
        yearMonth.write(dataOutput);
        day.write(dataOutput);
        temperature.write(dataOutput);
    }

    @Override
    public void readFields(DataInput in) throws IOException {
        yearMonth.readFields(in);
        day.readFields(in);
        temperature.readFields(in);
    }


    public void setYearMonth(String yearMonthAsString) {
        yearMonth.set(yearMonthAsString);
    }

    public void setTemperature(int Temp) {
        temperature.set(Temp);
    }

    public void setDay(String dayAsString) {
        day.set(dayAsString);
    }

    public Text getYearMonth() {
        return yearMonth;
    }

    public Text getDay() {
        return day;
    }

    public IntWritable getTemperature() {
        return temperature;
    }

    public int compareTo(DateTemperaturePair pair) {
        int compareValue = this.yearMonth.compareTo(pair.getYearMonth());
        if (compareValue == 0) {
            compareValue = temperature.compareTo(pair.getTemperature());
        }
        return -1 * compareValue;//降序排序
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DateTemperaturePair that = (DateTemperaturePair) o;
        if (temperature != null ? !temperature.equals(that.temperature) : that.temperature != null) {
            return false;
        }
        if (yearMonth != null ? !yearMonth.equals(that.yearMonth) : that.yearMonth != yearMonth) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        int result = yearMonth != null ? yearMonth.hashCode() : 0;
        result = 31 * result + (temperature != null ? temperature.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return "DateTemperaturePair{" +
                "yearMonth=" + yearMonth +
                ", day=" + day +
                ", temperature=" + temperature +
                '}';
    }
}
```

2.定制分区器

partitioner会根据mapper输出的键来决定将其输出发送到那个表reducer，为此我们需要：

​	1.一个定制partitioner控制哪个reducer处理哪些键

​	2.一个定制比较器对reducer值排序

定制分区器会确保具有相同键（自然键，并非包含temperature的组合键）的所有数据都发送给同一个reducer，定制比较器会完成排序，保证数据一到达reducer就会按自然键对数据分组。

```java
public class DateTemperaturePartitioner extends Partitioner<DateTemperaturePair, Text> {
    @Override
    public int getPartition(DateTemperaturePair dateTemperaturePair, Text text, int i) {
        return Math.abs(dateTemperaturePair.getYearMonth().hashCode() % i);
    }
}
```

3.分组比较器

```java
/**
 * @author lihe
 * @Title:
 * @Description: 分组比较器，控制哪些键分组到一个reduce函数调用
 * @date 2018/6/7上午11:33
 */
public class DateTempratureGroupingComparator  extends WritableComparator {
    public DateTempratureGroupingComparator() {
        super(DateTemperaturePair.class, true);
    }

    @Override
    public int compare(WritableComparable a, WritableComparable b) {
        DateTemperaturePair pair = (DateTemperaturePair) a;
        DateTemperaturePair pair2 = (DateTemperaturePair) b;
        return pair.getYearMonth().compareTo(pair2.getYearMonth());
    }
}
```

#### 三、MAPREDUCER/Hadoop的二次排序解决方案

**输入：**

<year><,><month><,><day><,><temperature>

示例：

2012，01，01，35

2012，12，23，-4

**期望输出：**

<year><-><month>:<temperature><,><temperature><,>...

其中<temperature1> <= <temperature2> <= ...

示例：
2012-01: 5，10，13，30，...

2012-03: 12，23，31， ...

**map()函数**

```java
/**
 * @author harold
 * @Title:
 * @Description: map()函数完成解析和词法分析，然后将temperature注入到reducer键中
 * @date 2018/6/7下午1:34
 */
public class SecondarySortMapper extends Mapper<LongWritable, Text, DateTemperaturePair, Text> {

    private final Text theTemperature = new Text();
    private final DateTemperaturePair pair = new DateTemperaturePair();

    @Override
    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
        String line = value.toString();
        String [] tokens = line.split(",");
        String yearMonth = tokens[0] + tokens[1];
        String day = tokens[2];
        int temperature = Integer.parseInt(tokens[3]);

        pair.setDay(day);
        pair.setTemperature(temperature);
        pair.setYearMonth(yearMonth);
        theTemperature.set(tokens[3]);

        context.write(pair, theTemperature);
    }
}
```

**reduce()函数**

```java
/**
 * @author lihe
 * @Title:
 * @Description: 连接值
 * @date 2018/6/7下午1:44
 */
public class SecondarySortReducer  extends Reducer<DateTemperaturePair, Text, Text, Text> {
    @Override
    protected void reduce(DateTemperaturePair key, Iterable<Text> values, Context context) throws IOException, InterruptedException {
        StringBuilder builder = new StringBuilder();
        for (Text value : values) {
            builder.append(value.toString());
            builder.append(",");
        }
        context.write(key.getYearMonth(), new Text(builder.toString()));
    }
}
```

**驱动函数**

第一个比较器（DateTemperaturePair.compareTo()）方法会控制键的排序顺序，第二个比较器（DateTemperatureGroupingComparator.compare()）方法会控制哪些键分到一个reducer（）。通过这两个比较器，建立作业时就好像定义了值得顺序一样。

```java
/**
 * @author lihe
 * @Title:
 * @Description: 驱动器
 * @date 2018/6/7下午1:54
 */
public class SecondarySortDriver extends Configured implements Tool {

    private static Logger theLogger = Logger.getLogger(SecondarySortDriver.class);

    @Override
    public int run(String[] args) throws Exception {
        Configuration conf = getConf();
        Job job = new Job(conf);
        job.setJarByClass(SecondarySortDriver.class);
        job.setJobName("SecondarySort");

        FileInputFormat.setInputPaths(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        job.setMapOutputKeyClass(DateTemperaturePair.class);
        job.setMapOutputValueClass(Text.class);

        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(Text.class);

        job.setMapperClass(SecondarySortMapper.class);
        job.setReducerClass(SecondarySortReducer.class);
        job.setPartitionerClass(DateTemperaturePartitioner.class);
        job.setGroupingComparatorClass(DateTempratureGroupingComparator.class);

        boolean status = job.waitForCompletion(true);
        theLogger.info("run: status" + status);
        return status ? 0 : 1;
    }

    public static void main(String[] args) throws Exception {
        if (args.length != 2) {
            theLogger.warn("SecondarySortDriver <input-dir> <output-dir>");
            throw new IllegalArgumentException("SecondarySortDriver <input-dir> <output-dir>");
        }

        int returnStatus = ToolRunner.run(new SecondarySortDriver(), args);
        theLogger.info("returnStatus=" + returnStatus);
        System.exit(returnStatus);
    }
}
```
