---
title: 数据算法——二次排序：详细示例
date: 2018-06-08 10:18:13
tags: [分布式算法, 大数据, 机器学习, Hadoop]
---

#### 一、二次排序技术

Mapreduce框架会按键对reducer的输入排序，不过reducer值的顺序是任意的。假设对应$key = K$有以下值：

$(K,V_1),(K,V_2),…(K,V_n)​$

另外假设每个$V_i$是包含m个属性的一个元组，即$V_i = (a_{i1},a_{i2},…,a_{im})$
在这里，我们希望按$a_{i1}$对reducer值排序，我们将用r表示$(a_{i2},a_{i3},…,a_{im})​$(其余属性)，因此可以将reducer值表示为：

$(K,(a_1, r_1)),(K,(a_2, r_2)),...(K,(a_m, r_m))$

要按$a_i$对reducer值排序，需要创建一个组合键：$（K，a_i）$，新的mapper将发出对应键值对：
  <!-- more-->
|    键     |     值      |
| :-------: | :---------: |
| $(K,a_1)$ | $(a_1,r_1)$ |
| $(K,a_2)$ | $(a_2,r_2)$ |
|    ...    |     ...     |
| $(K,a_n)$ | $(a_n,r_n)$ |

组合键：$(K,a_i)$，自然键：K，如果希望对键分区，要按自然键来完成分区 。

必须告诉MR框架如何使用组合键对键排序，要定义一个排序插件类CompositeKeyComparator，用这个插件类对组合键排序；另外要定义“自然键分区器”，这个类要实现Partitioner接口；最后要定义自然键分组比较器，用来比较两个自然键。

#### 二、二次排序完整示例：以股票排序为例

**输入格式：**

Stock-Symble，Date，Closed_Price

例如：

LIMN，2013-08-28，98.2

GOOG，2014-07-23，34

LIMN，2013-04-20，324.2

GOOG，2012-03-21，777.0

LIMN，2013-03-05，777.0

**输出格式：**希望输出按收盘价日期排序

LIMN: （2013-03-05，777.0）（2013-04-20，324.2）（2013-08-28，98.2）

GOOG：（2012-03-21，777.0）（2014-07-23，34）

**组合键：**（Stock-Symble，Date）

**组合键定义：**

```java
/**
 * @author lihe
 * @Title: CompositeKey
 * @Description: 组合键定义,在stockSymbol字段上完成一次分组，将相同类型的所有数据分为一组，然后shufful阶段的二次排序，
 * 使用timeStamp分量对数据点排序，使得他们到达reducer时已经分区且有序
 * @date 2018/6/8上午11:34
 */
public class CompositeKey implements WritableComparable<CompositeKey> {
    private String stockSymbol;
    private long timestamp;

    public CompositeKey() {
    }

    public CompositeKey(String stockSymbol, long timestamp) {
        this.stockSymbol = stockSymbol;
        this.timestamp = timestamp;
    }

    public String getStockSymbol() {
        return stockSymbol;
    }

    public void setStockSymbol(String stockSymbol) {
        this.stockSymbol = stockSymbol;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }

    @Override
    public int compareTo(CompositeKey other) {
        if (this.stockSymbol.compareTo(other.stockSymbol) != 0) {
            return this.stockSymbol.compareTo(other.stockSymbol);
        } else if (this.timestamp != other.timestamp) {
            return this.timestamp < other.timestamp ? -1 : 1;
        } else {
            return 0;
        }
    }

    @Override
    public void write(DataOutput dataOutput) throws IOException {
        dataOutput.writeUTF(this.stockSymbol);
        dataOutput.writeLong(this.timestamp);
    }

    @Override
    public void readFields(DataInput dataInput) throws IOException {
        this.stockSymbol = dataInput.readUTF();
        this.timestamp = dataInput.readLong();
    }

    //这里的组合键比较器
    public static class CompositeKeyComparator extends WritableComparator {
        public CompositeKeyComparator() {
            super(CompositeKey.class, true);
        }
		//compare方法可以从每个字节数组b1和b2中读取给定起始位置(s1和s2)以及长度l1和l2的一个整数直接进行比较。
        @Override
        public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
            return compareBytes(b1, s1, l1, b2, s2, l2);
        }
    }
    //注册键比较器
    static {
        WritableComparator.define(CompositeKey.class, new CompositeKeyComparator());
    }
}
```

一开始对组合键比较器中的比较逻辑不清楚，查资料后发现原来WritableComparable接口默认是先反序列化数据流为对象之后再调用compareTo()方法的比较，而自己在CompositeKeyComparator重写compare方法可以实现不需要反序列化就可以比较，这样这样避免了新建对象的额外开销。具体可以看本博客转载的[博文](https://harold1994.github.io/2018/06/08/Java和Hadoop序列化机制浅讲/)。

**自然键分区器：**

```java
/**
 * @author lihe
 * @Title: NatureKeyPartitioner
 * @Description: 自然键分区器,在shufful之前执行分区
 * @date 2018/6/8下午3:46
 */
public class NaturalKeyPartitioner extends Partitioner<CompositeKey, NaturalValue> {
    @Override
    public int getPartition(CompositeKey compositeKey, NaturalValue naturalValue, int numberOfPartitions) {
        return Math.abs((int) (hash(compositeKey.getStockSymbol()) % numberOfPartitions));
    }

    static long hash(String str) {
        long h = 1125899906842597L; // prime
        int length = str.length();
        for (int i = 0; i < length; i++ ) {
            h = 31*h + str.charAt(i);
        }
        return h;
    }
}
```

上面代码中的NaturalValue值为自然值的类型。

**自然值：**

```java
/**
 * @author lihe
 * @Title: NaturalValue
 * @Description: 自然值，这里是（timestamp, price）对
 * @date 2018/6/8下午3:51
 */
public class NaturalValue implements WritableComparable<NaturalValue> {
    private long timestamp;
    private double price;

    public NaturalValue(long timestamp, double price) {
        this.timestamp = timestamp;
        this.price = price;
    }

    public NaturalValue() {
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public double getPrice() {
        return price;
    }

    public static NaturalValue copy(NaturalValue value) {
        return new NaturalValue(value.timestamp, value.price);
    }

    public NaturalValue clone() {
        return new NaturalValue(this.timestamp, this.price);
    }

    public String getDate() {
        return DateUtil.getDateAsString(this.timestamp);
    }

    public static NaturalValue read(DataInput in) throws IOException {
        NaturalValue value = new NaturalValue();
        value.readFields(in);
        return value;
    }

    @Override
    public int compareTo(NaturalValue o) {
        return 0;
    }

    @Override
    public void write(DataOutput dataOutput) throws IOException {
        dataOutput.writeLong(this.timestamp);
        dataOutput.writeDouble(this.price);
    }

    @Override
    public void readFields(DataInput dataInput) throws IOException {
        this.timestamp = dataInput.readLong();
        this.price = dataInput.readDouble();
    }
```

**分组比较器：**

```java
/**
 * @author lihe
 * @Title: NaturalKeyGroupingComparator
 * @Description: 分组比较器，在shuffel阶段根据自然键对组合键分组
 * @date 2018/6/8下午4:32
 */
public class NaturalKeyGroupingComparator extends WritableComparator {
    protected NaturalKeyGroupingComparator() {
        super(CompositeKey.class, true);
    }

    @Override
    public int compare(WritableComparable a, WritableComparable b) {
        CompositeKey ck1 = (CompositeKey) a;
        CompositeKey ck2 = (CompositeKey) b;
        return ck1.getStockSymbol().compareTo(ck2.getStockSymbol());
    }
}
```

**Mapper：**

```java
/**
 * @author lihe
 * @Title:
 * @Description: mapper
 * @date 2018/6/8下午4:39
 */
public class SecondarySortMapper extends Mapper<LongWritable, Text, CompositeKey, NaturalValue> {
    private final CompositeKey reduceKey = new CompositeKey();
    private final NaturalValue reduceValue = new NaturalValue();

    @Override
    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
        String [] tokens = StringUtils.split(value.toString().trim(),',');
        if (tokens.length == 3) {
            Date date = DateUtil.getDate(tokens[1]);
            if (date == null) {
                return;
            }
            long timestamp = date.getTime();
            reduceKey.setStockSymbol(tokens[0]);
            reduceKey.setTimestamp(timestamp);
            reduceValue.setTimestamp(timestamp);
            reduceValue.setPrice(Double.parseDouble(tokens[2]));
            context.write(reduceKey, reduceValue);
        }
        else {
            // ignore the entry or log as error, not enough tokens
        }
    }
}
```

**Reducer():**

```java
/**
 * @author lihe
 * @Title:
 * @Description: Reducer
 * @date 2018/6/8下午4:52
 */
public class SecondarySortReducer extends Reducer<CompositeKey, NaturalValue, Text, Text> {
    @Override
    protected void reduce(CompositeKey key, Iterable<NaturalValue> values, Context context) throws IOException, InterruptedException {
        StringBuilder builder = new StringBuilder();
        for (NaturalValue data : values) {
            builder.append("(");
            String dateAsString = DateUtil.getDateAsString(data.getTimestamp());
            double price = data.getPrice();
            builder.append(dateAsString);
            builder.append(",");
            builder.append(price);
            builder.append(")");
        }
        context.write(new Text(key.getStockSymbol()), new Text(builder.toString()));
    }
}
```

**Driver():**

```java
/**
 * @author lihe
 * @Title: SecondarySortDrive
 * @Description:
 * @date 2018/6/8下午5:29
 */
public class SecondarySortDriver {
    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {
        Configuration conf = new Configuration();
        Job job = new Job(conf, "SecondarySort");
        String [] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
        if (otherArgs.length != 2) {
            System.err.println("Usage: SecondarySortDriver <input> <output>");
            System.exit(1);
        }
        job.setJarByClass(SecondarySortDriver.class);
        job.setJarByClass(SecondarySortMapper.class);
        job.setJarByClass(SecondarySortReducer.class);

        job.setMapperClass(SecondarySortMapper.class);
        job.setReducerClass(SecondarySortReducer.class);

        job.setMapOutputKeyClass(CompositeKey.class);
        job.setMapOutputValueClass(NaturalValue.class);

        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(Text.class);

        //二次排序中比较关键的设置部分
        job.setPartitionerClass(NaturalKeyPartitioner.class);
        job.setGroupingComparatorClass(NaturalKeyGroupingComparator.class);
        job.setSortComparatorClass(CompositeKey.CompositeKeyComparator.class);
        
        job.setInputFormatClass(TextInputFormat.class);
        job.setOutputFormatClass(TextOutputFormat.class);

        FileInputFormat.setInputPaths(job, new Path(otherArgs[0]));
        FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
        
        job.waitForCompletion(true);
    }
}
```

二次排序设计模式中，在驱动器程序中的以下设置是比较重要的，单独拿出来展示一下：

job.setPartitionerClass(NaturalKeyPartitioner.class); job.setGroupingComparatorClass(NaturalKeyGroupingComparator.class); job.setSortComparatorClass(CompositeKey.CompositeKeyComparator.class);