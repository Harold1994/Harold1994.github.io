---
title: 动态规划算法面试题----硬币组合问题
date: 2018-03-23 23:02:10
tags: 算法
---

师兄做腾讯春季实习生笔试题目算法第二道题目,小明有2^k个硬币各两个,如1,1,2,2,4,4,8,8...,给定一个币值n,问小明有多少种方法从自己已有的硬币中组合出n.

第一眼看到这个题目有两个想法,要么用二进制的方式解决,要么用动态规划解决,二进制的办法现场没想出来,试着用动态规划解,开始想的是自底向上的解法,写了一小段代码,可以输出一部分解,方案不完备,晚上回来系统的写一下此类问题的解法.
  <!-- more-->
先看一下典型的币值组合问题的描述:
> In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:
>    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
>It is possible to make £2 in the following way:
>    1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
>How many different ways can £2 be made using any number of coins?

不难发现,这是一道完全背包问题,第i种硬币i最多可以被选择`sum/coin[i]`个,我们用`dp[i][sum]`表示用前i种硬币构成sum的所有组合数,用`Xi`表示第i种硬币被选择的数量,`Vi`表示第i种硬币的币值,以最后一种硬币被选择的数量来写递归公式:
> `sum = X1*V1 + X2*V2 + ... +  0*V8`
`sum = X1*V1 + X2*V2 + ... +  1*V8`
`sum = X1*V1 + X2*V2 + ... +  2*V8`
`...`
>`sum = X1*V1 + X2*V2 + ... +  (sum/V8)*V8`

可以看出,前i种硬币组合出sum的组合数量等于当第i种硬币取0,1,2...sum/Vi时,前i-1种硬币组合出sum-(Xi*Vi)的组合数之和,
因此状态转移方程是 :

`dp[i][sum] = dp[i-1][sum-0*Vi] + dp[i-1][sum-1*Vi] + ... + dp[i-1][sum-(sum/Vi)*Vi] `

当sum=0时,只有一种可能组成sum,因此`dp[i][0]=0`
如果我们用二位数组表示dp[i][sum], 我们发现第i行的值全部依赖与i-1行的值，所以我们可以逐行求解该数组。如果前0种硬币要组成sum，我们规定为dp[0][sum] = 0.

代码:

```java
Scanner scanner = new Scanner(System.in);
        int sum = scanner.nextInt();
        int [] coin = {1,2,5,10,20,50,100,200};
        int [][] dp = new int[8][sum+1];

        for (int i = 1; i<=sum; i++)
            dp[0][i] = 0;

        for (int i = 0 ; i < 8; i++)
            dp[i][0] = 1;

        for (int i = 1; i< 8; i++) {
            for (int j = 1; j<=sum; j++){
                dp[i][j] = 0;
                for (int k = 0; k <= j/coin[i-1]; k++)
                    dp[i][j] += dp[i-1][j-k*coin[i-1]];
            }
        }
        System.out.println(dp[7][sum]);
```

现在让我们回到一开始的题目中,笔试题中每种硬币最多只能选两次,因此我们需要对上面代码的k添加K<=2的约束.

```java
import java.util.Arrays;
import java.util.Scanner;

public class CoinCombination {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int sum = scanner.nextInt();
        int e = (int) (Math.log(sum) / Math.log(2));//计算sum是2的几次方
        int coinType = e + 2;//此处+2是为了能够将最后一种硬币计算进去,否则后面循环会少算,因为dp[i][j]表示的是前i个硬币组合成j的数目.
        int coin[] = new int[coinType];
        for (int i = 0; i < coinType; i++) { //构造coin[]
            coin[i] = (int) Math.pow(2, i);
        }
        int[][] dp = new int[coinType][sum + 1];

        for (int i = 1; i <= sum; i++)
            dp[0][i] = 0;

        for (int i = 0; i < coinType; i++)
            dp[i][0] = 1;

        for (int i = 1; i < coinType; i++) {
            for (int j = 1; j <= sum; j++) {
                dp[i][j] = 0;
                for (int k = 0; k <= j / coin[i - 1] && k <= 2; k++)//此处添加K<=2的约束
                    dp[i][j] += dp[i - 1][j - k * coin[i - 1]];
            }
        }
        System.out.println(dp[e + 1][sum]);
    }
}
```




