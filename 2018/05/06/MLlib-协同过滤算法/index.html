<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MLlib----协同过滤算法 | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/05/06/MLlib-协同过滤算法/">MLlib----协同过滤算法</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">May 06 2018</p>
  </section>

  <section class="article-entry">
    <p>协同过滤算法是最常用的推荐算法,主要有两种形式:基于用户和基于物品的推荐算法.</p>
<p>ALS(alternate least square)是交替最小二乘法的简称,也是MLlib的基础推荐算法.</p>
<p><strong>一. 协同过滤</strong></p>
<p>协同过滤算法是一种基于群体用户或物品的典型推荐算法,主要有两种:</p>
<blockquote>
<ul>
<li>通过考察具有相同爱好的用户对相同物品的评分标准进行计算</li>
<li>考察具有相同特质的物品从而推荐给选择了某件物品的用户</li>
</ul>
</blockquote>
<a id="more"></a>
<p>不足:</p>
<blockquote>
<ul>
<li>基于用户: 针对热点物品的处理不够准确,一些常用的物品其推荐结果往往排在首位,但是这样没有实际意义.其次,数据量大,计算费事</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>基于物品: 存在推荐同类物品的问题</li>
</ul>
</blockquote>
<p><strong>二. 相似度度量</strong></p>
<ol>
<li><p>基于欧几里德距离的相似度计算</p>
<p>欧式距离表示空间中两个点的真实距离,<img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D272/sign=824f524b36292df593c3ab128e305ce2/9e3df8dcd100baa1dbb0d0df4b10b912c8fc2e31.jpg" alt="img">,在相似度计算中,不同的物品或用户可将其定义成不同的坐标点,特定目标定位成坐标原点.因为欧式距离越大,相近度越小,因此一般以<code>1/(ρ+1)</code>作为相似度近似值</p>
</li>
<li><p>基于余弦角度的相似度</p>
<p>余弦相似度通过计算两个向量的夹角余弦值来评估他们的相似度</p>
</li>
</ol>
<p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=ff93f325064f78f0940692a118586130/e850352ac65c1038573da3b3b7119313b07e897b.jpg" alt="img"></p>
<p>计算公式:   <img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D187/sign=50b538a78244ebf869716037eef8d736/0df431adcbef760970e3983b2bdda3cc7dd99ead.jpg" alt="img">      余弦值大小在[-1,1],值大小与夹角成正比</p>
<ol>
<li><p>欧式距离相似度与余弦相似度比较 </p>
<p>欧式相似度以目标绝对距离作为衡量标准,余弦相似度以目标差异大小作为衡量标准.一般来说,欧氏相似度用来表现不同目标的绝对差异性,分析目标之间的相似度与差异情况.余弦相似度更多的从目标的方向趋势上区分,而随特定坐标数字不敏感.</p>
</li>
<li><p>余弦相似度实战—-使用余弦相似度计算不同用户之间的相似性</p>
<p>步骤:</p>
<p>a. 输入数据</p>
<p>b.建立相似度算法公式</p>
<p>c.计算不同用户之间的相似度</p>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CollaborativeFilteringSpark</span> </span>&#123;</span><br><span class="line">  <span class="comment">//屏蔽不必要的日志显示在终端上</span></span><br><span class="line">  <span class="type">Logger</span>.getLogger(<span class="string">"org.apache.spark"</span>).setLevel(<span class="type">Level</span>.<span class="type">WARN</span>)</span><br><span class="line">  <span class="type">Logger</span>.getLogger(<span class="string">"org.apache.eclipse.jetty.server"</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> conf= <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[1]"</span>).setAppName(<span class="string">"CollaborativeFilteringSpark"</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">  <span class="keyword">val</span> users = sc.parallelize(<span class="type">Array</span>(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"ddd"</span>, <span class="string">"eee"</span>))<span class="comment">//设置用户名</span></span><br><span class="line">  <span class="keyword">val</span> films = sc.parallelize(<span class="type">Array</span>(<span class="string">"StarWar"</span>,<span class="string">"Spider"</span>,<span class="string">"Ghost"</span>,<span class="string">"Beauty"</span>,<span class="string">"Hero"</span>))<span class="comment">//设置电影名</span></span><br><span class="line">  <span class="keyword">val</span> source = <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>]]()<span class="comment">//用来存储user对每个电影的打分</span></span><br><span class="line">  <span class="keyword">val</span> filmsource = <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>]()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSource</span></span>() : <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>]] = &#123;<span class="comment">//设置电影评分</span></span><br><span class="line">    <span class="keyword">val</span> user1FilmSource = <span class="type">Map</span>(<span class="string">"StarWar"</span> -&gt; <span class="number">2</span>,<span class="string">"Spider"</span>-&gt;<span class="number">3</span>,<span class="string">"Ghost"</span>-&gt;<span class="number">1</span>,<span class="string">"Beauty"</span> -&gt; <span class="number">0</span>,<span class="string">"Hero"</span> -&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> user2FilmSource = <span class="type">Map</span>(<span class="string">"StarWar"</span> -&gt; <span class="number">1</span>,<span class="string">"Spider"</span>-&gt;<span class="number">2</span>,<span class="string">"Ghost"</span>-&gt;<span class="number">2</span>,<span class="string">"Beauty"</span> -&gt; <span class="number">1</span>,<span class="string">"Hero"</span> -&gt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> user3FilmSource = <span class="type">Map</span>(<span class="string">"StarWar"</span> -&gt; <span class="number">2</span>,<span class="string">"Spider"</span>-&gt;<span class="number">1</span>,<span class="string">"Ghost"</span>-&gt;<span class="number">0</span>,<span class="string">"Beauty"</span> -&gt; <span class="number">1</span>,<span class="string">"Hero"</span> -&gt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> user4FilmSource = <span class="type">Map</span>(<span class="string">"StarWar"</span> -&gt; <span class="number">3</span>,<span class="string">"Spider"</span>-&gt;<span class="number">2</span>,<span class="string">"Ghost"</span>-&gt;<span class="number">0</span>,<span class="string">"Beauty"</span> -&gt; <span class="number">5</span>,<span class="string">"Hero"</span> -&gt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> user5FilmSource = <span class="type">Map</span>(<span class="string">"StarWar"</span> -&gt; <span class="number">5</span>,<span class="string">"Spider"</span>-&gt;<span class="number">3</span>,<span class="string">"Ghost"</span>-&gt;<span class="number">1</span>,<span class="string">"Beauty"</span> -&gt; <span class="number">0</span>,<span class="string">"Hero"</span> -&gt; <span class="number">2</span>)</span><br><span class="line">    source += (<span class="string">"aaa"</span> -&gt; user1FilmSource)</span><br><span class="line">    source += (<span class="string">"bbb"</span> -&gt; user2FilmSource)</span><br><span class="line">    source += (<span class="string">"ccc"</span> -&gt; user3FilmSource)</span><br><span class="line">    source += (<span class="string">"ddd"</span> -&gt; user4FilmSource)</span><br><span class="line">    source += (<span class="string">"eee"</span> -&gt; user5FilmSource)</span><br><span class="line">    source</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//两两计算分值，采用余弦相似性</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getCollaborateSource</span></span>(user1: <span class="type">String</span>, user2: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="comment">//获得1，2两个用户的评分</span></span><br><span class="line">    <span class="keyword">val</span> user1FilmSource = source.get(user1).get.values.toVector</span><br><span class="line">    <span class="keyword">val</span> user2FilmSource = source.get(user2).get.values.toVector</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对公式部分分子进行计算</span></span><br><span class="line">    <span class="keyword">val</span> member = user1FilmSource.zip(user2FilmSource).map(d =&gt; d._1 * d._2).reduce(_ + _).toDouble</span><br><span class="line">    <span class="comment">//求出分母第一个变量值</span></span><br><span class="line">    <span class="keyword">val</span> temp1 = math.sqrt(user1FilmSource.map(num =&gt; &#123;</span><br><span class="line">      math.pow(num, <span class="number">2</span>)</span><br><span class="line">    &#125;).reduce(_ + _))</span><br><span class="line">    <span class="comment">//求出分母第二个变量值</span></span><br><span class="line">    <span class="keyword">val</span> temp2 = math.sqrt(user2FilmSource.map(num =&gt; &#123;</span><br><span class="line">      math.pow(num, <span class="number">2</span>)</span><br><span class="line">    &#125;).reduce(_ + _))</span><br><span class="line">    <span class="comment">//求出分母</span></span><br><span class="line">    <span class="keyword">val</span> denominator = temp1 * temp2</span><br><span class="line">    <span class="comment">//进行计算</span></span><br><span class="line">    member / denominator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    getSource()</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"aaa"</span></span><br><span class="line">    users.foreach(user =&gt; &#123;</span><br><span class="line">      println(name + <span class="string">" 相对于 "</span> + user + <span class="string">"的相似性分数为:"</span> + getCollaborateSource(name, user))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三-MLlib中的交替最小二乘法-ALS算法"><a href="#三-MLlib中的交替最小二乘法-ALS算法" class="headerlink" title="三. MLlib中的交替最小二乘法(ALS算法)"></a>三. MLlib中的交替最小二乘法(ALS算法)</h4><p>交替最小二乘法是统计分析中最常用的逼近计算的一种算法,其交替计算结果使得最终结果尽可能的逼近真实结果.</p>
<p><strong>1.最小二乘法(LS算法)</strong></p>
<p>对于一元线性回归模型, 假设从总体中获取了n组观察值$(X1,Y1)(X2,Y2),(Xn,Yn)$.对于平面中的这n个点，可以使用无数条曲线来拟合。要求样本回归函数尽可能好地拟合这组值。综合起来看，这条直线处于样本数据的中心位置最合理。 选择最佳拟合曲线的标准可以确定为：使总的拟合误差（即总残差）达到最小。有以下三个标准可以选择：</p>
<p>​        （1）用“残差和最小”确定直线位置是一个途径。但很快发现计算“残差和”存在相互抵消的问题。<br>        （2）用“残差绝对值和最小”确定直线位置也是一个途径。但绝对值的计算比较麻烦。<br>        （3）最小二乘法的原则是以“残差平方和最小”确定直线位置。用最小二乘法除了计算比较方便外，得到的估计量还具有优良特性。这种方法对异常值非常敏感。</p>
<p>用数学公式描述就是： </p>
<p>​                        $Q=min\sum_i^n(y_{ie}-y_i)^2$ 　　　　　　　　　　　　　　　　　　　　</p>
<p>其中，$y_ie$表示根据$y=ax+b$估算出来的值，$y_i$是观察得到的真实值。</p>
<p><strong>2.MLlib中的交替最小二乘法(ALS)</strong></p>
<p>2.1　ALS算法</p>
<p>从协同过滤的分类来说，ALS算法属于User-Item CF，也叫做混合CF。它同时考虑了User和Item两个方面。</p>
<p>用户和商品的关系，可以抽象为如下的三元组：<code>&lt;User,Item,Rating&gt;</code>。其中，Rating是用户对商品的评分，表征用户对该商品的喜好程度。</p>
<p>ALS算法是基于模型的推荐算法。起基本思想是对稀疏矩阵进行模型分解，评估出缺失项的值，以此来得到一个基本的训练模型。然后依照此模型可以针对新的用户和物品数据进行评估。ALS是采用交替的最小二乘法来算出缺失项的。交替的最小二乘法是在最小二乘法的基础上发展而来的。</p>
<p>假设我们有一批用户数据，其中包含m个User和n个Item，则我们定义Rating矩阵，其中的元素表示第u个User对第i个Item的评分。</p>
<p>在实际使用中，由于n和m的数量都十分巨大，因此R矩阵的规模很容易就会突破1亿项。这时候，传统的矩阵分解方法对于这么大的数据量已经是很难处理了。</p>
<p>另一方面，一个用户也不可能给所有商品评分，因此，Rating矩阵注定是个稀疏矩阵。矩阵中所缺失的评分，又叫做missing item。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-18/62022843.jpg" alt=""></p>
<p>针对这样的特点，我们可以假设用户和商品之间存在若干关联维度（比如用户年龄、性别、受教育程度和商品的外观、价格等），我们只需要将R矩阵投射到这些维度上即可。</p>
<p>如下图，对于一个R（观众对电影的一个评价矩阵）可以分解为U（观众的特征矩阵）和V（电影的特征矩阵）</p>
<p><img src="https://img-blog.csdn.net/20160523103701786" alt="img"></p>
<p>现在假如观众有5个人，电影有5部，那么R就是一个5*5的矩阵。假设评分如下：**</p>
<p><img src="https://img-blog.csdn.net/20160523110941941" alt="img"></p>
<p>假设d是三个属性（性格，文化程度，兴趣爱好）那么U的矩阵如下：</p>
<p><img src="https://img-blog.csdn.net/20160523112421700" alt="img"></p>
<p>V的矩阵如下：</p>
<p><img src="https://img-blog.csdn.net/20160523114759278" alt="img"></p>
<p>R约等于U*V，为什么是约等于呢？因为对于一个U矩阵来说，我们并不可能说（性格，文化程度，兴趣爱好）这三个属性就代表着一个人对一部电影评价全部的属性，比如还有地域等因素。但是我们可以用“主成分分析的思想”来近似（我没有从纯数学角度来谈，是为了大家更好理解）。这也是ALS和核心：一个评分矩阵可以用两个小矩阵来近似（ALS是NNMF问题下在丢失数据情况下的一个重要手段）。</p>
<p>那么如何评价这两个矩阵的好坏？</p>
<p>理想的情况下：<br>$$<br>r_{i,j} = &lt;u_i,v_i&gt;<br>$$<br>但在实际中，我们求$r_{i,j}$使用数值方法来求，那么计算得到的$r_{i,j}$就会存在误差，采用均方根误差RMSE来评价$r_{i,j}$的好坏：<br>$$<br>RMSE=\sqrt{\frac1n\sum_{u,v}|(p_{u,v} - r_{u,v})^2|}<br>$$<br>$p_{u,v}$是u对v评分的预测值，$r_{u,v}$是u对v评分的观察值。<br>$$<br>p_{i,j}=&lt;u_i,v_j&gt;<br>$$<br>那么就是转化的要求：<br>$$<br>(u_i,v_j) = min_{u,v}\sum_{(u,v)\in \kappa}(p_{u,v} - r_{u,v})<br>$$<br>现在一共有$(n_u + n_v)*d$个参数需要求解，而且碰到以下问题：</p>
<ul>
<li>K矩阵是稀疏矩阵（K就是R在U对V没有全部评价的矩阵）</li>
<li>K的大小远小于R的密集对应的大小$n_u*n_v$</li>
</ul>
<p>采用拟合数据的形式来进行解决数据是稀疏的问题，公式如下：<br>$$<br>(u_i,v_j) = min_{u,v}\sum_{(i,j)\in \kappa}(p_{i,j} - r_{i,j})^2 + \lambda(||u_i||^2 + ||v_j||^2)<br>$$<br>后面的$ \lambda(||u_i||^2 + ||v_j||^2)$是为了解决过拟合问题而增加的。</p>
<p>对于ALS来求解這样這个问题的思想是：先固定$u_i$或者$v_j$,然后就转化为最小二乘法的问题了。他這样做就可以把一个非凸函数的问题转为二次函数的问题了。下面就求解步骤[1]：<br>步骤1：初始化矩阵V（可以取平均值也可以随机取值）</p>
<p>步骤2：固定V，然后通过最小化误差函数(RMSE)解决求解U</p>
<p>步骤3：固定步骤2中的U，然后通过最小化误差函数(RMSE)解决求解V</p>
<p>步骤4：反复步骤2，3；直到U和V收敛。</p>
<p>梳理：为什么是交替，从处理步骤来看就是确定V，来优化U，再来优化V，再来优化U,直到收敛</p>
<p>因为采用梯度下降和最小二乘都可以解决這个问题，在此不写代码来讲如何决定参数，可以看前面的最小二乘或者梯度下降算法。</p>
<p>2.2 MLlib中的交替最小二乘法</p>
<p>MLlib中的ALS算法有固定的数据格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Rating</span> (<span class="params">user: <span class="type">Int</span>, product: <span class="type">Int</span>, rating: <span class="type">Double</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>其中Rating是固定的ALS输入格式,要求是一个元组类型的数据，其中数值类型分别是[Int,Int,Double],因此在数据集建立时，用户名和物品分别用用数值代替。</p>
<p>ALS.train方法源码如下，参数类型见代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param ratings    RDD of [[Rating]] objects with userID, productID, and rating</span></span><br><span class="line"><span class="comment">   * @param rank       number of features to use (also referred to as the number of latent factors)</span></span><br><span class="line"><span class="comment">   * @param iterations number of iterations of ALS</span></span><br><span class="line"><span class="comment">   * @param lambda     regularization parameter</span></span><br><span class="line"><span class="comment">   * @param blocks     level of parallelism to split computation into</span></span><br><span class="line"><span class="comment">   * @param seed       random seed for initial matrix factorization model</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Since</span>(<span class="string">"0.9.1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span></span>(</span><br><span class="line">    ratings: <span class="type">RDD</span>[<span class="type">Rating</span>],</span><br><span class="line">    rank: <span class="type">Int</span>,</span><br><span class="line">    iterations: <span class="type">Int</span>,</span><br><span class="line">    lambda: <span class="type">Double</span>,</span><br><span class="line">    blocks: <span class="type">Int</span>,</span><br><span class="line">    seed: <span class="type">Long</span></span><br><span class="line">): <span class="type">MatrixFactorizationModel</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ALS</span>(blocks, blocks, rank, iterations, lambda, <span class="literal">false</span>, <span class="number">1.0</span>, seed).run(ratings)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CollaborativeFilter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"CollaborativeFilter"</span>).setMaster(<span class="string">"local"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> data = sc.textFile(<span class="string">"u1.txt"</span>)</span><br><span class="line">    <span class="keyword">val</span> rating = data.map(_.split(<span class="string">" "</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Array</span>(user, item, rate) =&gt;</span><br><span class="line">        <span class="type">Rating</span>(user.toInt, item.toInt, rate.toDouble)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> rank = <span class="number">2</span><span class="comment">//设置隐藏因子</span></span><br><span class="line">    <span class="keyword">val</span> numIteration = <span class="number">2</span> <span class="comment">//设置迭代次数</span></span><br><span class="line">    <span class="keyword">val</span> model = <span class="type">ALS</span>.train(rating,rank,numIteration,<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">val</span> rs = model.recommendProducts(<span class="number">2</span>,<span class="number">1</span>)<span class="comment">//为用户２推荐一个商品</span></span><br><span class="line">    rs.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ALS算法的缺点在于：</p>
<p>1.它是一个离线算法。</p>
<p>2.无法准确评估新加入的用户或商品。这个问题也被称为Cold Start问题。</p>
<p>2.3 使用DataFrame API的协同过滤算法</p>
<p><a href="http://en.wikipedia.org/wiki/Recommender_system#Collaborative_filtering" target="_blank" rel="noopener">协作过滤</a>通常用于推荐系统。这些技术旨在填补用户-项目关联矩阵中丢失的条目。<strong>spark.ml</strong> 目前支持基于模型的协同过滤，其中用户和项目通过一小组潜在因素来描述，可用于预测缺失的条目。<strong>spark.ml</strong> 使用<a href="http://dl.acm.org/citation.cfm?id=1608614" target="_blank" rel="noopener"> <strong>ALS</strong>（交替最小二乘法）</a>算法来学习这些潜在因素。<strong>spark.ml</strong> 中的实现具有以下参数：</p>
<ul>
<li>numBlocks 是用户和项目将被分区以便并行化计算的块数（默认值为10）。</li>
<li>rank是模型中潜在因素的数量（默认为10）。</li>
<li>maxIter是要运行的最大迭代次数（默认为10）。</li>
<li>implicitPrefs指定是使用显式反馈ALS的版本还是用适用于隐式反馈数据集的版本（默认值为 false，这意味着使用显式反馈）。</li>
<li>alpha是适用于ALS的隐式反馈版本的参数，用于控制偏好观察值的基线置信度（默认为1.0）。</li>
<li>nonnegative 指定是否对最小二乘使用非负约束（默认为 false ）。</li>
</ul>
<p><strong>注意：</strong>用于 <strong>ALS</strong> 的基于 <strong>DataFrame</strong>（数据框）的 API 目前仅支持整数的用户和项目id。 用户和项目id的列支持其他数字类型，但是列中id的取值必须在整数值范围内。</p>
<p> <strong>显式与隐式反馈</strong></p>
<p>​    基于矩阵分解的协同过滤的标准方法中，“用户－商品”矩阵中的条目是用户给予商品的显式偏好，例如，用户给电影评级。然而在现实世界中使用时，我们常常只能访问隐式反馈（如意见、点击、购买、喜欢以及分享等），在spark.ml中我们使用“隐式反馈数据集的协同过滤“来处理这类数据。本质上来说它不是直接对评分矩阵进行建模，而是将数据当作数值来看待，这些数值代表用户行为的观察值（如点击次数，用户观看一部电影的持续时间）。这些数值被用来衡量用户偏好观察值的置信水平，而不是显式地给商品一个评分。然后，模型用来寻找可以用来预测用户对商品预期偏好的潜在因子。</p>
<p><strong>正则化参数</strong></p>
<p>​    我们调整正则化参数regParam来解决用户在更新用户因子时产生新评分或者商品更新商品因子时收到的新评分带来的最小二乘问题。这个方法叫做“ALS-WR”它降低regParam对数据集规模的依赖，所以我们可以将从部分子集中学习到的最佳参数应用到整个数据集中时获得同样的性能。</p>
<p>在以下示例中，我们从 <a href="http://grouplens.org/datasets/movielens/" target="_blank" rel="noopener">MovieLens</a> 数据集加载评分数据，每行由用户，电影，评分和时间戳组成。 然后，我们训练一个 <strong>ALS</strong> 模型，默认情况下假定评分是显式的（ implicitPrefs是 false ）。 我们通过测量评级预测的 <strong>root-mean-square error</strong>（均方根误差）来评估推荐模型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ALSExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Rating</span>(<span class="params">userId: <span class="type">Int</span>, movieId: <span class="type">Int</span>, rating: <span class="type">Float</span>, timeStamp: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">parseRating</span>(<span class="params">str: <span class="type">String</span></span>)</span>: <span class="type">Rating</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> fields = str.split(<span class="string">"::"</span>)</span><br><span class="line">    assert(fields.size == <span class="number">4</span>)</span><br><span class="line">    <span class="type">Rating</span>(fields(<span class="number">0</span>).toInt, fields(<span class="number">1</span>).toInt, fields(<span class="number">2</span>).toFloat, fields(<span class="number">3</span>).toLong)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder</span><br><span class="line">      .master(<span class="string">"local"</span>)</span><br><span class="line">      .appName(<span class="string">"ALSExample"</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">val</span> ratings = spark.read.textFile(<span class="string">"data/als/sample_movielens_ratings.txt"</span>)</span><br><span class="line">      .map(parseRating)</span><br><span class="line">      .toDF()</span><br><span class="line">    <span class="keyword">val</span> <span class="type">Array</span>(training, test) = ratings.randomSplit(<span class="type">Array</span>(<span class="number">0.8</span>, <span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> als = <span class="keyword">new</span> <span class="type">ALS</span>()</span><br><span class="line">      .setMaxIter(<span class="number">5</span>)</span><br><span class="line">      .setRegParam(<span class="number">0.01</span>)</span><br><span class="line">      .setUserCol(<span class="string">"userId"</span>)</span><br><span class="line">      .setItemCol(<span class="string">"movieId"</span>)</span><br><span class="line">      .setRatingCol(<span class="string">"rating"</span>)</span><br><span class="line">    <span class="keyword">val</span> model = als.fit(training)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> predictions = model.transform(test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> evaluator = <span class="keyword">new</span> <span class="type">RegressionEvaluator</span>()</span><br><span class="line">      .setMetricName(<span class="string">"rmse"</span>)</span><br><span class="line">      .setLabelCol(<span class="string">"rating"</span>)</span><br><span class="line">      .setPredictionCol(<span class="string">"prediction"</span>)</span><br><span class="line">    <span class="keyword">val</span> rmse = evaluator.evaluate(predictions)</span><br><span class="line">    println(<span class="string">s"Root-mean-square error = <span class="subst">$rmse</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每个用户产生top10推荐电影</span></span><br><span class="line">    <span class="keyword">val</span> userRecs = model.recommendForAllUsers(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//为每部电影产生Top10推荐用户</span></span><br><span class="line">    <span class="keyword">val</span> movieRecs = model.recommendForAllItems(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//为特定集合的用户推荐电影</span></span><br><span class="line">    <span class="keyword">val</span> users = ratings.select(als.getUserCol).distinct().limit(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> userSubsetRecs = model.recommendForUserSubset(users, <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//为特定集合的电影推荐用户</span></span><br><span class="line">    <span class="keyword">val</span> movies = ratings.select(als.getItemCol).distinct().limit(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> movieSubSetRecs = model.recommendForItemSubset(movies, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    userRecs.show()</span><br><span class="line">    movieRecs.show()</span><br><span class="line">    userSubsetRecs.show()</span><br><span class="line">    movieSubSetRecs.show()</span><br><span class="line">    spark.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=协同过滤算法是最常用的推荐算法,主要有两"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = '//harold.me/2018/05/06/MLlib-协同过滤算法/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
