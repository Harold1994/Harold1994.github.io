<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>TCP与UDP | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/06/24/TCP与UDP/">TCP与UDP</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">June 24 2018</p>
  </section>

  <section class="article-entry">
    <blockquote>
<p>OSI参考模型：</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li><strong>传输层</strong> </li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</blockquote>
<p>TCP/IP中有两个具有代表性的传输层协议，分别是TCP和UDP。TCP提供可靠的通信传输，而UDP常用于让广播和细节控制交给应用的通信传输。</p>
<a id="more"></a>
<h4 id="一、传输层的作用"><a href="#一、传输层的作用" class="headerlink" title="一、传输层的作用"></a>一、传输层的作用</h4><p><strong>1. 传输层定义</strong></p>
<p>IP首部有一个协议字段，用来标识网络层（IP）的上一层所采用的是哪一种传输层协议。根据这个字段的协议号，就可以识别IP传输的数据部分究竟是TCP的内容还是UDP的内容。</p>
<p>同样，传输层的TCP和UDP，为了识别自己所传输的数据应该发给哪个应用，也设定了这样一个编号。在TCP/IP通信中需要指定“应用程序”。而传输层必须指出这个具体的程序，为了实现这一功能，使用<strong>端口号</strong>这样一种识别码。根据端口号可以识别在传输层上一层的应用层中所要进行处理的具体程序。</p>
<p><strong>2.通信处理</strong></p>
<p>TCP/IP中的众多协议大多以客户端、服务端的形式运行。客户端是请求的发起端，服务端是请求处理端。服务端程序必须提前启动，准备接受客户端的请求。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-20/80533231.jpg" alt=""></p>
<p>这些服务端程序在UNIX系统中叫做守护进程，例如HTTP的服务端程序是httpd（HTTP守护进程），而ssh的服务端程序是sshd（SSH守护进程）。<strong>UNIX中并不需要将这些守护进程逐个启动，而是启动一个可以代表他们接收客户端请求的inetd(互联网守护进程)服务程序即可。它是一种超级守护进程，该超级守护进程在收到客户端请求时会fork新的进程并转换（exec）为sshd等各个守护进程</strong></p>
<p>确认一个请求究竟发给的是哪个服务端（守护进程），可以通过所收到数据包的目标<strong>端口号</strong>轻松识别。当收到TCP的建立连接请求时，如果目标端口为22，则转给sshd，如果是80则转给httd。然后，这些守护进程会继续对该连接上的通信传输进行处理。上图中，传输协议的数据将被传递给HTTP、TELNET以及FTP等应用层协议。</p>
<p><strong>3.两种传输协议TCP和UDP</strong></p>
<ul>
<li><p>TCP</p>
<p>TCP是<strong>面向连接</strong>的、可靠的流协议。流指不间断的数据结构。采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。</p>
<blockquote>
<p>例如发送端应用程序发送了10次100字节的消息，那么在接收端可能会接受到一个1000字节连续的不间断数据</p>
</blockquote>
<p>TCP为提供可靠性传输，实行<strong>“顺序控制”</strong>或/<strong>“重发控制”</strong>机制，此外还具有“流控制”，“拥塞控制”、提高网络利用率等众多功能。</p>
</li>
<li><p>UDP</p>
<p>UDP不具有可靠地数据报协议。细节处理它会交给上层应用程序去完成。UDP可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时需要根据需要进行重发处理。</p>
<blockquote>
<p>UDP协议中，发送端发送一个100字节的消息，那么接收端也会以100字节为长度接收数据。</p>
</blockquote>
</li>
</ul>
<p><strong>4. TCP 与 UDP 区分</strong></p>
<ul>
<li>TCP用于传输层有必要实现可靠传输的情况：面向有连接，具备顺序控制、重发机制等</li>
<li>UDP主要用于对高速传输和实时性有较高要求的通信或广播通信。例如在实时传送动画或声音时，一部分丢包可能会引起短暂停顿，但实际使用中这一干扰并无大碍。</li>
</ul>
<blockquote>
<ul>
<li><p>套接字（Socket）</p>
<p>使用TCP或UDP时，会广泛用到套接字的API，套接字原本是由BSD UNIX开发的，但是后被移植到Windows以及嵌入式操作系统中。 </p>
<p>套接字 socket = (IP地址 : 端口号)</p>
<p>对于TCP，每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定 ，即</p>
<p>​             $TCP_{conn} ::= \lbrace socket1, socket2\rbrace = \lbrace (IP1: port1):  (IP2:port2) \rbrace$</p>
<p>由于 UDP 的通信是无连接的，因此不需要使用套接字 。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-20/64237040.jpg" alt=""></p>
</li>
</ul>
</blockquote>
<h4 id="二、端口号"><a href="#二、端口号" class="headerlink" title="二、端口号"></a>二、端口号</h4><p><strong>1、 端口号定义</strong></p>
<p>数据链路和IP中的地址，分别指MAC地址和IP地址，MAC地址用来识别同一链路中的不同计算机，IP地址用来识别TCP/IP网络中互连的主机和路由器。在传输层中类似的概念就是端口号，端口号用来<strong>识别同一台计算机中进行通信的不同应用程序</strong>，也被称为程序地址。</p>
<p><strong>2、 根据端口号识别应用</strong></p>
<p>一台计算机上可以同时运行多个程序，传输层协议利用端口号识别本机中正在进行通信的应用程序，并准确的进行数据传输。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/21105202.jpg" alt=""></p>
<p><strong>3、 通过IP地址、端口号、协议号进行通信识别</strong></p>
<p>仅凭一个端口号识别应用是远远不够的，如下图所示，①和②的通信在两台机器上进行，它们的目标端口号都是80，例如打开Web服务器，同时访问服务器上的两个不同页面，就会在这个浏览器跟服务器之间产生类似前面两个的通信。此时，可以根据<strong>源端口号</strong>加以区分。</p>
<p>①和③的目标端口号和源端口号完全相同，但是他们的源IP地址不同。此外，还有可能IP地址和端口全都一样，只是协议号（表示上层是TCP或UDP的一种编号）不同，这种情况下，也会认为是两个不同的通信。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/73038964.jpg" alt=""></p>
<p>因此，TCP/IP或UDP/IP通信中通常采用五个信息来识别一个通信：</p>
<p><em>源IP地址</em> 、<em>目标IP地址</em>、<em>协议号</em>、<em>源端口号</em>，<em>目标端口号</em></p>
<p>只要其中某一项不同，就被认为是其他通信。</p>
<p><strong>4、 端口号如何确定</strong></p>
<p>在实际通信中，要实现确定端口号，有两种确定方法：</p>
<ul>
<li><p>标准既定的端口号：</p>
<p>​    这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。每个端口号都有其对应的使用目的。</p>
<p>​    HTTP、TELNET、FTP等端口号就是固定的。这些端口号被称之为知名端口号（Well-Known Port Number）。知名端口号一般由0到1023的数字分配而成。</p>
</li>
<li><p>时序分配法</p>
<p>​    第二种方法也叫时序（或动态的）分配法。此时服务端有必要确定监听端口号，但是接受服务的客户端没有必要确定端口号。这种方式下，客户端应用程序可以完全不用自己设置端口号，而全权交给操作系统进行分配。根据动态分配端口号的机制，即使是同一个客户端程序发起的多个TCP连接，识别这些通信连接的5部分数值也不会全部相同。动态分配的端口号取值范围在49152到65535之间。</p>
</li>
</ul>
<p><strong>5、 端口号与协议</strong></p>
<p>端口号由其使用的传输层协议决定。因此，不同的传输协议可以使用相同的端口号。例如，TCP与UDP使用同一个端口号，但使用目的各不相同。这是因为端口号上的处理是根据每个传输协议的不同而进行的。</p>
<p>数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。传给TCP或UDP去做端口号处理。就是是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不会影响。</p>
<p>那些知名端口号与传输层协议并无关系，只要端口一致都将分配同一种程序进行处理。例如，53端口在TCP与UDP中都用于DNS服务（由域名确定IP地址时所用的协议），80端口用于HTTP通信。从目前看，由于HTTP通信必须使用TCP，所以UDP的80端口并未投入使用。</p>
<h4 id="三、UDP"><a href="#三、UDP" class="headerlink" title="三、UDP"></a>三、UDP</h4><p><strong>UDP的特点及其目的：</strong></p>
<ol>
<li>UDP（User Datagram Protocol）不提供复杂的控制机制，利用IP提供<strong>面向无连接</strong>的通信服务。并且它是将应用程序发来的数据在收到那一刻，立即按照原样发送到网络上的一种机制。</li>
<li>即使出现网络拥堵，UDP也<strong>无法进行流量控制</strong>等避免拥塞的行为。此外，传输途中即使出现<em>丢包</em>，UDP也<strong>不负责重发</strong>。甚至出现包到达顺序错乱时也<strong>没有纠正</strong>的功能。</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。</li>
<li>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。  </li>
<li>由于UDP面向无连接，可以随时发送数据，本身处理简单高效，常用于以下方面：<ul>
<li>包总量较少的通信</li>
<li>即时通信</li>
<li>限定于LAN等特定网络中的应用通信</li>
<li>广播通信</li>
</ul>
</li>
</ol>
<h4 id="四、-TCP"><a href="#四、-TCP" class="headerlink" title="四、 TCP"></a>四、 TCP</h4><p>TCP实现了数据传输中各种控制功能，可以进行丢包时的重发控制、对次序乱掉的分包进行顺序控制。TCP是一种<strong>面向有连接</strong>的协议，只有在确认通信对端存在时才会发送数据，可以控制通信流量的浪费。</p>
<p><strong>1、TCP的特点及其目的</strong></p>
<p>TCP通过检验和、序列号、确认应道、重发控制、连接管理以及窗口控制等机制实现可靠性传输。每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。TCP面向字节流，提供全双工通信。</p>
<p><strong>2、 通过序列号与确认应答提高可靠性</strong></p>
<p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个以收到消息的通知，这个消息叫确认应答(ACK)，同时也有否认确认应道（NACK）。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-20/45981043.jpg" alt=""></p>
<p>TCP通过肯定的确认应答（ACK）实现可靠地数据传输。当数据端将数据发出之后会等待对端的确认应答，如果有确认应答，说明数据传输成功，反之，则数据很可能丢失。</p>
<p>如下图所示，在一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。因此即使产生了丢包，任然能够保证数据能够达到对端，实现可靠传输。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-20/74149779.jpg" alt=""></p>
<p>未收到确认应答并不一定意味着数据丢失，也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致数据重发，但是此时接收端已经收到过相同的数据，当再有相同数据到达时它会放弃。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-20/33209239.jpg" alt=""></p>
<p>目标主机反复收到相同数据时，为了对上层应用提供可靠传输，必须得放弃重复的数据包，为此必须引入一种机制，用以识别是否已经接收数据，又能够判断是否需要接收。</p>
<p>上述提到的确认应答处理、重发控制以及重复控制等功能都可以通过<strong>序列号</strong>实现。</p>
<p><strong>序列号</strong>是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号，接收端查询接收数据TCP首部中的序列号和数据长度，将自己<strong>下一步应该接收的序号</strong>作为确认应答返送回去。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/72275985.jpg" alt=""></p>
<blockquote>
<p>序列号（确认应答号），也指字节与字节之间的分隔。</p>
</blockquote>
<p><strong>3、重发超时的确定</strong></p>
<p>重发超时指在重发数据之前，等待确认应答到来的那个特定的时间间隔，如果超过这个时间仍未收到确认应答，发送端将进行数据重发。</p>
<p>TCP要求在任何网络环境中都能提供高性能通信，为此，它在每次发包时都会计算往返时间及其偏差，将往返时间和偏差相加，重发超时的时间就是比这个总和要大一点的值。</p>
<p>数据重发之后若还是收不到确认应答，会再次发送，此时等待确认应答的时间会以2倍，4倍的指数函数延长。此外，数据不会被无限制重发，达到一定数量后，如果仍没有收到确认应答，就会判断网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止。</p>
<p><strong>4、 连接管理</strong></p>
<p>TCP提供面向有连接的通信传输，面向有连接指在数据通信开始之前先做好通信两端之间的准备工作。</p>
<p>TCP在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答，如果对端发来确认应答，则认为可以进行数据通信。建立一个TCP连接需要发送三个包，这个过程也称为<strong>三次握手</strong>。</p>
<p>在通信结束时会进行断开连接的处理（FIN包）</p>
<p>可以使用TCP首部用于控制的字段来管理TCP连接，一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/7855917.jpg" alt=""></p>
<blockquote>
<p>TCP中发送第一个SYN包的一方叫客户端，接收的一方叫服务端。</p>
</blockquote>
<p><strong>5、 TCP以段（Segment）为单位发送数据</strong></p>
<p>在建立TCP连接的同时，也可以确定发送数据包的单位，称为”最大消息长度(MSS:Max Segment Size)“，理想情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。</p>
<p>TCP在传送大量数据时，是以MSS的大小将数据分割发送，进行重发也是以MSS为单位。MSS是在三次握手的时候，在两端主机被计算得出，会在两端的MSS中选一个较小的值投入使用。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/8156623.jpg" alt=""></p>
<p><strong>6、 利用窗口控制提高速度提高</strong></p>
<p>TCP以1个段为单位，每发一个段进行一次确认应答的处理，这样的缺点是<strong>包的往返时间越长通信性能就越低</strong></p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/18290152.jpg" alt=""></p>
<p>于是TCP引入了“窗口”的概念，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将被大幅缩短。也就是说，发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。</p>
<p><strong>窗口大小</strong>就是指无需等待确认应答而可以继续发送数据的最大值。这个机制实现了使用大量的<em>缓冲区</em>，通过对多个段同时进行确认应答的功能。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/48942688.jpg" alt=""></p>
<p>一个窗口内的数据即使没有收到确认应答也可以被送出去，不过，如果其中部分数据出现丢包，发送端仍然要负责重传。为此，发送端主机得设置缓存保留这些待被重传的数据。当数据发出后如期收到应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>
<p>收到确认应答，将窗口滑动到确认应答中的需要的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为<strong>滑动窗口控制。</strong> </p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/76706471.jpg" alt=""></p>
<p><strong>7、 窗口控制与重发控制</strong></p>
<p>使用窗口控制中， 如果出现段丢失怎么办？ </p>
<p>首先考虑确认应答未能返回的情况。这种情况下，数据已经达到对端，是不需要进行重发的。然而，在没有使用窗口控制的时候，没有收到确认应答的数据会被重发。而使用了窗口控制，如下图，某些确认应答即便丢失也无需重发。 </p>
<p>首先考虑确认应答未能返回的情况。这种情况下，数据已经达到对端，是不需要进行重发的。然而，在没有使用窗口控制的时候，没有收到确认应答的数据会被重发。而使用了窗口控制，如下图，某些确认应答即便丢失也无需重发。 </p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/37515881.jpg" alt=""></p>
<p>其次，考虑一下某个报文段丢失的情况。如下图，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前位置收到数据返回确认应答（不过即使接收端主机收到的包序号并不连续，也不会将数据丢弃而是暂时保存至缓冲区中）。</p>
<p>当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答（之所以连续收到3次而不是两次的理由是因为，即使数据段的序号被替换两次也不会触发重发机制）。就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作<strong>高速重发控制</strong>。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/85348334.jpg" alt=""></p>
<p><strong>8、流控制</strong></p>
<p>TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。它的具体操作时，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限制的数据。该大小限度就被称为<strong>窗口大小</strong>。 </p>
<p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己的可以接收的缓冲区大小放入这个字段通知给发送端。这个值越大，说明网络的吞吐量越高。 </p>
<p>不过，接收端这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也形成了一个完整的TCP流控制（流量控制）。</p>
<p>根据窗口大小控制流量过程示例：</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/48529645.jpg" alt=""></p>
<p><strong>9、 拥塞控制</strong></p>
<p>有了TCP窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。然而，如果在通信刚开始就发送大量数据，也可能会引发其他问题。</p>
<p>TCP为了防止该问题的出现，在通信一开始就会通过一个叫做<strong>慢启动</strong>的算法得出的数值，对发送数据量进行控制。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/84480758.jpg" alt=""></p>
<h4 id="五、UDP首部格式"><a href="#五、UDP首部格式" class="headerlink" title="五、UDP首部格式"></a>五、UDP首部格式</h4><p>如图所示，用户数据报 UDP 有两个字段：数据字段和首部字段 ，首部字段有 8 个字节，由 4 个字段组成，分别是源端口号、目标端口号、包长度和校验和。</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/73522512.jpg" alt=""></p>
<h4 id="六、TCP首部格式"><a href="#六、TCP首部格式" class="headerlink" title="六、TCP首部格式"></a>六、TCP首部格式</h4><p>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。 一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。 </p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-6-21/41460022.jpg" alt=""></p>
<ul>
<li>序列号：指发送数据的位置，每发送一次数据，就累加一次数据字节数的大小。</li>
<li>数据偏移：表示TCP所传输的数据部分应该从TCP包的那个位置开始计算。</li>
</ul>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=ockquote>
<p>OSI参考模型"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = '//harold.me/2018/06/24/TCP与UDP/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
