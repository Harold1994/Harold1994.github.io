<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java和Hadoop序列化机制浅讲 | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/06/08/Java和Hadoop序列化机制浅讲/">Java和Hadoop序列化机制浅讲</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">June 08 2018</p>
  </section>

  <section class="article-entry">
    <p>转自：<a href="https://blog.csdn.net/zq602316498/article/details/45190175" target="_blank" rel="noopener">https://blog.csdn.net/zq602316498/article/details/45190175</a></p>
<h1 id="Java-和-Hadoop-序列化机制浅讲"><a href="#Java-和-Hadoop-序列化机制浅讲" class="headerlink" title="Java 和 Hadoop 序列化机制浅讲"></a>Java 和 Hadoop 序列化机制浅讲</h1><p>序列化  (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程（<strong>字节流</strong>）。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p>
<p>通常来说有三个用途：</p>
<ul>
<li>持久化：对象可以被存储到磁盘上</li>
<li>通信：对象可以通过网络进行传输</li>
<li>拷贝、克隆：可以通过将某一对象序列化到内存的缓冲区，然后通过反序列化生成该对象的一个深拷贝（破解单例模式的一种方法）<a id="more"></a>
在Java中要实现序列化，只需要实现Serializable即可（说是实现，其实不需要实现任何成员方法）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想对某个对象进行序列化的操作，只需要在OutputStream对象上创建一个输入流 ObjectOutputStream 对象，然后调用 writeObject（）。</p>
<p>在序列化过程中，对象的类、类签名、雷瑟所有非暂态和非静态成员变量的值，以及它所有的父类都会被写入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">OutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">objOut.writeObject(d);</span><br></pre></td></tr></table></figure>
<p>如果想对某个基本类型进行序列化，ObjectOutputStream 还提供了多种 writeBoolean、writeByte等方法</p>
<p><img src="https://img-blog.csdn.net/20150422091844504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenE2MDIzMTY0OTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>反序列过程类似，只需要调用 ObjectInputStream 的 readObject() ，并向下转型，就可以得到正确结果。</p>
<p><strong>优点</strong>：实现简便，对于循环引用和重复引用的情况也能处理，允许一定程度上的类成员改变。支持加密，验证。</p>
<p><strong>缺点</strong>：序列化后的对象占用空间过大，数据膨胀。反序列会不断创建新的对象。同一个类的对象的序列化结果只输出一份元数据（描述类关系），导致了文件不能分割。</p>
<p>对于需要保存和处理大规模数据的Hadoop来说，其序列化机制要达到以下目的：</p>
<ul>
<li>排列紧凑：尽量减少带宽，加快数据交换速度</li>
<li>处理快速：进程间通信需要大量的数据交互，使用大量的序列化机制，必须减少序列化和反序列的开支</li>
<li>跨语言：可以支持不同语言间的数据交互啊，如C++</li>
<li>可扩展：当系统协议升级，类定义发生变化，序列化机制需要支持这些升级和变化</li>
</ul>
<p>为了支持以上特性，引用了Writable接口。和说明性Serializable接口不一样，它要求实现两个方法。</p>
<ol>
<li>public interface Writable {  </li>
<li>void write(DataOutput out) throws IOException;  </li>
<li>void readFields(DataInput in) throws IOException;  </li>
<li>}  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Writable &#123;</span><br><span class="line">  void write(DataOutput out) throws IOException;</span><br><span class="line">  void readFields(DataInput in) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，我们需要实现一个表示某一时间段的类，就可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartEndDate</span> <span class="keyword">implements</span> <span class="title">Writable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date startDate;</span><br><span class="line">	<span class="keyword">private</span> Date endDate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		out.writeLong(startDate.getTime());</span><br><span class="line">		out.writeLong(endDate.getTime());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		startDate = <span class="keyword">new</span> Date(in.readLong());</span><br><span class="line">		endDate = <span class="keyword">new</span> Date(in.readLong());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getStartDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> startDate;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartDate</span><span class="params">(Date startDate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.startDate = startDate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Hadoop 还提供了另外几个重要的接口：</p>
<p><strong>WritableComparable:</strong>它不仅提供序列化功能，而且还提供比较的功能。这种比较式基于反序列后的对象成员的值，速度较慢。</p>
<p><strong>RawComparator:</strong>由于MapReduce十分依赖基于键的比较排序（自定义键还需要重写hashCode和equals方法），因此提供了一个优化接口   RawComparator。该接口允许直接比较数据流中的记录，无需把数据流反序列化为对象，这样避免了新建对象的额外开销。RawComparator定义如下，compare方法可以从每个字节数组b1和b2中读取给定起始位置(s1和s2)以及长度l1和l2的一个整数直接进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RawComparator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">byte</span>[] b1, <span class="keyword">int</span> s1, <span class="keyword">int</span> l1, <span class="keyword">byte</span>[] b2, <span class="keyword">int</span> s2, <span class="keyword">int</span> l2)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WritableComparator:</strong> 是 RawComparator 的一个通用实现，提供两个功能：提供了一个 RawComparator的comparea()的默认实现，该默认实现只是反序列化了键然后再比较，没有什么性能优势。其次、充当了  RawComaprator 实例的一个工厂方法。</p>
<p>当我们要实现自定key排序时（自定义分组），需要指定自己的排序规则。</p>
<p>如需要以StartEndDate为键且以开始时间分组，则需要自定义分组器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGrouper</span> <span class="keyword">implements</span> <span class="title">RawComparator</span>&lt;<span class="title">StartEndDate</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(StartEndDate o1, StartEndDate o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(o1.getStartDate().getTime()- o2.getEndDate().getTime());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">byte</span>[] b1, <span class="keyword">int</span> s1, <span class="keyword">int</span> l1, <span class="keyword">byte</span>[] b2, <span class="keyword">int</span> s2, <span class="keyword">int</span> l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> compareBytes = WritableComparator.compareBytes(b1, s1, <span class="number">8</span>, b2, s2, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> compareBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在job中设置</p>
<p>job.setGroupingComparatorClass(MyGrouper.class);<br> 最好将equals和hashcode也进行重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="meta">@Override</span>  </span><br><span class="line"><span class="number">2</span>. <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line"><span class="number">3</span>.     <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> StartEndDate))  </span><br><span class="line"><span class="number">4</span>.         <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line"><span class="number">5</span>.     StartEndDate s = (StartEndDate)obj;  </span><br><span class="line"><span class="number">6</span>.     <span class="keyword">return</span> startDate.getTime()== s.startDate.getTime()&amp;&amp;endDate.getTime() == s.endDate.getTime();   </span><br><span class="line"><span class="number">7</span>. &#125;  </span><br><span class="line"><span class="number">8</span>. <span class="meta">@Override</span>  </span><br><span class="line"><span class="number">9</span>. <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="number">10</span>.     <span class="keyword">int</span> result = <span class="number">17</span>;    </span><br><span class="line"><span class="number">11</span>.      result = <span class="number">31</span>*result +startDate.hashCode();   </span><br><span class="line"><span class="number">12</span>.      result = <span class="number">31</span>*result +endDate.hashCode();    </span><br><span class="line"><span class="number">13</span>.      <span class="keyword">return</span> result;  </span><br><span class="line"><span class="number">14</span>. &#125;;</span><br></pre></td></tr></table></figure>
<p>ps： equal 和 hashcode 方法中应该还要对成员变量判空，以后还需要修改。</p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=转自：<a href="https://"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = '//harold.me/2018/06/08/Java和Hadoop序列化机制浅讲/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
