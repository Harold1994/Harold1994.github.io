<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BoostTrees简介 | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/05/28/BoostTrees简介/">BoostTrees简介</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">May 28 2018</p>
  </section>

  <section class="article-entry">
    <p>本文翻译自陈天奇大神的英文ppt,喜欢看英文的同学可以<a href="https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf" target="_blank" rel="noopener">直接跳转</a>,翻译当中也增加了一些个人的补充.</p>
<h2 id="一、监督学习的关键概念"><a href="#一、监督学习的关键概念" class="headerlink" title="一、监督学习的关键概念"></a>一、监督学习的关键概念</h2><h4 id="监督学习中的元素"><a href="#监督学习中的元素" class="headerlink" title="监督学习中的元素"></a>监督学习中的元素</h4><p>$x_i \in R^D$ :训练集中第i条记录</p>
<p><strong>模型</strong>： 根据$x_i$预测$\hat y_i$<br><a id="more"></a><br>线性模型：$\hat y_i = \sum_j \omega_jx_{ij}$（包括线性回归和逻辑回归）</p>
<p>在不同的任务中$y^i$有不同的解释：</p>
<ul>
<li>线性回归中：$y^i$是预测得分</li>
<li>逻辑回归中：$1/(1+exp(- \hat y))$是结果为正例的概率</li>
<li>其他任务，比如打分中，表示预测的分数</li>
</ul>
<p><strong>参数</strong>：我们需要从数据中习得的东西</p>
<p>线性模型：$\Theta = \lbrace\omega_j|j=1,…,d\rbrace$</p>
<h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><p>$object(\Theta) = L(\Theta) + \Omega(\Theta)$</p>
<p><strong>训练集的损失</strong>：$L = \sum_{i=1}^nl(y_i, \hat y_i)$</p>
<ul>
<li>平方损失：$l(y_i, \hat y_i) = (y_i - \hat y_i)^2$</li>
<li>Logistic损失：$l(y_i, \hat y_i) = y_iln(1+e^{-y^i}) + (1+e^{\hat y_i})$</li>
</ul>
<p><strong>正则化项</strong>：描述模型结构复杂程度</p>
<ul>
<li>L2正则化：$\Omega(\omega) = \lambda||\omega||^2$</li>
<li>L1正则化：$\Omega(\omega) = \lambda||\omega||_1$ </li>
</ul>
<h4 id="已知的线性回归目标函数"><a href="#已知的线性回归目标函数" class="headerlink" title="已知的线性回归目标函数"></a>已知的线性回归目标函数</h4><p><strong>岭回归</strong>：$\sum_{i=1}^n(y_i-\omega^Tx_i)^2 - \lambda||\omega||^2$</p>
<p>​    线性模型，平方损失， L2正则化</p>
<p><strong>Lasso回归：</strong>$\sum_{i=1}^n(y_i-\omega^Tx_i)^2 - \lambda||\omega||_1$</p>
<p>​    线性回归， 平方损失， L1正则化</p>
<p><strong>Logistic回归：</strong>$\sum_{i=1}^n[ y_iln(1+e^{-\omega^Tx_i})+ (1+e^{\omega^Tx_i})^2] - \lambda||\omega||^2$</p>
<p>​    线性回归， logistic损失， L2正则化</p>
<p>模型，参数，目标之间的概念分离也为带来了工程上的好处。</p>
<h4 id="方差与偏差的权衡"><a href="#方差与偏差的权衡" class="headerlink" title="方差与偏差的权衡"></a>方差与偏差的权衡</h4><ul>
<li><p>偏差.</p>
<p>这里的偏指的是 <strong>偏离</strong> , 那么它偏离了什么到导致了误差? 潜意识上, 当谈到这个词时, 我们可能会认为它是偏离了某个潜在的 “标准”, 而这里这个 “标准” 也就是真实情况 (ground truth). 在分类任务中, 这个 “标准” 就是真实标签 (label).</p>
</li>
<li><p>方差.</p>
<p>很多人应该都还记得在统计学中, 一个随机变量的方差描述的是它的离散程度, 也就是该随机变量在其期望值附近的 <strong>波动程度</strong> . </p>
</li>
</ul>
<p>先从下面的靶心图来对方差与偏差有个直观的感受：</p>
<p><img src="https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-diagram.png" alt="img"></p>
<p>假设红色的靶心区域是学习算法完美的正确预测值, 蓝色点为每个数据集所训练出的模型对样本的预测值, 当我们从靶心逐渐向外移动时, 预测效果逐渐变差.</p>
<p>很容易看出有两副图中蓝色点比较集中, 另外两幅中比较分散, 它们描述的是方差的两种情况. 比较集中的属于方差小的, 比较分散的属于方差大的情况.</p>
<p>再从蓝色点与红色靶心区域的位置关系, 靠近红色靶心的属于偏差较小的情况, 远离靶心的属于偏差较大的情况.</p>
<p><img src="https://liuchengxu.github.io/blog-cn/assets/images/posts/bulls-eye-label-diagram.png" alt="img"></p>
<p>[本节偏差方差解释部分来自博客]<a href="https://blog.csdn.net/simple_the_best/article/details/71167786" target="_blank" rel="noopener">https://blog.csdn.net/simple_the_best/article/details/71167786</a></p>
<p>将目标函数分为损失函数和正则化项的原因在于：</p>
<ul>
<li><p>优化训练损失会激励预测模型</p>
<p>​    对训练数据集的良好拟合，至少可以让模型在训练数据上表现良好，有可能更接近数据的底层分布</p>
</li>
<li><p>优化正则化项有利于产生简单的模型</p>
<p>​    简单的模型在预测数据上方差更小，使模型可靠性更强</p>
</li>
</ul>
<h2 id="二、回归树和集成方法"><a href="#二、回归树和集成方法" class="headerlink" title="二、回归树和集成方法"></a>二、回归树和集成方法</h2><p><strong>回归树（CART,又叫分类回归树）</strong></p>
<ul>
<li>像决策树一样制定规则</li>
<li>每个叶节点包含一个值</li>
</ul>
<p>例子：判断是否喜欢电脑游戏</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-5-10/74239098.jpg" alt=""></p>
<p><strong>回归树集成：最终的得分是每个树得分的和</strong><br><img src="http://p5s7d12ls.bkt.clouddn.com/18-5-10/14929391.jpg" alt=""></p>
<p><strong>树集成方法 ——模型和参数</strong></p>
<ul>
<li><p>模型：假设我们有K个树</p>
<p>$\hat y_i = \sum_{k=1}^Kf_k(x_i)  ,  f_k\in F$，F是包含所有回归树的函数空间</p>
</li>
</ul>
<p>考虑：回归树是将属性对应为得分的函数</p>
<ul>
<li>参数<ul>
<li>包括每棵树的结构和叶子结点的得分</li>
<li>或简单的被当作参数适用：$\Theta = \lbrace f_1, f_2,…,f_K\rbrace$</li>
<li>我们学习的是functions(trees)而不是$R^d$中的权重</li>
</ul>
</li>
</ul>
<h4 id="在单变量上学习回归树"><a href="#在单变量上学习回归树" class="headerlink" title="在单变量上学习回归树"></a>在单变量上学习回归树</h4><ul>
<li>如何学习目标函数？</li>
</ul>
<ul>
<li>定义目标函数(loss， regularization),然后优化它。</li>
<li>比如：<ul>
<li>考虑在单输入t = (time)上的回归树</li>
<li>想要预测是否想在t时刻听浪漫音乐</li>
</ul>
</li>
</ul>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-5-10/86261125.jpg" alt=""></p>
<ul>
<li><p>需要学习的东西：</p>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-5-10/41162967.jpg" alt=""></p>
</li>
<li><p>单变量回归树（阶梯函数）的目标：</p>
<ul>
<li>训练损失：函数对点的拟合程度如何？</li>
<li>结构损失：如何定义函数的结构复杂度？<ul>
<li>分裂点的数量，每段高度的L2正则化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-5-11/75298105.jpg" alt=""></p>
<h4 id="集成回归树的目标函数"><a href="#集成回归树的目标函数" class="headerlink" title="集成回归树的目标函数"></a>集成回归树的目标函数</h4><ul>
<li><p>模型：假设我们有K棵树</p>
<p>$\hat y_i = \sum_{k=1}^Kf_k(x_i)  ,  f_k\in F$</p>
</li>
<li><p>目标函数：</p>
<p>$Obj = \sum_{i=1}^nl(y,\hat y_i) + \sum_{k=1}^K\Omega(k)$</p>
</li>
<li><p>定义$\Omega$可能的方式：</p>
<ul>
<li>树的节点数，深度</li>
<li>L2正规项叶子权重的</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="客观性与启发式"><a href="#客观性与启发式" class="headerlink" title="客观性与启发式"></a>客观性与启发式</h4><ul>
<li>当谈及决策树时，经常是启发式的<ul>
<li>同个信息增益进行分割</li>
<li>剪枝</li>
<li>最大化树深度</li>
<li>平滑叶节点</li>
</ul>
</li>
<li>大多数启发式方法都符合目标，采取正式的（客观）观点让我们知道我们正在学习什么：<ul>
<li>信息增益 -》减少训练损失</li>
<li>剪枝 -》根据节点正则化</li>
<li>最大化树深度 -》函数空间的约束</li>
<li>平滑叶子value -》 叶子权重的L2正则化</li>
</ul>
</li>
</ul>
<h4 id="回归树不仅仅是为了回归问题"><a href="#回归树不仅仅是为了回归问题" class="headerlink" title="回归树不仅仅是为了回归问题"></a>回归树不仅仅是为了回归问题</h4><ul>
<li><p>集成回归树定义了如何获取得分，可被用于分类，回归，打分等场景，取决于如何定义目标函数：</p>
<ul>
<li>使用平方损失：梯度提升回归树（common gradient boosted machine）</li>
<li>使用Logistic损失：LogitBoost</li>
</ul>
<p>​</p>
</li>
</ul>
<h3 id="三、Gradient-Boosting"><a href="#三、Gradient-Boosting" class="headerlink" title="三、Gradient Boosting"></a>三、Gradient Boosting</h3><ul>
<li><p>目标函数：</p>
<p>​    $Obj = \sum_{i=1}^nl(y,\hat y_i) + \sum_{k=1}^K\Omega(f_k), f_k\in F$</p>
</li>
<li><p>我们不能使用梯度下降法来得到f，因为他们是树而不是简单的数值向量。</p>
</li>
<li><p>解决办法：<em>additive training</em>(boosting)</p>
<ul>
<li>从常量预测开始， 每次增加一个新的函数</li>
</ul>
</li>
</ul>
<p><img src="http://p5s7d12ls.bkt.clouddn.com/18-5-11/97010343.jpg" alt=""></p>
<h4 id="模型学习：additive-training"><a href="#模型学习：additive-training" class="headerlink" title="模型学习：additive training"></a>模型学习：additive training</h4><p>现在还剩下一个问题，我们如何选择每一轮加入什么f呢？答案是非常直接的，选取一个f来使得我们的目标函数尽量最大地降低。<br><a href="http://dataunion.org/wp-content/uploads/2015/04/510.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/510.png" alt="5"></a><br>这个公式可能有些过于抽象，我们可以考虑当l是平方误差的情况。这个时候我们的目标可以被写成下面这样的二次函数9：<br><a href="http://dataunion.org/wp-content/uploads/2015/04/61.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/61.png" alt="6"></a><br>更加一般的，对于不是平方误差的情况，我们会采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行这一步的计算。<br><a href="http://dataunion.org/wp-content/uploads/2015/04/72.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/72.png" alt="7"></a><br>当我们把常数项移除之后，我们会发现如下一个比较统一的目标函数。这一个目标函数有一个非常明显的特点，它只依赖于每个数据点的在误差函数上的一阶导数和二阶导数。有人可能会问，这个材料似乎比我们之前学过的决策树学习难懂。为什么要花这么多力气来做推导呢？<br><a href="http://dataunion.org/wp-content/uploads/2015/04/82.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/82.png" alt="8"></a></p>
<ul>
<li>因为这样做使得我们可以很清楚地理解整个目标是什么，并且一步一步推导出如何进行树的学习。</li>
<li>这一个抽象的形式对于实现机器学习工具也是非常有帮助的。传统的GBDT可能大家可以理解如优化平法a残差，但是这样一个形式包含可所有可以求导的目标函数。也就是说有了这个形式，我们写出来的代码可以用来求解包括回归，分类和排序的各种问题，<strong>正式的推导可以使得机器学习的工具更加一般</strong>。</li>
</ul>
<h4 id="树的复杂度"><a href="#树的复杂度" class="headerlink" title="树的复杂度"></a>树的复杂度</h4><p>到目前为止我们讨论了目标函数中训练误差的部分。接下来我们讨论如何定义树的复杂度。我们先对于f的定义做一下细化，把树拆分成结构部分q和叶子权重部分w。下图是一个具体的例子。结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。<br><a href="http://dataunion.org/wp-content/uploads/2015/04/94.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/94.png" alt="9"></a><br>当我们给定了如上定义之后，我们可以定义一棵树的复杂度如下。这个复杂度包含了一棵树里面节点的个数，以及每个树叶子节点上面输出分数的$L2$模平方。当然这不是唯一的一种定义方式，不过这一定义方式学习出的树效果一般都比较不错。下图还给出了复杂度计算的一个例子。</p>
<p><a href="http://dataunion.org/wp-content/uploads/2015/04/102.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/102.png" alt="10"></a></p>
<h4 id="重新审视目标"><a href="#重新审视目标" class="headerlink" title="重新审视目标"></a>重新审视目标</h4><ul>
<li><p>定义叶子j上面样本集合$ I_j =\lbrace i|q(x_i)=j\rbrace$</p>
</li>
<li><p>根据叶子重新组织目标</p>
<p><a href="http://dataunion.org/wp-content/uploads/2015/04/a.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/a-1024x199.png" alt="a"></a></p>
</li>
<li><p>由二次函数零点定理,有:</p>
<p>​    $argmin_x$  $Gx+\frac {1}{2}Hx^2 = -\frac {G}{H}, H&gt;0$</p>
</li>
<li><p>二次函数的最低点性质有: $min_x$ $Gx+\frac {1}{2}Hx^2 = -\frac {1}{2}G^2/H$</p>
</li>
<li><p>可以定义</p>
<p>​    <a href="http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163401.png" alt="QQ截图20150423163401"></a></p>
<p>那么这个目标函数可以进一步改写成如下的形式<a href="http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163423.png" alt="QQ截图20150423163423"></a></p>
<p>假设我们已经知道树的结构q(x)，我们可以通过这个目标函数来求解出最优的w，以及最好的w对应的目标函数最大的增益<a href="http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/QQ截图20150423163446.png" alt="QQ截图20150423163446"></a></p>
</li>
</ul>
<h4 id="结构分数的计算"><a href="#结构分数的计算" class="headerlink" title="结构分数的计算"></a>结构分数的计算</h4><p>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)。你可以认为这个就是类似吉尼系数一样更加一般的对于树结构进行打分的函数。下面是一个具体的打分函数计算的例子<br><a href="http://dataunion.org/wp-content/uploads/2015/04/143.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/143.png" alt="1"></a></p>
<h4 id="枚举所有不同树结构"><a href="#枚举所有不同树结构" class="headerlink" title="枚举所有不同树结构"></a>枚举所有不同树结构</h4><ul>
<li><p>枚举所有可能的树结构</p>
</li>
<li><p>利用得分等式,计算q的结构分数</p>
<p>​    $Obj = -\frac{1}{2}\sum_{j=1}^T \frac{G_j^2}{H_j+\lambda} + \gamma T$</p>
</li>
<li><p>找到最好的树结构,使用最优的叶子权重 $\omega_j^*=-\frac{G_i}{H_j+\lambda}$</p>
</li>
<li><p>但是,可能有无穷尽的树结构,</p>
</li>
</ul>
<h4 id="树结构的贪心法"><a href="#树结构的贪心法" class="headerlink" title="树结构的贪心法"></a>树结构的贪心法</h4><p>常用的方法是贪心法，每一次尝试去对已有的叶子加入一个分割。</p>
<ul>
<li>从深度为0的树开始</li>
<li>对每一个叶子节点尝试进行分割,我们可以获得的增益可以由如下公式计算</li>
</ul>
<p><a href="http://www.52cs.org/wp-content/uploads/2015/04/12.png" target="_blank" rel="noopener"></a><a href="http://dataunion.org/wp-content/uploads/2015/04/image1.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/image1.png" alt="image1"></a><br>对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？</p>
<p>假设我们要枚举所有 x&lt;a 这样的条件，对于某个特定的分割a我们要计算a左边和右边的导数和。<br><a href="http://dataunion.org/wp-content/uploads/2015/04/133.png" target="_blank" rel="noopener"><img src="http://dataunion.org/wp-content/uploads/2015/04/133.png" alt="13"></a><br>我们可以发现对于所有的a，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用上面的公式计算每个分割方案的分数就可以了。</p>
<p>观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic而进行的操作了。</p>
<h4 id="总操作概述"><a href="#总操作概述" class="headerlink" title="总操作概述"></a>总操作概述</h4><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-5-28/19435924.jpg" alt=""></p>
<p>讲到这里文章进入了尾声，虽然有些长，希望对大家有所帮助，这篇文章介绍了如何通过目标函数优化的方法比较严格地推导出boosted tree的学习。因为有这样一般的推导，得到的算法可以直接应用到回归，分类排序等各个应用场景中去。</p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=本文翻译自陈天奇大神的英文ppt,喜欢看"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = '//harold.me/2018/05/28/BoostTrees简介/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
