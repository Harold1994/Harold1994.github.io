<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Kafka中Consumer的多线程实现 | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/05/27/Kafka中Consumer的多线程实现/">Kafka中Consumer的多线程实现</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">May 27 2018</p>
  </section>

  <section class="article-entry">
    <p>【转自：<a href="http://www.cnblogs.com/huxi2b/p/6124937.html】" target="_blank" rel="noopener">http://www.cnblogs.com/huxi2b/p/6124937.html】</a></p>
<p>Kafka 0.9版本开始推出了Java版本的consumer，优化了coordinator的设计以及摆脱了对zookeeper的依赖。社区最近也在探讨正式用这套consumer API替换Scala版本的consumer的计划。鉴于目前这方面的资料并不是很多，本文将尝试给出一个利用KafkaConsumer编写的多线程消费者实例，希望对大家有所帮助。</p>
<a id="more"></a>    这套API最重要的入口就是KafkaConsumer(o.a.k.clients.consumer.KafkaConsumer)，普通的单线程使用方法官网API已有介绍，这里不再赘述了。因此，我们直奔主题——讨论一下如何创建多线程的方式来使用KafkaConsumer。KafkaConsumer和KafkaProducer不同，后者是线程安全的，因此我们鼓励用户在多个线程中共享一个KafkaProducer实例，这样通常都要比每个线程维护一个KafkaProducer实例效率要高。但对于KafkaConsumer而言，它不是线程安全的，所以实现多线程时通常由两种实现方法：<br><br>1 每个线程维护一个KafkaConsumer<br><br><img src="https://images2015.cnblogs.com/blog/735367/201612/735367-20161202105906443-1609157006.png" alt="img"><br><br>2  维护一个或多个KafkaConsumer，同时维护多个事件处理线程(worker thread)<br><br><img src="https://images2015.cnblogs.com/blog/735367/201612/735367-20161202110008787-550483601.png" alt="img"><br><br>当然，这种方法还可以有多个变种：比如每个worker线程有自己的处理队列。consumer根据某种规则或逻辑将消息放入不同的队列。不过总体思想还是相同的，故这里不做过多展开讨论了。<br><br>　　下表总结了两种方法的优缺点：<br><br>|                                              | 优点                                                         | 缺点                                                         |<br>| ——————————————– | ———————————————————— | ———————————————————— |<br>| 方法1(每个线程维护一个KafkaConsumer)         | 方便实现速度较快，因为不需要任何线程间交互易于维护分区内的消息顺序 | 更多的TCP连接开销(每个线程都要维护若干个TCP连接)consumer数受限于topic分区数，扩展性差频繁请求导致吞吐量下降线程自己处理消费到的消息可能会导致超时，从而造成rebalance |<br>| 方法2 (单个(或多个)consumer，多个worker线程) | 可独立扩展consumer数和worker数，伸缩性好                     | 实现麻烦通常难于维护分区内的消息顺序处理链路变长，导致难以保证提交位移的语义正确性 |<br><br><br><br>下面我们分别实现这两种方法。需要指出的是，下面的代码都是最基本的实现，并没有考虑很多编程细节，比如如何处理错误等。<br><br><strong>方法1</strong><br><br><strong>ConsumerRunnable类</strong><br><br><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"> 2 import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"> 3 import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"> 4 </span><br><span class="line"> 5 import java.util.Arrays;</span><br><span class="line"> 6 import java.util.Properties;</span><br><span class="line"> 7 </span><br><span class="line"> 8 public class ConsumerRunnable implements Runnable &#123;</span><br><span class="line"> 9 </span><br><span class="line">10     // 每个线程维护私有的KafkaConsumer实例</span><br><span class="line">11     private final KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line">12 </span><br><span class="line">13     public ConsumerRunnable(String brokerList, String groupId, String topic) &#123;</span><br><span class="line">14         Properties props = new Properties();</span><br><span class="line">15         props.put(&quot;bootstrap.servers&quot;, brokerList);</span><br><span class="line">16         props.put(&quot;group.id&quot;, groupId);</span><br><span class="line">17         props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);        //本例使用自动提交位移</span><br><span class="line">18         props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line">19         props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);</span><br><span class="line">20         props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">21         props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">22         this.consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class="line">23         consumer.subscribe(Arrays.asList(topic));   // 本例使用分区副本自动分配策略</span><br><span class="line">24     &#125;</span><br><span class="line">25 </span><br><span class="line">26     @Override</span><br><span class="line">27     public void run() &#123;</span><br><span class="line">28         while (true) &#123;</span><br><span class="line">29             ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);   // 本例使用200ms作为获取超时时间</span><br><span class="line">30             for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">31                 // 这里面写处理消息的逻辑，本例中只是简单地打印消息</span><br><span class="line">32                 System.out.println(Thread.currentThread().getName() + &quot; consumed &quot; + record.partition() +</span><br><span class="line">33                         &quot;th message with offset: &quot; + record.offset());</span><br><span class="line">34             &#125;</span><br><span class="line">35         &#125;</span><br><span class="line">36     &#125;</span><br><span class="line">37 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>ConsumerGroup类</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.my.kafka.test;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.ArrayList;</span><br><span class="line"> 4 import java.util.List;</span><br><span class="line"> 5 </span><br><span class="line"> 6 public class ConsumerGroup &#123;</span><br><span class="line"> 7 </span><br><span class="line"> 8     private List&lt;ConsumerRunnable&gt; consumers;</span><br><span class="line"> 9 </span><br><span class="line">10     public ConsumerGroup(int consumerNum, String groupId, String topic, String brokerList) &#123;</span><br><span class="line">11         consumers = new ArrayList&lt;&gt;(consumerNum);</span><br><span class="line">12         for (int i = 0; i &lt; consumerNum; ++i) &#123;</span><br><span class="line">13             ConsumerRunnable consumerThread = new ConsumerRunnable(brokerList, groupId, topic);</span><br><span class="line">14             consumers.add(consumerThread);</span><br><span class="line">15         &#125;</span><br><span class="line">16     &#125;</span><br><span class="line">17 </span><br><span class="line">18     public void execute() &#123;</span><br><span class="line">19         for (ConsumerRunnable task : consumers) &#123;</span><br><span class="line">20             new Thread(task).start();</span><br><span class="line">21         &#125;</span><br><span class="line">22     &#125;</span><br><span class="line">23 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>ConsumerMain类</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1 public class ConsumerMain &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     public static void main(String[] args) &#123;</span><br><span class="line"> 4         String brokerList = &quot;localhost:9092&quot;;</span><br><span class="line"> 5         String groupId = &quot;testGroup1&quot;;</span><br><span class="line"> 6         String topic = &quot;test-topic&quot;;</span><br><span class="line"> 7         int consumerNum = 3;</span><br><span class="line"> 8 </span><br><span class="line"> 9         ConsumerGroup consumerGroup = new ConsumerGroup(consumerNum, groupId, topic, brokerList);</span><br><span class="line">10         consumerGroup.execute();</span><br><span class="line">11     &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>方法2</strong></p>
<p><strong>Worker类</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"> 2 </span><br><span class="line"> 3 public class Worker implements Runnable &#123;</span><br><span class="line"> 4 </span><br><span class="line"> 5     private ConsumerRecord&lt;String, String&gt; consumerRecord;</span><br><span class="line"> 6 </span><br><span class="line"> 7     public Worker(ConsumerRecord record) &#123;</span><br><span class="line"> 8         this.consumerRecord = record;</span><br><span class="line"> 9     &#125;</span><br><span class="line">10 </span><br><span class="line">11     @Override</span><br><span class="line">12     public void run() &#123;</span><br><span class="line">13         // 这里写你的消息处理逻辑，本例中只是简单地打印消息</span><br><span class="line">14         System.out.println(Thread.currentThread().getName() + &quot; consumed &quot; + consumerRecord.partition()</span><br><span class="line">15             + &quot;th message with offset: &quot; + consumerRecord.offset());</span><br><span class="line">16     &#125;</span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>ConsumerHandler类</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> 1 import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"> 2 import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"> 3 import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"> 4 </span><br><span class="line"> 5 import java.util.Arrays;</span><br><span class="line"> 6 import java.util.Properties;</span><br><span class="line"> 7 import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"> 8 import java.util.concurrent.ExecutorService;</span><br><span class="line"> 9 import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">10 import java.util.concurrent.TimeUnit;</span><br><span class="line">11 </span><br><span class="line">12 public class ConsumerHandler &#123;</span><br><span class="line">13 </span><br><span class="line">14     // 本例中使用一个consumer将消息放入后端队列，你当然可以使用前一种方法中的多实例按照某张规则同时把消息放入后端队列</span><br><span class="line">15     private final KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line">16     private ExecutorService executors;</span><br><span class="line">17 </span><br><span class="line">18     public ConsumerHandler(String brokerList, String groupId, String topic) &#123;</span><br><span class="line">19         Properties props = new Properties();</span><br><span class="line">20         props.put(&quot;bootstrap.servers&quot;, brokerList);</span><br><span class="line">21         props.put(&quot;group.id&quot;, groupId);</span><br><span class="line">22         props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class="line">23         props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line">24         props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);</span><br><span class="line">25         props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">26         props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">27         consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class="line">28         consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">29     &#125;</span><br><span class="line">30 </span><br><span class="line">31     public void execute(int workerNum) &#123;</span><br><span class="line">32         executors = new ThreadPoolExecutor(workerNum, workerNum, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">33                 new ArrayBlockingQueue&lt;&gt;(1000), new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">34 </span><br><span class="line">35         while (true) &#123;</span><br><span class="line">36             ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);</span><br><span class="line">37             for (final ConsumerRecord record : records) &#123;</span><br><span class="line">38                 executors.submit(new Worker(record));</span><br><span class="line">39             &#125;</span><br><span class="line">40         &#125;</span><br><span class="line">41     &#125;</span><br><span class="line">42 </span><br><span class="line">43     public void shutdown() &#123;</span><br><span class="line">44         if (consumer != null) &#123;</span><br><span class="line">45             consumer.close();</span><br><span class="line">46         &#125;</span><br><span class="line">47         if (executors != null) &#123;</span><br><span class="line">48             executors.shutdown();</span><br><span class="line">49         &#125;</span><br><span class="line">50         try &#123;</span><br><span class="line">51             if (!executors.awaitTermination(10, TimeUnit.SECONDS)) &#123;</span><br><span class="line">52                 System.out.println(&quot;Timeout.... Ignore for this case&quot;);</span><br><span class="line">53             &#125;</span><br><span class="line">54         &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">55             System.out.println(&quot;Other thread interrupted this shutdown, ignore for this case.&quot;);</span><br><span class="line">56             Thread.currentThread().interrupt();</span><br><span class="line">57         &#125;</span><br><span class="line">58     &#125;</span><br><span class="line">59 </span><br><span class="line">60 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>Main类</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1 public class Main &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     public static void main(String[] args) &#123;</span><br><span class="line"> 4         String brokerList = &quot;localhost:9092,localhost:9093,localhost:9094&quot;;</span><br><span class="line"> 5         String groupId = &quot;group2&quot;;</span><br><span class="line"> 6         String topic = &quot;test-topic&quot;;</span><br><span class="line"> 7         int workerNum = 5;</span><br><span class="line"> 8 </span><br><span class="line"> 9         ConsumerHandler consumers = new ConsumerHandler(brokerList, groupId, topic);</span><br><span class="line">10         consumers.execute(workerNum);</span><br><span class="line">11         try &#123;</span><br><span class="line">12             Thread.sleep(1000000);</span><br><span class="line">13         &#125; catch (InterruptedException ignored) &#123;&#125;</span><br><span class="line">14         consumers.shutdown();</span><br><span class="line">15     &#125;</span><br><span class="line">16 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　总结一下，这两种方法或是模型都有各自的优缺点，在具体使用时需要根据自己实际的业务特点来选取对应的方法。就我个人而言，我比较推崇第二种方法以及背后的思想，即不要将很重的处理逻辑放入消费者的代码中，很多Kafka consumer使用者碰到的各种rebalance超时、coordinator重新选举、心跳无法维持等问题都来源于此。</p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=【转自：<a href="http://"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = '//harold.me/2018/05/27/Kafka中Consumer的多线程实现/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
