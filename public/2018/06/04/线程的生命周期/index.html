<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>线程的生命周期 | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/06/04/线程的生命周期/">线程的生命周期</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">June 04 2018</p>
  </section>

  <section class="article-entry">
    <p>  当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运</p>
<p>行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。<br><a id="more"></a> </p>
<ol>
<li>新建和就绪状态</li>
</ol>
<p>  当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量</p>
<p>值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。</p>
<p>  当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该</p>
<p>线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。</p>
<ol>
<li>运行和阻塞状态</li>
</ol>
<p>  如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态。</p>
<p>当发生如下情况下，线程将会进入阻塞状态：</p>
<pre><code>线程调用sleep方法主动放弃所占用的处理器资源。

线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。

线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。关于同步监视器的知识将在后面有更深入的介绍。

线程在等待某个通知(notify)。

程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。
</code></pre><p>  当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是</p>
<p>说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。</p>
<p>针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：</p>
<pre><code>调用sleep方法的线程经过了指定时间。

线程调用的阻塞式IO方法已经返回。

线程成功地获得了试图取得同步监视器。

线程正在等待某个通知时，其他线程发出了一个通知。

处于挂起状态的线程被调用了resume恢复方法。
</code></pre><p>线程状态转换图：<br><img src="https://img-blog.csdn.net/20160602105419074" alt=""></p>
<ol>
<li>线程死亡</li>
</ol>
<p>线程会以以下三种方式之一结束，结束后就处于死亡状态：</p>
<pre><code>run()方法执行完成，线程正常结束。

线程抛出一个未捕获的Exception或Error。

直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。
</code></pre>
  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=  当线程被创建并启动以后，它既不是一启"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = '//harold.me/2018/06/04/线程的生命周期/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
