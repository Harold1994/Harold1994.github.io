<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harold的博客</title>
  
  <subtitle>踏实前进,戒骄戒躁</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//harold.me/"/>
  <updated>2018-09-13T09:22:18.522Z</updated>
  <id>//harold.me/</id>
  
  <author>
    <name>李贺</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LSTM正弦函数预测</title>
    <link href="//harold.me/2018/09/12/LSTM%E6%AD%A3%E5%BC%A6%E5%87%BD%E6%95%B0%E9%A2%84%E6%B5%8B/"/>
    <id>//harold.me/2018/09/12/LSTM正弦函数预测/</id>
    <published>2018-09-12T00:47:28.000Z</published>
    <updated>2018-09-13T09:22:18.522Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">%matplotlib inline</span><br><span class="line">mpl.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">HIDDEN_SIZE=<span class="number">30</span><span class="comment">#LSTM中隐藏节点个数</span></span><br><span class="line">NUM_LAYERS=<span class="number">2</span> <span class="comment">#LSTM层数</span></span><br><span class="line"></span><br><span class="line">TIMESTEPS = <span class="number">10</span> <span class="comment">#rnn的训练序列长度</span></span><br><span class="line">TRAINING_STEPS = <span class="number">10000</span> <span class="comment">#训练轮数</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span> <span class="comment">#batch大小</span></span><br><span class="line"></span><br><span class="line">TRAINING_EXAMPLE = <span class="number">10000</span> <span class="comment">#训练数据个数</span></span><br><span class="line">TESTING_EXAMPLE = <span class="number">1000</span> <span class="comment">#测试数据个数</span></span><br><span class="line">SAMPLE_GAP = <span class="number">0.01</span> <span class="comment">#采样间隔</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_data</span><span class="params">(seq)</span>:</span></span><br><span class="line">    X = []</span><br><span class="line">    Y = []</span><br><span class="line">    <span class="comment">#用sin函数前TIMESTEPS个点的信息，预测第i+TIMESTEPS的值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)-TIMESTEPS):</span><br><span class="line">        X.append([seq[i:i+TIMESTEPS]])</span><br><span class="line">        Y.append([seq[i + TIMESTEPS]])</span><br><span class="line">    <span class="keyword">return</span> np.array(X, dtype=np.float32), np.array(Y, np.float32)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lstm_model</span><span class="params">(X,y,istraining)</span>:</span></span><br><span class="line">    <span class="comment">#使用多层LSTM结构</span></span><br><span class="line">    cell = tf.nn.rnn_cell.MultiRNNCell([</span><br><span class="line">        tf.nn.rnn_cell.BasicLSTMCell(HIDDEN_SIZE)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(NUM_LAYERS)])</span><br><span class="line">    <span class="comment">#outputs是最上层LSTM每一步输出的结果，维度是[batch_size, time, HODDEN_SIZE],这里只关心最后的结果</span></span><br><span class="line">    outputs,_ = tf.nn.dynamic_rnn(cell, X, dtype=tf.float32)</span><br><span class="line">    output = outputs[:,<span class="number">-1</span>,:]</span><br><span class="line">    <span class="comment">#全连接层计算结果</span></span><br><span class="line">    predictions = tf.contrib.layers.fully_connected(</span><br><span class="line">        output, <span class="number">1</span>, activation_fn=<span class="keyword">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> istraining:</span><br><span class="line">        <span class="keyword">return</span> predictions, <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计算损失函数</span></span><br><span class="line">    loss = tf.losses.mean_squared_error(labels=y, predictions=predictions)</span><br><span class="line">    </span><br><span class="line">    train_op = tf.contrib.layers.optimize_loss(</span><br><span class="line">        loss,tf.train.get_global_step(),</span><br><span class="line">        optimizer=<span class="string">'Adagrad'</span>,learning_rate=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> predictions, loss, train_op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(sess, train_X, train_Y)</span>:</span></span><br><span class="line">    <span class="comment">#将训练数据以数据集的方式提供给计算图</span></span><br><span class="line">    ds = tf.data.Dataset.from_tensor_slices((train_X, train_Y))<span class="comment">#作用是切分传入Tensor的第一个维度，生成相应的dataset。</span></span><br><span class="line">    ds = ds.repeat().shuffle(<span class="number">1000</span>).batch(BATCH_SIZE)</span><br><span class="line">    <span class="comment">#实例化了一个Iterator，这个Iterator是一个“one shot iterator”，即只能从头到尾读取一次</span></span><br><span class="line">    X,y = ds.make_one_shot_iterator().get_next()</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"model"</span>):</span><br><span class="line">        predictions, loss, train_op = lstm_model(X,y,<span class="keyword">True</span>)</span><br><span class="line">    </span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(TRAINING_STEPS):</span><br><span class="line">        _,l = sess.run([train_op,loss])</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"training step: "</span> + str(i) + <span class="string">", loss: "</span> + str(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_eval</span><span class="params">(sess, test_X, test_Y)</span>:</span></span><br><span class="line">    ds = tf.data.Dataset.from_tensor_slices((test_X, test_Y))</span><br><span class="line">    ds=ds.batch(<span class="number">1</span>)</span><br><span class="line">    X,y = ds.make_one_shot_iterator().get_next()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"model"</span>, reuse=<span class="keyword">True</span>):</span><br><span class="line">        prediction, _,_ = lstm_model(X,[<span class="number">0.0</span>],<span class="keyword">False</span>)</span><br><span class="line">        predictions = []</span><br><span class="line">        labels=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(TESTING_EXAMPLE):</span><br><span class="line">            p,l = sess.run([prediction,y]) </span><br><span class="line">            predictions.append(p)</span><br><span class="line">            labels.append(l)</span><br><span class="line">        predictions=np.array(predictions).squeeze()</span><br><span class="line">        labels =  np.array(labels).squeeze()</span><br><span class="line">        rmse = np.sqrt(((predictions-labels)**<span class="number">2</span>).mean(axis=<span class="number">0</span>))</span><br><span class="line">        print(<span class="string">"MRSE is : %f"</span> % rmse)</span><br><span class="line"></span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot(predictions, label=<span class="string">"predictions"</span>)</span><br><span class="line">        plt.plot(labels, label = <span class="string">"real_sin"</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#用正弦函数产生数据集</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line">test_start =  (TRAINING_EXAMPLE + TIMESTEPS)*SAMPLE_GAP</span><br><span class="line">test_end = test_start+(TESTING_EXAMPLE+TIMESTEPS)*SAMPLE_GAP</span><br><span class="line">train_X , train_Y = generate_data(np.sin(np.linspace(</span><br><span class="line"><span class="number">0</span>,test_start,TRAINING_EXAMPLE+TIMESTEPS, dtype=np.float32)))</span><br><span class="line">test_X , test_Y = generate_data(np.sin(np.linspace(</span><br><span class="line">test_start,test_end,TESTING_EXAMPLE+TIMESTEPS, dtype=np.float32)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    train(sess, train_X, train_Y)</span><br><span class="line">    run_eval(sess, test_X, test_Y)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="机器学习" scheme="//harold.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="tensorflow" scheme="//harold.me/tags/tensorflow/"/>
    
      <category term="深度学习" scheme="//harold.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow——模型持久化</title>
    <link href="//harold.me/2018/07/16/Tensorflow%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>//harold.me/2018/07/16/Tensorflow——模型持久化/</id>
    <published>2018-07-16T12:30:48.000Z</published>
    <updated>2018-09-13T09:22:18.526Z</updated>
    
    <content type="html"><![CDATA[<p>​    前一篇MNIST数字数字识别的代码在训练完成之后就直接退出了，并没有将训练得到的模型保存下来方便下次直接使用，为了让训练结果可复用，需要将训练得到的神经网络模型持久化。</p><h4 id="一、持久化代码设计"><a href="#一、持久化代码设计" class="headerlink" title="一、持久化代码设计"></a>一、持久化代码设计</h4><p>ts提供了tf.train.Save类来还原一个神经网络,下面实现了持久化一个简单的tf模型，虽然只指定了一个文件路径，但是在文件目录下会出现三个文件，因为tf将计算图和图上参数取值分开保存。</p><a id="more"></a>     <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">v1 = tf.Variable(tf.constant(<span class="number">1.0</span>, shape=[<span class="number">1</span>]), name=<span class="string">"v1"</span>)</span><br><span class="line">v2 = tf.Variable(tf.constant(<span class="number">2.0</span>, shape=[<span class="number">1</span>]), name=<span class="string">"v2"</span>)</span><br><span class="line">result = v1 + v2</span><br><span class="line"></span><br><span class="line">init_op = tf.initialize_all_variables()</span><br><span class="line"><span class="comment">#用于保存模型</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    saver.save(sess, <span class="string">"/data/model/model.ckpt"</span>)</span><br></pre></td></tr></table></figure><p>下面演示如何加载模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tf.reset_default_graph()</span><br><span class="line">v1 = tf.Variable(tf.constant(<span class="number">3.0</span>, shape=[<span class="number">1</span>]), name=<span class="string">"v1"</span>)<span class="comment">#将v1设为3.0并不影响最后的结果为3.0</span></span><br><span class="line">v2 = tf.Variable(tf.constant(<span class="number">2.0</span>, shape=[<span class="number">1</span>]), name=<span class="string">"v2"</span>)</span><br><span class="line">result = v1 + v2</span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment">#加载模型，通过已保存模型中的变量值来计算加法</span></span><br><span class="line">    saver.restore(sess, <span class="string">"/data/model/model.ckpt"</span>)</span><br><span class="line">    print(sess.run(result))<span class="comment">#[3.]</span></span><br></pre></td></tr></table></figure><p>加载的代码与保存的代码相比只是少了运行变量初始化的过程，而是将变量的值通过已保存的模型加载进来.</p><blockquote><p>注：在本来的代码中没有第一句<code>tf.reset_default_graph()</code>会报错Key v1_1 not found in checkpoint，</p><p>原因： 保存和加载在前后进行，在前后两次定义了<code>v1= tf.Variable(xxx,name=”v1”)</code></p><p>相当于 在TensorFlow 图的堆栈创建了两次 name = “v1” 的变量，第二个（第n个）的实际 name 会变成 “v1_1” ，之后我们在保存 checkpoint 中实际搜索的是 “v1_1” 这个变量 而不是 “v1” ，因此就会出错。</p><p>解决方案：<br>在加载过程中，定义 name 相同的变量前面加 <code>tf.reset_default_graph()</code> 清除默认图的堆栈，并设置全局图为默认图</p></blockquote><p>也可以直接加载已经持久化的图,以下代码默认加载了ts计算图上定义的全部变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接加载持久化的图</span></span><br><span class="line">saver = tf.train.import_meta_graph(</span><br><span class="line">    <span class="string">"/data/model/model.ckpt.meta"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">"/data/model/model.ckpt"</span>)</span><br><span class="line">    print(sess.run(tf.get_default_graph().get_tensor_by_name(<span class="string">"add:0"</span>)))</span><br></pre></td></tr></table></figure><p>有时可能只需要保存或加载部分变量，比如神经网络前几层的参数，为保存或加载部分变量,声明tf.train.Saver类时可以提供一个需要保存或加载的列表。ts还支持在保存或加载时给变量重命名，可以通过字典将模型保存时的变量名和需要加载的变量联系在一起，这样可以方便使用滑动平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">v1 = tf.Variable(tf.constant(<span class="number">1.0</span>, shape=[<span class="number">1</span>]), name=<span class="string">"other-v1"</span>)</span><br><span class="line">v2 = tf.Variable(tf.constant(<span class="number">2.0</span>, shape=[<span class="number">1</span>]), name=<span class="string">"other-v2"</span>)</span><br><span class="line">result = v1 + v2</span><br><span class="line"><span class="comment">#用于保存模型</span></span><br><span class="line">saver = tf.train.Saver(&#123;<span class="string">"v1"</span>:v1,<span class="string">"v2"</span>:v2&#125;)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    <span class="comment">#模型一般后缀为ckpt</span></span><br><span class="line">    saver.save(sess, <span class="string">"/data/model/model.ckpt"</span>)</span><br><span class="line">    print(sess.run(result))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">v = tf.Variable(<span class="number">0</span>, dtype=tf.float32, name=<span class="string">"v"</span>)</span><br><span class="line"><span class="comment">#在没有申明滑动平均模型时只有一个变量v,所以下面语句只会输出“v：0”</span></span><br><span class="line"><span class="keyword">for</span> variables <span class="keyword">in</span> tf.global_variables():</span><br><span class="line">    print(variables.name)<span class="comment">#v:0</span></span><br><span class="line"></span><br><span class="line">ema = tf.train.ExponentialMovingAverage(<span class="number">0.99</span>)</span><br><span class="line">maintain_average_op = ema.apply(tf.global_variables())</span><br><span class="line"><span class="comment">#申明滑动平均模型之后，ts会自动生成一个影子变量v/ExponentialMoving Average</span></span><br><span class="line"><span class="keyword">for</span> variables <span class="keyword">in</span> tf.global_variables():</span><br><span class="line">    print(variables.name)</span><br><span class="line">    <span class="comment">#v:0</span></span><br><span class="line">    <span class="comment">#v/ExponentialMovingAverage:0</span></span><br><span class="line"></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    sess.run(tf.assign(v,<span class="number">10</span>))</span><br><span class="line">    sess.run(maintain_average_op)</span><br><span class="line">    saver.save(sess, <span class="string">"/data/model/model.ckpt"</span>)</span><br><span class="line">    print(sess.run([v, ema.average(v)]))<span class="comment">#[10.0, 0.099999905]</span></span><br></pre></td></tr></table></figure><p>ts为了方便加载时重命名滑动平均值，tf.train.ExponentialMovingAverage类提供了variables_to_restore函数来生成tf.train.Saver类所需要的变量重命名字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.reset_default_graph()</span><br><span class="line">v = tf.Variable(<span class="number">0</span>, dtype=tf.float32, name=<span class="string">"v"</span>)</span><br><span class="line">ema = tf.train.ExponentialMovingAverage(<span class="number">0.99</span>)</span><br><span class="line">print(ema.variables_to_restore())</span><br><span class="line"><span class="comment">#输出：&#123;'v/ExponentialMovingAverage': &lt;tf.Variable 'v:0' shape=() dtype=float32_ref&gt;&#125;</span></span><br><span class="line"><span class="comment">#后面的Variable类代表v1</span></span><br><span class="line">saver = tf.train.Saver(ema.variables_to_restore())</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">"/data/model/model.ckpt"</span>)</span><br><span class="line">    print(sess.run(v))<span class="comment">#输出：0.99999905,即原来变量的滑动平均值</span></span><br></pre></td></tr></table></figure><p>使用tf.train.Saver会保存运行ts程序所需要的全部信息，然而有时候并不需要某些信息，ts提供了convert_variables_to_constants函数，将计算图中的变量及取值通过常量方式保存，这样整个图可以放到一个文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    <span class="comment">#导出计算图GraphDef部分，只需要这一部分就可以完成从输入层到输出层的计算</span></span><br><span class="line">    graph_def = tf.get_default_graph().as_graph_def()</span><br><span class="line">    <span class="comment">#将图中变量及取值转换为常量，去掉不必要节点，‘add’给出了需要保存的计算节点名称</span></span><br><span class="line">    output_graph_def = graph_util.convert_variables_to_constants(</span><br><span class="line">        sess, graph_def, [<span class="string">'add'</span>])</span><br><span class="line">    <span class="comment">#将模型存入文件</span></span><br><span class="line">    <span class="keyword">with</span> tf.gfile.GFile(<span class="string">"/data/model/combined_model.pb"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(output_graph_def.SerializeToString())</span><br></pre></td></tr></table></figure><p>通过下面的代码可以直接计算定义的加法运算的结果，当只需要知道计算图中某个节点的取值时，这提供了一个更加方便的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.platform <span class="keyword">import</span> gfile</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    model_filename = <span class="string">"/data/model/combined_model.pb"</span></span><br><span class="line">    <span class="comment">#将文件解析成对应的GraphDef Protocol Buffer</span></span><br><span class="line">    <span class="keyword">with</span> gfile.FastGFile(model_filename,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        graph_def = tf.GraphDef()</span><br><span class="line">        graph_def.ParseFromString(f.read())</span><br><span class="line">    <span class="comment">#将graph_def中保存的图加载到当前的图中,加载的时候给出的是张量的名称，所以是add:0</span></span><br><span class="line">    result = tf.import_graph_def(graph_def, return_elements=[<span class="string">"add:0"</span>])</span><br><span class="line">    print(sess.run(result))</span><br></pre></td></tr></table></figure><h4 id="二、重构MNIST数字识别代码"><a href="#二、重构MNIST数字识别代码" class="headerlink" title="二、重构MNIST数字识别代码"></a>二、重构MNIST数字识别代码</h4><p>现在回顾上一篇博客中的代码中的弊端：</p><ul><li>可扩展性差：计算前向传播函数需要将所有变量都传入，当神经网络结构变得更加复杂，参数更多时，程序可读性变得非常差</li><li>没有持久化训练好的模型：当程序退出时，无法使用训练好的模型，无法重用，没有在训练过程中每隔一段时间保存一次训练的中间结果，避免因死机造成的时间和资源浪费</li></ul><p>本节将重构之前的代码，将训练和测试分成两个独立的程序，是的组件更加灵活。将前向传播的过程抽象成一个单独的库函数，使得使用方便且保证训练和测试过程中的前向传播算法一定是一致的。</p><p><strong>1. mnist_inference.py：前向传播过程集神经网络参数的定义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#结构参数</span></span><br><span class="line">INPUT_NODE = <span class="number">784</span></span><br><span class="line">OUTPUT_NODE = <span class="number">10</span></span><br><span class="line">LAYER1_NODE = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight_variable</span><span class="params">(shape, regularizer)</span>:</span></span><br><span class="line">    weights = tf.get_variable(<span class="string">"weights"</span>,shape,initializer=tf.truncated_normal_initializer(stddev=<span class="number">0.1</span>))</span><br><span class="line">    <span class="comment">#将正则化损失加入losses集合</span></span><br><span class="line">    <span class="keyword">if</span> regularizer != <span class="keyword">None</span>:</span><br><span class="line">        tf.add_to_collection(<span class="string">'losses'</span>, regularizer(weights))</span><br><span class="line">    <span class="keyword">return</span> weights</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference</span><span class="params">(input_tensor, regularizer)</span>:</span></span><br><span class="line">    <span class="comment">#声明第一层变量并完成前向传播</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"layer1"</span>):</span><br><span class="line">        <span class="comment">#因为在训练或者测试中没有在同一个程序中多次调用这个函数，所以不用考虑reuse</span></span><br><span class="line">        weights = get_weight_variable(</span><br><span class="line">            [INPUT_NODE,LAYER1_NODE],regularizer)</span><br><span class="line">        biases = tf.get_variable(<span class="string">"biases"</span>,[LAYER1_NODE],initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">        layer1 = tf.nn.relu(tf.matmul(input_tensor, weights) + biases)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"layer2"</span>):</span><br><span class="line">        weights = get_weight_variable([LAYER1_NODE, OUTPUT_NODE], regularizer)</span><br><span class="line">        biases = tf.get_variable(<span class="string">"biases"</span>, [OUTPUT_NODE],initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">        layer2 = tf.nn.relu(tf.matmul(layer1,weights) + biases)</span><br><span class="line">    <span class="keyword">return</span> layer2</span><br></pre></td></tr></table></figure><p><strong>2.mnist_train.py:训练神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> mnist_inference</span><br><span class="line"></span><br><span class="line">BATCH_SIZE=<span class="number">100</span></span><br><span class="line">LEARNING_RATE_BASE=<span class="number">0.8</span></span><br><span class="line">LEARNING_RATE_DECAY=<span class="number">0.99</span></span><br><span class="line">REGULARAZTION_RATE=<span class="number">0.0001</span></span><br><span class="line">TRAINING_STEPS = <span class="number">30000</span></span><br><span class="line">MOVING_AVERAGE_DECAY=<span class="number">0.99</span></span><br><span class="line"></span><br><span class="line">MODEL_SAVE_PATH=<span class="string">"/data/model/"</span></span><br><span class="line">MODEL_NAME=<span class="string">"mnist_classify.ckpt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(mnist)</span>:</span></span><br><span class="line">    x = tf.placeholder(</span><br><span class="line">        tf.float32,[<span class="keyword">None</span>, mnist_inference.INPUT_NODE], name=<span class="string">"x-input"</span>)</span><br><span class="line">    y_ = tf.placeholder(</span><br><span class="line">        tf.float32, [<span class="keyword">None</span>, mnist_inference.OUTPUT_NODE], name=<span class="string">"y-input"</span>)</span><br><span class="line">    </span><br><span class="line">    regularizer = tf.contrib.layers.l2_regularizer(REGULARAZTION_RATE)</span><br><span class="line">    y= mnist_inference.inference(x,regularizer)</span><br><span class="line">    global_step = tf.Variable(<span class="number">0</span>,trainable=<span class="keyword">False</span>)</span><br><span class="line">    </span><br><span class="line">    variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)</span><br><span class="line">    variable_averages_op = variable_averages.apply(tf.trainable_variables())</span><br><span class="line">    </span><br><span class="line">    cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y,labels=tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">    cross_entropy_mean = tf.reduce_mean(cross_entropy)</span><br><span class="line">    loss = cross_entropy_mean + tf.add_n(tf.get_collection(<span class="string">'losses'</span>))</span><br><span class="line">    learning_rate = tf.train.exponential_decay(</span><br><span class="line">    LEARNING_RATE_BASE,</span><br><span class="line">    global_step,</span><br><span class="line">    mnist.train.num_examples/BATCH_SIZE,</span><br><span class="line">    LEARNING_RATE_DECAY)</span><br><span class="line">    train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss,global_step=global_step)</span><br><span class="line">    <span class="keyword">with</span> tf.control_dependencies([train_step, variable_averages_op]):</span><br><span class="line">        train_op = tf.no_op(name=<span class="string">"train"</span>)</span><br><span class="line">        </span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        tf.global_variables_initializer().run()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(TRAINING_STEPS):</span><br><span class="line">            xs,ys = mnist.train.next_batch(BATCH_SIZE)</span><br><span class="line">            _,loss_value,step = sess.run([train_op, loss, global_step],</span><br><span class="line">                                         feed_dict=&#123;x:xs,y_:ys&#125;)</span><br><span class="line">            <span class="keyword">if</span> i %<span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"after %d training steps, loss on training batch is %g."</span> % (step,loss_value))</span><br><span class="line">                saver.save(sess, os.path.join(MODEL_SAVE_PATH, MODEL_NAME), global_step=global_step) </span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv=None)</span>:</span></span><br><span class="line">    mnist = input_data.read_data_sets(<span class="string">"/data/"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line">    train(mnist)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    tf.app.run()</span><br></pre></td></tr></table></figure><p><strong>3.mnist_eval.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> mnist_inference</span><br><span class="line"><span class="keyword">import</span> mnist_train</span><br><span class="line"></span><br><span class="line"><span class="comment">#每10秒加载一次 模型</span></span><br><span class="line">EVAL_INTERVAL_SECS = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(mnist)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> g:</span><br><span class="line">        x = tf.placeholder(tf.float32,[<span class="keyword">None</span>, mnist_inference.INPUT_NODE], name=<span class="string">'x-input'</span>)</span><br><span class="line">        y_ = tf.placeholder(tf.float32,[<span class="keyword">None</span>,mnist_inference.OUTPUT_NODE], name=<span class="string">'y-input'</span>)</span><br><span class="line">        validate_feed = &#123;x:mnist.validation.images,</span><br><span class="line">                        y_:mnist.validation.labels&#125;</span><br><span class="line">        y = mnist_inference.inference(x,<span class="keyword">None</span>)</span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(y,<span class="number">1</span>), tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">        </span><br><span class="line">        variable_averages = tf.train.ExponentialMovingAverage(mnist_train.MOVING_AVERAGE_DECAY)</span><br><span class="line">        variables_to_restore = variable_averages.variables_to_restore()</span><br><span class="line">        saver = tf.train.Saver(variables_to_restore)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">                <span class="comment">#get_checkpoint_state会通过checkpoint文件自动找到目录中最新模型的文件名</span></span><br><span class="line">                ckpt = tf.train.get_checkpoint_state(mnist_train.MODEL_SAVE_PATH)</span><br><span class="line">                <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">                    saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line">                    global_step = ckpt.model_checkpoint_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>].split(<span class="string">'-'</span>)[<span class="number">-1</span>]</span><br><span class="line">                    accuracy_score = sess.run(accuracy, feed_dict=validate_feed)</span><br><span class="line">                    print(<span class="string">"after %s training steps, validation accuracy  %g"</span> % (global_step,accuracy_score))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"no check point found"</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            time.sleep(EVAL_INTERVAL_SECS)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv=None)</span>:</span></span><br><span class="line">    mnist = input_data.read_data_sets(<span class="string">"/data/"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line">    evaluate(mnist)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    tf.app.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    前一篇MNIST数字数字识别的代码在训练完成之后就直接退出了，并没有将训练得到的模型保存下来方便下次直接使用，为了让训练结果可复用，需要将训练得到的神经网络模型持久化。&lt;/p&gt;
&lt;h4 id=&quot;一、持久化代码设计&quot;&gt;&lt;a href=&quot;#一、持久化代码设计&quot; class=&quot;headerlink&quot; title=&quot;一、持久化代码设计&quot;&gt;&lt;/a&gt;一、持久化代码设计&lt;/h4&gt;&lt;p&gt;ts提供了tf.train.Save类来还原一个神经网络,下面实现了持久化一个简单的tf模型，虽然只指定了一个文件路径，但是在文件目录下会出现三个文件，因为tf将计算图和图上参数取值分开保存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow" scheme="//harold.me/tags/tensorflow/"/>
    
      <category term="深度学习" scheme="//harold.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow中optimizer如何实现神经网络的权重，偏移等系数的更新和梯度计算</title>
    <link href="//harold.me/2018/07/16/tensorflow%E4%B8%ADoptimizer%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%9D%83%E9%87%8D%EF%BC%8C%E5%81%8F%E7%A7%BB%E7%AD%89%E7%B3%BB%E6%95%B0%E7%9A%84%E6%9B%B4%E6%96%B0%E5%92%8C%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <id>//harold.me/2018/07/16/tensorflow中optimizer如何实现神经网络的权重，偏移等系数的更新和梯度计算/</id>
    <published>2018-07-15T16:38:07.000Z</published>
    <updated>2018-09-13T09:22:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>文章转自：<a href="https://blog.csdn.net/shenxiaoming77/article/details/77197708" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaoming77/article/details/77197708</a></p><p><strong>1.案例代码：</strong></p><p>建立抽象模型</p><a id="more"></a> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">x = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">784</span>])</span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">10</span>])  <span class="comment">#实际分布的概率值</span></span><br><span class="line"></span><br><span class="line">w = tf.Variable(tf.zeros([<span class="number">784</span>, <span class="number">10</span>]))</span><br><span class="line">b = tf.Variable(tf.zeros(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">a = tf.nn.softmax(tf.matmul(x, w) + b)  <span class="comment">#基于softmax多分类得到的预测概率</span></span><br><span class="line"><span class="comment">#定义损失函数和训练方法</span></span><br><span class="line">cross_entropy = tf.reduce_mean(-tf.reduce_sum(y * tf.log(a), reduction_indices=[<span class="number">1</span>]))  <span class="comment">#交叉熵</span></span><br><span class="line"></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)  <span class="comment">#梯度下降优化算法，学习步长为0.5</span></span><br><span class="line"></span><br><span class="line">train = optimizer.minimize(cross_entropy)  <span class="comment">#训练目标: 最小化损失函数</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">print(<span class="string">'start to run session:'</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2000</span>):</span><br><span class="line">        batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">        sess.run(train, feed_dict=&#123;x : batch_xs, y : batch_ys&#125;)</span><br><span class="line">    <span class="comment">#test trained model</span></span><br><span class="line">    correct_prediction = tf.equal(tf.argmax(a, <span class="number">1</span>), tf.argmax(y, <span class="number">1</span>))</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">    <span class="keyword">print</span> (sess.run(accuracy, feed_dict=&#123;x : mnist.test.images, y : mnist.test.labels&#125;))</span><br></pre></td></tr></table></figure><ul><li><p>第一步：</p><ul><li>神经网络模型系数w,  b 声明Variable变量，其中默认trainable=True, 那么这些variable变量就会自动放入到TensorFlow系统的<code>GraphKey.TRAINABLE_VARIABLES</code>列表中</li><li>后面进行不断的目标函数优化，梯度计算过程中，这些变量就会被新的梯度进行更新，达到权重系数更新的目标。</li></ul></li><li><p>第二步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cross_entropy = tf.reduce_mean(-tf.reduce_sum(y * tf.log(a), reduction_indices=[<span class="number">1</span>]))  <span class="comment">#交叉熵</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)  <span class="comment">#梯度下降优化算法，学习步长为0.5</span></span><br><span class="line">train = optimizer.minimize(cross_entropy)  <span class="comment">#训练目标: 最小化损失函数</span></span><br></pre></td></tr></table></figure><p>​    这里定义损失函数，优化算法以及最终训练模型这三个operation， 前后存在的任务依赖关系，在TensorFlow的graph中这些operation会形成保存依赖关系，最终session执行train 这个operation时，会根据依赖关系，往前搜索，找到最早的operation，开始一步步往下执行，最早的operation 即为w、b 等声明的这些op。</p><p>​    在optimizer.minimize函数中， 主要执行两个函数：<strong>compute_gradients </strong>函数和 <strong>apply_gradients</strong>函数</p><ul><li>compute_gradients 对var_list中的变量(没有特别指定var_list,则默认更新GraphKey.TRAINABLE_VARIABLES中的变量)，计算loss的梯度</li><li>apply_gradients 作用为将计算得到的梯度用于更新 var_list中的变量，如果没有指定var_list， 则更新GraphKey.TRAINABLE_VARIABLES中的变量</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章转自：&lt;a href=&quot;https://blog.csdn.net/shenxiaoming77/article/details/77197708&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/shenxiaoming77/article/details/77197708&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.案例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建立抽象模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow" scheme="//harold.me/tags/tensorflow/"/>
    
      <category term="深度学习" scheme="//harold.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow——MNIST数字识别问题</title>
    <link href="//harold.me/2018/07/15/tensorflow%E2%80%94%E2%80%94MNIST%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98/"/>
    <id>//harold.me/2018/07/15/tensorflow——MNIST数字识别问题/</id>
    <published>2018-07-15T13:40:42.000Z</published>
    <updated>2018-09-13T09:22:18.530Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、-MNIST数据处理"><a href="#一、-MNIST数据处理" class="headerlink" title="一、 MNIST数据处理"></a>一、 MNIST数据处理</h4><p><strong>1. input_data.read_data_seTensorflow函数</strong></p><p><strong>功能</strong>: 该函数生成的类能将MNIST数据集划分为train, validation和test三个数据集:</p><ul><li>train: 55000张图片</li><li>validation: 5000张</li><li>test: 10000张</li></ul><p>trian和validation组成了训练数据集. 每一张图片是一个长度为784(=28*28像素)的一维数组.</p><a id="more"></a> <p><strong>2. mnist.train.next_batch函数</strong></p><p>从所有的训练数据集中读取一小部分(batch)用来训练.</p><h4 id="二、神经网络训练及不同模型结果对比"><a href="#二、神经网络训练及不同模型结果对比" class="headerlink" title="二、神经网络训练及不同模型结果对比"></a>二、神经网络训练及不同模型结果对比</h4><p><strong>1.Tensorflow训练神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="comment">#MNIST数据集相关常数</span></span><br><span class="line">INPUT_NODE = <span class="number">784</span></span><br><span class="line">OUTPUT_NODE = <span class="number">10</span></span><br><span class="line"><span class="comment">#配置神经网络的参数</span></span><br><span class="line">LAYER1_NODE = <span class="number">500</span><span class="comment">#隐藏层节点个数</span></span><br><span class="line">BATCH_SIZE = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">LEARNING_RATE_BASE = <span class="number">0.8</span></span><br><span class="line">LEARNING_RATE_DECAY = <span class="number">0.99</span></span><br><span class="line"></span><br><span class="line">REGULARAZTION_RATE = <span class="number">0.0001</span><span class="comment">#正则化项系数</span></span><br><span class="line">TRAINING_STEPS = <span class="number">5000</span></span><br><span class="line">MOVING_AVERAGE_DECAY = <span class="number">0.99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算神经网络前向传播结果，定义了一个用ReLU激活函数的全连接神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference</span><span class="params">(input_tensor, avg_class, weighTensorflow1, biases1, weighTensorflow2, biases2)</span>:</span></span><br><span class="line">    <span class="comment">#如果没有提供滑动平均类，直接用参数当前取值</span></span><br><span class="line">    <span class="keyword">if</span> avg_class == <span class="keyword">None</span>:</span><br><span class="line">        layer1 = tf.nn.relu(</span><br><span class="line">            tf.matmul(input_tensor, weighTensorflow1) + biases1)</span><br><span class="line">        <span class="keyword">return</span> tf.matmul(layer1,weighTensorflow2) + biases2</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        layer1 = tf.nn.relu(</span><br><span class="line">            tf.matmul(input_tensor, avg_class.average(weighTensorflow1)) + avg_class.average(biases1))</span><br><span class="line">        <span class="keyword">return</span> tf.matmul(layer1, avg_class.average(weighTensorflow2)) + avg_class.average(biases2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练模型的过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(mnist)</span>:</span></span><br><span class="line">    x = tf.placeholder(tf.float32,[<span class="keyword">None</span>, INPUT_NODE], name=<span class="string">'x-input'</span>)</span><br><span class="line">    y_ = tf.placeholder(tf.float32,[<span class="keyword">None</span>, OUTPUT_NODE],name=<span class="string">'y-inpit'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 隐藏层参数</span></span><br><span class="line">    weighTensorflow1 = tf.Variable(tf.truncated_normal([INPUT_NODE,LAYER1_NODE], stddev=<span class="number">0.1</span>))</span><br><span class="line">    biases1 = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[LAYER1_NODE]))</span><br><span class="line">    <span class="comment">#输出层参数</span></span><br><span class="line">    weighTensorflow2 = tf.Variable(tf.truncated_normal([LAYER1_NODE,OUTPUT_NODE],stddev=<span class="number">0.1</span>))</span><br><span class="line">    biases2 = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[OUTPUT_NODE]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计算在当前参数下前向传播的结果，不使用滑动平均</span></span><br><span class="line">    y = inference(x, <span class="keyword">None</span>, weighTensorflow1, biases1, weighTensorflow2, biases2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#定义存储训练轮数的变量，不需要计算滑动平均，因此指定为不可训练变量</span></span><br><span class="line">    global_step = tf.Variable(<span class="number">0</span>, trainable=<span class="keyword">False</span>)</span><br><span class="line">    <span class="comment"># 初始化滑动平均类</span></span><br><span class="line">    variable_average = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)</span><br><span class="line">    <span class="comment">#在所有代表神经网络参数的变量上使用滑动平均</span></span><br><span class="line">    variable_average_op = variable_average.apply(tf.trainable_variables())</span><br><span class="line">    <span class="comment">#计算使用了滑动平均之后的前向传播结果</span></span><br><span class="line">    average_y = inference(x, variable_average, weighTensorflow1, biases1, weighTensorflow2, biases2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#交叉熵，当分类问题中只有一个正确答案时，sparse_softmax_cross_entropy_with_logiTensorflow函数</span></span><br><span class="line">    <span class="comment">#可以加速交叉熵的计算。标准答案是长度为10的一维数组，而该函数需要提供的是一个正确答案的数字，因此用tf.argmax函数</span></span><br><span class="line">    <span class="comment">#来得到正确答案对应类别编号</span></span><br><span class="line">    cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logiTensorflow(logiTensorflow=y, labels=tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">    <span class="comment">#计算当前batch中所有样例的平均交叉熵</span></span><br><span class="line">    cross_entropy_mean = tf.reduce_mean(cross_entropy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#L2损失函数</span></span><br><span class="line">    regularizer = tf.contrib.layers.l2_regularizer(REGULARAZTION_RATE)</span><br><span class="line">    regularization = regularizer(weighTensorflow1) + regularizer(weighTensorflow2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#总损失等于交叉熵损失加正则化损失</span></span><br><span class="line">    loss = cross_entropy_mean + regularization</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#指数衰减的学习率</span></span><br><span class="line">    learning_rate = tf.train.exponential_decay(</span><br><span class="line">        LEARNING_RATE_BASE,<span class="comment">#基础学习率</span></span><br><span class="line">        global_step, <span class="comment">#当前迭代轮数</span></span><br><span class="line">        mnist.train.num_examples/BATCH_SIZE,<span class="comment">#过完所有数据需要的迭代次数</span></span><br><span class="line">        LEARNING_RATE_DECAY)<span class="comment">#衰减速度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 优化损失函数</span></span><br><span class="line">    train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(</span><br><span class="line">        loss, global_step=global_step)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在训练神经网络模型时，每过一遍数据既需要通过反向传播来更新神经网络中的参数，</span></span><br><span class="line">    <span class="comment">#又要更新每一个参数的滑动平均值。为了一次完成多个操作，Tensorflow提供了tf.control_dependencies</span></span><br><span class="line">    <span class="comment">#和tf.group两种机制，下面两行等价于：train_op = tf.group(train_step, variable_average_op)</span></span><br><span class="line">    <span class="keyword">with</span> tf.control_dependencies([train_step, variable_average_op]):</span><br><span class="line">        train_op = tf.no_op(name = <span class="string">'train'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#检验使用了滑动平均模型的神经网络前向传播结果是否正确，tf.argmax(average_y,1)</span></span><br><span class="line">    <span class="comment">#计算每个样例的预测答案，第二个参数1表示选取最大值的操作仅在第一个维度进行。于是得到结果是一个长度为batch</span></span><br><span class="line">    <span class="comment">#的一维bool数组</span></span><br><span class="line">    correct_prediction = tf.equal(tf.argmax(average_y,<span class="number">1</span>), tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">    <span class="comment">#将bool数组转换为实数型，然后计算均值，即正确率</span></span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        tf.initialize_all_variables().run()</span><br><span class="line">        <span class="comment">#验证数据</span></span><br><span class="line">        validate_feed = &#123;x: mnist.validation.images,</span><br><span class="line">                         y_:mnist.validation.labels&#125;</span><br><span class="line">        <span class="comment">#测试数据</span></span><br><span class="line">        test_feed = &#123;x: mnist.test.images, </span><br><span class="line">                     y_:mnist.test.labels&#125;</span><br><span class="line">        <span class="comment">#迭代训练</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(TRAINING_STEPS):</span><br><span class="line">            <span class="comment">#每1000轮输出一次验证集上的测试结果</span></span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                validate_acc = sess.run(accuracy, feed_dict = validate_feed)</span><br><span class="line">                print(<span class="string">"After %d training steps(s), validation accuracy using average model is  %g"</span>%(i,validate_acc))</span><br><span class="line">            xs,ys = mnist.train.next_batch(BATCH_SIZE)</span><br><span class="line">            sess.run(train_op, feed_dict = &#123;x:xs, y_:ys&#125;)</span><br><span class="line">        test_acc = sess.run(accuracy, feed_dict=test_feed)</span><br><span class="line">        print(<span class="string">"After %d training steps(s), test accuracy using average model is  %g"</span>%(TRAINING_STEPS,test_acc))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv=None)</span>:</span></span><br><span class="line">    mnist = input_data.read_data_seTensorflow(<span class="string">'/data/'</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line">    train(mnist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tf.app.run()</span><br></pre></td></tr></table></figure><p><strong>2. 使用验证集判断模型效果</strong></p><p>​    在上一节程序的开始设置了初始学习率，隐藏层节点数量，迭代轮数等参数，这些参数的取值是需要通过实验调整的，不能使用模型在测试数据上的效果选择参数，使用测试集可能导致模型过度拟合，从而失去对未知数据的预测能力，因此一般从训练集中选一部分做验证集，验证数据就可以评判不同参数取值下模型的表现。除了使用验证集，还可以使用交叉验证来验证模型效果，但是神经网络训练时间本身较长，用cv会花费大量时间，所以在海量数据情况下，一般更多使用验证集来评估模型效果。</p><h4 id="三、变量管理"><a href="#三、变量管理" class="headerlink" title="三、变量管理"></a>三、变量管理</h4><p>​    在inference函数中传入了计算前向传播结果所需要的参数，当神经网络更复杂，参数更多的时候，就需要更好的方式来传递和管理神经网络中的参数。Tensorflow提供了通过<strong>变量名</strong>来创建和获取一个变量的机制，这样在不同的函数中可以直接通过变量的名字来使用变量。主要通过tf.get_variable和tf.variable_scope函数来实现。</p><p>除了tf.Variable，Tensorflow还可以用tf.get_variable函数来创建或获取变量，它和tf.Variable基本等价。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = tf.get_variable(<span class="string">"v"</span>, shape=[<span class="number">1</span>], </span><br><span class="line">                    initializer=tf.constant_initializer(<span class="number">1.0</span>))</span><br><span class="line">v = tf.Variable(tf.constant(<span class="number">1.0</span>,shape=[<span class="number">1</span>]), name=<span class="string">"v"</span>)</span><br></pre></td></tr></table></figure><p>Tensorflow提供了七种不同的初始化函数：</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-15/22335461.jpg" alt=""></p><p>​    tf.get_variable和tf.Variable函数最大的区别是制定变量名称的参数，后者的name=””参数可选,而对于tf.get_variable，变量名是一个必填的参数。tf.get_variable会根据这个名字去创建或获取变量，根据tf.get_variable创建的变量的变量名都是不可重复的。</p><p>​    如果需要通过tf.get_variable获取一个已经创建的变量，需要通过tf.variable_scope函数来生成一个上下文管理器，并明确指定在这个上下文管理器中，tf.get_variable将直接获取已经生成的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在名字为foo的命名空间中创建名字为v的变量</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    v = tf.get_variable(</span><br><span class="line">        <span class="string">"v"</span>, shape=[<span class="number">1</span>], initializer=tf.constant_initializer(<span class="number">1.0</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#因为在foo中已经存在名字为v的变量，所以下面会报错</span></span><br><span class="line"><span class="comment">#riable foo/v already exisTensorflow, disallowed. Did you mean to set reuse=True or reuse=tf.AUTO_REUSE in VarScope? Originally defined at:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with tf.variable_scope("foo"):</span></span><br><span class="line"><span class="comment">#     tf.get_variable("v",[1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在声明上下文管理器时，将参数reuse设为true，这样tf.get_variable函数将直接获取以声明的变量</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>,reuse=<span class="keyword">True</span>):</span><br><span class="line">    v1 = tf.get_variable(<span class="string">"v"</span>,[<span class="number">1</span>])</span><br><span class="line">    print(v==v1) <span class="comment">#True</span></span><br></pre></td></tr></table></figure><p>Tensorflow中，tf.variable_scope可以嵌套：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"root"</span>):</span><br><span class="line">    <span class="comment">#可以tf.get_variable_scope().reuse获取上下文中reuse参数的取值</span></span><br><span class="line">    print(tf.get_variable_scope().reuse)<span class="comment">#False,最外层reuse是False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse=<span class="keyword">True</span>):</span><br><span class="line">        print(tf.get_variable_scope().reuse)<span class="comment">#True</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">"bar"</span>):</span><br><span class="line">            print(tf.get_variable_scope().reuse)<span class="comment">#True,虽然bar没有制定</span></span><br><span class="line">                                                <span class="comment">#reuse,这时会和外层foo保持一致</span></span><br><span class="line">    print(tf.get_variable_scope().reuse)<span class="comment">#False，退出reuse为True的上下文后，又回到False</span></span><br></pre></td></tr></table></figure><p>tf.variable_scope函数生成的上下文也会创建一个Tensorflow中的命名空间，在命名空间内创建的变量名称都会带上命名空间作为前缀，tf.variable_scope提供了一个管理变量命名空间的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v1 = tf.get_variable(<span class="string">"v"</span>,[<span class="number">1</span>])</span><br><span class="line">print(v1.name) <span class="comment">#v:0,v是变量名，0表示这个变量是生成变量这个运算的第一个结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse=<span class="keyword">True</span>):</span><br><span class="line">    v2 = tf.get_variable(<span class="string">"v"</span>,[<span class="number">1</span>])</span><br><span class="line">    print(v2.name) <span class="comment">#foo/v:0 在/前加了命名空间名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>,reuse=<span class="keyword">True</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"bar"</span>):</span><br><span class="line">        v3 = tf.get_variable(<span class="string">"v"</span>,[<span class="number">1</span>])</span><br><span class="line">        print(v3.name)<span class="comment">#foo/bar/v:0</span></span><br><span class="line">    </span><br><span class="line">    v4 = tf.get_variable(<span class="string">"v"</span>,[<span class="number">1</span>])</span><br><span class="line">    print(v4.name)<span class="comment">#foo/v:0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">""</span>, reuse=<span class="keyword">True</span>):</span><br><span class="line">    <span class="comment">#可以通过带命名空间名称的变量名来获取其他命名空间下的变量</span></span><br><span class="line">    v5 = tf.get_variable(<span class="string">"foo/bar/v"</span>,[<span class="number">1</span>])</span><br><span class="line">    print(v5 == v3)<span class="comment">#True</span></span><br><span class="line">    v6 = tf.get_variable(<span class="string">"foo/v"</span>,[<span class="number">1</span>])</span><br><span class="line">    print(v6 == v4)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、-MNIST数据处理&quot;&gt;&lt;a href=&quot;#一、-MNIST数据处理&quot; class=&quot;headerlink&quot; title=&quot;一、 MNIST数据处理&quot;&gt;&lt;/a&gt;一、 MNIST数据处理&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1. input_data.read_data_seTensorflow函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;: 该函数生成的类能将MNIST数据集划分为train, validation和test三个数据集:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;train: 55000张图片&lt;/li&gt;
&lt;li&gt;validation: 5000张&lt;/li&gt;
&lt;li&gt;test: 10000张&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;trian和validation组成了训练数据集. 每一张图片是一个长度为784(=28*28像素)的一维数组.&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow" scheme="//harold.me/tags/tensorflow/"/>
    
      <category term="深度学习" scheme="//harold.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tenserflow——深层神经网络</title>
    <link href="//harold.me/2018/07/14/tenserflow%E2%80%94%E2%80%94%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>//harold.me/2018/07/14/tenserflow——深层神经网络/</id>
    <published>2018-07-14T15:55:12.000Z</published>
    <updated>2018-09-13T09:22:18.530Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、激活函数"><a href="#一、激活函数" class="headerlink" title="一、激活函数"></a>一、激活函数</h4><p>​    神经网络中激活函数的主要作用是提供网络的非线性建模能力，如不特别说明，激活函数一般而言是非线性函数。假设一个示例神经网络中仅包含线性卷积和全连接运算，那么该网络仅能够表达线性映射，即便增加网络的深度也依旧还是线性映射，难以有效建模实际环境中非线性分布的数据。加入（非线性）激活函数之后，深度神经网络才具备了分层的非线性映射学习能力。</p><a id="more"></a>     <ul><li><strong>非线性：</strong>如果不用激励函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合。如果使用的话，激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中。当激活函数是非线性的时候，一个两层的神经网络就可以逼近基本上所有的函数了。但是，如果激活函数是恒等激活函数的时候，就不满足这个性质了，而且如果MLP使用的是恒等激活函数，那么其实整个网络跟单层神经网络是等价的。</li><li><strong>可微性：</strong> 当优化方法是基于梯度的时候，这个性质是必须的。</li><li><strong>单调性：</strong> 当激活函数是单调的时候，单层网络能够保证是凸函数。当激活函数满足这个性质的时候，如果参数的初始化是random的很小的值，那么神经网络的训练将会很高效；如果不满足这个性质，那么就需要很用心的去设置初始值。</li><li><strong>输出值的范围：</strong> 当激活函数输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的learning rate。</li></ul><h5 id="常见的激活函数"><a href="#常见的激活函数" class="headerlink" title="常见的激活函数"></a>常见的激活函数</h5><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-15/83868805.jpg" alt=""></p><p><strong>1. Sigmoid函数</strong><br>  Sigmoid图形为一个S型曲线,函数定义如下： </p><p>​                                                                            $f(x)=\frac 1{1+e^{-x}}$</p><p>  Sigmoid函数将实数压缩到0~1区间。大的负数变成0，大的正数变成1。sigmoid函数由于其强大的解释力，常被用来表示神经元的活跃度程度：从不活跃（0）到假设上最大的（1）。在实践中，sigmoid函数最近从受欢迎到不受欢迎，很少再被使用。<br>它有两个主要缺点： </p><ol><li>sigmoid容易饱和，出现梯度消失的现象。sigmoid神经元的一个很差的属性就是神经元的活跃度在0和1处饱和，它的梯度在这些地方接近于0。回忆在反向传播中，某处的梯度和其目标输出的梯度相乘，以得到整个目标。因此，如果某处的梯度过小，就会很大程度上出现梯度消失，使得几乎没有信号经过这个神经元以及所有间接经过此处的数据。除此之外，人们必须额外注意sigmoid神经元权值的初始化来避免饱和。例如，当初始权值过大，几乎所有的神经元都会饱和以至于网络几乎不能学习。 </li><li>Sigmoid 的输出不是0均值的，这是我们不希望的，因为这会导致后层的神经元的输入是非0均值的信号，这会对梯度产生影响：假设后层神经元的输入都为正(e.g. x&gt;0 elementwise in f=wTx+b),那么对w求局部梯度则都为正，这样在反向传播的过程中w要么都往正方向更新，要么都往负方向更新，导致有一种捆绑的效果，使得收敛缓慢。 但是如果你是按batch去训练，那么每个batch可能得到不同的符号（正或负），那么相加一下这个问题还是可以缓解。 </li></ol><p><strong>2. tanh函数</strong></p><p>tanh和sigmoid函数是有异曲同工之妙的，不同的是它把实值得输入压缩到-1~1的范围。</p><p>优点：因为其输入的范围为-1~1，因此它基本是0均值的，这也就解决了上述sigmoid缺点中的第二个，所以实际中tanh会比sigmoid更常用。    </p><p>缺点：它依然存在梯度饱和的问题。 </p><p><strong>3. ReLU函数 </strong></p><p>优点：  </p><ol><li>其在梯度下降上与tanh/sigmoid相比有更快的收敛速度。这被认为时其线性、非饱和的形式。    </li><li>不会出现梯度消失的问题。    </li><li>Relu会使一部分神经元的输出为0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生。    </li><li>sigmoid和tanh涉及了很多很expensive的操作（比如指数），ReLU可以更加简单的实现。  </li></ol><p>缺点：    </p><p>​    ReLU单元脆弱且可能会在训练中死去。例如，大的梯度流经过ReLU单元时可能导致神经不会在以后任何数据节点再被激活。当这发生时，经过此单元的梯度将永远为零。ReLU单元可能不可逆地在训练中的数据流中关闭。例如，比可能会发现当学习速率过快时你40%的网络都“挂了”（神经元在此后的整个训练中都不激活）。当学习率设定恰当时，这种事情会更少出现。 </p><h4 id="二、-交叉熵"><a href="#二、-交叉熵" class="headerlink" title="二、 交叉熵"></a>二、 交叉熵</h4><p>在信息论中，交叉熵是表示两个概率分布p,q，其中p表示真实分布，q表示非真实分布，在相同的一组事件中，其中，用非真实分布q来表示某个事件发生所需要的平均比特数。</p><p>假设现在有一个样本集中两个概率分布p,q，其中p为真实分布，q为预测分布，通过q来表示p的交叉熵为：</p><p>​                                      $H(p,q)=-\sum_xp(s)\log {q(x)}$    </p><p>实际上，交叉熵是衡量两个概率分布p，q之间的相似性,而神经网络的输出却不一定是一个概率分布。SoftMax回归可以将神经网络前向传播得到的结果变成概率分布。</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-15/91325298.jpg" alt=""></p><h4 id="三、自定义损失函数"><a href="#三、自定义损失函数" class="headerlink" title="三、自定义损失函数"></a>三、自定义损失函数</h4><p>tf中greater方法会返回输入张量中每个元素的比较结果，where方法类似于C语言中的<code>？：</code>操作符，有三个参数，第一个为选择条件，选择条件为真，返回第二个参数的值，为假，返回第三个参数的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">v1 = tf.constant([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>])</span><br><span class="line">v2 = tf.constant([<span class="number">4.0</span>,<span class="number">3.0</span>,<span class="number">2.0</span>,<span class="number">1.0</span>])</span><br><span class="line"></span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print(tf.greater(v1,v2).eval())</span><br><span class="line">print(tf.where(tf.greater(v1,v2),v1,v2).eval())</span><br></pre></td></tr></table></figure><p>Tensorflow中封装了许多损失函数供用户调用，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用了softmax回归之后的交叉损失函数，y_代表真实值</span></span><br><span class="line">tf.nn.softmax_cross_entropy_with_logiTensorflow(y,y_)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#均方差的实现</span></span><br><span class="line">tf.reduce_mean(tf.square(y_ - y))</span><br></pre></td></tr></table></figure><p>Tensorflow不仅支持经典损失函数，还可以自定义损失函数，如：</p><p>​                     $Loss(y,y’) = \sum_{i=1}^nf(y_i,y_i’), \ f(x,y) = \begin{cases} a(x-y) &amp; x&gt;y\ b(y-x)&amp;x\le y\end{cases}$</p><p>可以用如下方式实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = tf.reduce_sum(tf.where(tf.greater(v1,v2), (v1-v2)*a,(v2-v1)*b))</span><br></pre></td></tr></table></figure><h4 id="四、神经网络优化算法"><a href="#四、神经网络优化算法" class="headerlink" title="四、神经网络优化算法"></a>四、神经网络优化算法</h4><p>反向传播算法是训练神经网络的核心算法，可以根据定义好的损失函数优化神经网络中参数的取值。目前没有通用方法可以对任意损失函数直接球的最佳参数取值，在实践中，梯度下降法是最常用的优化方法。</p><p>梯度下降法有不能达到全局最优和计算时间长的缺点，而随机梯度下降优化的不是在全部训练数据上的损失函数，而是在每一轮迭代中，随机优化某一条训练数据上的损失函数，所有问题也很明显，某一条数据上损失函数更小并不代表全局损失更小，所以可能连局部最优都达不到。在实际应用中，采用折中办法，每次计算一小部分（一个batch）训练数据的损失函数,这样每次在一个batch上优化的参数并不会比单个数据慢太多，此外可以大大减少迭代次数，是收敛到更接近梯度下降的结果。</p><h4 id="五、-神经网络进一步优化"><a href="#五、-神经网络进一步优化" class="headerlink" title="五、 神经网络进一步优化"></a>五、 神经网络进一步优化</h4><p><strong>1. 学习率设置</strong></p><p>学习率控制参数更新速度，幅度过大，可能导致参数在最优值两侧来回移动，过小，速度会降低。Tensorflow提供了<strong>指数衰减法</strong>，<code>tf.train.exponential_decay</code>实现了指数衰减学习率，这样学习率先大后小，使模型在后期逐渐稳定。</p><p><strong>2. 过拟合</strong></p><p>解决方法：正则化</p><p>L1正则化会让参数变得更稀疏，即有更多参数变为零，这样可以达到类似特征选取的功能。L2正则做不到这一点是因为当参数很小时，这个参数的平方基本可被忽略，于是模型不会进一步将这个参数调整为0。</p><p>其次L1正则化的计算公式不可导，L2正则化公式可导，因为在优化时需要计算损失函数偏导数，所以对含有L2正则化的损失函数的优化会更加简洁。实践中也可以将两种正则共同使用。</p><p>下面给出了带L2正则化的损失函数定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w=tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">1</span>], stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line">t=tf.matmul(x,w)</span><br><span class="line"><span class="comment">#loss为损失函数，lambda表示正则化项的权重，w是需要计算正则化损失的参数</span></span><br><span class="line">loss = tf.reduce_mean(tf.square(y_-y)) + tf.contrib.layers.l2_regularizer(<span class="keyword">lambda</span>)(w)</span><br></pre></td></tr></table></figure><p><code>tf.contrib.layers.l2_regularizer</code>和<code>tf.contrib.layers.l1_regularizer</code>分别可以计算了L1和L2正则化项，其中tfh会将L2的正则化损失除以2使得求导得到的结果更加简洁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weighTensorflow= tf.constant([[<span class="number">1.0</span>,<span class="number">-2.0</span>],[<span class="number">-3.0</span>,<span class="number">4.0</span>]])</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment">#输出（1+2+3+4）*0.5=5</span></span><br><span class="line">    print(sess.run(tf.contrib.layers.l1_regularizer(<span class="number">0.5</span>)(weighTensorflow)))</span><br><span class="line">    <span class="comment">#输出（1+4+9+16）/2*0.5=7.5</span></span><br><span class="line">    print(sess.run(tf.contrib.layers.l2_regularizer(<span class="number">.5</span>)(weighTensorflow)))</span><br></pre></td></tr></table></figure><p>对于简单神经网络，这种方式可以很好地计算带正则化的损失函数，但是当神经网络参数增多之后，这样可能导致损失函数loss的定义很长，可读性差且易出错，更主要的，网络结构复杂之后定义网络结构的部分和计算损失的部分可能不在同一个函数中，通过这样的方式计算损失函数就更不方便了。为解决此问题，可以使用Tensorflow提供的集合collection,它可以在一个计算图中保存一组实体（如张量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取一层神经网络边上的权重，并将这个权重的L2正则化损失加入名称为‘losses’的集合中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(shape, lambda)</span>:</span></span><br><span class="line">    var = tf.Variable(tf.random_normal(shape), dtype=tf.float32)</span><br><span class="line">    <span class="comment">#add_to_collection函数将这个新生成变量的L2正则化损失加入集合</span></span><br><span class="line">    <span class="comment">#函数的第一个参数‘losses’是集合的名字，第二个参数是要加入这个集合的内容</span></span><br><span class="line">    tf.add_to_collection(<span class="string">'losses'</span>, tf.contrib.layers.l2_regularizer(<span class="keyword">lambda</span>)(var))</span><br><span class="line">    <span class="keyword">return</span> var</span><br><span class="line"></span><br><span class="line">x = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>,<span class="number">2</span>))</span><br><span class="line">y_ = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>,<span class="number">2</span>))</span><br><span class="line">batch_size = <span class="number">8</span> </span><br><span class="line"><span class="comment">#定义每层网络中节点的个数</span></span><br><span class="line">layers_dimension = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">#神经网络的层数</span></span><br><span class="line">n_layers = len(layers_dimensions)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这个变量维护前向传播时最深的结点，开始的时候就是输入层</span></span><br><span class="line">cur_layer = x</span><br><span class="line"><span class="comment">#当前层节点个数</span></span><br><span class="line">in_dimension = layers_dimensions[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过一个循环来生成5层全连接的神经网络结构</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n_layers):</span><br><span class="line">    <span class="comment">#layer_dimension[i]为下一层节点个数</span></span><br><span class="line">    out_dimension = layers_dimension[i]</span><br><span class="line">    <span class="comment">#生成当前层中权重的变量，并将这个变量的L2正则化损失加入计算图上的集合</span></span><br><span class="line">    weight = get_weight([in_dimension, out_dimension],<span class="number">0.01</span>)</span><br><span class="line">    bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[out_dimension]))</span><br><span class="line">    <span class="comment">#使用ReLU激活函数</span></span><br><span class="line">    curl_layer = tf.nn.relu(tf.matmul(cur_layer, weight) + bias)</span><br><span class="line">    <span class="comment">#进入下一层之前将下一层节点个数更新为当前节点个数</span></span><br><span class="line">    in_dimension= layers_dimension[i]</span><br><span class="line"><span class="comment">#在定义神经网络前向传播的同时已经将所有L2正则化损失加入了图上的集合</span></span><br><span class="line"><span class="comment">#这里只需要计算科化模型在训练数据上表现的损失函数</span></span><br><span class="line">mse_loss = tf.reduce_mean(tf.square(y_ - cur_layer))</span><br><span class="line"><span class="comment">#将均方误差损失函数加入损失集合</span></span><br><span class="line">tf.add_to_collection(<span class="string">'losses'</span>, mse_loss)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_collection返回集合元素列表，加起来就是最终损失函数</span></span><br><span class="line">loss = tf.add_n(tf.get_collection(<span class="string">'losses'</span>))</span><br></pre></td></tr></table></figure><p><strong>3. 滑动平均模型</strong></p><p>滑动平均模型可以使模型在测试数据上更鲁棒，在Tensorflow中提供了<code>tf.train.ExponentialMovingAverage</code>来实现滑动平均模型，在初始化ExponentialMovingAverage时，需要提供一个衰减率(decay).这个衰减率将用于控制模型的更新速度。ExponentialMovingAverage对每个变量维护一个影子变量，这个影子变量的初始值就是相应变量的初始值，每次运行变量更新时，影子变量的值会更新为：<br>                             $shadow_variable=decay <em> shadow_variable + (1-decay)</em>variable$</p><p>其中shadow_variable为影子变量，variable为待更新的变量，decay为衰减率。decay决定了模型更新的速度，decay越大模型越趋于稳定。在实际应用中，decay一般设为非常接近1的数，为了使模型在训练前期可以更新的更快，ExponentialMovingAverage提供了num_updatyes参数来动态设置decay的大小，如果在ExponentialMovingAverage初始化时提供了num_updates参数，那么每次使用的衰减率将是：<br>$min\lbrace decay, \frac {1+num_updates}{10+num_updates}\rbrace$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个变量用于计算滑动平均，初始值为0，手动指定类型为float32</span></span><br><span class="line"><span class="comment">#所有需要计算滑动平均的变量必须是实数型</span></span><br><span class="line">v1 = tf.Variable(<span class="number">0</span>, dtype=tf.float32)</span><br><span class="line"><span class="comment">#setp模拟神经网络中迭代的轮数，可用于动态控制衰减率</span></span><br><span class="line">step = tf.Variable(<span class="number">0</span>, trainable=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个滑动平均的类，初始化时给定了衰减率0.99，和控制衰减率的变量step</span></span><br><span class="line">ema = tf.train.ExponentialMovingAverage(<span class="number">0.99</span>, step)</span><br><span class="line"><span class="comment">#定义一个更新变量滑动平均的操作，需要给定一个列表，每次执行这个动作时</span></span><br><span class="line"><span class="comment">#这个列表中的变量都会被更新</span></span><br><span class="line">maintain_average_op = ema.apply([v1])</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="comment">#通过ema.average(v1)获取滑动平均之后变量的取值，在初始化之后变量v1的值和v1的滑动平均都是0</span></span><br><span class="line">    print(sess.run([v1,ema.average(v1)])) <span class="comment">#[0.0, 0.0]</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">#更新变量v1的值到10</span></span><br><span class="line">    sess.run(tf.assign(v1,<span class="number">5</span>))</span><br><span class="line">    <span class="comment">#更新v1的滑动平均值，衰减率为min&#123;0.99,(1+step)/(10+step)=0.1&#125; = 0.1</span></span><br><span class="line">    <span class="comment">#所以v1的滑动平均值会被更新为0.1*0+0.9*5 =4.5</span></span><br><span class="line">    sess.run(maintain_average_op)</span><br><span class="line">    print(sess.run([v1,ema.average(v1)]))</span><br><span class="line">    </span><br><span class="line">      <span class="comment">#更新变量step的值到5</span></span><br><span class="line">    sess.run(tf.assign(step,<span class="number">10000</span>))</span><br><span class="line">    <span class="comment">#更新变量v1的值到10000</span></span><br><span class="line">    sess.run(tf.assign(v1,<span class="number">10</span>))</span><br><span class="line">    <span class="comment">#更新v1的滑动平均值，衰减率为min&#123;0.99,(1+step)/(10+step)=0.999&#125; = 0.99</span></span><br><span class="line">    <span class="comment">#所以v1的滑动平均值会被更新为0.99*4.5+0.01*5 =4.5555</span></span><br><span class="line">    sess.run(maintain_average_op)</span><br><span class="line">    print(sess.run([v1,ema.average(v1)]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#再次更新滑动平均值，得到新的滑动平均值为0.94*4.555+0.01*10 = 4.60945</span></span><br><span class="line">    sess.run(maintain_average_op)</span><br><span class="line">    print(sess.run([v1, ema.average(v1)]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、激活函数&quot;&gt;&lt;a href=&quot;#一、激活函数&quot; class=&quot;headerlink&quot; title=&quot;一、激活函数&quot;&gt;&lt;/a&gt;一、激活函数&lt;/h4&gt;&lt;p&gt;​    神经网络中激活函数的主要作用是提供网络的非线性建模能力，如不特别说明，激活函数一般而言是非线性函数。假设一个示例神经网络中仅包含线性卷积和全连接运算，那么该网络仅能够表达线性映射，即便增加网络的深度也依旧还是线性映射，难以有效建模实际环境中非线性分布的数据。加入（非线性）激活函数之后，深度神经网络才具备了分层的非线性映射学习能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow" scheme="//harold.me/tags/tensorflow/"/>
    
      <category term="深度学习" scheme="//harold.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——Mysql题目(二)</title>
    <link href="//harold.me/2018/07/14/leetcode%E2%80%94%E2%80%94Mysql%E9%A2%98%E7%9B%AE2/"/>
    <id>//harold.me/2018/07/14/leetcode——Mysql题目2/</id>
    <published>2018-07-14T07:32:14.000Z</published>
    <updated>2018-09-13T09:22:18.526Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、部门工资最高的员工"><a href="#一、部门工资最高的员工" class="headerlink" title="一、部门工资最高的员工"></a>一、部门工资最高的员工</h4><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure> <a id="more"></a><p><code>Department</code> 表包含公司所有部门的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure><ul><li><p>解法一：自己写的，15个测试用例通过13个，结合max和groupby</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT B.Name as Department,A.name as Employee,A.Salary FROM</span><br><span class="line">    Department B LEFT JOIN (</span><br><span class="line">    SELECT C.* from </span><br><span class="line">    (SELECT DepartmentId,MAX(Salary) AS maxs from </span><br><span class="line">    Employee Group By(DepartmentId)</span><br><span class="line">    ) D LEFT JOIN Employee C</span><br><span class="line">    ON C.Salary=D.maxs AND C.DepartmentId=D.DepartmentId</span><br><span class="line">    ) A</span><br><span class="line">    ON A.DepartmentId=B.Id</span><br><span class="line">    ORDER BY B.Id desc;</span><br></pre></td></tr></table></figure><p>看了一下错误的详细信息，原因在于null值的处理上，题目的意思是当工资表为空但是部门表不为空时，依然要显示每个部门的信息，将除部门名外的其他字段设为null.<img src="http://p5s7d12ls.bkt.clouddn.com/18-7-14/81554601.jpg" alt=""></p><p>要解决这个问题并不困难，只需要将第二行的left join改成join即可</p></li><li><p>解法二：用join和in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    Department.name AS &apos;Department&apos;,</span><br><span class="line">    Employee.name AS &apos;Employee&apos;,</span><br><span class="line">    Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">        JOIN</span><br><span class="line">    Department ON Employee.DepartmentId = Department.Id</span><br><span class="line">WHERE</span><br><span class="line">    (Employee.DepartmentId , Salary) IN</span><br><span class="line">    (   SELECT</span><br><span class="line">            DepartmentId, MAX(Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        GROUP BY DepartmentId</span><br><span class="line">    )</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二、部门工资前三高的员工"><a href="#二、部门工资前三高的员工" class="headerlink" title="二、部门工资前三高的员工"></a>二、部门工资前三高的员工</h4><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">| 5  | Janet | 69000  | 1            |</span><br><span class="line">| 6  | Randy | 85000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure><p><code>Department</code> 表包含公司所有部门的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| IT         | Randy    | 85000  |</span><br><span class="line">| IT         | Joe      | 70000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">| Sales      | Sam      | 60000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure><ul><li><p>解法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select A.Name as Department,B.Name as Employee,B.Salary from</span><br><span class="line">   Department A join (</span><br><span class="line">   select Name,DepartmentId,Salary,dense_rank() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) rk from Employee) B</span><br><span class="line">   ON A.Id=B.DepartmentId where B.rk&lt;=3</span><br></pre></td></tr></table></figure><p>rank()是跳跃排序，有两个第二名时接下来就是第四名（同样是在各个分组内）．   　　</p><p>dense_rank()l是连续排序，有两个第二名时仍然跟着第三名。相比之下row_number是没有重复值的 ．  </p></li><li><p>解法二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    d.Name AS &apos;Department&apos;, e1.Name AS &apos;Employee&apos;, e1.Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee e1</span><br><span class="line">        JOIN</span><br><span class="line">    Department d ON e1.DepartmentId = d.Id</span><br><span class="line">WHERE</span><br><span class="line">    3 &gt; (SELECT</span><br><span class="line">            COUNT(DISTINCT e2.Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee e2</span><br><span class="line">        WHERE</span><br><span class="line">            e2.Salary &gt; e1.Salary</span><br><span class="line">                AND e1.DepartmentId = e2.DepartmentId</span><br><span class="line">        )</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、部门工资最高的员工&quot;&gt;&lt;a href=&quot;#一、部门工资最高的员工&quot; class=&quot;headerlink&quot; title=&quot;一、部门工资最高的员工&quot;&gt;&lt;/a&gt;一、部门工资最高的员工&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Employee&lt;/code&gt; 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+----+-------+--------+--------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| Id | Name  | Salary | DepartmentId |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----+-------+--------+--------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 1  | Joe   | 70000  | 1            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 2  | Henry | 80000  | 2            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 3  | Sam   | 60000  | 2            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 4  | Max   | 90000  | 1            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----+-------+--------+--------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="//harold.me/tags/Mysql/"/>
    
      <category term="数据库， Hive" scheme="//harold.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C-Hive/"/>
    
  </entry>
  
  <entry>
    <title>leetcode所有shell题目</title>
    <link href="//harold.me/2018/07/12/leetcode%E6%89%80%E6%9C%89shell%E9%A2%98%E7%9B%AE/"/>
    <id>//harold.me/2018/07/12/leetcode所有shell题目/</id>
    <published>2018-07-12T13:39:45.000Z</published>
    <updated>2018-09-13T09:22:18.527Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、第十行"><a href="#一、第十行" class="headerlink" title="一、第十行"></a>一、第十行</h4><p>给定一个文本文件 <code>file.txt</code>，请只打印这个文件中的第十行。</p><p><strong>示例:</strong></p><p>假设 <code>file.txt</code> 有如下内容：</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">Line 6</span><br><span class="line">Line 7</span><br><span class="line">Line 8</span><br><span class="line">Line 9</span><br><span class="line">Line 10</span><br></pre></td></tr></table></figure><p>你的脚本应当显示第十行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Line 10</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>如果文件少于十行，你应当输出什么？</li><li>至少有三种不同的解法，请尝试尽可能多的方法来解题。</li></ol><ul><li><p>解法1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">cnt=0</span><br><span class="line">while read line &amp;&amp; [ $cnt -le 10 ]; do</span><br><span class="line">    cnt=$(($cnt+1))</span><br><span class="line">    if [ $cnt -eq 10 ]; then</span><br><span class="line">        echo "$line"    </span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line">done &lt; file.txt</span><br></pre></td></tr></table></figure></li><li><p>解法2：</p><p>利用awk的内建变量NR或FNR,根据行数做判断</p><p>NR,表示awk开始执行程序后所读取的数据行数.</p><p>FNR,与NR功用类似,不同的是awk每打开一个新文件,FNR便从0重新累计.</p><p>awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。</p><p>格式： {if (expression){ statement; statement; … } }</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk 'FNR == 10 &#123;print &#125;'  file.txt</span><br><span class="line"><span class="meta">#</span> OR</span><br><span class="line">awk 'NR == 10' file.txt</span><br></pre></td></tr></table></figure></li><li><p>解法3</p><p>利用sed函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &apos;10p&apos; file.txt</span><br></pre></td></tr></table></figure></li><li><p>解法4</p><p>利用cat和wc -l判断行数是否大于10，如果大于再利用head和tail组合读数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $(cat file.txt | wc -l) -ge 10 ] &amp;&amp; head -n10 file.txt | tail -n1</span><br></pre></td></tr></table></figure></li></ul><h4 id="二、有效电话号码"><a href="#二、有效电话号码" class="headerlink" title="二、有效电话号码"></a>二、有效电话号码</h4><p>给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个 bash 脚本输出所有有效的电话号码。</p><p>你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</p><p>你也可以假设每行前后没有多余的空格字符。</p><p><strong>示例:</strong></p><p>假设 <code>file.txt</code> 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">123 456 7890</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure><p>你的脚本应当输出下列有效的电话号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure><ul><li><p>解法一</p><p>用awk正则匹配</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/ &#123;print &#125;' file.txt</span><br></pre></td></tr></table></figure></li><li><p>解法二</p><p>用sed正则匹配，-r ：支持扩展表达式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -r '/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/p' file.txt</span><br></pre></td></tr></table></figure></li><li><p>解法三</p><p>用grep正则匹配,-P : 遵循POSIX标准的正则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -P '^(\d&#123;3&#125;-|\(\d&#123;3&#125;\) )\d&#123;3&#125;-\d&#123;4&#125;$' file.txt</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’]</td></tr><tr><td>.点</td><td>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</td></tr><tr><td>(?:pattern)</td><td>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(\</td><td>)”来组合一个模式的各个部分时很有用。例如“industr(?:y\</td><td>ies)”就是一个比“industry\</td><td>industries”更简略的表达式。</td></tr><tr><td>(?=pattern)</td><td>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95\</td><td>98\</td><td>NT\</td><td>2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95\</td><td>98\</td><td>NT\</td><td>2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题此处用或任意一项都不能超过2位，如“(?&lt;!95\</td><td>98\</td><td>NT\</td><td>20)Windows正确，“(?&lt;!95\</td><td>980\</td><td>NT\</td><td>20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配</td></tr><tr><td>x\</td><td>y</td><td>匹配x或y。例如，“z\</td><td>food”能匹配“z”或“food”(此处请谨慎)。“[z\</td><td>f]ood”则匹配“zood”或“food”或”\</td><td>ood”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td>\s</td><td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何可见字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td></tr><tr><td>\xn</td><td>匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。</td></tr><tr><td>\num</td><td>匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td></tr><tr><td>\un</td><td>匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。</td></tr><tr><td>\p{P}</td><td>小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。其他六个属性：L：字母；M：标记符号（一般不会单独出现）；Z：分隔符（比如空格、换行等）；S：符号（比如数学符号、货币符号等）；N：数字（比如阿拉伯数字、罗马数字等）；C：其他字符。*<em>注：此语法部分语言不支持，例：javascript。</em></td></tr><tr><td>\&lt;></td><td>匹配词（word）的开始（\&lt;）和结束（>）。例如正则表达式\&lt;the>能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>( )</td><td>将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。</td></tr><tr><td>\</td><td></td><td>将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him\</td><td>her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。</td></tr></tbody></table><h4 id="三、统计词频"><a href="#三、统计词频" class="headerlink" title="三、统计词频"></a>三、统计词频</h4><p>写一个 bash 脚本以统计一个文本文件 <code>words.txt</code> 中每个单词出现的频率。</p><p>为了简单起见，你可以假设：</p><ul><li><code>words.txt</code>只包括小写字母和 <code>&#39; &#39;</code> 。</li><li>每个单词只由小写字母组成。</li><li>单词间由一个或多个空格字符分隔。</li></ul><p><strong>示例:</strong></p><p>假设 <code>words.txt</code> 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br></pre></td></tr></table></figure><p>你的脚本应当输出（以词频降序排列）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the 4</span><br><span class="line">is 3</span><br><span class="line">sunny 2</span><br><span class="line">day 1</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><p>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。</p></li><li><p>你可以使用一行 <a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html" target="_blank" rel="noopener">Unix pipes</a> 实现吗？</p></li></ul><ul><li>解法1：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in `cat text` ; do echo $i ; done | sort | uniq -c</span><br></pre></td></tr></table></figure><blockquote><p><strong>uniq命令</strong>用于报告或忽略文件中的重复行，一般与<a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort</a>命令结合使用。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; uniq(选项)(参数)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; -c或——count：在每列旁边显示该行重复出现的次数；</span><br><span class="line">&gt; -d或--repeated：仅显示重复出现的行列；</span><br><span class="line">&gt; -f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；</span><br><span class="line">&gt; -s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；</span><br><span class="line">&gt; -u或——unique：仅显示出一次的行列；</span><br><span class="line">&gt; -w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>输入文件：指定要去除的重复行文件。如果不指定此项，则从标准读取数据；</li><li>输出文件：指定要去除重复行后的内容要写入的输出文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>删除重复行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; uniq file.txt</span><br><span class="line">&gt; sort file.txt | uniq</span><br><span class="line">&gt; sort -u file.txt</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>只显示单一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; uniq -u file.txt</span><br><span class="line">&gt; sort file.txt | uniq -u</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>统计各行在文件中出现的次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sort file.txt | uniq -c</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在文件中找出重复的行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sort file.txt | uniq -d</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>解法2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat words.txt|tr -s '[ \t\n]' '\n'|sort|uniq -c|(while read count word; do echo $word $count; done)|sort -rn -k2</span><br></pre></td></tr></table></figure><blockquote><p><strong>tr命令</strong>可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tr(选项)(参数)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; -c或——complerment：取代所有不属于第一字符集的字符；</span><br><span class="line">&gt; -d或——delete：删除所有属于第一字符集的字符；</span><br><span class="line">&gt; -s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">&gt; -t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</li><li>字符集2：指定要转换成的目标字符集。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>将输入字符由大写转换为小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo &quot;HELLO WORLD&quot; | tr &apos;A-Z&apos; &apos;a-z&apos;</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>‘A-Z’ 和 ‘a-z’都是集合，集合是可以自己制定的，例如：’ABD-}’、’bB.,’、’a-de-h’、’a-c0-9’都属于集合，集合里可以使用’\n’、’\t’，可以可以使用其他ASCII字符。</p><p>使用tr删除字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo &quot;hello 123 world 456&quot; | tr -d &apos;0-9&apos;</span><br><span class="line">&gt; hello  world </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>将制表符转换为空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat text | tr &apos;\t&apos; &apos; &apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>解法三</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123; for(i=1; i&lt;=NF; i++)&#123; print $i &#125; &#125;' words.txt | sort | uniq -c | sort -r | awk '&#123;print $2, $1&#125;'</span><br></pre></td></tr></table></figure></li></ul><h4 id="四、转置文件"><a href="#四、转置文件" class="headerlink" title="四、转置文件"></a>四、转置文件</h4><p>给定一个文件 <code>file.txt</code>，转置它的内容。</p><p>你可以假设每行列数相同，并且每个字段由 <code>&#39; &#39;</code> 分隔.</p><p><strong>示例:</strong></p><p>假设 <code>file.txt</code> 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name age</span><br><span class="line">alice 21</span><br><span class="line">ryan 30</span><br></pre></td></tr></table></figure><p>应当输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name alice ryan</span><br><span class="line">age 21 30</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">awk '</span><br><span class="line">&#123;</span><br><span class="line">    for (i = 1; i &lt;= NF; i++) &#123;</span><br><span class="line">        if (FNR == 1) &#123;</span><br><span class="line">            t[i] = $i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t[i] = t[i] " " $i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line">    for (i = 1; t[i] != ""; i++) &#123;</span><br><span class="line">        print t[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">' file.txt</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、第十行&quot;&gt;&lt;a href=&quot;#一、第十行&quot; class=&quot;headerlink&quot; title=&quot;一、第十行&quot;&gt;&lt;/a&gt;一、第十行&lt;/h4&gt;&lt;p&gt;给定一个文本文件 &lt;code&gt;file.txt&lt;/code&gt;，请只打印这个文件中的第十行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;file.txt&lt;/code&gt; 有如下内容：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令——find、join</title>
    <link href="//harold.me/2018/07/12/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A46/"/>
    <id>//harold.me/2018/07/12/linux常用命令6/</id>
    <published>2018-07-12T09:06:02.000Z</published>
    <updated>2018-09-13T09:22:18.529Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.find</strong></p><p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>参数说明：find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><a id="more"></a> <p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime -n : 在过去 n 天过读取过的文件</p><p>-cmin -n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更新的文件</p><p>-ctime -n : 在过去 n 天过修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。</p><p>-type c : 文件类型是 c 的文件。</p><p>d: 目录</p><p>c: 字型装置文件</p><p>b: 区块装置文件</p><p>p: 具名贮列</p><p>f: 一般文件</p><p>l: 符号连结</p><p>s: socket</p><p>-pid n : process id 是 n 的文件</p><p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p><p>exp1 -and exp2</p><p>! expr</p><p>-not expr</p><p>exp1 -or exp2</p><p>exp1, exp2</p><p>示例:</p><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> find . -name "*.c"</span><br></pre></td></tr></table></figure><p>将目前目录及其下子目录中所有一般文件列出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> find . -type f</span><br></pre></td></tr></table></figure><p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> find . -ctime -20</span><br></pre></td></tr></table></figure><p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> find / -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>-exec command：command 为其他指令，-exec后面可再接额外的指令来处理搜寻到的结果。</p><p><img src="http://linux.vbird.org/linux_basic/0220filemanager/centos7_find_exec.gif" alt="find 相關的額外動作"></p><p>{ }代表的是「由 find 找到的内容」，如上图所示，找到的结果会被放置到 { } 位置中;<br>-exec一直到 ; 是关键字，代表找到额外动作的开始（-exec）到结束（），在这中间的就是找到指令内的额外动作</p><p>因为「;」在bash的环境下是有特殊意义的，因此利用反斜线来跳脱。</p><p><strong>2.grep</strong></p><p>​    Linux grep命令用于查找文件里符合条件的字符串。grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>-a 或 –text</strong> : 不要忽略二进制的数据。</li><li><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li><li><strong>-b 或 –byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li><li><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li><li><strong>-c 或 –count</strong> : 计算符合样式的列数。</li><li><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li><li><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。</li><li><strong>-E 或 –extended-regexp</strong> : 将样式为延伸的普通表示法来使用。</li><li><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li><li><strong>-F 或 –fixed-regexp</strong> : 将样式视为固定字符串的列表。</li><li><strong>-G 或 –basic-regexp</strong> : 将样式视为普通的表示法来使用。</li><li><strong>-h 或 –no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li><li><strong>-H 或 –with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。</li><li><strong>-l 或 –file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。</li><li><strong>-L 或 –files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li><li><strong>-q 或 –quiet或–silent</strong> : 不显示任何信息。</li><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。</li><li><strong>-s 或 –no-messages</strong> : 不显示错误信息。</li><li><strong>-v 或 –revert-match</strong> : 显示不包含匹配文本的所有行。</li><li><strong>-V 或 –version</strong> : 显示版本信息。</li><li><strong>-w 或 –word-regexp</strong> : 只显示全字符合的列。</li><li><strong>-x –line-regexp</strong> : 只显示全列符合的列。</li><li><strong>-y</strong> : 此参数的效果和指定”-i”参数相同。</li></ul><p>示例：</p><p>1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test *file</span><br></pre></td></tr></table></figure><p>2、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r update /etc/acpi</span><br></pre></td></tr></table></figure><p>3、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。</p><p>查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v test *test*</span><br></pre></td></tr></table></figure><p><strong>3. join</strong></p><p>Linux join命令用于将两个文件中，指定栏位内容相同的行连接起来。</p><p>找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join [-i][-a&lt;1或2&gt;][-e&lt;字符串&gt;][-o&lt;格式&gt;][-t&lt;字符&gt;][-v&lt;1或2&gt;][-1&lt;栏位&gt;][-2&lt;栏位&gt;][--help][--version][文件1][文件2]</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>-a&lt;1或2&gt; 除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行。</li><li>-e&lt;字符串&gt; 若[文件1]与[文件2]中找不到指定的栏位，则在输出中填入选项中的字符串。</li><li>-i或–igore-case 比较栏位内容时，忽略大小写的差异。</li><li>-o&lt;格式&gt; 按照指定的格式来显示结果。</li><li>-t&lt;字符&gt; 使用栏位的分隔字符。</li><li>-v&lt;1或2&gt; 跟-a相同，但是只显示文件中没有相同栏位的行。</li><li>-1&lt;栏位&gt; 连接[文件1]指定的栏位。</li><li>-2&lt;栏位&gt; 连接[文件2]指定的栏位。</li><li>–help 显示帮助。</li><li>–version 显示版本信息。</li></ul><p>示例：</p><p>连接两个文件。</p><p>为了清楚地了解join命令，首先通过cat命令显示文件testfile_1和 testfile_2 的内容。</p><p>然后以默认的方式比较两个文件，将两个文件中指定字段的内容相同的行连接起来，在终端中输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join testfile_1 testfile_2</span><br></pre></td></tr></table></figure><p>首先查看testfile_1、testfile_2 中的文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat testfile_1 #testfile_1文件中的内容  </span><br><span class="line">Hello 95 #例如，本例中第一列为姓名，第二列为数额  </span><br><span class="line">Linux 85  </span><br><span class="line">test 30  </span><br><span class="line">cmd@hdd-desktop:~$ cat testfile_2 #testfile_2文件中的内容  </span><br><span class="line">Hello 2005 #例如，本例中第一列为姓名，第二列为年份  </span><br><span class="line">Linux 2009  </span><br><span class="line">test 2006</span><br></pre></td></tr></table></figure><p>然后使用join命令，将两个文件连接，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ join testfile_1 testfile_2 #连接testfile_1、testfile_2中的内容  </span><br><span class="line">Hello 95 2005 #连接后显示的内容  </span><br><span class="line">Linux 85 2009  </span><br><span class="line">test 30 2006</span><br></pre></td></tr></table></figure><p>文件1与文件2的位置对输出到标准输出的结果是有影响的。例如将命令中的两个文件互换，即输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join testfile_2 testfile_1</span><br></pre></td></tr></table></figure><p>最终在标准输出的输出结果将发生变化，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> join testfile_2 testfile_1 #改变文件顺序连接两个文件  </span><br><span class="line">Hello 2005 95 #连接后显示的内容  </span><br><span class="line">Linux 2009 85  </span><br><span class="line">test 2006 30</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指定输出字段：</span><br><span class="line">-o &lt;FILENO.FIELDNO&gt; ...</span><br><span class="line">其中FILENO=1表示第一个文件，FILENO=2表示第二个文件，FIELDNO表示字段序号，从1开始编号。默认会全部输出，但关键字列只输出一次。</span><br><span class="line">比如：-o 1.1 1.2 2.2 表示输出第一个文件的第一个字段、第二个字段，第二个文件的第二个字段。</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">使用示例</span><br><span class="line">示例一 内连接（忽略不匹配的行）</span><br><span class="line">不指定任何参数的情况下使用join命令，就相当于数据库中的内连接，关键字不匹配的行不会输出。</span><br><span class="line">[root@rhel55 linux]# cat month_cn.txt </span><br><span class="line">1       一月</span><br><span class="line">2       二月</span><br><span class="line">3       三月</span><br><span class="line">4       四月</span><br><span class="line">5       五月</span><br><span class="line">6       六月</span><br><span class="line">7       七月</span><br><span class="line">8       八月</span><br><span class="line">9       九月</span><br><span class="line">10      十月</span><br><span class="line">11      十一月</span><br><span class="line">12      十二月</span><br><span class="line">13      十三月，故意的 </span><br><span class="line">[root@rhel55 linux]# cat month_en.txt </span><br><span class="line">1       January</span><br><span class="line">2       February</span><br><span class="line">3       March</span><br><span class="line">4       April</span><br><span class="line">5       May</span><br><span class="line">6       June</span><br><span class="line">7       July</span><br><span class="line">8       August</span><br><span class="line">9       September</span><br><span class="line">10      October</span><br><span class="line">11              November</span><br><span class="line">12      December</span><br><span class="line">14      MonthUnknown</span><br><span class="line">注：注意两个文件的内容，中文版的多了十三月，英文版的多了14月，这纯粹是为了方便演示。 </span><br><span class="line">[root@rhel55 linux]# join month_cn.txt month_en.txt  </span><br><span class="line">1 一月 January</span><br><span class="line">2 二月 February</span><br><span class="line">3 三月 March</span><br><span class="line">4 四月 April</span><br><span class="line">5 五月 May</span><br><span class="line">6 六月 June</span><br><span class="line">7 七月 July</span><br><span class="line">8 八月 August</span><br><span class="line">9 九月 September</span><br><span class="line">10 十月 October</span><br><span class="line">11 十一月 November</span><br><span class="line">12 十二月 December</span><br><span class="line">[root@rhel55 linux]#</span><br><span class="line">示例二 左连接（又称左外连接，显示左边所有记录）</span><br><span class="line">显示左边文件中的所有记录，右边文件中没有匹配的显示空白。</span><br><span class="line">[root@rhel55 linux]# join -a1 month_cn.txt month_en.txt   </span><br><span class="line">1 一月 January</span><br><span class="line">2 二月 February</span><br><span class="line">3 三月 March</span><br><span class="line">4 四月 April</span><br><span class="line">5 五月 May</span><br><span class="line">6 六月 June</span><br><span class="line">7 七月 July</span><br><span class="line">8 八月 August</span><br><span class="line">9 九月 September</span><br><span class="line">10 十月 October</span><br><span class="line">11 十一月 November</span><br><span class="line">12 十二月 December</span><br><span class="line">13 十三月，故意的 </span><br><span class="line">[root@rhel55 linux]#</span><br><span class="line"> </span><br><span class="line">示例三 右连接（又称右外连接，显示右边所有记录）</span><br><span class="line">显示右边文件中的所有记录，左边文件中没有匹配的显示空白。</span><br><span class="line">[root@rhel55 linux]# join -a2 month_cn.txt month_en.txt  </span><br><span class="line">1 一月 January</span><br><span class="line">2 二月 February</span><br><span class="line">3 三月 March</span><br><span class="line">4 四月 April</span><br><span class="line">5 五月 May</span><br><span class="line">6 六月 June</span><br><span class="line">7 七月 July</span><br><span class="line">8 八月 August</span><br><span class="line">9 九月 September</span><br><span class="line">10 十月 October</span><br><span class="line">11 十一月 November</span><br><span class="line">12 十二月 December</span><br><span class="line">14 MonthUnknown </span><br><span class="line">[root@rhel55 linux]#</span><br><span class="line"> </span><br><span class="line">示例四 全连接（又称全外连接，显示左边和右边所有记录）</span><br><span class="line">[root@rhel55 linux]# join -a1 -a2 month_cn.txt month_en.txt </span><br><span class="line">1 一月 January</span><br><span class="line">2 二月 February</span><br><span class="line">3 三月 March</span><br><span class="line">4 四月 April</span><br><span class="line">5 五月 May</span><br><span class="line">6 六月 June</span><br><span class="line">7 七月 July</span><br><span class="line">8 八月 August</span><br><span class="line">9 九月 September</span><br><span class="line">10 十月 October</span><br><span class="line">11 十一月 November</span><br><span class="line">12 十二月 December</span><br><span class="line">13 十三月，故意的</span><br><span class="line">14 MonthUnknown </span><br><span class="line">[root@rhel55 linux]#</span><br><span class="line"> </span><br><span class="line">示例五 指定输出字段</span><br><span class="line">比如参数 -o 1.1 表示只输出第一个文件的第一个字段。</span><br><span class="line">[root@rhel55 linux]# join -o 1.1 month_cn.txt month_en.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">[root@rhel55 linux]# join -o 1.1 2.2 month_cn.txt month_en.txt   </span><br><span class="line">1 January</span><br><span class="line">2 February</span><br><span class="line">3 March</span><br><span class="line">4 April</span><br><span class="line">5 May</span><br><span class="line">6 June</span><br><span class="line">7 July</span><br><span class="line">8 August</span><br><span class="line">9 September</span><br><span class="line">10 October</span><br><span class="line">11 November</span><br><span class="line">12 December</span><br><span class="line">[root@rhel55 linux]# join -o 1.1 2.2 1.2 month_cn.txt month_en.txt </span><br><span class="line">1 January 一月</span><br><span class="line">2 February 二月</span><br><span class="line">3 March 三月</span><br><span class="line">4 April 四月</span><br><span class="line">5 May 五月</span><br><span class="line">6 June 六月</span><br><span class="line">7 July 七月</span><br><span class="line">8 August 八月</span><br><span class="line">9 September 九月</span><br><span class="line">10 October 十月</span><br><span class="line">11 November 十一月</span><br><span class="line">12 December 十二月</span><br><span class="line">[root@rhel55 linux]# join -o 1.1 2.2 1.2 1.3 month_cn.txt month_en.txt   &lt;== 字段1.3并不存在 </span><br><span class="line">1 January 一月 </span><br><span class="line">2 February 二月 </span><br><span class="line">3 March 三月 </span><br><span class="line">4 April 四月 </span><br><span class="line">5 May 五月 </span><br><span class="line">6 June 六月 </span><br><span class="line">7 July 七月 </span><br><span class="line">8 August 八月 </span><br><span class="line">9 September 九月 </span><br><span class="line">10 October 十月 </span><br><span class="line">11 November 十一月 </span><br><span class="line">12 December 十二月 </span><br><span class="line">[root@rhel55 linux]#</span><br><span class="line"> </span><br><span class="line">示例六 指定分隔符</span><br><span class="line">[root@rhel55 linux]# join -t ':' /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.find&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;find   path   -option   [   -print ]   [ -exec   -ok   command ]   &amp;#123;&amp;#125; \;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数说明：find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>shell程序设计（二）</title>
    <link href="//harold.me/2018/07/09/shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%BA%8C/"/>
    <id>//harold.me/2018/07/09/shell程序设计二/</id>
    <published>2018-07-09T12:27:54.000Z</published>
    <updated>2018-09-13T09:22:18.530Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.条件</strong></p><p>一个shell脚本能够对任何可以从命令行上调用的命令的退出码进行测试，包括自己写的脚本。</p><p><strong>test或[命令</strong></p><p><code>[</code>或<code></code>test<code>是布尔判断命令，在使用</code>[<code>时，使用符号</code>]`来结尾。</p><p>以下示例检查文件是否存在，用于实现这一操作的命令是<code>test -f &lt;filename&gt;</code></p><a id="more"></a> <p>可以使用如下所示代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if test -f fred.c</span><br><span class="line">then </span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ if fred.c ]</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>test命令的退出码(表明条件是否被满足)决定是否需要执行后面的代码。</p><blockquote><p>注意，必须在<code>[</code>符合和被检查的条件之间留出空格</p><p>如果想把then和if放到同一行，必须用一个分号把test语句和then分隔开：</p><p>if [ -f fred.c ]; then</p><p>…</p><p>fi</p></blockquote><p>test命令可以使用的条件可以归为3类：字符串比较、算数比较和与文件有关的条件测试。</p><table><thead><tr><th>字符串比较</th><th>结果</th></tr></thead><tbody><tr><td>string1 = string2</td><td>如果两个字符串相同结果为真</td></tr><tr><td>string1 != string2</td><td>两个字符串不相同为真</td></tr><tr><td>-n string</td><td>如果字符串不为空则为真</td></tr><tr><td>-z string</td><td>如果字符串为null，则结果为真</td></tr></tbody></table><table><thead><tr><th>算数比较</th><th>结果</th></tr></thead><tbody><tr><td>exp1 -eq exp2</td><td>如果两个表达式相等则为真</td></tr><tr><td>exp1 -ne exp2</td><td>如果两个表达式不相等则为真</td></tr><tr><td>exp1 -gt exp2</td><td>如果exp1大于exp2则为真</td></tr><tr><td>exp1 -ge exp2</td><td>如果exp1大于等于exp2则为真</td></tr><tr><td>exp1 -lt exp2</td><td>如果exp1小于exp2则为真</td></tr><tr><td>exp1 -le exp2</td><td>如果exp1小于等于exp2则为真</td></tr><tr><td>！exp1</td><td>表达式为假则为真</td></tr></tbody></table><table><thead><tr><th>文件条件测试</th><th>结果</th></tr></thead><tbody><tr><td>-d file</td><td>如果文件是一个目录则为真</td></tr><tr><td>-e file</td><td>如果文件存在则为真</td></tr><tr><td>-f file</td><td>如果文件是一个普通文件则为真</td></tr><tr><td>-g file</td><td>如果文件的set-group-id位被设置则为真</td></tr><tr><td>-r file</td><td>文件可读则为真</td></tr><tr><td>-s file</td><td>如果文件大小不为0则为真</td></tr><tr><td>-u file</td><td>如果文件的set-user-id位被设置则结果为真</td></tr><tr><td>-w file</td><td>文件可写则为真</td></tr><tr><td>-x file</td><td>如果文件可执行则为真</td></tr></tbody></table><blockquote><p>set-user-id(set-uid)授予程序其拥有者的访问权限而不是其他使用者的访问权限，set-group-id(set-gid)授予其所在组的访问权限，是通过chmod命令的s和g设置的。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/sh</span><br><span class="line">if [ -f /bin/bash ]</span><br><span class="line">then</span><br><span class="line">    echo "file /bin/bash exists"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -d /bin/bash ]</span><br><span class="line">then</span><br><span class="line">    echo "/bin/bash"</span><br><span class="line">else</span><br><span class="line">    echo "/bin/bash is not a directory"</span><br><span class="line">fi</span><br><span class="line">测试结果：</span><br><span class="line">./iftest.sh</span><br><span class="line">file /bin/bash exists</span><br><span class="line">/bin/bash is not a directory</span><br></pre></td></tr></table></figure><p><strong>2.控制结构</strong></p><ul><li><p>if 语句</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">statements</span><br><span class="line">else</span><br><span class="line">statements</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">echo "Is it morning? please answer yes or no"</span><br><span class="line">read timeofday</span><br><span class="line"></span><br><span class="line">if [ $timeofday = "yes" ]; then</span><br><span class="line">    echo "good morning"</span><br><span class="line">else </span><br><span class="line">    echo "good afternoon"</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>elif语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">echo "Is it morning? please answer yes or no"</span><br><span class="line">read timeofday</span><br><span class="line"></span><br><span class="line">if [ $timeofday = "yes" ]; then</span><br><span class="line">    echo "good morning"</span><br><span class="line">elif [ $timeofday = "no" ]; then</span><br><span class="line">    echo "good afternoon"</span><br><span class="line">else</span><br><span class="line">    echo "Sorry, $timeofday not recognized. Enter yes or no"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>一个与变量有关的问题</p><p>上面的程序存在一个隐含的问题，当输入为空（直接按enter）时，会出现<code>[: =: unexpected operator</code>的错误，因为在if语句中对变量timeofday进行测试的时候，它包含了一个空字符串<code>if [ = &quot;yes&quot; ]</code>，而这不是一个合法的条件，为了避免这个问题，需要给变量加上引号，如<code>if [ &quot;$timeofday&quot; = &quot;yes&quot; ]</code>,这样空变量提供的就是一个合法的测试了。</p></li><li><p>for语句</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for variable in values</span><br><span class="line">do</span><br><span class="line">statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"></span><br><span class="line">for foo in bar fud 43</span><br><span class="line">do</span><br><span class="line">    echo $foo</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>实验：通过通配符扩展的for循环</p><p>在字符串的值中使用一个通配符，并由shell在程序执行时填写所有的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">for file in $(ls f*.sh); do</span><br><span class="line"><span class="meta">#</span> 打印文件</span><br><span class="line">    lpr $file</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>while语句</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while condition do</span><br><span class="line">statement</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>实验：读取密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">echo "Enter password"</span><br><span class="line">read trythis</span><br><span class="line"></span><br><span class="line">while [ "$trythis" != "secret" ]; do</span><br><span class="line">    echo "Sorry, try again"</span><br><span class="line">    read trythis</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>until语句</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">statement</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>与while循环类似，循环将反复执行直到条件为真，如果需要循环至少执行一次，就是用while;如果可能根本都不用执行循环，就使用until.</p><p>实验：特定用户登录报警</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">until who | grep "$1" &gt; /dev/null</span><br><span class="line">do</span><br><span class="line">    sleep 60</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>用户登录，发出警报</span><br><span class="line">echo -e '\a'</span><br><span class="line">echo "***** $1 has just logged in *****"</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>case语句</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case variable in</span><br><span class="line">  pattern [ | pattern ] ...) statements;;</span><br><span class="line">  pattern [ | pattern ] ...) statements;;</span><br><span class="line">  ...</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>case允许通过一种比较复杂的方式将变量内容和模式进行匹配，再根据匹配的模式执行不同的代码。</p><blockquote><p>注意：每个模式以双分号(;;)结尾，因为可以再前后模式之间放置多条语句，所以用双分号标记一个语句的结束</p></blockquote><p>实验一：用户输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "Is it morning? answer yes or no"</span><br><span class="line">read timeofday</span><br><span class="line"></span><br><span class="line">case "$timeofday" in</span><br><span class="line">    yes) echo "good morning";;</span><br><span class="line">    no ) echo "good afternoon";;</span><br><span class="line">    y  ) echo "good morning";;</span><br><span class="line">    n  ) echo "good afternoon";;</span><br><span class="line">    *  ) echo "sorry, answer not recongnized";;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>实验二：合并匹配模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line">echo "Is it morning?"</span><br><span class="line">read timeofday</span><br><span class="line"></span><br><span class="line">case "$timeofday" in</span><br><span class="line">    yes | y | Yes | YES ) echo "good morning";;</span><br><span class="line">    no | n | No | NO )    echo "good afternoon";;</span><br><span class="line">    * )                   echo "sorry"</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><blockquote><p>通配符*在引号中不起作用</p></blockquote><p>实验三：执行多条语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line">echo "Is it morning?"</span><br><span class="line">read timeofday</span><br><span class="line"></span><br><span class="line">case "$timeofday" in</span><br><span class="line">    yes | y | Yes | YES )</span><br><span class="line">        echo "good morning"</span><br><span class="line">        echo "up bright and early this morning"</span><br><span class="line">        ;;</span><br><span class="line">    [nN]* )</span><br><span class="line">        echo "good afternoon"</span><br><span class="line">        echo "have a good rest"</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">    * )                   echo "sorry"</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><blockquote><p>需要把最精确的匹配放到最开始，而把一般匹配放到最后，因为case执行他找到的第一个匹配而不是最佳匹配。esac前的双分号是可选的，</p></blockquote></li><li><p>命令列表</p><ul><li><p>AND列表】</p><p>AND列表结构类似与C语言中的与逻辑：只有前面的所有命令都执行成功才执行下一条命令</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state1 &amp;&amp; state2 &amp;&amp; state3 &amp;&amp; ...</span><br></pre></td></tr></table></figure><p>实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">touch file_one</span><br><span class="line">rm -f file_two</span><br><span class="line"></span><br><span class="line">if [ -f file_one ] &amp;&amp; echo "hello" &amp;&amp; [ -f file_two ] &amp;&amp; echo "there"</span><br><span class="line">then</span><br><span class="line">    echo "in if"</span><br><span class="line">else</span><br><span class="line">    echo "in else"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>OR列表</p><p>OR结构允许持续执行一系列命令知道有一条命令成功为止，其后命令将不再被执行。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state1 || state2 || ...</span><br></pre></td></tr></table></figure><p>实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">rm -r file_one</span><br><span class="line">if [ -f file_one ] || echo "hello" || echo " there"</span><br><span class="line">then</span><br><span class="line">    echo "in if"</span><br><span class="line">else</span><br><span class="line">    echo "in else"</span><br><span class="line">fi  </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li></ul></li><li><p>语句块</p><p>可以用{}构造语句块，其中有多条语句。</p></li></ul><p><strong>3. 函数</strong></p><p>shell中定义函数，只需写出名字、然后一对空括号，再把函数中的语句放到一对花括号之中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function_name() &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">foo () &#123;</span><br><span class="line">echo "Function foo is executing"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "script starting"</span><br><span class="line">foo</span><br><span class="line">echo "script ends"</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><blockquote><p> 必须在调用一个函数之前先对它进行定义，因为所有脚本程序都是从顶部开始执行，所以只要把所有函数定义都放在任何一个函数调用之前，就可以保证函数被调用之前就被定义了。</p><p>当一个函数被调用时，脚本程序的位置参数（<code>$*</code>,<code>$@</code>,<code>$1</code>等）会被替换为函数的参数，当函数执行完毕后，参数会恢复为他们先前的值。</p></blockquote><p>​    通过return命令让函数返回数字值，函数返回字符串的常用方法是让函数将字符串保存在一个变量中，该变量可以在函数结束之后被使用，还可以echo一个字符串并捕获其结果。</p><p>​    可以使用local关键字声明局部变量，局部变量仅在函数作用域内有效，此外函数可以访问全局范围内的其他shell变量，如果一个局部变量和全局变量重名，前者会覆盖后者，但仅限于函数作用范围之内。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">sample_text="global variable"</span><br><span class="line">foo () &#123;</span><br><span class="line">    local sample_text="local variable"</span><br><span class="line">    echo "Function foo is executing"</span><br><span class="line">    echo "$sample_text"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "script starting"</span><br><span class="line">echo "$sample_text"</span><br><span class="line">foo</span><br><span class="line">echo "script ends"</span><br><span class="line">echo "$sample_text"</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>如果函数没有return命令指定返回值，则返回执行的最后一条命令的退出码。</p><p>实验：从函数中返回一个值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">yes_or_no() &#123;</span><br><span class="line">    echo "Is your name $*?"</span><br><span class="line">    while true </span><br><span class="line">    do</span><br><span class="line">      echo -n "Enter yes or no"</span><br><span class="line">      read x</span><br><span class="line">      case "$x" in </span><br><span class="line">        y | yes ) return 0;;</span><br><span class="line">        n | no  ) return 1;;</span><br><span class="line">        * )       echo "Answer yes or no"</span><br><span class="line">      esac</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Original parameter are $*"</span><br><span class="line"></span><br><span class="line">if yes_or_no "$1"</span><br><span class="line">then</span><br><span class="line">    echo "Hi $1 ,nice name"</span><br><span class="line">else </span><br><span class="line">    echo "never mind"</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p><strong>4.命令</strong></p><p>可以再shell脚本中执行两类命令，一类是在命令提示符中进行的<strong>外部命令</strong>，另一种是<strong>内置命令</strong>，内置命令是在shell中实现的，不能作为外部程序被调用。</p><ul><li><p>break命令</p><p>可以跳出for 、while或until，可以为break命令提供一个额外的数值参数来表明需要跳出的循环参数，默认情况下只跳出一层循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">yes_or_no() &#123;</span><br><span class="line">    echo "Is your name $*?"</span><br><span class="line">    while true </span><br><span class="line">    do</span><br><span class="line">      echo -n "Enter yes or no"</span><br><span class="line">      read x</span><br><span class="line">      case "$x" in </span><br><span class="line">        y | yes ) return 0;;</span><br><span class="line">        n | no  ) return 1;;</span><br><span class="line">        * )       echo "Answer yes or no"</span><br><span class="line">      esac</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Original parameter are $*"</span><br><span class="line"></span><br><span class="line">if yes_or_no "$1"</span><br><span class="line">then</span><br><span class="line">    echo "Hi $1 ,nice name"</span><br><span class="line">else </span><br><span class="line">    echo "never mind"</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>：命令</p><p>冒号（：）是一个空命令，偶尔用于简化条件逻辑，相当于true的一个别名，运行比true快，但是作为输出可读性较差。</p></li><li><p>continue</p><p>类似C语言中的同名语句</p></li><li><p>eval命令</p><p>eval命令允许对参数求值。它是shell的内置命令，通常不会以单独命令的形式存在。</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-12/65806701.jpg" alt=""></p><p>如上面的实验所示，eval命令有点像一个额外的<code>$</code>,它给出一个变量的值。</p></li><li><p>exit n</p><p>exit命令使脚本程序以退出码n结束运行，如果在任何一个交互式shell的命令提示符中使用这个命令，将会退出系统。如果允许自己的脚本程序存在退出时不指定一个退出状态，那么脚本中最后一条执行命令的状态将被用作返回值。在shell中，退出码0表示成功，退出码1-125是可以使用的错误码，其余数字有保留含义：</p><p>| 退 出 码  |    说 明     |<br>| :——-: | :———-: |<br>|    126    | 文件不可执行 |<br>|    127    |  命令未找到  |<br>| 128及以上 | 出现一个信号 |</p></li><li><p>export</p><p>export命令将作为它参数的变量导出到子shell中，并使之在子shell有效，在默认情况下，在一个shell中被创建的变量在这个shell调用的下级shell中是不可用的。export命令将自己的参数创建为一个环境变量，而这个环境变量可以被当前程序调用的其他脚本和程序看见。即，被导出的变量构成从shell衍生的任何子进程的环境变量。</p><p>实验：导出变量</p><p>export2.sh:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>！/bin/sh</span><br><span class="line">echo "$foo"</span><br><span class="line">echo "$bar"</span><br></pre></td></tr></table></figure><p>export1.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">foo="The first meta-syntactic variable"</span><br><span class="line">export bar="the second meta-syntactic variable"</span><br><span class="line">./export2.sh</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./export1.sh</span><br><span class="line"></span><br><span class="line">the second meta-syntactic variable</span><br></pre></td></tr></table></figure><p>可见，在运行export2时，foo值已经丢失，但是变量bar的值被导出到了第二个脚本中。一旦一个变量被shell导出，他就可以被该shell调用的任何脚本使用，也可以被后续依次调用的任何shell使用。</p><blockquote><p>set -a或set –allexport命令将导出它之后声明的所有变量。</p></blockquote></li><li><p>expr命令</p><p>expr将它的参数当做一个表达式来求值，常见用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=`expr $x + 1`</span><br></pre></td></tr></table></figure><p>反引号（<code></code>） 使x取值为命令$expr \ \ x+1$的执行结果，可以用语法 $()代替反引号 ，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=$(expr $x + 1)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个shell脚本能够对任何可以从命令行上调用的命令的退出码进行测试，包括自己写的脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;test或[命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[&lt;/code&gt;或&lt;code&gt;&lt;/code&gt;test&lt;code&gt;是布尔判断命令，在使用&lt;/code&gt;[&lt;code&gt;时，使用符号&lt;/code&gt;]`来结尾。&lt;/p&gt;
&lt;p&gt;以下示例检查文件是否存在，用于实现这一操作的命令是&lt;code&gt;test -f &amp;lt;filename&amp;gt;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>shell程序设计(一)</title>
    <link href="//harold.me/2018/07/09/shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>//harold.me/2018/07/09/shell程序设计/</id>
    <published>2018-07-09T07:36:57.000Z</published>
    <updated>2018-09-13T09:22:18.530Z</updated>
    
    <content type="html"><![CDATA[<p>shell是一个作为用户与Linux系统间借口的程序，它允许用户向操作系统输入需要执行的命令。可以使用<code>&lt;</code>和<code>&gt;</code>对输入输出重定向，使用<code>|</code>在同时执行的程序之间实现数据的管道传递，使用<code>${...}</code>获取子进程的输出。</p><h4 id="一、管道与重定向"><a href="#一、管道与重定向" class="headerlink" title="一、管道与重定向"></a>一、管道与重定向</h4><p><strong>1.重定向输出</strong></p><p><code>ls -l &gt; test.txt</code>,这条命令将ls命令的输出保存到test.txt中，文件描述符0代表一个程序的标准输入、1代表标准输出、2代表标准错误输出。上面例子通过<code>&gt;</code>将标准输出重定向到一个文，默认情况下，如果该文件已经存在，他的文件将被覆盖。想改变默认行为，可以通过<code>set -o noclobber</code>命令设置noclobber选项，从而阻止重定向操作对一个已有文件的覆盖。通过<code>set -o noclobber</code>取消该选项。</p><a id="more"></a> <p>可以使用    &gt;&gt; 操作符将输出文件附加到一个文件中，如<code>ps &gt;&gt; test.txt</code></p><p>想对标准输出重定向，需要把想重定向的文件描述符编号加在&gt;操作符前面，例如使用<code>2&gt; err.log</code> 将标准错误流重定向到errl.log。下面的命令将标准输出和标准错误输出分别重定向到不同文件：<br><code>kill -HUP 1234 &gt; killout.txt 2&gt;killerr.txt</code></p><p>可以用<code>&gt;&amp;</code>结合两个流重定向到一个文件：</p><p><code>kill -l 1234 &gt; killouterr.txt 2&gt;&amp;1</code>，这条命令将标准输出和标准错误输出都重定向到一个文件，这里的<strong>操作符顺序</strong>很重要，含义是“将标准输出流重定向到killouterr.txt ，然后将标准错误流输出重定向到与标准输出相同的地方”。</p><p>​    因为可以通过返回码了解kill命令的执行结果，所以通常不需要保存标准输出和错误的内容，可以通过回收站/dev/null有效的丢弃所有输出信息：<code>kill -l 1234 &gt;/dev/null 2&amp;&gt;1</code></p><p><strong>2.重定向输入</strong></p><p><code>more &lt; kill.txt</code></p><p><strong>3.管道</strong></p><p>可以使用<code>|</code>来连接进程，在Linux下通过管道连接的进程可以<strong>同时运行</strong>，并且随着数据流在它们之间自动协调。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps &gt; psout.txt</span><br><span class="line"><span class="meta">$</span> sort psout.txt &gt; pssort.txt</span><br></pre></td></tr></table></figure><p>可以用: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps | sort &gt; pssort.txt</span><br></pre></td></tr></table></figure><p>代替。</p><p>允许连接的进程数目是没有限制的，想查看系统之所有进程名字，但不包括shell,可以用如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps -xo comm | sort | uniq | grep -v sh | more</span><br></pre></td></tr></table></figure><p>上面命令先按照字母排序ps命令的输出，再用uniq去除相同名字的进程，然后用grep  -v删除名字为sh的进程，最终分页显示。</p><blockquote><p>如果有一系列命令需要执行，先用的输出文件是在这一组命令被创建的同时立刻被创建或者写入烦人，所以绝不要在命令流中使用相同的文件名。</p></blockquote><h4 id="二、-作为程序设计语言的shell"><a href="#二、-作为程序设计语言的shell" class="headerlink" title="二、 作为程序设计语言的shell"></a>二、 作为程序设计语言的shell</h4><p>shell运行的方式有两种，可以通过输入一系列命令让shelljiaohu执行，也可以将命令保存到一个文件中，然后将该文件作为一个程序来调用。</p><p><strong>1.交互式程序</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>列出包含“机器“二字的文件</span><br><span class="line"><span class="meta">$</span> for file in * </span><br><span class="line"><span class="meta">&gt;</span> do </span><br><span class="line"><span class="meta">&gt;</span> if grep -l 机器 $file</span><br><span class="line"><span class="meta">&gt;</span> then </span><br><span class="line"><span class="meta">&gt;</span> more $file</span><br><span class="line"><span class="meta">&gt;</span> fi</span><br><span class="line"><span class="meta">&gt;</span> done</span><br></pre></td></tr></table></figure><p>有更有效的方法执行上面简单的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more `grep -l 机器 *`</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more $(grep -l 机器 *)</span><br></pre></td></tr></table></figure><p>此外 <code>grep -l 机器 *</code>将列出所有包含”机器“的文件名。</p><p><strong>2.创建脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/sh</span><br><span class="line">for file in *</span><br><span class="line">do</span><br><span class="line">    if grep -q 机器 $file</span><br><span class="line">    then</span><br><span class="line">      echo $file</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>第一行注释<code>#！</code>告诉系统同一行上紧跟在他后面的那个参数是用来执行本文件的程序，exit命令的作用是确保脚本程序能够返回一个有意义的退出码。在shell中，0表示成功。</p><h4 id="三、shell的语法"><a href="#三、shell的语法" class="headerlink" title="三、shell的语法"></a>三、shell的语法</h4><p><strong>1.变量</strong></p><p>在shell中，使用变量之前通常不需要事先声明，默认情况下，所有变量都被看作字符串并以字符串来存储，即使被赋值为数字也是如此，Linux是大小写敏感的，shell认为Foo与foo是不同的。</p><p>在shell中，可以通过在变量名前加一个<code>$</code>符号来访问它的内容，要为变量赋值时，只需要使用变量名，该变量会根据需要自动创建。一种检查方式是在变量名前加一个 <code>$</code>符号，再用echo命令将它的内容输出到终端。</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-9/46189301.jpg" alt=""></p><blockquote><p>注意：如果字符串中包含空格，就必须用引号将他们括起来，此外，<strong>等号两边不能有空格</strong></p></blockquote><p>可以用<code>read</code>命令将用户的输入赋值给一个变量，这个命令需要一个参数，即准备读入用户输入数据的变量名，然后他会等待用户输入数据，用户按下回车,read结束,从终端读取一个变量时，一般不需要使用引号，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> read test</span><br><span class="line">harsdjkask</span><br><span class="line"><span class="meta">$</span> echo $test</span><br><span class="line">harsdjkask</span><br></pre></td></tr></table></figure><ul><li><p>使用引号</p><p>​    一般情况下，脚本文件中的参数以空白字符分隔，如果想要在一个参数中包含一个或多个空白字符，就必须给参数加上引号。</p><p>​    如果把一个<code>$</code>变量表达式放在双引号中，程序执行到这一行时会把变量替换为它的值；如果放到<strong>单引号中就不会发生替换</strong>现象，可以通过在<code>$</code>前加上一个<code>\</code>字符以取消它的特殊含义。字符串通常放在双引号中，以防止变量被空白字符分开，同时又允许<code>$</code>扩展。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>！ /bin/sh</span><br><span class="line">myvar="Hi there"</span><br><span class="line">echo $myvar</span><br><span class="line">echo "$myvar"</span><br><span class="line">echo '$myvar'</span><br><span class="line">echo \$myvar</span><br><span class="line"></span><br><span class="line">echo "enter some thing"</span><br><span class="line">read myvar</span><br><span class="line"></span><br><span class="line">echo '$myvar' noe equals $myvar</span><br><span class="line">exit 0 </span><br><span class="line">输出：</span><br><span class="line">Hi there</span><br><span class="line">Hi there</span><br><span class="line"><span class="meta">$</span>myvar</span><br><span class="line"><span class="meta">$</span>myvar</span><br><span class="line">enter some thing</span><br><span class="line">123</span><br><span class="line"><span class="meta">$</span>myvar noe equals 12</span><br></pre></td></tr></table></figure></li><li><p>环境变量</p><p>在一个shell脚本开始执行时，会根据环境设置中的值进行初始化，通常用大写字母做名字，以便和普通变量区分。</p></li></ul><table><thead><tr><th>环境变量</th><th>说明</th></tr></thead><tbody><tr><td>$HOME</td><td>当前用户家目录</td></tr><tr><td>$PATH</td><td>用冒号分隔的用来搜索命令的目录列表</td></tr><tr><td>$PS1</td><td>命令提示符，通常是$</td></tr><tr><td>$PS2</td><td>二级提示符，提示后续输入，通常是&gt;</td></tr><tr><td>$IFS</td><td>输入域分隔符，shell读取输入时，它给出用来分隔单词的一组字符，通常是空格、制表符</td></tr><tr><td>$0</td><td>shell脚本的名字</td></tr><tr><td>$#</td><td>传递给脚本的参数个数</td></tr><tr><td>$$</td><td>shell脚本进程号</td></tr></tbody></table><ul><li><p>参数变量</p><p>如果脚本程序在调用时带有参数，一些额外变量就会被创建。及时==即使没有任何参数，环境变量$#也任然存在，只不过是0.</p><p>| 参数变量       | 说    明                                                     |<br>| ————– | ———————————————————— |<br>| <code>$1</code>, <code>$2</code>,… | 脚本程序的参数                                               |<br>| $<em>             | 列出所有参数，各个参数用环境变量IFS中第一个字符分隔开。      |<br>| $@             | $</em>的一个变体，不使用IFS环境变量，所以及时IFS为空，参数也不会挤在一起 |</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">harold@harold-Lenovo-G510:~$ IFS=''</span><br><span class="line">harold@harold-Lenovo-G510:~$ set foo bar bam</span><br><span class="line">harold@harold-Lenovo-G510:~$ echo "$@"</span><br><span class="line">foo bar bam</span><br><span class="line">harold@harold-Lenovo-G510:~$ echo "$*"</span><br><span class="line">foobarbam</span><br><span class="line">harold@harold-Lenovo-G510:~$ unset IFS</span><br><span class="line">harold@harold-Lenovo-G510:~$ echo "$*"</span><br><span class="line">foo bar bam</span><br></pre></td></tr></table></figure><p>一般使用$@是个明智的选择。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/sh</span><br><span class="line">salutation="Hello"</span><br><span class="line">echo $salutation</span><br><span class="line">echo "the program $0 is now running"</span><br><span class="line">echo "the second parameter is $2"</span><br><span class="line">echo "the 1st  parameter is $1"</span><br><span class="line">echo "the parameter list is $*"</span><br><span class="line">echo "the user's home dir is $HOME"</span><br><span class="line"></span><br><span class="line">echo "Please enter a new greeting"</span><br><span class="line">read salutation</span><br><span class="line"></span><br><span class="line">echo $salutation</span><br><span class="line">echo the script is now completed</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">./try_var.sh foo bar baz</span><br><span class="line">Hello</span><br><span class="line">the program ./try_var.sh is now running</span><br><span class="line">the second parameter is bar</span><br><span class="line">the 1st  parameter is foo</span><br><span class="line">the parameter list is foo bar baz</span><br><span class="line">the user's home dir is /home/harold</span><br><span class="line">Please enter a new greeting</span><br><span class="line">gello</span><br><span class="line">gello</span><br><span class="line">the script is now completed</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shell是一个作为用户与Linux系统间借口的程序，它允许用户向操作系统输入需要执行的命令。可以使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;对输入输出重定向，使用&lt;code&gt;|&lt;/code&gt;在同时执行的程序之间实现数据的管道传递，使用&lt;code&gt;${...}&lt;/code&gt;获取子进程的输出。&lt;/p&gt;
&lt;h4 id=&quot;一、管道与重定向&quot;&gt;&lt;a href=&quot;#一、管道与重定向&quot; class=&quot;headerlink&quot; title=&quot;一、管道与重定向&quot;&gt;&lt;/a&gt;一、管道与重定向&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.重定向输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls -l &amp;gt; test.txt&lt;/code&gt;,这条命令将ls命令的输出保存到test.txt中，文件描述符0代表一个程序的标准输入、1代表标准输出、2代表标准错误输出。上面例子通过&lt;code&gt;&amp;gt;&lt;/code&gt;将标准输出重定向到一个文，默认情况下，如果该文件已经存在，他的文件将被覆盖。想改变默认行为，可以通过&lt;code&gt;set -o noclobber&lt;/code&gt;命令设置noclobber选项，从而阻止重定向操作对一个已有文件的覆盖。通过&lt;code&gt;set -o noclobber&lt;/code&gt;取消该选项。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow入门</title>
    <link href="//harold.me/2018/07/08/tensorflow%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E5%9B%BE/"/>
    <id>//harold.me/2018/07/08/tensorflow————计算图/</id>
    <published>2018-07-08T12:22:33.000Z</published>
    <updated>2018-09-13T09:22:18.531Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Tensorflow计算模型——计算图"><a href="#一、Tensorflow计算模型——计算图" class="headerlink" title="一、Tensorflow计算模型——计算图"></a>一、Tensorflow计算模型——计算图</h4><p>计算图是Tensorflow中最基本的一个概念，Tensorflow中所有计算都会被转化为计算图上的结点。Tensor就是张量，在tensorflow中可以理解为多维数组，Flow是“流”，体现了Tensorflow的计算模型，flow表达了张量之间通过计算相互转化的过程。Tensorflow是一个通过计算图的形式来表达计算的编程系统，它的每个计算都是计算图上的一个节点，节点之间的边描述了计算之间的依赖关系。</p> <a id="more"></a><p>Tensorflow程序分为<strong>定义图中所有的计算</strong>和<strong>执行计算</strong>两个阶段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#载入Tensorflow</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.constant([<span class="number">1.0</span>,<span class="number">2.0</span>], name = <span class="string">"a"</span>)</span><br><span class="line">b = tf.constant([<span class="number">2.0</span>,<span class="number">3.0</span>], name = <span class="string">"b"</span>)</span><br><span class="line">result = a + b</span><br></pre></td></tr></table></figure><p>在这个过程中，Tensorflow会自动将定义的计算转为计算图上的节点，在Tensorflow中，系统会维护一个默认计算图。通过tf.get_default_graph可以获得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#a.graph查看张量所属计算图，因为没有特定指定，所以</span></span><br><span class="line"><span class="comment">#这个计算图应该等于当前默认计算图</span></span><br><span class="line">print(a.graph <span class="keyword">is</span> tf.get_default_graph())</span><br></pre></td></tr></table></figure><p>除了默认计算图，Tensorflow支持通过tf.Graph函数来生成新的计算图。<strong>不同计算图上的张量和运算都不会共享</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">g1 = tf.Graph()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> g1.as_default():</span><br><span class="line">    <span class="comment">#在g1中定义v，设值为0</span></span><br><span class="line">    v = tf.get_variable(<span class="string">"v"</span>, initializer=tf.zeros_initializer()(shape=[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">g2 = tf.Graph()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> g2.as_default():</span><br><span class="line">    <span class="comment">#在g2中定义v,设值为2</span></span><br><span class="line">    v = tf.get_variable(<span class="string">"v"</span>, initializer=tf.ones_initializer()(shape=[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#在计算图2中读取变量“v的取值”</span></span><br><span class="line"><span class="keyword">with</span> tf.Session(graph=g2) <span class="keyword">as</span> sess:</span><br><span class="line">    tf.initialize_all_variables().run()</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">""</span>, reuse=<span class="keyword">True</span>):</span><br><span class="line">        print(sess.run(tf.get_variable(<span class="string">"v"</span>)))</span><br><span class="line">输出：[<span class="number">1.</span>]</span><br></pre></td></tr></table></figure><p>Tensorflow中的计算图不仅仅可以用来隔离张量和计算，还提供了管理张量和计算的机制，计算图可以通过tf.Graph.device函数指定运算的设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = tf.Graph()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> g.device(<span class="string">'gpu:0'</span>):</span><br><span class="line">    result = a + b</span><br></pre></td></tr></table></figure><p>在一个计算图中，可以通过集合(“collection”)管理不同类别的资源。比如通过tf.add_to_collection函数可将资源加入一个或多个集合中，然后通过tf.get_collection获取一个集合中的所有资源。</p><p>​                                ——Tensorflow中维护的集合列表——</p><table><thead><tr><th>集合名称</th><th style="text-align:left">集合内容</th><th style="text-align:left">使用场景</th></tr></thead><tbody><tr><td><code>tf.GraphKeys.VARIABLES</code></td><td style="text-align:left">所有变量</td><td style="text-align:left">持久化Tensorflow模型</td></tr><tr><td><code>tf.GraphKeys.TRAINABLE_VARIABLES</code></td><td style="text-align:left">可学习的变量（一般指神经网络中的参数）</td><td style="text-align:left">模型训练、生成模型可视化内容</td></tr><tr><td><code>tf.GraphKeys.SUMMARIES</code></td><td style="text-align:left">日志生成相关的张量</td><td style="text-align:left">Tensorflow计算可视化</td></tr><tr><td><code>tf.GraphKeys.QUEUE_RUNNERS</code></td><td style="text-align:left">处理输入的QueueRunner</td><td style="text-align:left">输入处理</td></tr><tr><td><code>tf.GraphKeys.MOVING_AVERAGE_VARIABLES</code></td><td style="text-align:left">所有计算了滑动平均值的变量</td><td style="text-align:left">计算变量的滑动平均值</td></tr></tbody></table><h4 id="二、Tensorflow数据模型——张量"><a href="#二、Tensorflow数据模型——张量" class="headerlink" title="二、Tensorflow数据模型——张量"></a>二、Tensorflow数据模型——张量</h4><p>在Tensorflow中，所有数据通过张量形式表示，可被理解为多维数组。零阶张量表示<strong>标量</strong>，就是一个数；一阶张量为<strong>向量</strong>，就是一维数组；n阶张量可以理解为一个n维数组。但是Tensorflow中张量并非采用数组形式，它只是对Tensorflow中运算结果的引用，张量中保存的不是数字，而是得到这些数字的计算过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#载入Tensorflow</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#tf.constant是一个计算，结果是一个张量，保存在a中</span></span><br><span class="line">a = tf.constant([<span class="number">1.0</span>,<span class="number">2.0</span>], name = <span class="string">"a"</span>)</span><br><span class="line">b = tf.constant([<span class="number">2.0</span>,<span class="number">3.0</span>], name = <span class="string">"b"</span>)</span><br><span class="line">result = tf.add(a,b,name=<span class="string">"add"</span>)</span><br><span class="line">print(result)</span><br><span class="line">输出：</span><br><span class="line"><span class="comment"># 名字：节点的第一个输出 </span></span><br><span class="line"><span class="comment"># 维度     </span></span><br><span class="line"><span class="comment"># 类型:每个张量类型唯一，不匹配会报错</span></span><br><span class="line">Tensor(<span class="string">"add_2:0"</span>, shape=(<span class="number">2</span>,), dtype=float32)</span><br></pre></td></tr></table></figure><p>从上面看出：Tensorflow计算结果不是一个具体数字而是一个张量的结构。</p><p>张量的使用主要分为两类：</p><ul><li><p>对中间计算结果的引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用张量记录中间结果</span></span><br><span class="line">a = tf.constant([<span class="number">1</span>,<span class="number">2</span>], name = <span class="string">"a"</span>, dtype=tf.float32)</span><br><span class="line">b = tf.constant([<span class="number">2.0</span>,<span class="number">3.0</span>], name = <span class="string">"b"</span>)</span><br><span class="line">result = tf.add(a,b,name=<span class="string">"add"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接计算向量和,可读性差</span></span><br><span class="line">result= tf.constant([<span class="number">1.0</span>,<span class="number">2.0</span>], name=<span class="string">"a"</span>) + tf.constant([<span class="number">2.0</span>,<span class="number">3.0</span>], name=<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure></li><li><p>获取计算结果</p><p>可以使用tf.Session().run(result)得到计算结果</p></li></ul><h4 id="三、Tensorflow运行模型——会话（session）"><a href="#三、Tensorflow运行模型——会话（session）" class="headerlink" title="三、Tensorflow运行模型——会话（session）"></a>三、Tensorflow运行模型——会话（session）</h4><p>session拥有并管理Tensorflow程序运行时的所有资源，当所有计算完成后需要关闭session来帮助系统回收资源。否则可能资源泄露。</p><p>创建会话有两种模式：</p><ul><li><p>明确会话生成和关闭函数: 当程序异常退出时将不能关闭会话导致资源泄露</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建会话</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment">#运算</span></span><br><span class="line">sess.run(...)</span><br><span class="line"><span class="comment"># 关闭会话，释放资源</span></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure></li><li><p>通过Python上下文管理器使用会话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建会话，通过上下文管理器管理会话</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(...)</span><br><span class="line"><span class="comment">#上下文退出时自动关闭session与释放资源</span></span><br></pre></td></tr></table></figure></li></ul><p>Tensorflow可以制定默认的session,默认session被指定后可通过tf.Tensor.eval函数计算一个张量的取值，有如下几种设定方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="keyword">with</span> sess.as_default():</span><br><span class="line">    print(result.eval())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(result.eval(session=sess))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>交互环境下直接构造默认会话，tf.InteractiveSession会自动将生成的会话注册为默认会话。</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print(result.eval())</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure><p>无论使用哪种方法都可以通过ConfigProto Protocol Bufefer配置要生成的会话，通过ConfigProto可以配置类似并行的线程数、GPU分配策略、运算超时时间等参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config = tf.ConfigProto(allow_soft_placement = <span class="keyword">True</span>,<span class="comment">#当某些运算无法被GPU支持时，自动调整到cpu</span></span><br><span class="line">                       log_device_placement = <span class="keyword">True</span>)<span class="comment">#日志中记录每个节点被安排在那个设备上</span></span><br><span class="line">sess1 = tf.InteractiveSession(config=config)</span><br><span class="line">sess2 = tf.Session(config=config)</span><br></pre></td></tr></table></figure><h4 id="四、Tensorflow实现神经网络"><a href="#四、Tensorflow实现神经网络" class="headerlink" title="四、Tensorflow实现神经网络"></a>四、Tensorflow实现神经网络</h4><p>在Tensorflow中，变量的作用就是保存和更新神经网络中的参数，Tensorflow变量需要赋初始值，在神经网络中，给参数赋予随机初始值最常见，所以一般使用随机数给Tensorflow中变量初始化。</p><p><code>weighTensorflow = tf.Variable(tf.random_normal([2,3], stddev = 2))</code>会产生一个2*3的随机数矩阵，矩阵元素均值为0，标准差为2，random_normal还可以通过参数mean指定平均数，在没指定时默认为零。通过满足正态分布的随机数来初始化神经网络中的参数是一个很常用的方法，还有一些其他随机数生成器：</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-8/22556167.jpg" alt=""></p><p>Tensorflow也支持通过常熟来初始化一个变量：</p><table><thead><tr><th>函数名</th><th>功能</th><th>样例</th></tr></thead><tbody><tr><td>tf.zeros</td><td>产生全0数组</td><td>tf.zeros([2,3],tf.int32) -&gt;[[000],[000]]</td></tr><tr><td>tf.ones</td><td>产生全1数组</td><td></td></tr><tr><td>tf.fill</td><td>产生一个全部为给定数字的数组</td><td>tf.fill([2,3],9)-&gt;[[9,9,9],[9,9,9]]</td></tr><tr><td>tf.constant</td><td>产生一个给定值的数组</td></tr></tbody></table><p>神经网络的前向传播：</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-9/34664713.jpg" alt=""></p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-9/39006147.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#声明变量，通过seed设定随机数种子</span></span><br><span class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line"><span class="comment">#将输入特征向量定义为常量，这里x是一个1*2的矩阵</span></span><br><span class="line">x = tf.constant([[<span class="number">0.7</span>,<span class="number">0.9</span>]])</span><br><span class="line"><span class="comment">#通过前向算法，计算矩阵乘法</span></span><br><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a,w2)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment">#初始化变量的两种方式</span></span><br><span class="line"><span class="comment">#1.分开挨个初始化</span></span><br><span class="line"><span class="comment"># sess.run(w1.initializer)</span></span><br><span class="line"><span class="comment"># sess.run(w2.initializer)</span></span><br><span class="line"><span class="comment">#2.一次性初始化所有变量tf.global_variables_initializer</span></span><br><span class="line">init_op = sess.run(tf.global_variables_initializer())</span><br><span class="line">sess.run(y)</span><br><span class="line"></span><br><span class="line">print(sess.run(y))</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure><p>上述代码实现了神经网络的前向传播过程,在计算y之前，需运行w1.initializer和w2.initializer给变量赋值，虽然直接调用变量的初始化过程是一个可行方案，但是当变量数目增多时，或者变量之间存在依赖关系时，单个调用就比较麻烦。因此可以使用tf.global_variables_initializer一次性初始化所有变量。</p><p>Tensorflow中所有变量都会被自动加入GraphKeys.VARIABLES集合，当构建机器学习模型时，可以通过变量声明函数中的trainable参数来区分需要优化的参数（比如神经网络中的参数）和其他参数（如迭代的轮数），如果声明trainable为True,变量会被加入GraphKeys.TRAINABLE_VARIABLES集合，可以通过tf.trainable_variable函数得到需要优化的参数。 Tensorflow中提供的神经网络优化算法会将GraphKeys.TRAINABLE_VARIABLES集合中的变量作为默认的优化对象。</p><p><strong>维度</strong>和<strong>类型</strong>也是变量的两个重要属性，变量类型不可改变，维度在运行中可改变，通过设置参数validate_shape=False。</p><p>在神经网络优化算法中，最常用的是反向传播法（bp）,流程图如下：</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-9/44477907.jpg" alt=""></p><p>​    每次迭代开始前要先选取一小部分训练数据，这一小部分叫一个batch,如果每轮迭代选取的数据都要通过常量来表示，那么Tensorflow的计算图会太大，因为每生成一个常量，Tensorflow都会在计算图中增加一个节点。为此，Tensorflow提供了placeholder机制用于提供输入数据，相当于定义了一个位置，这个位置中的数据在程序运行时再指定。在定义placeholder时，这个位置上的数据类型需要指定，且不可改变。</p><p>​    在得到一个batch的前向传播结果之后，需要定义一个损失函数来刻画当前的预测值和真实值之间的差距，然后通过反向传播算法来调整网络参数的取值使差距缩小。</p><p>例子：利用神经网络解决二分类问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> RandomState</span><br><span class="line"><span class="comment"># 定义训练数据batch大小</span></span><br><span class="line">batch_size = <span class="number">8</span></span><br><span class="line"><span class="comment">#定义神经网络参数</span></span><br><span class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">1</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line"><span class="comment">#在shape的一个维度上使用none可以方便使用不大的batch大小</span></span><br><span class="line">x = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">2</span>), name=<span class="string">'x-input'</span>)</span><br><span class="line">y_ = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>,<span class="number">1</span>), name=<span class="string">'y-input'</span>)</span><br><span class="line"></span><br><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a, w2)</span><br><span class="line"><span class="comment">#定义损失函数和反向传播算法，互熵损失，将在之后的帖子中介绍</span></span><br><span class="line"><span class="comment">#clip_by_value将输入的数值范围限制在（1e-10,1.0)之间，避免出现log0的状况</span></span><br><span class="line">cross_entropy = - tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, <span class="number">1e-10</span>,<span class="number">1.0</span>)))</span><br><span class="line">train_step = tf.train.AdamOptimizer(<span class="number">0.01</span>).minimize(cross_entropy)</span><br><span class="line"><span class="comment">#随机数模拟数据集</span></span><br><span class="line">rdm  = RandomState(<span class="number">1</span>)</span><br><span class="line">dataset_size = <span class="number">128</span></span><br><span class="line">X = rdm.rand(dataset_size, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 根据x1+x2&lt;1判断正反例</span></span><br><span class="line">Y= [[int (x1 + x2 &lt;<span class="number">1</span>)] <span class="keyword">for</span> (x1,x2) <span class="keyword">in</span> X]</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.initialize_all_variables()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    print(sess.run(w1))</span><br><span class="line">    print(sess.run(w2))</span><br><span class="line">    STEPS = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = (i * batch_size) % dataset_size</span><br><span class="line">        end = min(start + batch_size, dataset_size)</span><br><span class="line">        <span class="comment">#通过选取的样本训练网络并更新参数</span></span><br><span class="line">        sess.run(train_step, feed_dict=&#123;x:X[start:end], y_:Y[start:end]&#125;)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#每隔一段时间计算交叉熵</span></span><br><span class="line">            total_cross_entropy = sess.run(cross_entropy, feed_dict=&#123;x:X,y_:Y&#125;)</span><br><span class="line">            print(<span class="string">"After %d training steps(s), cross entropy on all data is %g"</span> % (i, total_cross_entropy))</span><br></pre></td></tr></table></figure><p>总结：神经网络训练步骤：</p><ol><li>定义网络结构和前向传输的输出结果</li><li>定义损失函数及选择反向传播优化算法</li><li>生成会话并在训练数据上反复运行反向传播优化算法</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Tensorflow计算模型——计算图&quot;&gt;&lt;a href=&quot;#一、Tensorflow计算模型——计算图&quot; class=&quot;headerlink&quot; title=&quot;一、Tensorflow计算模型——计算图&quot;&gt;&lt;/a&gt;一、Tensorflow计算模型——计算图&lt;/h4&gt;&lt;p&gt;计算图是Tensorflow中最基本的一个概念，Tensorflow中所有计算都会被转化为计算图上的结点。Tensor就是张量，在tensorflow中可以理解为多维数组，Flow是“流”，体现了Tensorflow的计算模型，flow表达了张量之间通过计算相互转化的过程。Tensorflow是一个通过计算图的形式来表达计算的编程系统，它的每个计算都是计算图上的一个节点，节点之间的边描述了计算之间的依赖关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow" scheme="//harold.me/tags/tensorflow/"/>
    
      <category term="深度学习" scheme="//harold.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow在Docker中切换Python版本</title>
    <link href="//harold.me/2018/07/06/tensorflow%E5%9C%A8Docker%E4%B8%AD%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC/"/>
    <id>//harold.me/2018/07/06/tensorflow在Docker中切换Python版本/</id>
    <published>2018-07-06T14:45:47.000Z</published>
    <updated>2018-09-13T09:22:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fissues%2F10179" target="_blank" rel="noopener">TensorFlow 的 这个 Issue</a> 可以看到，2017年5月已经支持<a href="https://link.jianshu.com?t=https%3A%2F%2Fhub.docker.com%2Fr%2Ftensorflow%2Ftensorflow%2Ftags%2F" target="_blank" rel="noopener">用 tag 提供不同的 image</a>。比如 <code>tensorflow/tensorflow:latest-py3</code> 就可以（安装并）打开 Python3 环境。</p><p>结合目录映射的需要，输入命令完成映射并在 python3 环境下打开：</p><a id="more"></a>     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8888:8888 -v ~/WorkStation/DeepLearning101-002/:/WorkStation/DeepLearning101-002 -w /WorkStation/DeepLearning101-002 tensorflow/tensorflow:latest-py3</span><br></pre></td></tr></table></figure><p>然后用<code>docker ps -a</code>查看所有 image，然后使用命令 <code>docker rename CONTAINER ID XXX</code>，将默认的 Python2 的 image 重命名为 dl，将 Python3 的 image 重命名为 dlpy3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                              COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">f46533729239        tensorflow/tensorflow:latest-py3   &quot;/run_jupyter.sh -...&quot;   11 minutes ago      Exited (0) 6 minutes ago                        dlpy3</span><br><span class="line">f7178713446b        tensorflow/tensorflow              &quot;/run_jupyter.sh -...&quot;   42 minutes ago      Exited (0) 15 minutes ago                       dl</span><br></pre></td></tr></table></figure><p>以后就可以根据需要，打开不同 Python 环境的 image。</p><p>文章内容来自：<a href="https://www.jianshu.com/p/8779099784b2" target="_blank" rel="noopener">https://www.jianshu.com/p/8779099784b2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fissues%2F10179&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TensorFlow 的 这个 Issue&lt;/a&gt; 可以看到，2017年5月已经支持&lt;a href=&quot;https://link.jianshu.com?t=https%3A%2F%2Fhub.docker.com%2Fr%2Ftensorflow%2Ftensorflow%2Ftags%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用 tag 提供不同的 image&lt;/a&gt;。比如 &lt;code&gt;tensorflow/tensorflow:latest-py3&lt;/code&gt; 就可以（安装并）打开 Python3 环境。&lt;/p&gt;
&lt;p&gt;结合目录映射的需要，输入命令完成映射并在 python3 环境下打开：&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow" scheme="//harold.me/tags/tensorflow/"/>
    
      <category term="深度学习" scheme="//harold.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>用Docker安装tensorflow</title>
    <link href="//harold.me/2018/07/06/%E7%94%A8Docker%E5%AE%89%E8%A3%85tensorflow/"/>
    <id>//harold.me/2018/07/06/用Docker安装tensorflow/</id>
    <published>2018-07-06T12:27:54.000Z</published>
    <updated>2018-09-13T09:22:18.536Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-关于TensorFlow"><a href="#1-关于TensorFlow" class="headerlink" title="1 关于TensorFlow"></a>1 关于TensorFlow</h4><hr><p>TensorFlow 随着AlphaGo的胜利也火了起来。google又一次成为大家膜拜的大神了。google大神在引导这机器学习的方向。 同时docker 也是一个非常好的工具，大大的方便了开发环境的构建，之前需要配置安装。 看各种文档，现在只要一个 pull 一个 run 就可以把环境弄好了。 同时如果有写地方需要个性化定制，直接在docker的镜像上面再加一层补丁就好了。 自己的需求就能满足了，同时还可以将这个通用的方法分享出去。</p><a id="more"></a>     <h4 id="2-下载TensorFlow-images"><a href="#2-下载TensorFlow-images" class="headerlink" title="2 下载TensorFlow images"></a>2 下载TensorFlow images</h4><hr><p>使用hub.docker.com的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tensorflow/tensorflow:latest1</span><br></pre></td></tr></table></figure><p>使用daocloud 的镜像，在国内用速度还是挺快的，如果docker.io的镜像慢，可以用daocloud的。<br>这个速度非常的快。一样用的。版本也挺新的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/daocloud/tensorflow:latest 1</span><br></pre></td></tr></table></figure><h4 id="3-启动镜像"><a href="#3-启动镜像" class="headerlink" title="3 启动镜像"></a>3 启动镜像</h4><hr><p>启动命令，设置端口，同时配置volume 数据卷，用于永久保存数据。加上 –rm 在停止的时候删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /data/tensorflow/notebooks</span><br><span class="line">docker run -it --rm --name myts -v /data/tensorflow/notebooks:/notebooks -p 8888:8888 daocloud.io/daocloud/tensorflow:latest12</span><br></pre></td></tr></table></figure><p>启动的时候并不是daemon 模式的，而是前台模式，同时显示了运行的日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">W 06:48:13.425 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.</span><br><span class="line">[I 06:48:13.432 NotebookApp] Serving notebooks from local directory: /notebooks</span><br><span class="line">[I 06:48:13.432 NotebookApp] 0 active kernels </span><br><span class="line">[I 06:48:13.432 NotebookApp] The Jupyter Notebook is running at: http://[all ip addresses on your system]:8888/?token=2031705799dc7a5d58bc51b1f406d8771f0fdf3086b95642</span><br><span class="line">[I 06:48:13.433 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span><br><span class="line">[C 06:48:13.433 NotebookApp] </span><br><span class="line"></span><br><span class="line">    Copy/paste this URL into your browser when you connect for the first time,</span><br><span class="line">    to login with a token:</span><br><span class="line">        http://localhost:8888/?token=2031705799dc7a5d58bc51b1f406d8771f0fdf3086b9564212345678910</span><br></pre></td></tr></table></figure><p>打开浏览器就可以直接看到界面了，同时可以编辑内容：</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-6/87067696.jpg" alt=""></p><h4 id="4-固定token"><a href="#4-固定token" class="headerlink" title="4 固定token"></a>4 固定token</h4><hr><p>vi run_jupyter.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">jupyter notebook --no-browser --NotebookApp.token=&apos;token1234&apos; &gt; /notebooks/jupyter-notebook.log 12</span><br></pre></td></tr></table></figure><p>然后重新打一个docker镜像。<br>vi Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM daocloud.io/daocloud/tensorflow:latest</span><br><span class="line">RUN rm -f /run_jupyter.sh</span><br><span class="line">COPY run_jupyter.sh /run_jupyter.sh</span><br><span class="line">ENTRYPOINT [&quot;/run_jupyter.sh&quot;]1234</span><br></pre></td></tr></table></figure><p>这样就固定token了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mytf:1.0 .</span><br><span class="line">docker run -it --rm --name myts -v /data/tensorflow/notebooks:/notebooks -p 8888:8888 -d mytf:1.012</span><br></pre></td></tr></table></figure><p>然后就可以 -d 参数，将docker 运行放到后台。然后就可以使用 docker exec -it xxx bash 登录进去查看系统的状况了。</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>docker 真的是非常好的技术，能够快速的搭建好环境，省去了繁琐的安装配置过程。 最后使用参数将环境跑起来，同时也可以根据自己的需求，给镜像增加新的功能，就像是盖房子。 一层一层的盖。所有的层，构成了一个整体的房子。 同时对于 TensorFlow 来说是一个程序员必须的技能了。就像是 lucence一样，其实大家都不太了解那个索引算法的。但是还是可以创建出一个索引分词来。 TensorFlow 也是一样的。当做一个工具来使用就好了，具体的算法也不太精通。 有一个说法，数据量上去了，用大数据优化，比算法优化要效果好。</p><p>文章来自：<a href="https://blog.csdn.net/freewebsys/article/details/70237003" target="_blank" rel="noopener">https://blog.csdn.net/freewebsys/article/details/70237003</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-关于TensorFlow&quot;&gt;&lt;a href=&quot;#1-关于TensorFlow&quot; class=&quot;headerlink&quot; title=&quot;1 关于TensorFlow&quot;&gt;&lt;/a&gt;1 关于TensorFlow&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;TensorFlow 随着AlphaGo的胜利也火了起来。google又一次成为大家膜拜的大神了。google大神在引导这机器学习的方向。 同时docker 也是一个非常好的工具，大大的方便了开发环境的构建，之前需要配置安装。 看各种文档，现在只要一个 pull 一个 run 就可以把环境弄好了。 同时如果有写地方需要个性化定制，直接在docker的镜像上面再加一层补丁就好了。 自己的需求就能满足了，同时还可以将这个通用的方法分享出去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow，深度学习" scheme="//harold.me/tags/tensorflow%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令————more、less、cmp、split、colrm、look</title>
    <link href="//harold.me/2018/07/06/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A45/"/>
    <id>//harold.me/2018/07/06/linux常用命令5/</id>
    <published>2018-07-06T07:41:35.000Z</published>
    <updated>2018-09-13T09:22:18.528Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.more</strong></p><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]</span><br></pre></td></tr></table></figure><a id="more"></a>     <p> <strong>参数</strong>：</p><ul><li>-num 一次显示的行数</li><li>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声</li><li>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</li><li>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）</li><li>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</li><li>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料</li><li>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</li><li>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</li><li>+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</li><li>+num 从第 num 行开始显示</li><li>fileNames 欲显示内容的文档，可为复数个数</li></ul><p>常用操作命令</p><ul><li>Enter 向下n行，需要定义。默认为1行</li><li>Ctrl+F 向下滚动一屏</li><li>空格键 向下滚动一屏</li><li>Ctrl+B 返回上一屏</li><li>= 输出当前行的行号</li><li>：f 输出文件名和当前行的行号</li><li>V 调用vi编辑器</li><li>!命令 调用Shell，并执行命令</li><li>q 退出more</li></ul><p><strong>2.less</strong></p><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [参数] 文件</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-b &lt;缓冲区大小&gt; 设置缓冲区的大小</li><li>-e 当文件显示结束后，自动离开</li><li>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li><li>-g 只标志最后搜索的关键词</li><li>-i 忽略搜索时的大小写</li><li>-m 显示类似more命令的百分比</li><li>-N 显示每行的行号</li><li>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</li><li>-Q 不使用警告音</li><li>-s 显示连续空行为一行</li><li>-S 行过长时间将超出部分舍弃</li><li>-x &lt;数字&gt; 将”tab”键显示为规定的数字空格</li><li>/字符串：向下搜索”字符串”的功能</li><li>?字符串：向上搜索”字符串”的功能</li><li>n：重复前一个搜索（与 / 或 ? 有关）</li><li>N：反向重复前一个搜索（与 / 或 ? 有关）</li><li>b 向后翻一页</li><li>d 向后翻半页</li><li>h 显示帮助界面</li><li>Q 退出less 命令</li><li>u 向前滚动半页</li><li>y 向前滚动一行</li><li>空格键 滚动一页</li><li>回车键 滚动一行</li><li>[pagedown]： 向下翻动一页</li><li>[pageup]： 向上翻动一页</li></ul><p><strong>3.cmp</strong></p><p>Linux cmp命令用于比较两个文件是否有差异。</p><p>当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为”-“，则cmp指令会从标准输入设备读取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp [-clsv][-i &lt;字符数目&gt;][--help][第一个文件][第二个文件]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-c或–print-chars 　除了标明差异处的十进制字码之外，一并显示该字符所对应字符。</li><li>-i&lt;字符数目&gt;或–ignore-initial=&lt;字符数目&gt; 　指定一个数目。</li><li>-l或–verbose 　标示出所有不一样的地方。</li><li>-s或–quiet或–silent 　不显示错误信息。</li><li>-v或–version 　显示版本信息。</li><li><p>–help 　在线帮助。</p><p>要确定两个文件是否相同，请输入：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp prog.o.bak prog.o</span><br></pre></td></tr></table></figure><p><strong>4.split</strong></p><p>Linux split命令用于将一个文件分割成数个。</p><p>该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-&lt;行数&gt; : 指定每多少行切成一个小文件</li><li>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</li><li>–help : 在线帮助</li><li>–version : 显示版本信息</li><li>-C&lt;字节&gt; : 与参数”-b”相似，但是在切 割时将尽量维持每行的完整性</li><li><p>[输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</p><p>使用指令”split”将文件”README”每6行切割成一个文件，输入如下命令：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ split -6 README       #将README文件每六行分割成一个文件</span><br></pre></td></tr></table></figure><p>以上命令执行后，指令”split”会将原来的大文件”README”切割成多个以”x”开头的小文件。而在这些小文件中，每个文件都只有6行内容。</p><p>使用指令”ls”查看当前目录结构，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls                                #执行ls指令  </span><br><span class="line">#获得当前目录结构  </span><br><span class="line">README xaa xad xag xab xae xah xac xaf xai</span><br></pre></td></tr></table></figure><p><strong>5.colrm</strong></p><p>Linux colrm命令用于滤掉指定的列。</p><p>colrm指令从标准输入设备读取书记，转而输出到标准输出设备。如果不加任何参数，则该指令不会过滤任何一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colrm [开始行数编号&lt;结束行数编号&gt;]</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>开始列数编号： 指定要删除的列的起始编号。</li><li>结束列数编号：指定要删除的列的结束编号，有时候这个参数可以省略。</li></ul><p>按回车键后，光标将在第一行闪烁，等待标准输入，此时输入字符，如”Hello Linux！”，再按回车键后第二行将出现与第一行相同内容，此时按Ctrl+C组合键可以退出。终端中显示的内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd@hdd-desktop:~$ colrm  </span><br><span class="line">Hello Linux! #输入Hello Linux！字符串  </span><br><span class="line">Hello Linux! #输出刚才输入的字符串Hello Linux！</span><br></pre></td></tr></table></figure><p>如想要删除第4 列之后的所有内容，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colrm 4</span><br></pre></td></tr></table></figure><p>类似于上例，此时标准输入等待输入，用户输入字符串按回车键后，将输出如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd@hdd-desktop:~$ colrm 4  </span><br><span class="line">Hello Linux! #输入Hello Linux！字符串  </span><br><span class="line">Hel #输出删除了第4列以后所有内容的字符串</span><br></pre></td></tr></table></figure><p>删除指定列的内容。如删除第4列到第6列的内容，可使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colrm 4 6</span><br></pre></td></tr></table></figure><p>输出的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd@hdd-desktop:~$ colrm 4 6  </span><br><span class="line">Hello Linux! #输入Hello Linux！字符串  </span><br><span class="line">HelLinux! #输出删除了从第4列到第6列字符的字符串</span><br></pre></td></tr></table></figure><p><strong>6.look</strong></p><p>Linux look命令用于查询单词。</p><p>look指令用于英文单字的查询。您仅需给予它欲查询的字首字符串，它会显示所有开头字符串符合该条件的单字。</p><p><code>look [-adf][-t&lt;字尾字符串&gt;][字首字符串][字典文件]</code></p><p><strong>参数说明</strong>：</p><ul><li>-a 使用另一个字典文件web2，该文件也位于/usr/dict目录下。</li><li>-d 只对比英文字母和数字，其余一慨忽略不予比对。</li><li>-f 忽略字符大小写差别。</li><li>-t&lt;字尾字符串&gt; 设置字尾字符串。</li></ul><p>为了查找在testfile文件中以字母L开头的所有的行，可以输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">look L testfile</span><br></pre></td></tr></table></figure><p>原文件testfile中的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat testfile #查看testfile 文件内容  </span><br><span class="line">HELLO LINUX!  </span><br><span class="line">Linux is a free unix-type opterating system.  </span><br><span class="line">This is a linux testfile!  </span><br><span class="line">Linux test</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.more&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——Mysql题目（一）</title>
    <link href="//harold.me/2018/07/06/leetcode%E2%80%94%E2%80%94Mysql%E9%A2%98%E7%9B%AE/"/>
    <id>//harold.me/2018/07/06/leetcode——Mysql题目/</id>
    <published>2018-07-06T01:22:10.000Z</published>
    <updated>2018-09-13T09:22:18.526Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.寻找第n大</strong></p><p>Write a SQL query to get the <em>n</em>th highest salary from the <code>Employee</code> table.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//方法一：171ms</span><br><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE M INT;</span><br><span class="line">SET M=N-1;</span><br><span class="line">  RETURN (</span><br><span class="line">      # 这里的distinct是关键</span><br><span class="line">      select distinct Salary from Employee Order by(Salary) desc limit M,1</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><a id="more"></a>     <p>需要回忆一下mysql的执行顺序：MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。</p><p><img src="http://p5s7d12ls.bkt.clouddn.com/18-7-6/82375438.jpg" alt=""></p><ol><li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li><li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。</join-condition></li><li><strong>JOIN</strong>： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li><li><strong>WHERE</strong>： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。</where-condition></li><li><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li><li><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li><li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。</having-condition></li><li><strong>SELECT</strong>： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li><li><strong>DISTINCT</strong>： 对VT8中的记录进行去重。产生虚拟表VT9.</li><li><strong>ORDER BY</strong>: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10、</li><li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//方法二：480ms</span><br><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  RETURN (</span><br><span class="line">     SELECT IFNULL(</span><br><span class="line">     (</span><br><span class="line">         SELECT e1.Salary </span><br><span class="line">         from Employee e1</span><br><span class="line">         join Employee e2</span><br><span class="line">         on e2.Salary &gt;= e1.Salary</span><br><span class="line">         group by e1.Salary</span><br><span class="line">         HAVING count(distinct e2.Salary) = N</span><br><span class="line">     ),null)      </span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p> <strong>2.排名</strong></p><p>Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no “holes” between ranks.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p>For example, given the above <code>Scores</code> table, your query should generate the following report (order by highest score):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">| Score | Rank |</span><br><span class="line">+-------+------+</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.50  | 4    |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure><p>方法一：634ms</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s1.Score, (select count(distinct s2.Score) from Scores s2 where s2.Score&gt;=s1.Score) as Rank from Scores s1 order by s1.Score desc;</span><br></pre></td></tr></table></figure><p>方法二：257ms</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select s.Score, CAST(temp.Rank as SIGNED) as Rank from Scores s left join </span><br><span class="line">(</span><br><span class="line">select t.Score, @rank := @rank + 1 as Rank from </span><br><span class="line">(</span><br><span class="line">select Score</span><br><span class="line">from Scores</span><br><span class="line">group by Score </span><br><span class="line">order by Score desc</span><br><span class="line">) t, (select @rank := 0) r</span><br><span class="line">) temp on s.Score = temp.Score</span><br><span class="line">order by s.Score desc</span><br></pre></td></tr></table></figure><p>方法三：193ms</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select s.Score, CAST(temp.Rank as signed) Rank from</span><br><span class="line">Scores s left join (</span><br><span class="line">    Select t.Score,@row := @row +1 Rank from (</span><br><span class="line">    select distinct Score</span><br><span class="line">    from Scores order by Score desc</span><br><span class="line">    ) t,(select @row :=0) r</span><br><span class="line">) temp on s.Score = temp.Score order by s.Score desc</span><br></pre></td></tr></table></figure><p>在MySQl中可以利用SQL语句将值存储在用户自定义变量中，然后再利用另一条SQL语句来查询用户自定义变量。这样一来，可以在不同的SQL间传递值。</p><p>用户自定义变量的声明方法形如：@var_name，其中变量名称由字母、数字、“.”、“_”和“$”组成。当然，在以字符串或者标识符引用时也可以包含其他字符（例如：@’my-var’，@”my-var”，或者@<code>my-var</code>）。</p><p>用户自定义变量是会话级别的变量。其变量的作用域仅限于声明其的客户端链接。当这个客户端断开时，其所有的会话变量将会被释放。</p><p>用户自定义变量是不区分大小写的。</p><p>使用SET语句来声明用户自定义变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 SET @var_name = expr[, @var_name = expr] ...</span><br></pre></td></tr></table></figure><p>在使用SET设置变量时，可以使用“=”或者“:=”操作符进行赋值。</p><p>当然，除了SET语句还有其他赋值的方式。比如下面这个例子，但是赋值操作符只能使用“:=”。因为“=”操作符将会被认为是比较操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @t1=1, @t2=2, @t3:=4;</span><br><span class="line">mysql&gt; SELECT @t1, @t2, @t3, @t4 := @t1+@t2+@t3;</span><br><span class="line">+------+------+------+--------------------+</span><br><span class="line">| @t1  | @t2  | @t3  | @t4 := @t1+@t2+@t3 |</span><br><span class="line">+------+------+------+--------------------+</span><br><span class="line">|    1 |    2 |    4 |                  7 |</span><br><span class="line">+------+------+------+--------------------+</span><br></pre></td></tr></table></figure><p>用户变量的类型仅限于：整形、浮点型、二进制与非二进制串和NULL。在赋值浮点数时，系统不会保留精度。其他类型的值将会被转成相应的上述类型。比如：一个包含时间或者空间数据类型（temporal or spatial data type）的值将会转换成一个二进制串。</p><p><strong>* 方法四：</strong>在Mysql中没有<code>ROW_NUMBER() over (PARTITION BY xx ORDER BY ** DESC)</code>这样的函数，但是在Hive或者Oracle中是存在的简单的说row_number()从1开始，为每一条分组记录返回一个数字，这里的ROW_NUMBER() OVER (ORDER BY xlh DESC) 是先把xlh列降序，再为降序以后的没条xlh记录返回一个序号。 </p><p>row_number() 是没有重复值的排序(即使两天记录相等也是不重复的)，可以利用它来实现分页<br>dense_rank() 是连续排序，两个第二名仍然跟着第三名<br>rank() 是跳跃拍学，两个第二名下来就是第四名</p><p>使用方法 fun() over( partition by field,field… order by flag.. asc/desc)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.寻找第n大&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Write a SQL query to get the &lt;em&gt;n&lt;/em&gt;th highest salary from the &lt;code&gt;Employee&lt;/code&gt; table.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+----+--------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| Id | Salary |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----+--------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 1  | 100    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 2  | 200    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 3  | 300    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----+--------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//方法一：171ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DECLARE M INT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SET M=N-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  RETURN (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      # 这里的distinct是关键&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      select distinct Salary from Employee Order by(Salary) desc limit M,1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;END&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="//harold.me/tags/Mysql/"/>
    
      <category term="数据库， Hive" scheme="//harold.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C-Hive/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令————read、col、cat、tail、查看日志命令</title>
    <link href="//harold.me/2018/07/05/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A44/"/>
    <id>//harold.me/2018/07/05/linux常用命令4/</id>
    <published>2018-07-05T14:53:52.000Z</published>
    <updated>2018-09-13T09:22:18.528Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.read</strong></p><p>Linux read命令用于从标准输入读取数值。</p><p>read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]</span><br></pre></td></tr></table></figure><a id="more"></a>     <p><strong>参数说明:</strong></p><ul><li>-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</li><li>-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。</li><li>-p 后面跟提示信息，即在输入前打印提示信息。</li><li>-e 在输入的时候可以时候命令补全功能。</li><li>-n 后跟一个数字，定义输入文本的长度，很实用。</li><li>-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。</li><li>-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</li><li>-t 后面跟秒数，定义输入字符的等待时间。</li><li>-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</li></ul><p><strong>a、简单读取</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#这里默认会换行  </span><br><span class="line">echo &quot;输入网站名: &quot;  </span><br><span class="line">#读取从键盘的输入  </span><br><span class="line">read website  </span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;  </span><br><span class="line">exit 0  #退出</span><br></pre></td></tr></table></figure><p><strong>b、-p 参数，允许在 read 命令行中直接指定一个提示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">read -p &quot;输入网站名:&quot; website</span><br><span class="line">echo &quot;你输入的网站名是 $website&quot; </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p><strong>c.读取文件</strong></p><p>每次调用 read 命令都会读取文件中的 “一行” 文本。当文件没有可读的行时，read 命令将以非零状态退出。</p><p>通过什么样的方法将文件中的数据传给 read 呢？使用 cat 命令并通过管道将结果直接传送给包含 read 命令的 while 命令。</p><p>测试文件 test.txt 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">  </span><br><span class="line">count=1    # 赋值语句，不加空格</span><br><span class="line">cat test.txt | while read line      # cat 命令的输出作为read命令的输入,read读到&gt;的值放在line中</span><br><span class="line">do</span><br><span class="line">   echo &quot;Line $count:$line&quot;</span><br><span class="line">   count=$[ $count + 1 ]          # 注意中括号中的空格。</span><br><span class="line">done</span><br><span class="line">echo &quot;finish&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p><strong>2.col</strong></p><p>Linux col命令用于过滤控制字符。</p><p>在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符”&gt;”和”&gt;&gt;”，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col [-bfx][-l&lt;缓冲区列数&gt;]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-b 过滤掉所有的控制字符，包括RLF和HRLF。</li><li>-f 滤除RLF字符，但允许将HRLF字符呈现出来。</li><li>-x 以多个空格字符来表示跳格字符。</li><li><p>-l&lt;缓冲区列数&gt; 预设的内存缓冲区有128列，您可以自行指定缓冲区的大小。</p><p>下面以 man 命令帮助文档为例，讲解col 命令的使用。</p></li></ul><p>将man 命令的帮助文档保存为man_help，使用-b 参数过滤所有控制字符。在终端中使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man man | col-b &gt; man_help</span><br></pre></td></tr></table></figure><p><strong>3.tail</strong></p><p>tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。</p><p>tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p><p><strong>命令格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [参数] [文件]</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>-f 循环读取</li><li>-q 不显示处理信息</li><li>-v 显示详细的处理信息</li><li>-c&lt;数目&gt; 显示的字节数</li><li>-n&lt;行数&gt; 显示行数</li><li>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.</li><li>-q, –quiet, –silent 从不输出给出文件名的首部</li><li><p>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</p><p>要显示 notes.log 文件的最后 10 行，请输入以下命令：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail notes.log</span><br></pre></td></tr></table></figure><p>要跟踪名为 notes.log 的文件的增长情况，请输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f notes.log</span><br></pre></td></tr></table></figure><p>此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。</p><p>显示文件 notes.log 的内容，从第 20 行至文件末尾:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail +20 notes.log</span><br></pre></td></tr></table></figure><p>显示文件 notes.log 的最后 10 个字符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -c 10 notes.log</span><br></pre></td></tr></table></figure><p><strong>4.cat</strong></p><p>cat 命令用于连接文件并打印到标准输出设备上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。</p><p><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。</p><p><strong>-s 或 –squeeze-blank</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行。</p><p><strong>-v 或 –show-nonprinting</strong>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</p><p><strong>-E 或 –show-ends</strong> : 在每行结束处显示 $。</p><p><strong>-T 或 –show-tabs</strong>: 将 TAB 字符显示为 ^I。</p><p><strong>-e</strong> : 等价于 -vE。</p><p><strong>-A, –show-all</strong>：等价于 -vET。</p><p><strong>-e：</strong>等价于”-vE”选项；</p><p><strong>-t：</strong>等价于”-vT”选项；</p><p><strong>5.Linux查看日志命令</strong></p><p>当日志文件存储日志很大时，我们就不能用vi直接进去查看日志，需要Linux的命令去完成我们的查看任务.</p><ul><li><strong>混合使用命令</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A.  tail web.2016-06-06.log -n 300 -f  </span><br><span class="line">    查看底部即最新300条日志记录，并实时刷新      </span><br><span class="line"></span><br><span class="line">B.  grep &apos;nick&apos; | tail web.2016-04-04.log -C 10   </span><br><span class="line">    查看字符‘nick’前后10条日志记录, 大写C  </span><br><span class="line"></span><br><span class="line">C.  cat -n test.log |tail -n +92|head -n 20  </span><br><span class="line">    tail -n +92表示查询92行之后的日志  </span><br><span class="line">    head -n 20 则表示在前面的查询结果里再查前20条记录</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.read&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux read命令用于从标准输入读取数值。&lt;/p&gt;
&lt;p&gt;read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令————前后台进程管理</title>
    <link href="//harold.me/2018/07/05/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A43/"/>
    <id>//harold.me/2018/07/05/linux常用命令3/</id>
    <published>2018-07-05T14:33:48.000Z</published>
    <updated>2018-09-13T09:22:18.528Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、&amp;</strong></p><p>在Linux终端运行命令的时候，在命令末尾加上 &amp; 符号，就可以让程序在后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tcpserv01 &amp;</span><br></pre></td></tr></table></figure><p><strong>2、 Ctrl+z 和 bg</strong></p><p> 如果程序正在前台运行，可以使用 Ctrl+z 选项把程序暂停，然后用 bg %[number] 命令把这个程序放到后台运行.通过bg %num 即可将挂起的job的状态由stopped改为running，仍在后台执行；当需要改为在前台执行时，执行命令fg %num即可</p><a id="more"></a> <p><strong>3. fg</strong></p><p> 将后台中的命令调至前台继续运行.如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</p><p><strong>4.jobs</strong></p><p>查看当前有多少在后台运行的命令</p><p>jobs命令执行的结果，<strong>＋（加号）</strong>表示是一个当前的作业，<strong>- （减号）</strong>表示是一个当前作业之后的一个作业，jobs -l选项可显示所有任务的PID.</p><p>jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息；</p><p><strong>5.jps</strong></p><p>jps – Java Virtual Machine Process Status Tool  </p><p>可以列出本机所有java进程的pid </p><p>-q 仅输出VM标识符，不包括class name,jar name,arguments in main method<br>-m 输出main method的参数<br>-l 输出完全的包名，应用主类名，jar的完全路径名<br>-v 输出jvm参数<br>-V 输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件</p><p>-Joption 传递参数到vm,例如:-J-Xms48m</p><p>下列命令可以用来操纵进程任务：</p><p>　　ps 列出系统中正在运行的进程；</p><p>　　kill 发送信号给一个或多个进程（经常用来杀死一个进程）；</p><p>　　jobs 列出当前shell环境中已启动的任务状态，若未指定jobsid，则显示所有活动的任务状态信息；</p><p>如果报告了一个任务的终止(即任务的状态被标记为Terminated)，shell 从当前的shell环境已知的列表中删除任务的进程标识；</p><p>　　bg 将进程搬到后台运行（Background）；</p><p>　　fg 将进程搬到前台运行（Foreground）； </p><p><strong>概念：当前任务</strong><br>　　如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]”的后台任务。</p><p>所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果不加任何引号，则所变动的均是当前任务。</p><p><strong>==== 前台进程的挂起</strong>： ctrl+Z;<br><strong>==== 进程的终止:　　  —-  后台进程的终止：</strong></p><p>　　 方法一：通过jobs命令查看job号（假设为num），然后执行kill %num   <strong>$ kill %1</strong><br>　　 方法二：通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid  <strong>$ kill 5270</strong></p><p>—–  ctrl+c,ctrl+d,ctrl+z在linux中意义：</p><p>​        ctrl-c 发送 SIGINT 信号给前台进程组中的所有进程。常用于终止正在运行的程序。<br>        ctrl-z 发送 SIGTSTP 信号给前台进程组中的所有进程，常用于挂起一个进程。<br>        ctrl-d 不是发送信号，而是表示一个特殊的二进制值，表示 EOF。<br>        ctrl-\ 发送 SIGQUIT 信号给前台进程组中的所有进程，终止前台进程并生成 core 文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、&amp;amp;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Linux终端运行命令的时候，在命令末尾加上 &amp;amp; 符号，就可以让程序在后台运行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./tcpserv01 &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2、 Ctrl+z 和 bg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如果程序正在前台运行，可以使用 Ctrl+z 选项把程序暂停，然后用 bg %[number] 命令把这个程序放到后台运行.通过bg %num 即可将挂起的job的状态由stopped改为running，仍在后台执行；当需要改为在前台执行时，执行命令fg %num即可&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令————crontab、du、df、sort</title>
    <link href="//harold.me/2018/07/05/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A42/"/>
    <id>//harold.me/2018/07/05/linux常用命令2/</id>
    <published>2018-07-05T13:11:49.000Z</published>
    <updated>2018-09-13T09:22:18.528Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.crontab</strong></p><p>Linux crontab是用来定期执行程序的命令。</p><p>当安装完成操作系统之后，默认便会启动此任务调度命令。</p><p>crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><p>而linux任务调度的工作主要分为以下两类：</p><ul><li>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</li><li>2、个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</li></ul><a id="more"></a> <p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [ -u user ] file</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [ -u user ] &#123; -l | -r | -e &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>crontab 是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。</p><p>-u user 是指设定指定 user 的时程表，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设定自己的时程表。</p><p><strong>参数说明</strong>：</p><ul><li>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)</li><li>-r : 删除目前的时程表</li><li>-l : 列出目前的时程表</li></ul><p>时程表的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br></pre></td></tr></table></figure><ul><li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li><li>当 f1 为 <em> 时表示每分钟都要执行 program，f2 为 </em> 时表示每小时都要执行程序，其馀类推</li><li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li><li>当 f1 为 <em>/n 时表示每 n 分钟个时间间隔执行一次，f2 为 </em>/n 表示每 n 小时个时间间隔执行一次，其馀类推</li><li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li></ul><p>使用者也可以将所有的设定先存放在文件中，用 crontab file 的方式来设定时程表。</p><p><strong>实例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * /bin/ls</span><br></pre></td></tr></table></figure><p>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 6-12/3 * 12 * /usr/bin/backup</span><br></pre></td></tr></table></figure><p>周一到周五每天下午 5:00 寄一封信给 <a href="mailto:alex@domain.name" target="_blank" rel="noopener">alex@domain.name</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata</span><br></pre></td></tr></table></figure><p>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 0-23/2 * * * echo &quot;haha&quot;</span><br></pre></td></tr></table></figure><p>下面再看看几个具体的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 */2 * * * /sbin/service httpd restart  意思是每两个小时重启一次apache </span><br><span class="line"></span><br><span class="line">50 7 * * * /sbin/service sshd start  意思是每天7：50开启ssh服务 </span><br><span class="line"></span><br><span class="line">50 22 * * * /sbin/service sshd stop  意思是每天22：50关闭ssh服务 </span><br><span class="line"></span><br><span class="line">0 0 1,15 * * fsck /home  每月1号和15号检查/home 磁盘 </span><br><span class="line"></span><br><span class="line">1 * * * * /home/bruce/backup  每小时的第一分执行 /home/bruce/backup这个文件 </span><br><span class="line"></span><br><span class="line">00 03 * * 1-5 find /home &quot;*.xxx&quot; -mtime +4 -exec rm &#123;&#125; \;  每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span><br><span class="line"></span><br><span class="line">30 6 */10 * * ls  意思是每月的1、11、21、31日是的6：30执行一次ls命令</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当程序在你所指定的时间执行后，系统会寄一封信给你，显示该程序执行的内容，若是你不希望收到这样的信，请在每一行空一格之后加上 &gt; /dev/null 2&gt;&amp;1 即可</p><p><strong>crond服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service crond start    //启动服务</span><br><span class="line">/sbin/service crond stop     //关闭服务</span><br><span class="line">/sbin/service crond restart  //重启服务</span><br><span class="line">/sbin/service crond reload   //重新载入配置</span><br></pre></td></tr></table></figure><p>查看crontab服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond status</span><br></pre></td></tr></table></figure><p>手动启动crontab服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond start</span><br></pre></td></tr></table></figure><p>查看crontab服务是否已设置为开机启动，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntsysv</span><br></pre></td></tr></table></figure><p>加入开机自动启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig –level 35 crond on</span><br></pre></td></tr></table></figure><p> <strong>2.du</strong></p><p>Linux du命令用于显示目录或文件的大小。</p><p>du会显示指定的目录或文件所占用的磁盘空间。</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][--block-size][--exclude=&lt;目录或文件&gt;][--max-depth=&lt;目录层数&gt;][--help][--version][目录或文件]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-a或-all 显示目录中个别文件的大小。</li><li>-b或-bytes 显示目录或文件大小时，以byte为单位。</li><li>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li><li>-D或–dereference-args 显示指定符号连接的源文件大小。</li><li>-h或–human-readable 以K，M，G为单位，提高信息的可读性。</li><li>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。</li><li>-k或–kilobytes 以1024 bytes为单位。</li><li>-l或–count-links 重复计算硬件连接的文件。</li><li>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。</li><li>-m或–megabytes 以1MB为单位。</li><li>-s或–summarize 仅显示总计。</li><li>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li><li>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li><li>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li><li>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</li><li>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。</li><li>–help 显示帮助。</li><li><p>–version 显示版本信息。</p><p><strong>实例</strong></p></li></ul><p>显示目录或者文件所占空间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># du</span><br><span class="line">608     ./test6</span><br><span class="line">308     ./test4</span><br><span class="line">4       ./scf/lib</span><br><span class="line">4       ./scf/service/deploy/product</span><br><span class="line">4       ./scf/service/deploy/info</span><br><span class="line">12      ./scf/service/deploy</span><br><span class="line">16      ./scf/service</span><br><span class="line">4       ./scf/doc</span><br><span class="line">4       ./scf/bin</span><br><span class="line">32      ./scf</span><br><span class="line">8       ./test3</span><br><span class="line">1288    .</span><br></pre></td></tr></table></figure><p>只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小</p><p>显示指定文件所占空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># du log2012.log </span><br><span class="line">300     log2012.log</span><br></pre></td></tr></table></figure><p>方便阅读的格式显示test目录所占空间情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># du -h test</span><br><span class="line">608K    test/test6</span><br><span class="line">308K    test/test4</span><br><span class="line">4.0K    test/scf/lib</span><br><span class="line">4.0K    test/scf/service/deploy/product</span><br><span class="line">4.0K    test/scf/service/deploy/info</span><br><span class="line">12K     test/scf/service/deploy</span><br><span class="line">16K     test/scf/service</span><br><span class="line">4.0K    test/scf/doc</span><br><span class="line">4.0K    test/scf/bin</span><br><span class="line">32K     test/scf</span><br><span class="line">8.0K    test/test3</span><br><span class="line">1.3M    test</span><br></pre></td></tr></table></figure><p><strong>实践：</strong></p><p>​    怎么查看用户组中占用存储空间最多的前5个用户？</p><p>​    答：du -s /home| sort -n|tail -5</p><p><strong>3.df</strong></p><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项]... [FILE]...</span><br></pre></td></tr></table></figure><ul><li>文件-a, –all 包含所有的具有 0 Blocks 的文件系统</li><li>文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks</li><li>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)</li><li>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024</li><li>文件-i, –inodes 列出 inode 资讯，不列出已使用 block</li><li>文件-k, –kilobytes 就像是 –block-size=1024</li><li>文件-l, –local 限制列出的文件结构</li><li>文件-m, –megabytes 就像 –block-size=1048576</li><li>文件–no-sync 取得资讯前不 sync (预设值)</li><li>文件-P, –portability 使用 POSIX 输出格式</li><li>文件–sync 在取得资讯前 sync</li><li>文件-t, –type=TYPE 限制列出文件系统的 TYPE</li><li>文件-T, –print-type 显示文件系统的形式</li><li>文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE</li><li>文件-v (忽略)</li><li>文件–help 显示这个帮手并且离开</li><li>文件–version 输出版本资讯并且离开 </li></ul><p><strong>4.quota</strong></p><p>Linux quota命令用于显示磁盘已使用的空间与限制。</p><p>执行quota指令，可查询磁盘空间的限制，并得知已使用多少空间。</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quota [-quvV][用户名称...] 或 quota [-gqvV][群组名称...]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-g 列出群组的磁盘空间限制。</li><li>-q 简明列表，只列出超过限制的部分。</li><li>-u 列出用户的磁盘空间限制。</li><li>-v 显示该用户或群组，在所有挂入系统的存储设备的空间限制。</li><li>-V 显示版本信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># quota -guvs    &lt;==显示目前执行者（就是 root ）的 quota 值 </span><br><span class="line"># quota -uvs test &lt;==显示 test 这个使用者的 quota 值</span><br></pre></td></tr></table></figure><p><strong>5.sort</strong></p><p>Linux sort命令用于将文本文件内容加以排序。</p><p>sort可针对文本文件的内容，以行为单位来排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-b 忽略每行前面开始出的空格字符。</li><li>-c 检查文件是否已经按照顺序排序。</li><li>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</li><li>-f 排序时，将小写字母视为大写字母。</li><li>-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</li><li>-m 将几个排序好的文件进行合并。</li><li>-M 将前面3个字母依照月份的缩写进行排序。</li><li>-n 依照数值的大小排序。</li><li>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。</li><li>-r 以相反的顺序来排序。</li><li>-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。</li><li>+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</li><li>–help 显示帮助。</li><li>–version 显示版本信息。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在使用sort命令以默认的式对文件的行进行排序，使用的命令如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort testfile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.crontab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux crontab是用来定期执行程序的命令。&lt;/p&gt;
&lt;p&gt;当安装完成操作系统之后，默认便会启动此任务调度命令。&lt;/p&gt;
&lt;p&gt;crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。&lt;/p&gt;
&lt;p&gt;而linux任务调度的工作主要分为以下两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存&lt;/li&gt;
&lt;li&gt;2、个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令————awk、sed、wc</title>
    <link href="//harold.me/2018/07/05/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>//harold.me/2018/07/05/linux常用命令/</id>
    <published>2018-07-05T02:17:53.000Z</published>
    <updated>2018-09-13T09:22:18.527Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.awk</strong></p><p><strong>awk是行处理器</strong>: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息</p><p><strong>awk处理过程:</strong> 依次对每一行进行处理，然后输出</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] &apos;script&apos; var=value file(s)</span><br><span class="line">或</span><br><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><a id="more"></a> <p><strong>选项参数说明：</strong></p><ul><li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</li><li>-v var=value or –asign var=value<br>赋值一个用户定义变量。</li><li>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。</li><li>-mf nnn and -mr nnn<br>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li><li>-W compact or –compat, -W traditional or –traditional<br>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li><li>-W copyleft or –copyleft, -W copyright or –copyright<br>打印简短的版权信息。</li><li>-W help or –help, -W usage or –usage<br>打印全部awk选项和每个选项的简短说明。</li><li>-W lint or –lint<br>打印不能向传统unix平台移植的结构的警告。</li><li>-W lint-old or –lint-old<br>打印关于不能向传统unix平台移植的结构的警告。</li><li>-W posix<br>打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替^和^=；fflush无效。</li><li>-W re-interval or –re-inerval<br>允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</li><li>-W source program-text or –source program-text<br>使用program-text作为源代码，可与-f命令混用。</li><li>-W version or –version<br>打印bug报告信息的版本。</li></ul><p><strong>基本用法</strong></p><p>log.txt文本内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 this is a test</span><br><span class="line">3 Are you like awk</span><br><span class="line">This&apos;s a test</span><br><span class="line">10 There are orange,apple,mongo</span><br></pre></td></tr></table></figure><p>用法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;[pattern] action&#125;&apos; &#123;filenames&#125;   # 行匹配语句 awk &apos;&apos; 只能用单引号</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 每行按空格或TAB分割，输出文本中的1、4项</span><br><span class="line"> $ awk &apos;&#123;print $1,$4&#125;&apos; log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 a</span><br><span class="line"> 3 like</span><br><span class="line"> This&apos;s</span><br><span class="line"> 10 orange,apple,mongo</span><br><span class="line"> # 格式化输出</span><br><span class="line"> $ awk &apos;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$4&#125;&apos; log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2        a</span><br><span class="line"> 3        like</span><br><span class="line"> This&apos;s</span><br><span class="line"> 10       orange,apple,mongo</span><br></pre></td></tr></table></figure><p>用法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F  #-F相当于内置变量FS, 指定分割字符</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 使用&quot;,&quot;分割</span><br><span class="line"> $  awk -F, &apos;&#123;print $1,$2&#125;&apos;   log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 this is a test</span><br><span class="line"> 3 Are you like awk</span><br><span class="line"> This&apos;s a test</span><br><span class="line"> 10 There are orange apple</span><br><span class="line"> # 或者使用内建变量</span><br><span class="line"> $ awk &apos;BEGIN&#123;FS=&quot;,&quot;&#125; &#123;print $1,$2&#125;&apos;     log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 this is a test</span><br><span class="line"> 3 Are you like awk</span><br><span class="line"> This&apos;s a test</span><br><span class="line"> 10 There are orange apple</span><br><span class="line"> # 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割</span><br><span class="line"> $ awk -F &apos;[ ,]&apos;  &apos;&#123;print $1,$2,$5&#125;&apos;   log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 this test</span><br><span class="line"> 3 Are awk</span><br><span class="line"> This&apos;s a</span><br><span class="line"> 10 There apple</span><br></pre></td></tr></table></figure><p>用法三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -v  # 设置变量</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk -va=1 &apos;&#123;print $1,$1+a&#125;&apos; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">This&apos;s 1</span><br><span class="line">10 11</span><br><span class="line">$ awk -va=1 -vb=s &apos;&#123;print $1,$1+a,$1b&#125;&apos; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">2 3 2s</span><br><span class="line">3 4 3s</span><br><span class="line">This&apos;s 1 This&apos;ss</span><br><span class="line">10 11 10s</span><br></pre></td></tr></table></figure><p>用法四：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f &#123;awk脚本&#125; &#123;文件名&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -f cal.awk log.txt</span><br></pre></td></tr></table></figure><p><strong>运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>= += -= *= /= %= ^= **=</td><td>赋值</td></tr><tr><td>?:</td><td>C条件表达式</td></tr><tr><td>\</td><td>\</td><td></td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>~ ~!</td><td>匹配正则表达式和不匹配正则表达式</td></tr><tr><td>&lt; &lt;= &gt; &gt;= != ==</td><td>关系运算符</td></tr><tr><td>空格</td><td>连接</td></tr><tr><td>+ -</td><td>加，减</td></tr><tr><td>* / %</td><td>乘，除与求余</td></tr><tr><td>+ - !</td><td>一元加，减和逻辑非</td></tr><tr><td>^ ***</td><td>求幂</td></tr><tr><td>++ –</td><td>增加或减少，作为前缀或后缀</td></tr><tr><td>$</td><td>字段引用</td></tr><tr><td>in</td><td>数组成员</td></tr></tbody></table><p><strong>内建变量</strong></p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>$n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td>$0</td><td>完整的输入记录</td></tr><tr><td>ARGC</td><td>命令行参数的数目</td></tr><tr><td>ARGIND</td><td>命令行中当前文件的位置(从0开始算)</td></tr><tr><td>ARGV</td><td>包含命令行参数的数组</td></tr><tr><td>CONVFMT</td><td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td></tr><tr><td>ERRNO</td><td>最后一个系统错误的描述</td></tr><tr><td>FIELDWIDTHS</td><td>字段宽度列表(用空格键分隔)</td></tr><tr><td>FILENAME</td><td>当前文件名</td></tr><tr><td>FNR</td><td>各文件分别计数的行号</td></tr><tr><td>FS</td><td>字段分隔符(默认是任何空格)</td></tr><tr><td>IGNORECASE</td><td>如果为真，则进行忽略大小写的匹配</td></tr><tr><td>NF</td><td>一条记录的字段的数目</td></tr><tr><td>NR</td><td>已经读出的记录数，就是行号，从1开始</td></tr><tr><td>OFMT</td><td>数字的输出格式(默认值是%.6g)</td></tr><tr><td>OFS</td><td>输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td></tr><tr><td>ORS</td><td>输出记录分隔符(默认值是一个换行符)</td></tr><tr><td>RLENGTH</td><td>由match函数所匹配的字符串的长度</td></tr><tr><td>RS</td><td>记录分隔符(默认是一个换行符)</td></tr><tr><td>RSTART</td><td>由match函数所匹配的字符串的第一个位置</td></tr><tr><td>SUBSEP</td><td>数组下标分隔符(默认值是/034)</td></tr></tbody></table><p><strong>使用正则，字符串匹配</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 输出第二列包含 &quot;th&quot;，并打印第二列与第四列</span><br><span class="line">$ awk &apos;$2 ~ /th/ &#123;print $2,$4&#125;&apos; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">this a</span><br></pre></td></tr></table></figure><p><strong>~ 表示模式开始。// 中是模式。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出包含&quot;re&quot; 的行</span><br><span class="line">$ awk &apos;/re/ &apos; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">3 Are you like awk</span><br><span class="line">10 There are orange,apple,mongo</span><br></pre></td></tr></table></figure><p><strong>忽略大小写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;BEGIN&#123;IGNORECASE=1&#125; /this/&apos; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">2 this is a test</span><br><span class="line">This&apos;s a test</span><br></pre></td></tr></table></figure><p><strong>模式取反</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;$2 !~ /th/ &#123;print $2,$4&#125;&apos; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">Are like</span><br><span class="line">a</span><br><span class="line">There orange,apple,mongo</span><br><span class="line">$ awk &apos;!/th/ &#123;print $2,$4&#125;&apos; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">Are like</span><br><span class="line">a</span><br><span class="line">There orange,apple,mongo</span><br></pre></td></tr></table></figure><p><strong>awk脚本</strong></p><p>关于awk脚本，我们需要注意两个关键词BEGIN和END。</p><ul><li>BEGIN{ 这里面放的是执行前的语句 }</li><li>END {这里面放的是处理完所有的行后要执行的语句 }</li><li>{这里面放的是处理每一行时要执行的语句}</li></ul><p>假设有这么一个文件（学生成绩表）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat score.txt</span><br><span class="line">Marry   2143 78 84 77</span><br><span class="line">Jack    2321 66 78 45</span><br><span class="line">Tom     2122 48 77 71</span><br><span class="line">Mike    2537 87 97 95</span><br><span class="line">Bob     2415 40 57 62</span><br></pre></td></tr></table></figure><p>我们的awk脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat cal.awk</span><br><span class="line">#!/bin/awk -f</span><br><span class="line">#运行前</span><br><span class="line">BEGIN &#123;</span><br><span class="line">    math = 0</span><br><span class="line">    english = 0</span><br><span class="line">    computer = 0</span><br><span class="line"> </span><br><span class="line">    printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;</span><br><span class="line">    printf &quot;---------------------------------------------\n&quot;</span><br><span class="line">&#125;</span><br><span class="line">#运行中</span><br><span class="line">&#123;</span><br><span class="line">    math+=$3</span><br><span class="line">    english+=$4</span><br><span class="line">    computer+=$5</span><br><span class="line">    printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5</span><br><span class="line">&#125;</span><br><span class="line">#运行后</span><br><span class="line">END &#123;</span><br><span class="line">    printf &quot;---------------------------------------------\n&quot;</span><br><span class="line">    printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer</span><br><span class="line">    printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math/NR, english/NR, computer/NR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk -f cal.awk score.txt</span><br><span class="line">NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL</span><br><span class="line">---------------------------------------------</span><br><span class="line">Marry  2143     78       84       77      239</span><br><span class="line">Jack   2321     66       78       45      189</span><br><span class="line">Tom    2122     48       77       71      196</span><br><span class="line">Mike   2537     87       97       95      279</span><br><span class="line">Bob    2415     40       57       62      159</span><br><span class="line">---------------------------------------------</span><br><span class="line">  TOTAL:       319      393      350</span><br><span class="line">AVERAGE:     63.80    78.60    70.00</span><br></pre></td></tr></table></figure><p><strong>另外一些实例</strong></p><p>AWK的hello world程序为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123; print &quot;Hello, world!&quot; &#125;</span><br></pre></td></tr></table></figure><p>计算文件大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l *.txt | awk &apos;&#123;sum+=$6&#125; END &#123;print sum&#125;&apos;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">666581</span><br></pre></td></tr></table></figure><p>从文件中找出长度大于80的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;length&gt;80&apos; log.txt</span><br></pre></td></tr></table></figure><p>打印九九乘法表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq 9 | sed &apos;H;g&apos; | awk -v RS=&apos;&apos; &apos;&#123;for(i=1;i&lt;=NF;i++)printf(&quot;%dx%d=%d%s&quot;, i, NR, i*NR, i==NR?&quot;\n&quot;:&quot;\t&quot;)&#125;&apos;</span><br></pre></td></tr></table></figure><h4 id="2-sed"><a href="#2-sed" class="headerlink" title="2.sed"></a>2.sed</h4><p>Linux sed命令是利用script来处理文本文件。</p><p>sed可依照script的指令，来处理、编辑文本文件。</p><p>Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-e<script>或–expression=<script> 以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help 显示帮助。</li><li>-n或–quiet或–silent 仅显示script处理后的结果。</li><li>-V或–version 显示版本信息。</li></ul><p><strong>动作说明</strong>：</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何东西；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li><p>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g </p><p><strong>实例</strong></p></li></ul><p>在testfile文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e 4a\newLine testfile</span><br></pre></td></tr></table></figure><p>首先查看testfile中的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat testfile #查看testfile 中的内容  </span><br><span class="line">HELLO LINUX!  </span><br><span class="line">Linux is a free unix-type opterating system.  </span><br><span class="line">This is a linux testfile!  </span><br><span class="line">Linux test</span><br></pre></td></tr></table></figure><p>使用sed命令后，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e 4a\newline testfile #使用sed 在第四行后添加新字符串  </span><br><span class="line">HELLO LINUX! #testfile文件原有的内容  </span><br><span class="line">Linux is a free unix-type opterating system.  </span><br><span class="line">This is a linux testfile!  </span><br><span class="line">Linux test  </span><br><span class="line">newline</span><br></pre></td></tr></table></figure><p><strong>以行为单位的新增/删除</strong></p><p>将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2,5d&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>sed 的动作为 ‘2,5d’ ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！</p><p>只要删除第 2 行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl /etc/passwd | sed &apos;2d&apos;</span><br></pre></td></tr></table></figure><p>要删除第 3 到最后一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl /etc/passwd | sed &apos;3,$d&apos;</span><br></pre></td></tr></table></figure><p>在第二行后(亦即是加在第三行)加上『drink tea?』字样！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2a drink tea&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>那如果是要在第二行前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl /etc/passwd | sed &apos;2i drink tea&apos;</span><br></pre></td></tr></table></figure><p>如果是要增加两行以上，在第二行后面加入两行字，例如『Drink tea or …..』与『drink beer?』</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2a Drink tea or ......\</span><br><span class="line">&gt; drink beer ?&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Drink tea or ......</span><br><span class="line">drink beer ?</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>每一行之间都必须要以反斜杠『 \ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在。</p><p><strong>以行为单位的替换与显示</strong></p><p>将第2-5行的内容取代成为『No 2-5 number』呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2,5c No 2-5 number&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">No 2-5 number</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>透过这个方法我们就能够将数据整行取代了！</p><p>仅列出 /etc/passwd 文件内的第 5-7 行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed -n &apos;5,7p&apos;</span><br><span class="line">5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></table></figure><p>可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。</p><p><strong>数据的搜寻并显示</strong></p><p>搜索 /etc/passwd有root关键字的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nl /etc/passwd | sed &apos;/root/p&apos;</span><br><span class="line">1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">3  bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">4  sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line">5  sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">....下面忽略</span><br></pre></td></tr></table></figure><p>如果root找到，除了输出所有行，还会输出匹配行。</p><p>使用-n的时候将只打印包含模板的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nl /etc/passwd | sed -n &apos;/root/p&apos;</span><br><span class="line">1  root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>数据的搜寻并删除</strong></p><p>删除/etc/passwd所有包含root的行，其他行输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nl /etc/passwd | sed  &apos;/root/d&apos;</span><br><span class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">3  bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">....下面忽略</span><br><span class="line">#第一行的匹配root已经删除了</span><br></pre></td></tr></table></figure><p><strong>数据的搜寻并执行命令</strong></p><p>搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nl /etc/passwd | sed -n &apos;/bash/&#123;s/bash/blueshell/;p;q&#125;&apos;    </span><br><span class="line">1  root:x:0:0:root:/root:/bin/blueshell</span><br></pre></td></tr></table></figure><p>最后的q是退出。</p><p><strong>数据的搜寻并替换</strong></p><p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s/要被取代的字串/新的字串/g&apos;</span><br></pre></td></tr></table></figure><p>先观察原始信息，利用 /sbin/ifconfig 查询 IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# /sbin/ifconfig eth0</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84</span><br><span class="line">inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line">inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link</span><br><span class="line">UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">.....(以下省略).....</span><br></pre></td></tr></table></figure><p>本机的ip是192.168.1.100。</p><p>将 IP 前面的部分予以删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos; | sed &apos;s/^.*addr://g&apos;</span><br><span class="line">192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br></pre></td></tr></table></figure><p>接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</p><p>将 IP 后面的部分予以删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos; | sed &apos;s/^.*addr://g&apos; | sed &apos;s/Bcast.*$//g&apos;</span><br><span class="line">192.168.1.100</span><br></pre></td></tr></table></figure><h4 id="3-wc命令"><a href="#3-wc命令" class="headerlink" title="3.wc命令"></a>3.wc命令</h4><p>Linux wc命令用于计算字数。</p><p>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [-clw][--help][--version][文件...]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-c或–bytes或–chars 只显示Bytes数。</li><li>-l或–lines 只显示行数。</li><li>-w或–words 只显示字数。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><p><strong>实例</strong></p><p>在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc testfile</span><br></pre></td></tr></table></figure><p> 如果想同时统计多个文件的信息，例如同时统计testfile、testfile_1、testfile_2，可使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc testfile testfile_1 testfile_2   #统计三个文件的信息</span><br></pre></td></tr></table></figure><h4 id="4-grep命令"><a href="#4-grep命令" class="headerlink" title="4. grep命令"></a>4. grep命令</h4><p>Linux grep命令用于查找文件里符合条件的字符串。</p><p>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><strong>-a 或 –text</strong> : 不要忽略二进制的数据。</li><li><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li><li><strong>-b 或 –byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li><li><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li><li><strong>-c 或 –count</strong> : 计算符合样式的列数。</li><li><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li><li><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。</li><li><strong>-E 或 –extended-regexp</strong> : 将样式为延伸的普通表示法来使用。</li><li><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li><li><strong>-F 或 –fixed-regexp</strong> : 将样式视为固定字符串的列表。</li><li><strong>-G 或 –basic-regexp</strong> : 将样式视为普通的表示法来使用。</li><li><strong>-h 或 –no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li><li><strong>-H 或 –with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。</li><li><strong>-l 或 –file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。</li><li><strong>-L 或 –files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li><li><strong>-q 或 –quiet或–silent</strong> : 不显示任何信息。</li><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。</li><li><strong>-s 或 –no-messages</strong> : 不显示错误信息。</li><li><strong>-v 或 –revert-match</strong> : 显示不包含匹配文本的所有行。</li><li><strong>-V 或 –version</strong> : 显示版本信息。</li><li><strong>-w 或 –word-regexp</strong> : 只显示全字符合的列。</li><li><strong>-x –line-regexp</strong> : 只显示全列符合的列。</li><li><strong>-y</strong> : 此参数的效果和指定”-i”参数相同。</li></ul></script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.awk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;awk是行处理器&lt;/strong&gt;: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;awk处理过程:&lt;/strong&gt; 依次对每一行进行处理，然后输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;awk [选项参数] &amp;apos;script&amp;apos; var=value file(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;awk [选项参数] -f scriptfile var=value file(s)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//harold.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hadpoop和Spark实现矩阵相乘</title>
    <link href="//harold.me/2018/07/04/Hadpoop%E5%92%8CSpark%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/"/>
    <id>//harold.me/2018/07/04/Hadpoop和Spark实现矩阵相乘/</id>
    <published>2018-07-04T11:31:22.000Z</published>
    <updated>2018-09-13T09:22:18.519Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵的存储格式如下：</p><p>矩阵名 行号 列号 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">M 0 0 1</span><br><span class="line">M 0 1 0</span><br><span class="line">M 0 2 2</span><br><span class="line">M 1 0 2 </span><br><span class="line">M 1 1 3                          </span><br><span class="line">M 1 2 1</span><br><span class="line">N 0 0 1</span><br><span class="line">N 0 1 0</span><br><span class="line">N 1 0 2</span><br><span class="line">N 1 1 3</span><br><span class="line">N 2 0 2</span><br><span class="line">N 2 1 0</span><br></pre></td></tr></table></figure><a id="more"></a> <h4 id="一、Hadoop实现"><a href="#一、Hadoop实现" class="headerlink" title="一、Hadoop实现"></a>一、Hadoop实现</h4><p><strong>1.方法一</strong></p><p><strong>Map1</strong>阶段：对于矩阵M，把列作为key,对于矩阵N,把行作为key</p><p><strong>Reduce1</strong>阶段：对于相同key的值，M矩阵和N矩阵的值做笛卡尔积，输出key：<code>(M的行) + （N的列值）+ （MN相乘的value</code>，输出的value：<code>“”</code></p><p><strong>Map2阶段</strong>：读取<strong>Reduce1</strong>的输出值</p><p><strong>Reduce2阶段</strong>：把所有相同key的value值相加，输出即可</p><p>第一次MapReduce:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String str = value.toString();</span><br><span class="line">        String[] strs = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span> (strs[<span class="number">0</span>].equals(<span class="string">"M"</span>) &amp;&amp; strs.length == <span class="number">4</span>)</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(strs[<span class="number">2</span>]), <span class="keyword">new</span> Text(strs[<span class="number">0</span>] + <span class="string">" "</span> + strs[<span class="number">1</span>] +<span class="string">" "</span> + strs[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (strs[<span class="number">0</span>].equals(<span class="string">"N"</span>) &amp;&amp; strs.length == <span class="number">4</span>)</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(strs[<span class="number">1</span>]), <span class="keyword">new</span> Text(strs[<span class="number">0</span>] + <span class="string">" "</span> + strs[<span class="number">2</span>] + <span class="string">" "</span> + strs[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; mTrix = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; nTrix = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Text value : values) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.toString().contains(<span class="string">"M"</span>))</span><br><span class="line">                mTrix.add(value.toString());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nTrix.add(value.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        String [] mItems, nItems;</span><br><span class="line">        <span class="keyword">for</span> (String m : mTrix)&#123;</span><br><span class="line">            mItems = m.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (String n : nTrix) &#123;</span><br><span class="line">                nItems = n.split(<span class="string">" "</span>);</span><br><span class="line">                context.write(<span class="keyword">new</span> Text(key + <span class="string">"+"</span> + mItems[<span class="number">1</span>] + <span class="string">"+"</span> + nItems[<span class="number">1</span>] + <span class="string">"+"</span> + (Integer.parseInt(mItems[<span class="number">2</span>]) * Integer.parseInt(nItems[<span class="number">2</span>]))),<span class="keyword">new</span> Text(<span class="string">""</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixMul</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = getConf();</span><br><span class="line">        Job job = <span class="keyword">new</span> Job(conf);</span><br><span class="line">        job.setJarByClass(MatrixMul.class);</span><br><span class="line">        job.setJobName(<span class="string">"MatrixMul"</span>);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(strings[<span class="number">0</span>]));</span><br><span class="line">       FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(strings[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(ReadMapper.class);</span><br><span class="line">        job.setReducerClass(WriteReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> returnStatus = ToolRunner.run(<span class="keyword">new</span> MatrixMul(), args);</span><br><span class="line">        System.exit(returnStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0+1+1+0</span><br><span class="line">0+1+0+2</span><br><span class="line">0+0+1+0</span><br><span class="line">0+0+0+1</span><br><span class="line">1+1+1+9</span><br><span class="line">1+1+0+6</span><br><span class="line">1+0+1+0</span><br><span class="line">1+0+0+0</span><br><span class="line">2+1+1+0</span><br><span class="line">2+1+0+2</span><br><span class="line">2+0+1+0</span><br><span class="line">2+0+0+4</span><br></pre></td></tr></table></figure><p>第二次MapReduce:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixMulStep2</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = getConf();</span><br><span class="line">        Job job = <span class="keyword">new</span> Job(conf);</span><br><span class="line">        job.setJobName(<span class="string">"MatrixMulStep2"</span>);</span><br><span class="line">        job.setJarByClass(MatrixMulStep2.class);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(ReadMapper1.class);</span><br><span class="line">        job.setReducerClass(WriteReducer1.class);</span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> returnStatus = ToolRunner.run(<span class="keyword">new</span> MatrixMulStep2(), args);</span><br><span class="line">        System.exit(returnStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadMapper1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String[] str = value.toString().split(<span class="string">"\\+"</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.length &gt;=<span class="number">4</span> )&#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(str[<span class="number">1</span>] + <span class="string">" "</span> + str[<span class="number">2</span>]), <span class="keyword">new</span> Text(str[<span class="number">3</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteReducer1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Text t : values)</span><br><span class="line">            sum += Integer.parseInt(t.toString());</span><br><span class="line">        context.write(key, <span class="keyword">new</span> Text(sum + <span class="string">""</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 05</span><br><span class="line">0 10</span><br><span class="line">1 010</span><br><span class="line">1 19</span><br></pre></td></tr></table></figure><p><strong>2.方法二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleStep</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WIDTH = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MATRIX_K = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] values = value.toString().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (values[<span class="number">0</span>].equals(<span class="string">"M"</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)</span><br><span class="line">                    context.write(<span class="keyword">new</span> Text(values[<span class="number">1</span>] + <span class="string">" "</span> + i), <span class="keyword">new</span> Text(values[<span class="number">0</span>] + <span class="string">" "</span> + values[<span class="number">2</span>] + <span class="string">" "</span> + values[<span class="number">3</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WIDTH; i++)</span><br><span class="line">                    context.write(<span class="keyword">new</span> Text(i + <span class="string">" "</span> + values[<span class="number">2</span>]), <span class="keyword">new</span> Text(values[<span class="number">0</span>] + <span class="string">" "</span> + values[<span class="number">1</span>] + <span class="string">" "</span> + values[<span class="number">3</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            Integer[] m_matrix = <span class="keyword">new</span> Integer[MATRIX_K];</span><br><span class="line">            Integer[] n_matrix = <span class="keyword">new</span> Integer[MATRIX_K];</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Text value : values) &#123;</span><br><span class="line">                String[] tmp = value.toString().split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp[<span class="number">0</span>].equals(<span class="string">"M"</span>))</span><br><span class="line">                    m_matrix[Integer.parseInt(tmp[<span class="number">1</span>])] = Integer.parseInt(tmp[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">else</span> n_matrix[Integer.parseInt(tmp[<span class="number">1</span>])] = Integer.parseInt(tmp[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对两个矩阵相乘相加</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MATRIX_K; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_matrix[i] != <span class="keyword">null</span> &amp;&amp; n_matrix[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result += m_matrix[i] * n_matrix[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key, <span class="keyword">new</span> Text(result + <span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = getConf();</span><br><span class="line">        Job job = <span class="keyword">new</span> Job(conf);</span><br><span class="line">        job.setJarByClass(MatrixMul.class);</span><br><span class="line">        job.setJobName(<span class="string">"SingleStep"</span>);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(strings[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(strings[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(MatrixMapper.class);</span><br><span class="line">        job.setReducerClass(MatrixReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> returnStatus = ToolRunner.run(<span class="keyword">new</span> SingleStep(), args);</span><br><span class="line">        System.exit(returnStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、Spark实现"><a href="#二、Spark实现" class="headerlink" title="二、Spark实现"></a>二、Spark实现</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatrixMulSpark</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setAppName(<span class="string">"MatrixMulSpark"</span>)</span><br><span class="line">      .setMaster(<span class="string">"local"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf);</span><br><span class="line">    <span class="keyword">val</span> input = sc.textFile(<span class="string">"in/in.txt"</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">M</span> = input.filter(line =&gt; line.contains(<span class="string">"M"</span>))</span><br><span class="line">    <span class="keyword">val</span> <span class="type">N</span> = input.filter(line =&gt; line.contains(<span class="string">"N"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordM = <span class="type">M</span>.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> words = line.split(<span class="string">" "</span>)</span><br><span class="line">      (words(<span class="number">2</span>), words)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordN = <span class="type">N</span>.map( line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> word = line.split(<span class="string">" "</span>)</span><br><span class="line">      (word(<span class="number">1</span>), word)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dword = wordM.join(wordN)</span><br><span class="line">    dword.collect.foreach(println)</span><br><span class="line">    <span class="keyword">val</span> map = dword.values.map( x =&gt; &#123;</span><br><span class="line">      (x._1(<span class="number">1</span>) + <span class="string">" "</span> + x._2(<span class="number">2</span>),x._1(<span class="number">3</span>).toDouble * x._2(<span class="number">3</span>).toDouble)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> reduce = map.reduceByKey((x,y) =&gt; &#123;</span><br><span class="line">      x + y</span><br><span class="line">    &#125;)</span><br><span class="line">    reduce.foreach(x =&gt; println(x._1+<span class="string">" "</span> + x._2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;矩阵的存储格式如下：&lt;/p&gt;
&lt;p&gt;矩阵名 行号 列号 值&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;M 0 0 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M 0 1 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M 0 2 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M 1 0 2									 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M 1 1 3                          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M 1 2 1							&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N 0 0 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N 0 1 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N 1 0 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N 1 1 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N 2 0 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N 2 1 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="//harold.me/tags/Hadoop/"/>
    
      <category term="Spark" scheme="//harold.me/tags/Spark/"/>
    
  </entry>
  
</feed>
